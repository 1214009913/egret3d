var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var paper;
(function (paper) {
    /**
     * @internal
     */
    function registerClass(baseClass) {
        baseClass.__onRegister();
    }
    paper.registerClass = registerClass;
    function serializedField(classPrototypeOrKey, key) {
        if (key) {
            var baseClass = classPrototypeOrKey.constructor;
            registerClass(baseClass);
            baseClass.__serializeKeys[key] = null;
        }
        else {
            return function (classPrototype, key) {
                var baseClass = classPrototype.constructor;
                registerClass(baseClass);
                baseClass.__serializeKeys[key] = classPrototypeOrKey;
            };
        }
    }
    paper.serializedField = serializedField;
    /**
     * 通过装饰器标记反序列化时需要忽略的属性。
     */
    function deserializedIgnore(classPrototype, key) {
        var baseClass = classPrototype.constructor;
        registerClass(baseClass);
        var keys = baseClass.__deserializeIgnore;
        if (keys.indexOf(key) < 0) {
            keys.push(key);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 通过装饰器标记组件是否允许在同一实体上添加多个实例。
     */
    function allowMultiple(componentClass) {
        registerClass(componentClass);
        if (!componentClass.__isSingleton) {
            componentClass.allowMultiple = true;
        }
        else {
            console.warn("Singleton component cannot allow multiple.");
        }
    }
    paper.allowMultiple = allowMultiple;
    /**
     * 通过装饰器标记组件依赖的其他组件。
     */
    function requireComponent(requireComponentClass) {
        return function (componentClass) {
            var requireComponents = componentClass.requireComponents;
            if (requireComponents.indexOf(requireComponentClass) < 0) {
                requireComponents.push(requireComponentClass);
            }
        };
    }
    paper.requireComponent = requireComponent;
    /**
     * 通过装饰器标记组件是否在编辑模式拥有生命周期。
     */
    function executeInEditMode(componentClass) {
        registerClass(componentClass);
        componentClass.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**属性信息 */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**编辑类型 */
        var EditType;
        (function (EditType) {
            /**数字输入 */
            EditType[EditType["NUMBER"] = 0] = "NUMBER";
            /**文本输入 */
            EditType[EditType["TEXT"] = 1] = "TEXT";
            /**选中框 */
            EditType[EditType["CHECKBOX"] = 2] = "CHECKBOX";
            /**vertor2 */
            EditType[EditType["VECTOR2"] = 3] = "VECTOR2";
            /**vertor3 */
            EditType[EditType["VECTOR3"] = 4] = "VECTOR3";
            /**vertor4 */
            EditType[EditType["VECTOR4"] = 5] = "VECTOR4";
            /**Quaternion */
            EditType[EditType["QUATERNION"] = 6] = "QUATERNION";
            /**颜色选择器 */
            EditType[EditType["COLOR"] = 7] = "COLOR";
            /**下拉 */
            EditType[EditType["LIST"] = 8] = "LIST";
            /**Rect */
            EditType[EditType["RECT"] = 9] = "RECT";
            /**材质 */
            EditType[EditType["MATERIAL"] = 10] = "MATERIAL";
            /**材质数组 */
            EditType[EditType["MATERIAL_ARRAY"] = 11] = "MATERIAL_ARRAY";
            /**游戏对象 */
            EditType[EditType["GAMEOBJECT"] = 12] = "GAMEOBJECT";
            /**变换 TODO 不需要*/
            EditType[EditType["TRANSFROM"] = 13] = "TRANSFROM";
            /**组件 */
            EditType[EditType["COMPONENT"] = 14] = "COMPONENT";
            /**声音 */
            EditType[EditType["SOUND"] = 15] = "SOUND";
            /**Mesh */
            EditType[EditType["MESH"] = 16] = "MESH";
            /**shader */
            EditType[EditType["SHADER"] = 17] = "SHADER";
            /**数组 */
            EditType[EditType["ARRAY"] = 18] = "ARRAY";
        })(EditType = editor.EditType || (editor.EditType = {}));
        var customMap = {};
        /**
         * 装饰器:自定义
         */
        function custom() {
            return function (target) {
                customMap[target.name] = true;
            };
        }
        editor.custom = custom;
        var propertyMap = {};
        /**
         * 从枚举中生成装饰器列表项。
         */
        function getItemsFromEnum(enumObject) {
            var items = [];
            for (var k in enumObject) {
                if (!isNaN(Number(k))) {
                    continue;
                }
                items.push({ label: k, value: enumObject[k] });
            }
            return items;
        }
        editor.getItemsFromEnum = getItemsFromEnum;
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function property(editType, option) {
            return function (target, property) {
                if (!propertyMap[target.constructor.name]) {
                    propertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    propertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 检测一个实例对象是否为已被自定义
         * @param classInstance 实例对象
         */
        function isCustom(classInstance) {
            return customMap[classInstance.constructor.name] ? true : false;
        }
        editor.isCustom = isCustom;
        /**
       * 获取一个实例对象的编辑信息
       * @param classInstance 实例对象
       */
        function getEditInfo(classInstance) {
            var whileInsance = classInstance.__proto__;
            var retrunList = [];
            var className;
            while (whileInsance) {
                className = whileInsance.constructor.name;
                var classInfo = propertyMap[className];
                if (classInfo) {
                    retrunList = retrunList.concat(classInfo.propertyList);
                }
                whileInsance = whileInsance.__proto__;
            }
            return retrunList;
        }
        editor.getEditInfo = getEditInfo;
        /**
         * 获取一个实例对象的编辑信息
         * @param classInstance 实例对象
         */
        function getEditInfo2(classInstance) {
            var className = classInstance.constructor.name;
            function _getEditInfo(className) {
                var classInfo = propertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getEditInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getEditInfo(className);
        }
        editor.getEditInfo2 = getEditInfo2;
        function getEditInfoByPrototype(classInstance) {
            function _getEditInfo(proto) {
                var classInfo;
                var extendsInfo;
                if (proto && Object.getPrototypeOf(proto)) {
                    classInfo = propertyMap[Object.getPrototypeOf(proto).constructor.name];
                }
                if (classInfo) {
                    extendsInfo = _getEditInfo(Object.getPrototypeOf(proto));
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                else {
                    if (proto) {
                        extendsInfo = _getEditInfo(Object.getPrototypeOf(proto));
                        return extendsInfo;
                    }
                }
                return [];
            }
            return _getEditInfo(classInstance);
        }
        editor.getEditInfoByPrototype = getEditInfoByPrototype;
        var extraPropertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function extraProperty(editType, option) {
            return function (target, property) {
                if (!extraPropertyMap[target.constructor.name]) {
                    extraPropertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    extraPropertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.extraProperty = extraProperty;
        /**
         * 额外信息
         * @param classInstance 实例对象
         */
        function getExtraInfo(classInstance) {
            var className = classInstance.constructor.name;
            function _getExtraInfo(className) {
                var classInfo = extraPropertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getExtraInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getExtraInfo(className);
        }
        editor.getExtraInfo = getExtraInfo;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     * @internal
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    /**
     * 基础对象。
     */
    var BaseObject = (function () {
        function BaseObject() {
            /**
             *
             */
            this.uuid = paper.createUUID();
        }
        /**
         * @internal
         */
        BaseObject.__onRegister = function () {
            if (this.__owner && this.__owner === this) {
                return false;
            }
            this.__deserializeIgnore = [];
            this.__serializeKeys = {};
            this.__owner = this;
            return true;
        };
        __decorate([
            paper.serializedField
        ], BaseObject.prototype, "uuid", void 0);
        return BaseObject;
    }());
    paper.BaseObject = BaseObject;
    __reflect(BaseObject.prototype, "paper.BaseObject", ["paper.IUUID"]);
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var EulerOrder;
    (function (EulerOrder) {
        EulerOrder[EulerOrder["XYZ"] = 0] = "XYZ";
        EulerOrder[EulerOrder["XZY"] = 1] = "XZY";
        EulerOrder[EulerOrder["YXZ"] = 2] = "YXZ";
        EulerOrder[EulerOrder["YZX"] = 3] = "YZX";
        EulerOrder[EulerOrder["ZXY"] = 4] = "ZXY";
        EulerOrder[EulerOrder["ZYX"] = 5] = "ZYX";
    })(EulerOrder = egret3d.EulerOrder || (egret3d.EulerOrder = {}));
    /**
     *
     */
    var Vector3 = (function () {
        /**
         * 请使用 `egret3d.Vector3.create()` 创建实例。
         * @see egret3d.Vector3.create()
         * @deprecated
         * @private
         */
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        Vector3.create = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(x, y, z);
            }
            return new Vector3().set(x, y, z);
        };
        Vector3.prototype.release = function () {
            if (Vector3._instances.indexOf(this) < 0) {
                Vector3._instances.push(this);
            }
            return this;
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector3.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z);
        };
        Vector3.prototype.clone = function () {
            return Vector3.create(this.x, this.y, this.z);
        };
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.000001; }
            if (Math.abs(this.x - value.x) > threshold) {
                return false;
            }
            if (Math.abs(this.y - value.y) > threshold) {
                return false;
            }
            if (Math.abs(this.z - value.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.prototype.set = function (x, y, z) {
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            return this;
        };
        Vector3.prototype.fromPlaneProjection = function (plane, source) {
            if (!source) {
                source = this;
            }
            return this.add(egret3d.helpVector3A.multiplyScalar(-plane.getDistance(source), plane.normal));
        };
        Vector3.prototype.applyMatrix = function (matrix, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var rawData = matrix.rawData;
            var w = 1.0 / (rawData[3] * x + rawData[7] * y + rawData[11] * z + rawData[15]);
            this.x = (rawData[0] * x + rawData[4] * y + rawData[8] * z + rawData[12]) * w;
            this.y = (rawData[1] * x + rawData[5] * y + rawData[9] * z + rawData[13]) * w;
            this.z = (rawData[2] * x + rawData[6] * y + rawData[10] * z + rawData[14]) * w;
            return this;
        };
        Vector3.prototype.applyDirection = function (matrix, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var rawData = matrix.rawData;
            this.x = rawData[0] * x + rawData[4] * y + rawData[8] * z;
            this.y = rawData[1] * x + rawData[5] * y + rawData[9] * z;
            this.z = rawData[2] * x + rawData[6] * y + rawData[10] * z;
            return this;
        };
        Vector3.prototype.applyQuaternion = function (quaternion, source) {
            if (!source) {
                source = this;
            }
            var x = source.x, y = source.y, z = source.z;
            var qx = quaternion.x, qy = quaternion.y, qz = quaternion.z, qw = quaternion.w;
            // calculate quat * vector
            var ix = qw * x + qy * z - qz * y;
            var iy = qw * y + qz * x - qx * z;
            var iz = qw * z + qx * y - qy * x;
            var iw = -qx * x - qy * y - qz * z;
            // calculate result * inverse quat
            this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
            this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
            this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
            return this;
        };
        Vector3.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            var l = Math.sqrt(source.x * source.x + source.y * source.y + source.z * source.z);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 1.0;
            }
            return this;
        };
        Vector3.prototype.negate = function (source) {
            if (!source) {
                source = this;
            }
            this.x = source.x * -1.00;
            this.y = source.y * -1.00;
            this.z = source.z * -1.00;
        };
        Vector3.prototype.addScalar = function (add, source) {
            if (source) {
                this.x = source.x + add;
                this.y = source.y + add;
                this.z = source.z + add;
            }
            else {
                this.x += add;
                this.y += add;
                this.z += add;
            }
            return this;
        };
        Vector3.prototype.add = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x + valueB.x;
                this.y = valueA.y + valueB.y;
                this.z = valueA.z + valueB.z;
            }
            else {
                this.x += valueA.x;
                this.y += valueA.y;
                this.z += valueA.z;
            }
            return this;
        };
        Vector3.prototype.subtract = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x - valueB.x;
                this.y = valueA.y - valueB.y;
                this.z = valueA.z - valueB.z;
            }
            else {
                this.x -= valueA.x;
                this.y -= valueA.y;
                this.z -= valueA.z;
            }
            return this;
        };
        Vector3.prototype.multiplyScalar = function (scale, source) {
            if (source) {
                this.x = scale * source.x;
                this.y = scale * source.y;
                this.z = scale * source.z;
            }
            else {
                this.x *= scale;
                this.y *= scale;
                this.z *= scale;
            }
            return this;
        };
        Vector3.prototype.multiply = function (valueA, valueB) {
            if (valueB) {
                this.x = valueA.x * valueB.x;
                this.y = valueA.y * valueB.y;
                this.z = valueA.z * valueB.z;
            }
            else {
                this.x *= valueA.x;
                this.y *= valueA.y;
                this.z *= valueA.z;
            }
            return this;
        };
        Vector3.prototype.dot = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            return valueA.x * valueB.x + valueA.y * valueB.y + valueA.z * valueB.z;
        };
        Vector3.prototype.cross = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var x = valueA.x;
            var y = valueA.y;
            var z = valueA.z;
            this.x = y * valueB.z - z * valueB.y;
            this.y = z * valueB.x - x * valueB.z;
            this.z = x * valueB.y - y * valueB.x;
            return this;
        };
        Vector3.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var p = 1.0 - t;
            this.x = valueA.x * p + valueB.x * t;
            this.y = valueA.y * p + valueB.y * t;
            this.z = valueA.z * p + valueB.z * t;
            return this;
        };
        Vector3.prototype.min = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.min(valueA.x, valueB.x);
            this.y = Math.min(valueA.y, valueB.y);
            this.z = Math.min(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.max = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.x = Math.max(valueA.x, valueB.x);
            this.y = Math.max(valueA.y, valueB.y);
            this.z = Math.max(valueA.z, valueB.z);
            return this;
        };
        Vector3.prototype.clamp = function (min, max, source) {
            if (!source) {
                source = this;
            }
            // assumes min < max, componentwise
            this.x = Math.max(min.x, Math.min(max.x, source.x));
            this.y = Math.max(min.y, Math.min(max.y, source.y));
            this.z = Math.max(min.z, Math.min(max.z, source.z));
            return this;
        };
        Vector3.prototype.getSquaredDistance = function (value) {
            return helpVector.subtract(value, this).squaredLength;
        };
        Vector3.prototype.getDistance = function (value) {
            return helpVector.subtract(value, this).length;
        };
        Vector3.prototype.closestToTriangle = function (triangle, value) {
            if (!value) {
                value = this;
            }
            var vab = egret3d.helpVector3A;
            var vac = egret3d.helpVector3B;
            var vbc = egret3d.helpVector3C;
            var vap = egret3d.helpVector3D;
            var vbp = egret3d.helpVector3E;
            var vcp = egret3d.helpVector3F;
            var a = triangle.a, b = triangle.b, c = triangle.c;
            var v, w;
            // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
            // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
            // under the accompanying license; see chapter 5.1.5 for detailed explanation.
            // basically, we're distinguishing which of the voronoi regions of the triangle
            // the point lies in with the minimum amount of redundant computation.
            vab.subtract(b, a);
            vac.subtract(c, a);
            vap.subtract(value, a);
            var d1 = vab.dot(vap);
            var d2 = vac.dot(vap);
            if (d1 <= 0 && d2 <= 0) {
                // vertex region of A; barycentric coords (1, 0, 0)
                return this.copy(a);
            }
            vbp.subtract(value, b);
            var d3 = vab.dot(vbp);
            var d4 = vac.dot(vbp);
            if (d3 >= 0 && d4 <= d3) {
                // vertex region of B; barycentric coords (0, 1, 0)
                return this.copy(b);
            }
            var vc = d1 * d4 - d3 * d2;
            if (vc <= 0 && d1 >= 0 && d3 <= 0) {
                v = d1 / (d1 - d3);
                // edge region of AB; barycentric coords (1-v, v, 0)
                return this.multiplyScalar(v, vab).add(a);
            }
            vcp.subtract(value, c);
            var d5 = vab.dot(vcp);
            var d6 = vac.dot(vcp);
            if (d6 >= 0 && d5 <= d6) {
                // vertex region of C; barycentric coords (0, 0, 1)
                return this.copy(c);
            }
            var vb = d5 * d2 - d1 * d6;
            if (vb <= 0 && d2 >= 0 && d6 <= 0) {
                w = d2 / (d2 - d6);
                // edge region of AC; barycentric coords (1-w, 0, w)
                return this.multiplyScalar(w, vac).add(a);
            }
            var va = d3 * d6 - d5 * d4;
            if (va <= 0 && (d4 - d3) >= 0 && (d5 - d6) >= 0) {
                vbc.subtract(c, b);
                w = (d4 - d3) / ((d4 - d3) + (d5 - d6));
                // edge region of BC; barycentric coords (0, 1-w, w)
                return this.multiplyScalar(w, vbc).add(b); // edge region of BC
            }
            // face region
            var denom = 1 / (va + vb + vc);
            // u = va * denom
            v = vb * denom;
            w = vc * denom;
            return this.add(a, vac.multiplyScalar(w).add(vab.multiplyScalar(v)));
        };
        Object.defineProperty(Vector3.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "squaredLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            var num = Vector3.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
                v.z = v.z / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
                v.z = 0.0;
            }
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        /**
         * @deprecated
         */
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        /**
         * @deprecated
         */
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        /**
         * @deprecated
         */
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, helpVector));
        };
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }());
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "paper.IRelease", "paper.ISerializable"]);
    var helpVector = Vector3.create();
    egret3d.helpVector3A = Vector3.create();
    egret3d.helpVector3B = Vector3.create();
    egret3d.helpVector3C = Vector3.create();
    egret3d.helpVector3D = Vector3.create();
    egret3d.helpVector3E = Vector3.create();
    egret3d.helpVector3F = Vector3.create();
    egret3d.helpVector3G = Vector3.create();
    egret3d.helpVector3H = Vector3.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件基类
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        /**
         * 禁止实例化组件。
         * @protected
         */
        function BaseComponent() {
            var _this = _super.call(this) || this;
            /**
             * 组件挂载的 GameObject
             */
            _this.gameObject = null;
            /**
             * 仅保存在编辑器环境的额外数据，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._enabled = true;
            if (BaseComponent._createEnabled) {
                _this.gameObject = BaseComponent._createEnabled;
                BaseComponent._createEnabled = null;
            }
            else {
                throw new Error("Create an instance of a component is not allowed.");
            }
            return _this;
        }
        /**
         * @internal
         */
        BaseComponent.__onRegister = function () {
            if (!paper.BaseObject.__onRegister.call(this)) {
                return false;
            }
            if (this.requireComponents) {
                this.requireComponents = this.requireComponents.concat();
            }
            else {
                this.requireComponents = [];
            }
            if (this._componentClasses.indexOf(this) < 0) {
                this.__index = this._componentClasses.length;
                this._componentClasses.push(this);
            }
            return true;
        };
        /**
         * @internal
         */
        BaseComponent.create = function (componentClass, gameObject) {
            this._createEnabled = gameObject;
            return new componentClass();
        };
        /**
         * 添加组件后，组件内部初始化。
         * - 重载此方法时，必须调用 `super.initialize()`。
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载。
         * - 重载此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 组件的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                if (!value && this.constructor === egret3d.Transform) {
                    console.log("Cannot disable transform compnent.");
                    return;
                }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    paper.EventPool.dispatchEvent(currentEnabled ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "transform", {
            /**
             *
             */
            get: function () {
                return this.gameObject.transform;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 是否在编辑模式拥有生命周期。
         */
        BaseComponent.executeInEditMode = false;
        /**
         * 是否允许在同一实体上添加多个实例。
         */
        BaseComponent.allowMultiple = false;
        /**
         * 依赖的其他组件。
         */
        BaseComponent.requireComponents = null;
        /**
         * @internal
         */
        BaseComponent.__isSingleton = false;
        /**
         * @internal
         */
        BaseComponent.__index = -1;
        BaseComponent._componentClasses = [];
        BaseComponent._createEnabled = null;
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseComponent.prototype, "enabled", null);
        return BaseComponent;
    }(paper.BaseObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * Base Class for Asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 资源基类，扩展资源类型需要继承此抽象类
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        function Asset(name) {
            if (name === void 0) { name = ""; }
            var _this = _super.call(this) || this;
            /**
             * @readonly
             */
            _this.name = "";
            /**
             * @internal
             */
            _this._isBuiltin = false;
            _this.name = name;
            return _this;
        }
        /**
         * @internal
         */
        Asset.register = function (asset) {
            if (!this._assets[asset.name]) {
                this._assets[asset.name] = asset;
            }
            else if (this._assets[asset.name] !== asset) {
                console.debug("Replace asset.", asset.name);
                this._assets[asset.name] = asset;
            }
        };
        /**
         *
         */
        Asset.find = function (name) {
            var result = this._assets[name];
            if (!result) {
                return RES.getRes(name);
            }
            return result;
        };
        /**
         * dispose asset
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 释放资源。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Asset.prototype.dispose = function (disposeChildren) {
            if (this._isBuiltin) {
                console.warn("Can not dispose builtin asset.", this.name);
                return false;
            }
            delete Asset._assets[this.name];
            this.name = "";
            return true;
        };
        /**
         * @internal
         */
        Asset._assets = {};
        return Asset;
    }(paper.BaseObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var Vector4 = (function () {
        /**
         * 请使用 `egret3d.Quaternion.create()` 创建实例。
         * @see egret3d.Quaternion.create()
         * @deprecated
         * @private
         */
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        /**
         *
         */
        Vector4.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(x, y, z, w);
            }
            return new Vector4().set(x, y, z, w);
        };
        Vector4.prototype.release = function () {
            if (Vector4._instances.indexOf(this) < 0) {
                Vector4._instances.push(this);
            }
            return this;
        };
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Vector4.prototype.copy = function (value) {
            return this.set(value.x, value.y, value.z, value.w);
        };
        Vector4.prototype.clone = function () {
            return Vector4.create(this.x, this.y, this.z, this.w);
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.x = value[offset];
            this.y = value[offset + 1];
            this.z = value[offset + 2];
            this.w = value[offset + 3];
            return this;
        };
        Vector4.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            var l = Math.sqrt(source.x * source.x + source.y * source.y + source.z * source.z + source.w * source.w);
            if (l > egret3d.EPSILON) {
                l = 1.0 / l;
                this.x *= l;
                this.y *= l;
                this.z *= l;
                this.w *= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        Object.defineProperty(Vector4.prototype, "length", {
            get: function () {
                return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector4.prototype, "squaredLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
            },
            enumerable: true,
            configurable: true
        });
        Vector4._instances = [];
        return Vector4;
    }());
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "egret3d.IVector3", "paper.IRelease", "paper.ISerializable"]);
    egret3d.helpVector4A = new Vector4();
    egret3d.helpVector4B = new Vector4();
    egret3d.helpVector4C = new Vector4();
    egret3d.helpVector4D = new Vector4();
    egret3d.helpVector4E = new Vector4();
    egret3d.helpVector4F = new Vector4();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var BaseObjectAsset = (function (_super) {
        __extends(BaseObjectAsset, _super);
        function BaseObjectAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._raw = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseObjectAsset.prototype.$parse = function (json) {
            this._raw = json;
        };
        BaseObjectAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this._raw = null;
            return true;
        };
        BaseObjectAsset.prototype.caclByteLength = function () {
            return 0;
        };
        return BaseObjectAsset;
    }(paper.Asset));
    paper.BaseObjectAsset = BaseObjectAsset;
    __reflect(BaseObjectAsset.prototype, "paper.BaseObjectAsset");
    /**
     * scene asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 场景数据资源
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        RawScene.prototype.createInstance = function (keepUUID) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var scene = deserializer.deserialize(this._raw, keepUUID);
            if (scene && isEditor) {
            }
            return scene;
        };
        return RawScene;
    }(BaseObjectAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _array = [
        1.0, 0.0, 0.0, 0.0,
        0.0, 1.0, 0.0, 0.0,
        0.0, 0.0, 1.0, 0.0,
        0.0, 0.0, 0.0, 1.0
    ];
    /**
     *
     */
    var Matrix4 = (function () {
        /**
         * 请使用 `egret3d.Matrix4.create()` 创建实例。
         * @see egret3d.Matrix4.create()
         * @deprecated
         * @private
         */
        function Matrix4() {
            /**
             *
             */
            this.rawData = new Float32Array(_array);
        }
        /**
         *
         * @param rawData
         * @param offset
         */
        Matrix4.create = function (rawData, offset) {
            if (rawData === void 0) { rawData = null; }
            if (offset === void 0) { offset = 0; }
            if (this._instances.length > 0) {
                return this._instances.pop();
            }
            var matrix = new Matrix4();
            if (rawData) {
                matrix.fromArray(rawData, offset);
            }
            return matrix;
        };
        /**
         *
         */
        Matrix4.prototype.release = function () {
            if (Matrix4._instances.indexOf(this) < 0) {
                Matrix4._instances.push(this);
            }
            return this;
        };
        Matrix4.prototype.serialize = function () {
            return this.rawData;
        };
        Matrix4.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Matrix4.prototype.copy = function (value) {
            this.fromArray(value.rawData);
            return this;
        };
        Matrix4.prototype.clone = function () {
            return Matrix4.create(this.rawData);
        };
        Matrix4.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.set = function (n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
            var rawData = this.rawData;
            rawData[0] = n11;
            rawData[4] = n12;
            rawData[8] = n13;
            rawData[12] = n14;
            rawData[1] = n21;
            rawData[5] = n22;
            rawData[9] = n23;
            rawData[13] = n24;
            rawData[2] = n31;
            rawData[6] = n32;
            rawData[10] = n33;
            rawData[14] = n34;
            rawData[3] = n41;
            rawData[7] = n42;
            rawData[11] = n43;
            rawData[15] = n44;
            return this;
        };
        Matrix4.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            for (var i = 0; i < 16; ++i) {
                this.rawData[i] = value[i + offset];
            }
            return this;
        };
        Matrix4.prototype.fromTranslate = function (value, rotationAndScaleStays) {
            if (rotationAndScaleStays === void 0) { rotationAndScaleStays = false; }
            if (!rotationAndScaleStays) {
                this.identity();
            }
            this.rawData[12] = value.x;
            this.rawData[13] = value.y;
            this.rawData[14] = value.z;
            return this;
        };
        Matrix4.prototype.fromRotation = function (rotation, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            return this.compose(translateStays ? _helpVector3A.fromArray(this.rawData, 12) : egret3d.Vector3.ZERO, rotation, egret3d.Vector3.ONE);
        };
        Matrix4.prototype.fromEuler = function (value, order, translateStays) {
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            if (order === void 0) { order = 2 /* YXZ */; }
            if (translateStays === void 0) { translateStays = false; }
            var cos = Math.cos;
            var sin = Math.sin;
            var x = value.x, y = value.y, z = value.z;
            var a = cos(x), b = sin(x);
            var c = cos(y), d = sin(y);
            var e = cos(z), f = sin(z);
            var rawData = this.rawData;
            switch (order) {
                case 0 /* XYZ */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = -c * f;
                    rawData[8] = d;
                    rawData[1] = af + be * d;
                    rawData[5] = ae - bf * d;
                    rawData[9] = -b * c;
                    rawData[2] = bf - ae * d;
                    rawData[6] = be + af * d;
                    rawData[10] = a * c;
                    break;
                }
                case 1 /* XZY */: {
                    var ac_1 = a * c, ad_1 = a * d, bc_1 = b * c, bd_1 = b * d;
                    rawData[0] = c * e;
                    rawData[4] = -f;
                    rawData[8] = d * e;
                    rawData[1] = ac_1 * f + bd_1;
                    rawData[5] = a * e;
                    rawData[9] = ad_1 * f - bc_1;
                    rawData[2] = bc_1 * f - ad_1;
                    rawData[6] = b * e;
                    rawData[10] = bd_1 * f + ac_1;
                    break;
                }
                case 2 /* YXZ */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce + df * b;
                    rawData[4] = de * b - cf;
                    rawData[8] = a * d;
                    rawData[1] = a * f;
                    rawData[5] = a * e;
                    rawData[9] = -b;
                    rawData[2] = cf * b - de;
                    rawData[6] = df + ce * b;
                    rawData[10] = a * c;
                    break;
                }
                case 3 /* YZX */: {
                    var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
                    rawData[0] = c * e;
                    rawData[4] = bd - ac * f;
                    rawData[8] = bc * f + ad;
                    rawData[1] = f;
                    rawData[5] = a * e;
                    rawData[9] = -b * e;
                    rawData[2] = -d * e;
                    rawData[6] = ad * f + bc;
                    rawData[10] = ac - bd * f;
                    break;
                }
                case 4 /* ZXY */: {
                    var ce = c * e, cf = c * f, de = d * e, df = d * f;
                    rawData[0] = ce - df * b;
                    rawData[4] = -a * f;
                    rawData[8] = de + cf * b;
                    rawData[1] = cf + de * b;
                    rawData[5] = a * e;
                    rawData[9] = df - ce * b;
                    rawData[2] = -a * d;
                    rawData[6] = b;
                    rawData[10] = a * c;
                    break;
                }
                case 5 /* ZYX */: {
                    var ae = a * e, af = a * f, be = b * e, bf = b * f;
                    rawData[0] = c * e;
                    rawData[4] = be * d - af;
                    rawData[8] = ae * d + bf;
                    rawData[1] = c * f;
                    rawData[5] = bf * d + ae;
                    rawData[9] = af * d - be;
                    rawData[2] = -d;
                    rawData[6] = b * c;
                    rawData[10] = a * c;
                    break;
                }
            }
            // bottom row
            rawData[3] = 0.0;
            rawData[7] = 0.0;
            rawData[11] = 0.0;
            if (!translateStays) {
                // last column
                rawData[12] = 0.0;
                rawData[13] = 0.0;
                rawData[14] = 0.0;
                rawData[15] = 1.0;
            }
            return this;
        };
        Matrix4.prototype.fromScale = function (x, y, z, translateStays) {
            if (translateStays === void 0) { translateStays = false; }
            if (translateStays) {
                _helpVector3A.fromArray(this.rawData, 12);
            }
            this.identity();
            this.rawData[0] = x;
            this.rawData[5] = y;
            this.rawData[10] = z;
            if (translateStays) {
                this.rawData[12] = _helpVector3A.x;
                this.rawData[13] = _helpVector3A.y;
                this.rawData[14] = _helpVector3A.z;
            }
            return this;
        };
        Matrix4.prototype.fromAxis = function (axis, radian) {
            if (radian === void 0) { radian = 0.0; }
            // Based on http://www.gamedev.net/reference/articles/article1199.asp
            var c = Math.cos(radian);
            var s = Math.sin(radian);
            var t = 1.0 - c;
            var x = axis.x, y = axis.y, z = axis.z;
            var tx = t * x, ty = t * y;
            this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0.0, tx * y + s * z, ty * y + c, ty * z - s * x, 0.0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromAxises = function (axisX, axisY, axisZ) {
            this.set(axisX.x, axisY.x, axisZ.x, 0.0, axisX.y, axisY.y, axisZ.y, 0.0, axisX.z, axisY.z, axisZ.z, 0.0, 0.0, 0.0, 0.0, 1.0);
            return this;
        };
        Matrix4.prototype.fromRotationX = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationY = function (radian) {
            var c = Math.cos(radian), s = Math.sin(radian);
            this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.fromRotationZ = function (theta) {
            var c = Math.cos(theta), s = Math.sin(theta);
            this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
            return this;
        };
        Matrix4.prototype.determinant = function () {
            var rawData = this.rawData;
            var n11 = rawData[0], n12 = rawData[4], n13 = rawData[8], n14 = rawData[12];
            var n21 = rawData[1], n22 = rawData[5], n23 = rawData[9], n24 = rawData[13];
            var n31 = rawData[2], n32 = rawData[6], n33 = rawData[10], n34 = rawData[14];
            var n41 = rawData[3], n42 = rawData[7], n43 = rawData[11], n44 = rawData[15];
            //TODO: make this more efficient
            //( based on https://github.com/mrdoob/three.js/blob/dev/src/math/Matrix4.js )
            return (n41 * (+n14 * n23 * n32
                - n13 * n24 * n32
                - n14 * n22 * n33
                + n12 * n24 * n33
                + n13 * n22 * n34
                - n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34
                    - n11 * n24 * n33
                    + n14 * n21 * n33
                    - n13 * n21 * n34
                    + n13 * n24 * n31
                    - n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32
                    - n11 * n22 * n34
                    - n14 * n21 * n32
                    + n12 * n21 * n34
                    + n14 * n22 * n31
                    - n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31
                    - n11 * n23 * n32
                    + n11 * n22 * n33
                    + n13 * n21 * n32
                    - n12 * n21 * n33
                    + n12 * n23 * n31));
        };
        Matrix4.prototype.compose = function (translation, rotation, scale) {
            var rawData = this.rawData;
            var x = rotation.x, y = rotation.y, z = rotation.z, w = rotation.w;
            var x2 = x + x, y2 = y + y, z2 = z + z;
            var xx = x * x2, xy = x * y2, xz = x * z2;
            var yy = y * y2, yz = y * z2, zz = z * z2;
            var wx = w * x2, wy = w * y2, wz = w * z2;
            var sx = scale.x, sy = scale.y, sz = scale.z;
            rawData[0] = (1.0 - (yy + zz)) * sx;
            rawData[1] = (xy + wz) * sx;
            rawData[2] = (xz - wy) * sx;
            rawData[3] = 0.0;
            rawData[4] = (xy - wz) * sy;
            rawData[5] = (1.0 - (xx + zz)) * sy;
            rawData[6] = (yz + wx) * sy;
            rawData[7] = 0.0;
            rawData[8] = (xz + wy) * sz;
            rawData[9] = (yz - wx) * sz;
            rawData[10] = (1.0 - (xx + yy)) * sz;
            rawData[11] = 0.0;
            rawData[12] = translation.x;
            rawData[13] = translation.y;
            rawData[14] = translation.z;
            rawData[15] = 1.0;
            return this;
        };
        Matrix4.prototype.decompose = function (translation, rotation, scale) {
            if (translation === void 0) { translation = null; }
            if (rotation === void 0) { rotation = null; }
            if (scale === void 0) { scale = null; }
            var rawData = this.rawData;
            if (translation) {
                translation.x = rawData[12];
                translation.y = rawData[13];
                translation.z = rawData[14];
            }
            if (rotation || scale) {
                var sx = _helpVector3A.set(rawData[0], rawData[1], rawData[2]).length;
                var sy = _helpVector3A.set(rawData[4], rawData[5], rawData[6]).length;
                var sz = _helpVector3A.set(rawData[8], rawData[9], rawData[10]).length;
                // if determine is negative, we need to invert one scale
                var det = this.determinant();
                if (det < 0.0)
                    sx = -sx;
                if (rotation) {
                    // scale the rotation part
                    _helpMatrix.copy(this);
                    var invSX = 1.0 / sx;
                    var invSY = 1.0 / sy;
                    var invSZ = 1.0 / sz;
                    _helpMatrix.rawData[0] *= invSX;
                    _helpMatrix.rawData[1] *= invSX;
                    _helpMatrix.rawData[2] *= invSX;
                    _helpMatrix.rawData[4] *= invSY;
                    _helpMatrix.rawData[5] *= invSY;
                    _helpMatrix.rawData[6] *= invSY;
                    _helpMatrix.rawData[8] *= invSZ;
                    _helpMatrix.rawData[9] *= invSZ;
                    _helpMatrix.rawData[10] *= invSZ;
                    rotation.fromMatrix(_helpMatrix);
                }
                if (scale) {
                    scale.x = sx;
                    scale.y = sy;
                    scale.z = sz;
                }
            }
            return this;
        };
        Matrix4.prototype.transpose = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var temp = 0.0;
            temp = valueRawData[1];
            rawData[1] = valueRawData[4];
            rawData[4] = temp;
            temp = valueRawData[2];
            rawData[2] = valueRawData[8];
            rawData[8] = temp;
            temp = valueRawData[6];
            rawData[6] = valueRawData[9];
            rawData[9] = temp;
            temp = valueRawData[3];
            rawData[3] = valueRawData[12];
            rawData[12] = temp;
            temp = valueRawData[7];
            rawData[7] = valueRawData[13];
            rawData[13] = temp;
            temp = valueRawData[11];
            rawData[11] = valueRawData[14];
            rawData[14] = temp;
            return this;
        };
        Matrix4.prototype.inverse = function (source) {
            if (!source) {
                source = this;
            }
            var valueRawData = source.rawData;
            var rawData = this.rawData;
            var n11 = valueRawData[0], n21 = valueRawData[1], n31 = valueRawData[2], n41 = valueRawData[3], n12 = valueRawData[4], n22 = valueRawData[5], n32 = valueRawData[6], n42 = valueRawData[7], n13 = valueRawData[8], n23 = valueRawData[9], n33 = valueRawData[10], n43 = valueRawData[11], n14 = valueRawData[12], n24 = valueRawData[13], n34 = valueRawData[14], n44 = valueRawData[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
            var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
            if (det === 0.0) {
                console.warn("Cannot invert matrix, determinant is 0.");
                return this.identity();
            }
            var detInv = 1.0 / det;
            rawData[0] = t11 * detInv;
            rawData[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
            rawData[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
            rawData[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
            rawData[4] = t12 * detInv;
            rawData[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
            rawData[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
            rawData[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
            rawData[8] = t13 * detInv;
            rawData[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
            rawData[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
            rawData[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
            rawData[12] = t14 * detInv;
            rawData[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
            rawData[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
            rawData[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
            return this;
        };
        Matrix4.prototype.multiplyScalar = function (value, source) {
            if (!source) {
                source = this;
            }
            var sourceRawData = source.rawData;
            var rawData = this.rawData;
            rawData[0] = sourceRawData[0] * value;
            rawData[1] = sourceRawData[1] * value;
            rawData[2] = sourceRawData[2] * value;
            rawData[3] = sourceRawData[3] * value;
            rawData[4] = sourceRawData[4] * value;
            rawData[5] = sourceRawData[5] * value;
            rawData[6] = sourceRawData[6] * value;
            rawData[7] = sourceRawData[7] * value;
            rawData[8] = sourceRawData[8] * value;
            rawData[9] = sourceRawData[9] * value;
            rawData[10] = sourceRawData[10] * value;
            rawData[11] = sourceRawData[11] * value;
            rawData[12] = sourceRawData[12] * value;
            rawData[13] = sourceRawData[13] * value;
            rawData[14] = sourceRawData[14] * value;
            rawData[15] = sourceRawData[15] * value;
        };
        Matrix4.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var ae = valueA.rawData;
            var be = valueB.rawData;
            var te = this.rawData;
            var a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];
            var a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];
            var a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];
            var a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];
            var b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];
            var b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];
            var b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];
            var b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];
            te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
            te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
            te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
            te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
            te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
            te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
            te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
            te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
            te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
            te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
            te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
            te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
            te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
            te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
            te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
            te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
            return this;
        };
        Matrix4.prototype.premultiply = function (value) {
            return this.multiply(value, this);
        };
        Matrix4.prototype.lerp = function (t, value, source) {
            if (!source) {
                source = this;
            }
            var p = 1.0 - t;
            for (var i = 0; i < 16; i++) {
                this.rawData[i] = source.rawData[i] * p + value.rawData[i] * t;
            }
            return this;
        };
        /**
         * - 两点位置不重合。
         * @param eye
         * @param target
         * @param up
         */
        Matrix4.prototype.lookAt = function (eye, target, up) {
            var z = _helpVector3C.subtract(target, eye).normalize(); //right handle
            var x = _helpVector3A.cross(up, z).normalize();
            var y = _helpVector3B.cross(z, x);
            var rawData = this.rawData;
            rawData[0] = x.x;
            rawData[4] = y.x;
            rawData[8] = z.x;
            rawData[1] = x.y;
            rawData[5] = y.y;
            rawData[9] = z.y;
            rawData[2] = x.z;
            rawData[6] = y.z;
            rawData[10] = z.z;
            return this;
        };
        Matrix4.prototype.getMaxScaleOnAxis = function () {
            var rawData = this.rawData;
            var scaleXSq = rawData[0] * rawData[0] + rawData[1] * rawData[1] + rawData[2] * rawData[2];
            var scaleYSq = rawData[4] * rawData[4] + rawData[5] * rawData[5] + rawData[6] * rawData[6];
            var scaleZSq = rawData[8] * rawData[8] + rawData[9] * rawData[9] + rawData[10] * rawData[10];
            return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
        };
        Matrix4.prototype.toEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = this.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            switch (order) {
                case 0 /* XYZ */: {
                    value.y = Math.asin(egret3d.floatClamp(m13, -1.0, 1.0));
                    if (Math.abs(m13) < 0.999999) {
                        value.x = Math.atan2(-m23, m33);
                        value.z = Math.atan2(-m12, m11);
                    }
                    else {
                        value.x = Math.atan2(m32, m22);
                        value.z = 0.0;
                    }
                    break;
                }
                case 1 /* XZY */: {
                    value.z = Math.asin(-egret3d.floatClamp(m12, -1.0, 1.0));
                    if (Math.abs(m12) < 0.999999) {
                        value.x = Math.atan2(m32, m22);
                        value.y = Math.atan2(m13, m11);
                    }
                    else {
                        value.x = Math.atan2(-m23, m33);
                        value.y = 0.0;
                    }
                    break;
                }
                case 2 /* YXZ */: {
                    value.x = Math.asin(-egret3d.floatClamp(m23, -1.0, 1.0));
                    if (Math.abs(m23) < 0.999999) {
                        value.y = Math.atan2(m13, m33);
                        value.z = Math.atan2(m21, m22);
                    }
                    else {
                        value.y = Math.atan2(-m31, m11);
                        value.z = 0.0;
                    }
                    break;
                }
                case 3 /* YZX */: {
                    value.z = Math.asin(egret3d.floatClamp(m21, -1.0, 1.0));
                    if (Math.abs(m21) < 0.999999) {
                        value.x = Math.atan2(-m23, m22);
                        value.y = Math.atan2(-m31, m11);
                    }
                    else {
                        value.x = 0.0;
                        value.y = Math.atan2(m13, m33);
                    }
                    break;
                }
                case 4 /* ZXY */: {
                    value.x = Math.asin(egret3d.floatClamp(m32, -1.0, 1.0));
                    if (Math.abs(m32) < 0.999999) {
                        value.y = Math.atan2(-m31, m33);
                        value.z = Math.atan2(-m12, m22);
                    }
                    else {
                        value.y = 0.0;
                        value.z = Math.atan2(m21, m11);
                    }
                    break;
                }
                case 5 /* ZYX */: {
                    value.y = Math.asin(-egret3d.floatClamp(m31, -1.0, 1.0));
                    if (Math.abs(m31) < 0.999999) {
                        value.x = Math.atan2(m32, m33);
                        value.z = Math.atan2(m21, m11);
                    }
                    else {
                        value.x = 0.0;
                        value.z = Math.atan2(-m12, m22);
                    }
                    break;
                }
            }
            return value;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformVector3 = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            if (!out) {
                out = value;
            }
            out.x = x / w;
            out.y = y / w;
            out.z = z / w;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.transformNormal = function (value, out) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            if (!out) {
                out = value;
            }
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.scale = function (scaler) {
            var rawData = this.rawData;
            rawData[0] *= scaler;
            rawData[1] *= scaler;
            rawData[2] *= scaler;
            rawData[3] *= scaler;
            rawData[4] *= scaler;
            rawData[5] *= scaler;
            rawData[6] *= scaler;
            rawData[7] *= scaler;
            rawData[8] *= scaler;
            rawData[9] *= scaler;
            rawData[10] *= scaler;
            rawData[11] *= scaler;
            rawData[12] *= scaler;
            rawData[13] *= scaler;
            rawData[14] *= scaler;
            rawData[15] *= scaler;
            return this;
        };
        /**
         * @deprecated
         */
        Matrix4.prototype.add = function (left, right) {
            if (!right) {
                right = left;
                left = this;
            }
            this.rawData[0] = left.rawData[0] + right.rawData[0];
            this.rawData[1] = left.rawData[1] + right.rawData[1];
            this.rawData[2] = left.rawData[2] + right.rawData[2];
            this.rawData[3] = left.rawData[3] + right.rawData[3];
            this.rawData[4] = left.rawData[4] + right.rawData[4];
            this.rawData[5] = left.rawData[5] + right.rawData[5];
            this.rawData[6] = left.rawData[6] + right.rawData[6];
            this.rawData[7] = left.rawData[7] + right.rawData[7];
            this.rawData[8] = left.rawData[8] + right.rawData[8];
            this.rawData[9] = left.rawData[9] + right.rawData[9];
            this.rawData[10] = left.rawData[10] + right.rawData[10];
            this.rawData[11] = left.rawData[11] + right.rawData[11];
            this.rawData[12] = left.rawData[12] + right.rawData[12];
            this.rawData[13] = left.rawData[13] + right.rawData[13];
            this.rawData[14] = left.rawData[14] + right.rawData[14];
            this.rawData[15] = left.rawData[15] + right.rawData[15];
            return this;
        };
        /**
         * @deprecated
         */
        Matrix4.perspectiveProjectLH = function (fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (zfar + znear) / (zfar - znear);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = -2 * (znear * zfar) / (zfar - znear);
            return out;
        };
        /**
         * @deprecated
         */
        Matrix4.orthoProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        Matrix4._instances = [];
        return Matrix4;
    }());
    egret3d.Matrix4 = Matrix4;
    __reflect(Matrix4.prototype, "egret3d.Matrix4", ["paper.IRelease", "paper.ISerializable"]);
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = Matrix4.create();
    egret3d.helpMatrixA = Matrix4.create();
    egret3d.helpMatrixB = Matrix4.create();
    egret3d.helpMatrixC = Matrix4.create();
    egret3d.helpMatrixD = Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var RendererEventType;
    (function (RendererEventType) {
        RendererEventType["Materials"] = "materials";
    })(RendererEventType = paper.RendererEventType || (paper.RendererEventType = {}));
    var _helpVector3A = egret3d.Vector3.create();
    /**
     * renderer component interface
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 渲染器组件接口
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._boundingSphereDirty = true;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._lightmapIndex = -1;
            _this._boundingSphere = egret3d.Sphere.create();
            _this._aabb = egret3d.AABB.create();
            _this._lightmapScaleOffset = new Float32Array([1.0, 1.0, 0.0, 0.0]);
            return _this;
        }
        BaseRenderer.prototype._recalculateSphere = function () {
            var worldMatrix = this.gameObject.transform.getWorldMatrix();
            this._boundingSphere.set(this._aabb.center, this._aabb.boundingSphereRadius);
            this._boundingSphere.center.applyMatrix(worldMatrix);
            this._boundingSphere.radius *= worldMatrix.getMaxScaleOnAxis();
        };
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            /**
             *
             */
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            /**
             *
             */
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapIndex", {
            /**
             *
             */
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "aabb", {
            /**
             *
             */
            get: function () {
                return this._aabb;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "boundingSphere", {
            /**
             *
             */
            get: function () {
                if (this._boundingSphereDirty) {
                    this._recalculateSphere();
                    this._boundingSphereDirty = false;
                }
                return this._boundingSphere;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapScaleOffset", {
            /**
             * TODO
             */
            get: function () {
                return this._lightmapScaleOffset;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapScaleOffset", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseRenderer.prototype, "lightmapIndex", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    /**
     * 射线
     */
    var Ray = (function () {
        /**
         * 请使用 `egret3d.Ray.create()` 创建实例。
         * @see egret3d.Ray.create()
         */
        function Ray() {
            /**
             * 射线起始点
             */
            this.origin = egret3d.Vector3.create();
            /**
             * 射线的方向向量
             */
            this.direction = egret3d.Vector3.create();
        }
        Ray.create = function (origin, direction) {
            if (origin === void 0) { origin = egret3d.Vector3.ZERO; }
            if (direction === void 0) { direction = egret3d.Vector3.RIGHT; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(origin, direction);
            }
            return new Ray().set(origin, direction);
        };
        Ray.prototype.release = function () {
            if (Ray._instances.indexOf(this) >= 0) {
                Ray._instances.push(this);
            }
            return this;
        };
        Ray.prototype.serialize = function () {
            return [this.origin.x, this.origin.y, this.origin.z, this.direction.x, this.direction.y, this.direction.z];
        };
        Ray.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Ray.prototype.copy = function (value) {
            return this.set(value.origin, value.direction);
        };
        Ray.prototype.clone = function () {
            return Ray.create(this.origin, this.direction);
        };
        Ray.prototype.set = function (origin, direction) {
            this.origin.copy(origin);
            this.direction.copy(direction);
            return this;
        };
        Ray.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.origin.fromArray(value);
            this.direction.fromArray(value, 3);
            return this;
        };
        Ray.prototype.getSquaredDistance = function (value) {
            var directionDistance = egret3d.helpVector3A.subtract(value, this.origin).dot(this.direction);
            // point behind the ray
            if (directionDistance < 0.0) {
                return this.origin.getSquaredDistance(value);
            }
            egret3d.helpVector3A.multiplyScalar(directionDistance, this.direction).add(this.origin);
            return egret3d.helpVector3A.getSquaredDistance(value);
        };
        Ray.prototype.getDistance = function (value) {
            return Math.sqrt(this.getSquaredDistance(value));
        };
        /**
         * 与三角形相交检测
         */
        Ray.prototype.intersectTriangle = function (p1, p2, p3, backfaceCulling) {
            // // from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
            // const edge1 = helpVector3A;
            // const edge2 = helpVector3B;
            // const diff = helpVector3C;
            // const normal = helpVector3D;
            if (backfaceCulling === void 0) { backfaceCulling = false; }
            // edge1.subtract(p2, p1);
            // edge2.subtract(p3, p1);
            // normal.cross(edge1, edge2);
            // // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
            // // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
            // //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
            // //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
            // //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
            // let DdN = this.direction.dot(normal);
            // let sign = 1.0;
            // if (DdN > 0.0) {
            //     if (backfaceCulling) return null;
            // }
            // else if (DdN < 0.0) {
            //     sign = -1.0;
            //     DdN = -DdN;
            // }
            // else {
            //     return null;
            // }
            // diff.subtract(this.origin, p1);
            // const DdQxE2 = sign * this.direction.dot(edge2.cross(diff, edge2));
            // // b1 < 0, no intersection
            // if (DdQxE2 < 0.0) {
            //     return null;
            // }
            // const DdE1xQ = sign * this.direction.dot(edge1.cross(diff));
            // // b2 < 0, no intersection
            // if (DdE1xQ < 0.0) {
            //     return null;
            // }
            // // b1+b2 > 1, no intersection
            // if (DdQxE2 + DdE1xQ > DdN) {
            //     return null;
            // }
            // // Line intersects triangle, check if ray does.
            // const QdN = - sign * diff.dot(normal);
            // // t < 0, no intersection
            // if (QdN < 0) {
            //     return null;
            // }
            // const pickInfo = new PickInfo();
            // pickInfo.distance = QdN / DdN;
            // pickInfo.position.multiplyScalar(pickInfo.distance, this.direction).add(this.origin);
            // pickInfo.textureCoordA.x = DdQxE2;
            // pickInfo.textureCoordA.y = DdE1xQ;
            // return pickInfo;
            // TODO
            var edge1 = egret3d.helpVector3A;
            var edge2 = egret3d.helpVector3B;
            var pvec = egret3d.helpVector3C;
            var tvec = egret3d.helpVector3D;
            var qvec = egret3d.helpVector3E;
            edge1.subtract(p2, p1);
            edge2.subtract(p3, p1);
            pvec.cross(this.direction, edge2);
            var det = pvec.dot(edge1);
            if (det === 0.0) {
                return null;
            }
            var invdet = 1.0 / det;
            tvec.subtract(this.origin, p1);
            var bu = pvec.dot(tvec) * invdet;
            if (bu < 0.0 || bu > 1.0) {
                return null;
            }
            qvec.cross(tvec, edge1);
            var bv = qvec.dot(this.direction) * invdet;
            if (bv < 0.0 || bu + bv > 1.0) {
                return null;
            }
            var pickInfo = new PickInfo();
            pickInfo.distance = qvec.dot(edge2) * invdet;
            pickInfo.position.multiplyScalar(pickInfo.distance, this.direction).add(this.origin);
            pickInfo.textureCoordA.x = bu;
            pickInfo.textureCoordA.y = bv;
            return pickInfo;
        };
        /**
         * 与aabb碰撞相交检测
         */
        Ray.prototype.intersectAABB = function (aabb) {
            return this.intersectBoxMinMax(aabb.minimum, aabb.maximum);
        };
        Ray.prototype.intersectPlane = function (planePoint, planeNormal) {
            var vp1 = planeNormal.x;
            var vp2 = planeNormal.y;
            var vp3 = planeNormal.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = this.direction.x;
            var v2 = this.direction.y;
            var v3 = this.direction.z;
            var m1 = this.origin.x;
            var m2 = this.origin.y;
            var m3 = this.origin.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                return null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                return new egret3d.Vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
            }
        };
        // /**
        //  * 与transform表示的plane碰撞相交检测，主要用于2d检测
        //  * @param transform transform实例
        //  */
        // public intersectPlaneTransform(transform: Transform): PickInfo {
        //     let pickinfo = null;
        //     let panelpoint = transform.getPosition();
        //     let forward = helpVec3_1;
        //     transform.getForward(forward);
        //     let hitposition = this.intersectPlane(panelpoint, forward);
        //     if (hitposition) {
        //         pickinfo = new PickInfo();
        //         pickinfo.hitposition = hitposition;
        //         pickinfo.distance = Vector3.getDistance(pickinfo.hitposition, this.origin);
        //     }
        //     return pickinfo;
        // }
        /**
         * 与最大最小点表示的box相交检测
         * @param minimum 最小点
         * @param maximum 最大点
         * @version paper 1.0
         */
        Ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
            var d = 0.0;
            var maxValue = Number.MAX_VALUE;
            var inv;
            var min;
            var max;
            var temp;
            if (Math.abs(this.direction.x) < 0.0000001) {
                if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.x;
                min = (minimum.x - this.origin.x) * inv;
                max = (maximum.x - this.origin.x) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.y) < 0.0000001) {
                if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.y;
                min = (minimum.y - this.origin.y) * inv;
                max = (maximum.y - this.origin.y) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.z) < 0.0000001) {
                if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.z;
                min = (minimum.z - this.origin.z) * inv;
                max = (maximum.z - this.origin.z) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            return true;
        };
        /**
         * 与球相交检测
         */
        Ray.prototype.intersectsSphere = function (center, radius) {
            var center_ori = helpVec3_1;
            egret3d.Vector3.subtract(center, this.origin, center_ori);
            var raydist = egret3d.Vector3.dot(this.direction, center_ori);
            if (raydist < 0)
                return false; // 到圆心的向量在方向向量上的投影为负，夹角不在-90与90之间
            var orilen2 = egret3d.Vector3.getSqrLength(center_ori);
            var rad2 = radius * radius;
            if (orilen2 < rad2)
                return true; // 射线起点在球里
            var d = rad2 - (orilen2 - raydist * raydist);
            if (d < 0)
                return false;
            return true;
        };
        /**
         * 获取射线拾取到的最近物体。
         */
        Ray.raycast = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, false, isPickMesh);
        };
        /**
         * 获取射线路径上的所有物体。
         */
        Ray.raycastAll = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, true, isPickMesh);
        };
        Ray._doPick = function (ray, maxDistance, layerMask, pickAll, isPickMesh) {
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (pickAll === void 0) { pickAll = false; }
            if (isPickMesh === void 0) { isPickMesh = false; }
            var pickedList = [];
            for (var _i = 0, _a = paper.Application.sceneManager.activeScene.getRootGameObjects(); _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.layer & layerMask) {
                    if (isPickMesh) {
                        this._pickMesh(ray, gameObject.transform, pickedList);
                    }
                    else {
                        this._pickCollider(ray, gameObject.transform, pickedList);
                    }
                }
            }
            if (pickedList.length === 0) {
                return null;
            }
            if (pickAll) {
                return pickedList;
            }
            var index = 0;
            for (var i = 1; i < pickedList.length; i++) {
                if (pickedList[i].distance < pickedList[index].distance) {
                    index = i;
                }
            }
            return pickedList[index];
        };
        Ray._pickMesh = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                var meshFilter = transform.gameObject.getComponent(egret3d.MeshFilter);
                if (meshFilter) {
                    var mesh = meshFilter.mesh;
                    if (mesh) {
                        var pickinfo = mesh.raycast(ray, transform.getWorldMatrix());
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
                else {
                    var skinmesh = transform.gameObject.getComponent(egret3d.SkinnedMeshRenderer);
                    if (skinmesh && skinmesh.mesh) {
                        var pickinfo = skinmesh.mesh.raycast(ray, transform.getWorldMatrix());
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickMesh(ray, child, pickInfos);
            }
        };
        Ray._pickCollider = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                // const pickInfo = ray.intersectCollider(transform);
                // if (pickInfo) {
                //     pickInfos.push(pickInfo);
                //     pickInfo.transform = transform;
                // }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickCollider(ray, child, pickInfos);
            }
        };
        Ray._instances = [];
        return Ray;
    }());
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray", ["paper.IRelease", "paper.ISerializable"]);
    /**
     * 场景拣选信息
     */
    var PickInfo = (function () {
        function PickInfo() {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = 0.0;
            this.position = new egret3d.Vector3();
            this.textureCoordA = new egret3d.Vector2();
            this.textureCoordB = new egret3d.Vector2();
            this.transform = null;
        }
        return PickInfo;
    }());
    egret3d.PickInfo = PickInfo;
    __reflect(PickInfo.prototype, "egret3d.PickInfo");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset._createConfig = function () {
            var config = {
                version: "4",
                asset: {
                    version: "2.0"
                },
                extensions: {},
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return config;
        };
        /**
         * @internal
         */
        GLTFAsset.parseFromBinary = function (array) {
            var index = 0;
            var result = { config: {}, buffers: [] };
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    result.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    result.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
            return result;
        };
        /**
         *
         */
        GLTFAsset.createMeshConfig = function () {
            var config = this._createConfig();
            config.buffers = [{ byteLength: 0 }];
            config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }]; // VBO
            config.accessors = [];
            config.meshes = [{
                    primitives: [{ attributes: {} }],
                    extensions: { paper: {} },
                }];
            return config;
        };
        /**
         *
         */
        GLTFAsset.createGLTFExtensionsConfig = function () {
            var config = this._createConfig();
            config.materials = [];
            config.extensions = {
                KHR_techniques_webgl: {
                    shaders: [],
                    techniques: [],
                    programs: [],
                },
                paper: {},
            };
            return config;
        };
        GLTFAsset.createTechnique = function (source) {
            var target = { name: source.name, attributes: {}, uniforms: {} }; // , states: { enable: [], functions: {} }
            for (var key in source.attributes) {
                var attribute = source.attributes[key];
                target.attributes[key] = { semantic: attribute.semantic };
            }
            for (var key in source.uniforms) {
                var uniform = source.uniforms[key];
                var value = void 0;
                if (uniform.type === 35678 /* SAMPLER_2D */ && !uniform.value) {
                    value = egret3d.DefaultTextures.WHITE; // Default texture.
                }
                else if (Array.isArray(uniform.value)) {
                    value = uniform.value ? uniform.value.concat() : [];
                }
                else {
                    value = uniform.value ? uniform.value : [];
                }
                var targetUniform = target.uniforms[key] = { type: uniform.type, value: value };
                if (uniform.semantic) {
                    targetUniform.semantic = uniform.semantic;
                }
            }
            // if (source.states) {
            //     const states = GLTFAsset.copyTechniqueStates(source.states);
            //     if (states) {
            //         target.states = states;
            //     }
            // }
            return target;
        };
        GLTFAsset.copyTechniqueStates = function (source, target) {
            if (source.enable && source.enable.length > 0) {
                if (!target) {
                    target = {};
                }
                target.enable = source.enable.concat();
            }
            if (source.functions) {
                for (var k in source.functions) {
                    if (!target) {
                        target = {};
                    }
                    if (!target.functions) {
                        target.functions = {};
                    }
                    if (Array.isArray(source.functions[k])) {
                        target.functions[k] = source.functions[k].concat();
                    }
                    else {
                        target.functions[k] = source.functions[k];
                    }
                }
            }
            return target;
        };
        GLTFAsset.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            this.buffers.length = 0; // TODO clear buffer.
            this.config = null;
            return true;
        };
        GLTFAsset.prototype.caclByteLength = function () {
            return 0;
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                default:
                    throw new Error();
            }
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorTypeCount = this.getAccessorTypeCount(accessor.type);
            var bufferCount = accessorTypeCount * (count || accessor.count);
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            if (offset > 0) {
                bufferOffset += offset * accessorTypeCount * this.getComponentTypeCount(accessor.componentType);
            }
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.prototype.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * 自定义 Mesh 的属性枚举。
         */
        GLTFAsset.prototype.getMeshAttributeType = function (type) {
            switch (type) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return this.getAccessorTypeCount(accessor.type) * this.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            return this.config.nodes[index];
        };
        /*
         * 获取动画剪辑。
         */
        GLTFAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Prefab.create = function (name, xOrScene, y, z, scene) {
            var prefab = paper.Asset.find(name);
            if (prefab) {
                if (xOrScene !== undefined && xOrScene !== null) {
                    if (xOrScene instanceof paper.Scene) {
                        var gameObject = prefab.createInstance(xOrScene);
                        gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                        return gameObject;
                    }
                    else {
                        var gameObject = prefab.createInstance(scene || null);
                        gameObject.transform.setLocalPosition(xOrScene, y, z);
                        return gameObject;
                    }
                }
                else {
                    var gameObject = prefab.createInstance();
                    gameObject.transform.setLocalPosition(0.0, 0.0, 0.0);
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * @deprecated
         */
        Prefab.prototype.createInstance = function (scene, keepUUID) {
            if (!this._raw) {
                return null;
            }
            var isEditor = paper.Application.playerMode === 2 /* Editor */;
            var deserializer = new paper.Deserializer();
            var gameObject = deserializer.deserialize(this._raw, keepUUID, isEditor, scene);
            if (gameObject && isEditor) {
                if (!gameObject.extras.prefab) {
                    gameObject.extras.prefab = this;
                }
            }
            return gameObject;
        };
        return Prefab;
    }(paper.BaseObjectAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * SystemManager 是ecs内部的系统管理者，负责每帧循环时轮询每个系统。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._systems = [];
            this._currentSystem = null;
        }
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._preRegister = function (systemClass) {
            if (this.getSystem(systemClass)) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return true;
            }
            return false;
        };
        /**
         * 注册一个系统到管理器中。
         */
        SystemManager.prototype.register = function (systemClass, after) {
            if (after === void 0) { after = paper.UpdateSystem; }
            if (this._preRegister(systemClass)) {
                return;
            }
            var index = -1;
            var system = paper.BaseSystem.create(systemClass);
            if (after) {
                for (var i = 0, l = this._systems.length; i < l; ++i) {
                    var eachSystem = this._systems[i];
                    if (eachSystem && eachSystem.constructor === after) {
                        index = i + 1;
                        this._systems.splice(index, 0, system);
                        break;
                    }
                }
            }
            if (index < 0) {
                this._systems.push(system);
            }
            system.initialize();
        };
        /**
         * 注册一个系统到管理器中。
         */
        SystemManager.prototype.registerBefore = function (systemClass, before) {
            if (before === void 0) { before = null; }
            if (this._preRegister(systemClass)) {
                return;
            }
            var index = -1;
            var system = paper.BaseSystem.create(systemClass);
            if (before) {
                for (var i = 0, l = this._systems.length; i < l; ++i) {
                    var eachSystem = this._systems[i];
                    if (eachSystem && eachSystem.constructor === before) {
                        index = i;
                        this._systems.splice(index, 0, system);
                        break;
                    }
                }
            }
            if (index < 0) {
                this._systems.unshift(system);
            }
            system.initialize();
        };
        /**
         *
         */
        SystemManager.prototype.enableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = true;
            }
            else {
                console.warn("Enable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         *
         */
        SystemManager.prototype.disableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = false;
            }
            else {
                console.warn("Disable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         * 获取一个管理器中指定的系统实例。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * @internal
         */
        SystemManager.prototype.update = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.enabled && !system._started) {
                    this._currentSystem = system;
                    system._started = true;
                    system.onStart && system.onStart();
                }
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    this._currentSystem = system;
                    system.update();
                }
            }
            for (var _d = 0, _e = this._systems; _d < _e.length; _d++) {
                var system = _e[_d];
                if (system) {
                    this._currentSystem = system;
                    system.lateUpdate();
                }
            }
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             *
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 场景管理器
     */
    var SceneManager = (function () {
        function SceneManager() {
            /**
             *
             */
            this.camerasScene = null;
            /**
             *
             */
            this.lightsScene = null;
            this._scenes = [];
            this._globalScene = null;
            this._editorScene = null;
            this._globalGameObject = null;
        }
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype._addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) >= 0) {
                console.debug("Add the scene again.", scene.name);
            }
            if (isActive) {
                this._scenes.unshift(scene);
            }
            else {
                this._scenes.push(scene);
            }
        };
        /**
         * @internal
         */
        SceneManager.prototype._removeScene = function (scene) {
            if (scene === this._globalScene ||
                scene === this._editorScene) {
                console.warn("Cannot dispose global scene.");
                return false;
            }
            var index = this._scenes.indexOf(scene);
            if (index < 0) {
                console.debug("Remove scene error.", scene.name);
                return false;
            }
            this._scenes.splice(index, 1);
            return true;
        };
        /**
         * 卸载所有场景。
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            var i = this._scenes.length;
            while (i--) {
                var scene = this._scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                scene.destroy();
            }
        };
        /**
         *
         */
        SceneManager.prototype.getSceneByName = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             *
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             *
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = paper.Scene.createEmpty("Global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                if (this._scenes.length === 0) {
                    paper.Scene.createEmpty();
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value //|| // Cannot active global scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index < 0) {
                    console.debug("Active scene error.", value.name);
                }
                this._scenes.splice(index, 1);
                this._scenes.unshift(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             *
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = paper.Scene.createEmpty("Editor" /* Editor */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalGameObject", {
            /**
             *
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = paper.GameObject.create("Global" /* Global */, "Global" /* Global */, this.globalScene);
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            return paper.Scene.createEmpty(name, isActive);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            return paper.Scene.create(resourceName, combineStaticObjects);
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.unloadScene = function (scene) {
            scene.destroy();
        };
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Quaternion = (function (_super) {
        __extends(Quaternion, _super);
        function Quaternion() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         *
         */
        Quaternion.create = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            if (this._instancesQ.length > 0) {
                return this._instancesQ.pop().set(x, y, z, w);
            }
            return new Quaternion().set(x, y, z, w);
        };
        Quaternion.prototype.release = function () {
            if (Quaternion._instancesQ.indexOf(this) < 0) {
                Quaternion._instancesQ.push(this);
            }
            return this;
        };
        Quaternion.prototype.clone = function () {
            return Quaternion.create(this.x, this.y, this.z, this.w);
        };
        Quaternion.prototype.fromMatrix = function (matrix) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
            // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
            var rawData = matrix.rawData;
            var m11 = rawData[0], m12 = rawData[4], m13 = rawData[8];
            var m21 = rawData[1], m22 = rawData[5], m23 = rawData[9];
            var m31 = rawData[2], m32 = rawData[6], m33 = rawData[10];
            var trace = m11 + m22 + m33;
            var s = 0.0;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                this.w = 0.25 / s;
                this.x = (m32 - m23) * s;
                this.y = (m13 - m31) * s;
                this.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                this.w = (m32 - m23) / s;
                this.x = 0.25 * s;
                this.y = (m12 + m21) / s;
                this.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                this.w = (m13 - m31) / s;
                this.x = (m12 + m21) / s;
                this.y = 0.25 * s;
                this.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                this.w = (m21 - m12) / s;
                this.x = (m13 + m31) / s;
                this.y = (m23 + m32) / s;
                this.z = 0.25 * s;
            }
            return this;
        };
        Quaternion.prototype.fromEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            var x = value.x, y = value.y, z = value.z;
            // http://www.mathworks.com/matlabcentral/fileexchange/
            // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
            //	content/SpinCalc.m
            var cos = Math.cos;
            var sin = Math.sin;
            var c1 = cos(x * 0.5);
            var c2 = cos(y * 0.5);
            var c3 = cos(z * 0.5);
            var s1 = sin(x * 0.5);
            var s2 = sin(y * 0.5);
            var s3 = sin(z * 0.5);
            switch (order) {
                case 0 /* XYZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 1 /* XZY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 2 /* YXZ */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 - s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
                case 3 /* YZX */:
                    this.x = s1 * c2 * c3 + c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 4 /* ZXY */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 + s1 * s2 * c3;
                    this.w = c1 * c2 * c3 - s1 * s2 * s3;
                    break;
                case 5 /* ZYX */:
                    this.x = s1 * c2 * c3 - c1 * s2 * s3;
                    this.y = c1 * s2 * c3 + s1 * c2 * s3;
                    this.z = c1 * c2 * s3 - s1 * s2 * c3;
                    this.w = c1 * c2 * c3 + s1 * s2 * s3;
                    break;
            }
            return this;
        };
        /**
         * - 向量必须已归一化。
         */
        Quaternion.prototype.fromAxis = function (axis, radian) {
            // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
            // assumes axis is normalized
            var halfAngle = radian * 0.5, s = Math.sin(halfAngle);
            this.x = axis.x * s;
            this.y = axis.y * s;
            this.z = axis.z * s;
            this.w = Math.cos(halfAngle);
            return this;
        };
        Quaternion.prototype.inverse = function (source) {
            if (!source) {
                source = this;
            }
            this.x = source.x * -1;
            this.y = source.y * -1;
            this.z = source.z * -1;
            return this;
        };
        Quaternion.prototype.dot = function (value) {
            return this.x * value.x + this.y * value.y + this.z * value.z + this.w * value.w;
        };
        Quaternion.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            var qax = valueA.x, qay = valueA.y, qaz = valueA.z, qaw = valueA.w;
            var qbx = valueB.x, qby = valueB.y, qbz = valueB.z, qbw = valueB.w;
            this.x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
            this.y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
            this.z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
            this.w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
            return this;
        };
        Quaternion.prototype.premultiply = function (value) {
            return this.multiply(value, this);
        };
        Quaternion.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            if (t === 0.0)
                return this.copy(valueA);
            if (t === 1.0)
                return this.copy(valueB);
            var x = valueA.x, y = valueA.y, z = valueA.z, w = valueA.w;
            // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
            var cosHalfTheta = w * valueB.w + x * valueB.x + y * valueB.y + z * valueB.z;
            if (cosHalfTheta < 0.0) {
                this.w = -valueB.w;
                this.x = -valueB.x;
                this.y = -valueB.y;
                this.z = -valueB.z;
                cosHalfTheta = -cosHalfTheta;
            }
            else {
                this.copy(valueB);
            }
            if (cosHalfTheta >= 1.0) {
                this.w = w;
                this.x = x;
                this.y = y;
                this.z = z;
                return this;
            }
            var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
            if (sqrSinHalfTheta <= egret3d.EPSILON) {
                var s = 1.0 - t;
                this.w = s * w + t * this.w;
                this.x = s * x + t * this.x;
                this.y = s * y + t * this.y;
                this.z = s * z + t * this.z;
                return this.normalize();
            }
            var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
            var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
            var ratioA = Math.sin((1.0 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
            this.w = (w * ratioA + this.w * ratioB);
            this.x = (x * ratioA + this.x * ratioB);
            this.y = (y * ratioA + this.y * ratioB);
            this.z = (z * ratioA + this.z * ratioB);
        };
        Quaternion.prototype.lookAt = function (eye, target) {
            var dir = _helpVector3A.subtract(target, eye).normalize();
            var dirxz = _helpVector3B.set(dir.x, 0.0, dir.z).normalize();
            var dirxz1 = _helpVector3C.set(dir.x, 0.0, dir.z);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var v3length = dirxz1.length;
            if (v3length > 0.999999) {
                v3length = 1.0;
            }
            else if (v3length < -0.999999) {
                v3length = -1.0;
            }
            var pitch = Math.acos(v3length);
            if (dir.y > 0.0) {
                pitch = -pitch;
            }
            _helpVector3A.set(pitch, yaw, 0.0);
            this.fromEuler(_helpVector3A, 5 /* ZYX */).normalize();
            return this;
        };
        Quaternion.prototype.toEuler = function (value, order) {
            if (order === void 0) { order = 2 /* YXZ */; }
            return _helpMatrix.fromRotation(this).toEuler(value, order);
        };
        Quaternion._instancesQ = [];
        return Quaternion;
    }(egret3d.Vector4));
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion");
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    ;
    /**
     * 单例组件基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         *
         */
        SingletonComponent.getInstance = function (componentClass) {
            if (this.__instance) {
                return this.__instance;
            }
            return paper.Application.sceneManager.globalGameObject.getOrAddComponent(componentClass);
        };
        SingletonComponent.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            if (this.constructor.__instance) {
                console.debug("Initialize singleton component error.", egret.getQualifiedClassName(this));
            }
            this.constructor.__instance = this;
        };
        SingletonComponent.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this.constructor.__instance !== this) {
                console.debug("Uninitialize singleton component error.", egret.getQualifiedClassName(this));
            }
            this.constructor.__instance = null;
        };
        /**
         * @internal
         */
        SingletonComponent.__isSingleton = true;
        /**
         * @internal
         */
        SingletonComponent.__instance = null;
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var HideFlags;
    (function (HideFlags) {
        /**
         *
         */
        HideFlags[HideFlags["None"] = 0] = "None";
        /**
         *
         */
        HideFlags[HideFlags["NotEditable"] = 1] = "NotEditable";
        /**
         *
         */
        HideFlags[HideFlags["Hide"] = 2] = "Hide";
        /**
         *
         */
        HideFlags[HideFlags["HideAndDontSave"] = 3] = "HideAndDontSave";
    })(HideFlags = paper.HideFlags || (paper.HideFlags = {}));
    /**
     *
     */
    var DefaultNames;
    (function (DefaultNames) {
        DefaultNames["NoName"] = "NoName";
        DefaultNames["Global"] = "Global";
        DefaultNames["MainCamera"] = "MainCamera";
        DefaultNames["EditorCamera"] = "EditorCamera";
        DefaultNames["Editor"] = "Editor";
    })(DefaultNames = paper.DefaultNames || (paper.DefaultNames = {}));
    /**
     *
     */
    var DefaultTags;
    (function (DefaultTags) {
        DefaultTags["Untagged"] = "";
        DefaultTags["Respawn"] = "Respawn";
        DefaultTags["Finish"] = "Finish";
        DefaultTags["EditorOnly"] = "EditorOnly";
        DefaultTags["MainCamera"] = "MainCamera";
        DefaultTags["Player"] = "Player";
        DefaultTags["GameController"] = "GameController";
        DefaultTags["Global"] = "Global";
    })(DefaultTags = paper.DefaultTags || (paper.DefaultTags = {}));
    /**
     * 渲染排序
     */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = paper.RenderQueue || (paper.RenderQueue = {}));
    /**
     * 这里暂未实现用户自定义层级，但用户可以使用预留的UserLayer。
     * 这个属性可以实现相机的选择性剔除。
     */
    var Layer;
    (function (Layer) {
        Layer[Layer["Default"] = 2] = "Default";
        Layer[Layer["UI"] = 4] = "UI";
        Layer[Layer["UserLayer1"] = 8] = "UserLayer1";
        Layer[Layer["UserLayer2"] = 16] = "UserLayer2";
        Layer[Layer["UserLayer3"] = 32] = "UserLayer3";
        Layer[Layer["UserLayer4"] = 64] = "UserLayer4";
        Layer[Layer["UserLayer5"] = 128] = "UserLayer5";
        Layer[Layer["UserLayer6"] = 240] = "UserLayer6";
        Layer[Layer["UserLayer7"] = 256] = "UserLayer7";
        Layer[Layer["UserLayer8"] = 512] = "UserLayer8";
        Layer[Layer["UserLayer9"] = 1024] = "UserLayer9";
        Layer[Layer["UserLayer10"] = 2048] = "UserLayer10";
        Layer[Layer["UserLayer11"] = 3840] = "UserLayer11";
    })(Layer = paper.Layer || (paper.Layer = {}));
    /**
     * culling mask
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * culling mask 枚举。
     * 相机的cullingmask与renderer的renderLayer相匹配，才会执行渲染。否则将会被跳过。
     * 这个属性可以实现相机的选择性剔除。
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var CullingMask;
    (function (CullingMask) {
        CullingMask[CullingMask["Everything"] = 16777215] = "Everything";
        CullingMask[CullingMask["Nothing"] = 1] = "Nothing";
        CullingMask[CullingMask["Default"] = 2] = "Default";
        CullingMask[CullingMask["UI"] = 4] = "UI";
        CullingMask[CullingMask["UserLayer1"] = 8] = "UserLayer1";
        CullingMask[CullingMask["UserLayer2"] = 16] = "UserLayer2";
        CullingMask[CullingMask["UserLayer3"] = 32] = "UserLayer3";
        CullingMask[CullingMask["UserLayer4"] = 64] = "UserLayer4";
        CullingMask[CullingMask["UserLayer5"] = 128] = "UserLayer5";
        CullingMask[CullingMask["UserLayer6"] = 240] = "UserLayer6";
        CullingMask[CullingMask["UserLayer7"] = 256] = "UserLayer7";
        CullingMask[CullingMask["UserLayer8"] = 512] = "UserLayer8";
        CullingMask[CullingMask["UserLayer9"] = 1024] = "UserLayer9";
        CullingMask[CullingMask["UserLayer10"] = 2048] = "UserLayer10";
        CullingMask[CullingMask["UserLayer11"] = 3840] = "UserLayer11";
    })(CullingMask = paper.CullingMask || (paper.CullingMask = {}));
    function layerTest(cullingMask, layer) {
        return (cullingMask & layer) !== 0;
    }
    paper.layerTest = layerTest;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * 生命周期的顺序。
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._isReseted = false;
            /**
             * @internal
             */
            _this._isStarted = false;
            return _this;
        }
        Behaviour.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onAwake && this.onAwake(config);
            }
        };
        Behaviour.prototype.uninitialize = function () {
            if (paper.Application.playerMode !== 2 /* Editor */ || this.constructor.executeInEditMode) {
                this.onDestroy && this.onDestroy(); // TODO onDestroy 如果不是 enabled 就不派发
            }
            _super.prototype.uninitialize.call(this);
        };
        /**
         * @deprecated
         */
        Behaviour.prototype.onCollide = function (collider) { };
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 系统基类。
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem() {
            /**
             * @internal
             */
            this._started = true;
            this._locked = false;
            this._enabled = true;
            /**
             *
             */
            this._interests = [];
            /**
             *
             */
            this._groups = [];
            /**
             *
             */
            this._globalGameObject = paper.Application.sceneManager.globalGameObject;
            /**
             *
             */
            this._clock = paper.Clock.getInstance(paper.Clock);
            if (!BaseSystem._createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            BaseSystem._createEnabled = false;
        }
        /**
         * @internal
         */
        BaseSystem.create = function (systemClass) {
            this._createEnabled = true;
            return new systemClass();
        };
        /**
         * 系统内部初始化。
         * @internal
         */
        BaseSystem.prototype.initialize = function () {
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                    var interest = interests_1[_i];
                    for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                        var config = interest_1[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.addEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.addEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                    this._groups.push(paper.Group.create(interest));
                }
            }
            this.onAwake && this.onAwake();
            this.onEnable && this.onEnable();
        };
        /**
         * 系统内部卸载。
         * @internal
         */
        BaseSystem.prototype.uninitialize = function () {
            this.onDestroy && this.onDestroy();
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_2 = interests; _i < interests_2.length; _i++) {
                    var interest = interests_2[_i];
                    for (var _a = 0, interest_2 = interest; _a < interest_2.length; _a++) {
                        var config = interest_2[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.removeEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.removeEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.update = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                if (this.onAddGameObject) {
                    for (var _b = 0, _c = group._addedGameObjects; _b < _c.length; _b++) {
                        var gameObject = _c[_b];
                        if (gameObject) {
                            this.onAddGameObject(gameObject, group);
                        }
                    }
                }
                if (this.onAddComponent) {
                    for (var _d = 0, _e = group._addedComponents; _d < _e.length; _d++) {
                        var component = _e[_d];
                        if (component) {
                            this.onAddComponent(component, group);
                        }
                    }
                }
            }
            this.onUpdate && this.onUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.lateUpdate = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            this.onLateUpdate && this.onLateUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        Object.defineProperty(BaseSystem.prototype, "enabled", {
            /**
             * 该系统是否被激活。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._locked) {
                    console.warn("Cannot change the enabled value when the system is updating.", egret.getQualifiedClassName(this));
                    return;
                }
                if (this._enabled === value) {
                    return;
                }
                this._enabled = value;
                if (this._enabled) {
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "groups", {
            /**
             *
             */
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        BaseSystem._createEnabled = false;
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
            this._eventMap = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                list = this._eventMap[type] = [];
            }
            list.push({ listener: listener, thisObject: thisObject || this });
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == (thisObject || this)) {
                    list.splice(i, 1);
                    break;
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            event.target = this;
            this.notifyListener(event);
        };
        EventDispatcher.prototype.notifyListener = function (event) {
            var list = this._eventMap[event.type || event];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                bin.listener.call(bin.thisObject, event);
            }
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
    __reflect(EventDispatcher.prototype, "egret3d.EventDispatcher");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * light component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 灯光组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * TODO
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             *
             */
            _this.intensity = 1.0;
            /**
             *
             */
            _this.color = egret3d.Color.create(1.0, 1.0, 1.0, 1.0);
            /**
             *
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.shadowRadius = 0.5;
            /**
             *
             */
            _this.shadowBias = 0.001;
            /**
             *
             */
            _this.shadowSize = 512;
            /**
             *
             */
            _this.shadowCameraNear = 1.0;
            /**
             *
             */
            _this.shadowCameraFar = 100.0;
            /**
             *
             */
            _this.shadowCameraSize = 30;
            _this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            _this.matrix = egret3d.Matrix4.create();
            return _this;
        }
        BaseLight.prototype._updateMatrix = function (camera) {
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            var matrix = this.matrix;
            matrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            var context = camera.context;
            context.updateCamera(camera, this.gameObject.transform.getWorldMatrix());
            context.updateLightDepth(this);
            matrix.multiply(context.matrix_p).multiply(context.matrix_v);
        };
        /**
         * @internal
         */
        BaseLight.prototype.update = function (camera, faceIndex) {
            camera.backgroundColor.set(1.0, 1.0, 1.0, 1.0);
            camera.clearOption_Color = true;
            camera.clearOption_Depth = true;
            this._updateMatrix(camera);
        };
        Object.defineProperty(BaseLight.prototype, "power", {
            /**
             *
             */
            get: function () {
                return this.intensity * (Math.PI * 4.0);
            },
            set: function (value) {
                this.intensity = value / (Math.PI * 4.0);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], BaseLight.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.COLOR)
        ], BaseLight.prototype, "color", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowBias", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowSize", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraFar", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraSize", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Mesh 渲染组件。
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [egret3d.DefaultMaterials.MESH_BASIC];
            return _this;
        }
        MeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._materials.length = 0;
        };
        MeshRenderer.prototype.recalculateAABB = function () {
            this.aabb.clear();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                var vertices = filter.mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this.aabb.add(position);
                }
            }
        };
        Object.defineProperty(MeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value === this._materials) {
                    return;
                }
                // TODO 共享材质的接口。
                this._materials.length = 0;
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var material = value_1[_i];
                    if (!material) {
                        console.warn("Invalid material.");
                    }
                    this._materials.push(material || egret3d.DefaultMaterials.MISSING);
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(MeshRenderer.prototype, "material", {
            /**
             * 材质数组中的第一个材质。
             */
            get: function () {
                return this._materials.length > 0 ? this._materials[0] : null;
            },
            set: function (value) {
                var dirty = false;
                if (value) {
                    if (this._materials.length > 0) {
                        if (this._materials[0] !== value) {
                            this._materials[0] = value;
                            dirty = true;
                        }
                    }
                    else {
                        this._materials.push(value);
                        dirty = true;
                    }
                }
                else if (this._materials.length > 0) {
                    this._materials.splice(0, 1);
                    dirty = true;
                }
                if (dirty) {
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MATERIAL_ARRAY)
        ], MeshRenderer.prototype, "materials", null);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Vector2 = (function () {
        /**
         * 请使用 `egret3d.Vector2.create()` 创建实例。
         * @see egret3d.Vector2.create()
         * @deprecated
         * @private
         */
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            this.x = x;
            this.y = y;
        }
        Vector2.create = function (x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(x, y);
            }
            return new Vector2().set(x, y);
        };
        Vector2.prototype.release = function () {
            if (Vector2._instances.indexOf(this) < 0) {
                Vector2._instances.push(this);
            }
            return this;
        };
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            return this;
        };
        Vector2.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        Vector2.prototype.clone = function () {
            var value = new Vector2();
            value.copy(this);
            return value;
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        Vector2._instances = [];
        return Vector2;
    }());
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形可序列化对象
     */
    var Rectangle = (function () {
        /**
         *
         */
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
            return this;
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Color = (function () {
        /**
         * 请使用 `egret3d.Color.create()` 创建实例。
         * @see egret3d.Color.create()
         */
        function Color() {
        }
        Color.create = function (r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(r, g, b, a);
            }
            return new Color().set(r, g, b, a);
        };
        Color.prototype.release = function () {
            if (Color._instances.indexOf(this) < 0) {
                Color._instances.push(this);
            }
            return this;
        };
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        Color.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        Color.prototype.clone = function () {
            return Color.create(this.r, this.g, this.b, this.a);
        };
        Color.prototype.copy = function (value) {
            return this.set(value.r, value.g, value.b, value.a);
        };
        Color.prototype.set = function (r, g, b, a) {
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        Color.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this.r = value[0 + offset];
            this.g = value[1 + offset];
            this.b = value[2 + offset];
            this.a = value[3 + offset];
            return this;
        };
        Color.prototype.multiply = function (valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = valueA.r * valueB.r;
            this.g = valueA.g * valueB.g;
            this.b = valueA.b * valueB.b;
            this.a = valueA.a * valueB.a;
            return this;
        };
        Color.prototype.scale = function (value, source) {
            if (!source) {
                source = this;
            }
            this.r = source.r * value;
            this.g = source.g * value;
            this.b = source.b * value;
            this.a = source.a * value;
            return this;
        };
        Color.prototype.lerp = function (t, valueA, valueB) {
            if (!valueB) {
                valueB = valueA;
                valueA = this;
            }
            this.r = t * (valueB.r - valueA.r) + valueA.r;
            this.g = t * (valueB.g - valueA.g) + valueA.g;
            this.b = t * (valueB.b - valueA.b) + valueA.b;
            this.a = t * (valueB.a - valueA.a) + valueA.a;
            return this;
        };
        Color.WHITE = new Color().set(1.0, 1.0, 1.0, 1.0);
        Color.BLACK = new Color().set(0.0, 0.0, 0.0, 1.0);
        Color._instances = [];
        return Color;
    }());
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["paper.IRelease", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = egret3d.Vector3.create();
    var _helpVector3B = egret3d.Vector3.create();
    var _helpVector3C = egret3d.Vector3.create();
    var _helpMatrix = egret3d.Matrix4.create();
    var _helpRay = egret3d.Ray.create();
    var _attributeNames = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TANGENT" /* TANGENT */,
        "COLOR_0" /* COLOR_0 */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     *
     */
    var BaseMesh = (function (_super) {
        __extends(BaseMesh, _super);
        function BaseMesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            var _this = _super.call(this, typeof attributeNamesOrName === "string" ? attributeNamesOrName : "") || this;
            _this._drawMode = 35044 /* Static */;
            _this._vertexCount = 0;
            _this._attributeNames = [];
            _this._customAttributeTypes = {};
            _this._glTFMesh = null;
            if (typeof vertexCountOrConfig === "number") {
                vertexCountOrConfig = vertexCountOrConfig || 3;
                indexCountOrBuffers = indexCountOrBuffers || 0;
                _this.config = egret3d.GLTFAsset.createMeshConfig();
                //
                var buffer = _this.config.buffers[0];
                var vertexBufferView = _this.config.bufferViews[0];
                var accessors = _this.config.accessors;
                var attributes = _this.config.meshes[0].primitives[0].attributes;
                //
                var hasCustomAttributeType = false;
                if (attributeTypes) {
                    for (var k in attributeTypes) {
                        hasCustomAttributeType = true;
                        _this._customAttributeTypes[k] = attributeTypes[k];
                    }
                }
                for (var _i = 0, _a = (attributeNamesOrName || _attributeNames); _i < _a.length; _i++) {
                    var attributeName = _a[_i];
                    var attributeType = hasCustomAttributeType ? _this._customAttributeTypes[attributeName] || _this.getMeshAttributeType(attributeName) : _this.getMeshAttributeType(attributeName);
                    var byteOffset = vertexBufferView.byteLength;
                    vertexBufferView.byteLength += vertexCountOrConfig * _this.getAccessorTypeCount(attributeType) * Float32Array.BYTES_PER_ELEMENT;
                    attributes[attributeName] = accessors.length;
                    accessors.push({
                        bufferView: 0,
                        byteOffset: byteOffset,
                        count: vertexCountOrConfig,
                        normalized: attributeName === "NORMAL" /* NORMAL */ || attributeName === "TANGENT" /* TANGENT */,
                        componentType: 5126 /* Float */,
                        type: attributeType,
                    });
                }
                buffer.byteLength = vertexBufferView.byteLength;
                _this.buffers[0] = new Float32Array(vertexBufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
                _this._drawMode = drawMode || 35044 /* Static */;
                if (indexCountOrBuffers > 0) {
                    _this.addSubMesh(indexCountOrBuffers, 0);
                }
                else {
                    _this.config.meshes[0].primitives[0].material = 0;
                }
            }
            else {
                _this.config = vertexCountOrConfig;
                for (var _b = 0, _c = indexCountOrBuffers; _b < _c.length; _b++) {
                    var buffer = _c[_b];
                    _this.buffers.push(buffer);
                }
                _this.name = attributeNamesOrName;
            }
            var accessor = _this.getAccessor(0);
            _this._vertexCount = accessor.count;
            _this._glTFMesh = _this.config.meshes[0];
            for (var k in _this._glTFMesh.primitives[0].attributes) {
                _this._attributeNames.push(k);
            }
            return _this;
        }
        /**
         *
         */
        BaseMesh.prototype.clone = function () {
            var value = new egret3d.Mesh(this.vertexCount, 0, this._attributeNames, this._customAttributeTypes, this.drawMode);
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    value.addSubMesh(accessor.count, primitive.material, primitive.mode);
                }
            }
            var index = 0;
            for (var _b = 0, _c = this.config.bufferViews; _b < _c.length; _b++) {
                var bufferViewA = _c[_b];
                var bufferViewB = value.config.bufferViews[index++];
                var a = this.createTypeArrayFromBufferView(bufferViewA, 5125 /* UnsignedInt */);
                var b = value.createTypeArrayFromBufferView(bufferViewB, 5125 /* UnsignedInt */);
                for (var i = 0, l = a.length; i < l; ++i) {
                    b[i] = a[i];
                }
            }
            return value;
        };
        /**
         * TODO
         */
        BaseMesh.prototype.raycast = function (ray, worldMatrix) {
            _helpMatrix.inverse(worldMatrix);
            _helpRay.copy(ray);
            _helpRay.origin.applyMatrix(_helpMatrix);
            _helpRay.direction.applyDirection(_helpMatrix).normalize();
            var subMeshIndex = 0;
            var p0 = _helpVector3A;
            var p1 = _helpVector3B;
            var p2 = _helpVector3C;
            var vertices = this.getVertices();
            var pickInfo = null; // TODO
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                switch (primitive.mode) {
                    case 0 /* Points */:
                        break;
                    case 1 /* Lines */:
                        break;
                    case 2 /* LineLoop */:
                        break;
                    case 3 /* LineStrip */:
                        break;
                    case 6 /* TrianglesFan */:
                        break;
                    case 5 /* TrianglesStrip */:
                        break;
                    case 4 /* Triangles */:
                    default:
                        if (primitive.indices === undefined) {
                            for (var i = 0, l = vertices.length; i < l; i += 9) {
                                p0.fromArray(vertices, i);
                                p0.fromArray(vertices, i + 3);
                                p0.fromArray(vertices, i + 6);
                                var result = _helpRay.intersectTriangle(p0, p1, p2);
                                if (result) {
                                    if (result.distance < 0) {
                                        continue;
                                    }
                                    if (!pickInfo || pickInfo.distance > result.distance) {
                                        pickInfo = result;
                                        pickInfo.subMeshIndex = subMeshIndex;
                                        pickInfo.triangleIndex = i / 3; // TODO
                                    }
                                }
                            }
                        }
                        else {
                            var indices = this.getIndices(subMeshIndex++);
                            for (var i = 0, l = indices.length; i < l; i += 3) {
                                p0.fromArray(vertices, indices[i] * 3);
                                p1.fromArray(vertices, indices[i + 1] * 3);
                                p2.fromArray(vertices, indices[i + 2] * 3);
                                var result = _helpRay.intersectTriangle(p0, p1, p2);
                                if (result) {
                                    if (result.distance < 0) {
                                        continue;
                                    }
                                    if (!pickInfo || pickInfo.distance > result.distance) {
                                        pickInfo = result;
                                        pickInfo.subMeshIndex = subMeshIndex;
                                        pickInfo.triangleIndex = i / 3; // TODO
                                    }
                                }
                            }
                        }
                        break;
                }
            }
            return pickInfo;
        };
        /**
         *
         */
        BaseMesh.prototype.addSubMesh = function (indexCount, materialIndex, randerMode) {
            if (materialIndex === void 0) { materialIndex = 0; }
            var accessors = this.config.accessors;
            var primitives = this.config.meshes[0].primitives;
            var subMeshIndex = this.buffers.length === primitives.length + 1 ? primitives.length : 0;
            var indexBufferView = this.config.bufferViews[subMeshIndex + 1] = {
                buffer: subMeshIndex + 1,
                byteOffset: 0,
                byteLength: indexCount * this.getAccessorTypeCount("SCALAR" /* SCALAR */) * Uint16Array.BYTES_PER_ELEMENT,
                target: 34963 /* ElementArrayBuffer */,
            };
            var primitive = primitives[subMeshIndex] = primitives[subMeshIndex] || {
                attributes: primitives[0].attributes,
            };
            primitive.indices = accessors.length;
            primitive.material = materialIndex;
            primitive.mode = randerMode;
            accessors.push({
                bufferView: 1, byteOffset: 0,
                count: indexCount,
                componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
            });
            this.buffers[subMeshIndex + 1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
            this.config.buffers[subMeshIndex + 1] = { byteLength: indexBufferView.byteLength };
            return primitives.length - 1;
        };
        /**
         *
         */
        BaseMesh.prototype.getVertices = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("POSITION" /* POSITION */, offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.getUVs = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.getColors = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.getNormals = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.getTangents = function (offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.getAttributes = function (attributeType, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var accessorIndex = this._glTFMesh.primitives[0].attributes[attributeType];
            if (accessorIndex === undefined) {
                return null;
            }
            return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex), offset, count);
        };
        /**
         *
         */
        BaseMesh.prototype.setAttributes = function (attributeType, value, offset, count) {
            if (offset === void 0) { offset = 0; }
            if (count === void 0) { count = 0; }
            var target = this.getAttributes(attributeType, offset, count);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        /**
         *
         */
        BaseMesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                return this.createTypeArrayFromAccessor(this.getAccessor(accessorIndex));
            }
            console.warn("Error arguments.");
            return null;
        };
        /**
         *
         */
        BaseMesh.prototype.setIndices = function (value, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            var target = this.getIndices(subMeshIndex);
            if (target) {
                for (var i = 0, l = Math.min(value.length, target.length); i < l; i++) {
                    target[i] = value[i];
                }
            }
            return target;
        };
        Object.defineProperty(BaseMesh.prototype, "drawMode", {
            /**
             *
             */
            get: function () {
                return this._drawMode;
            },
            set: function (value) {
                this._drawMode = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "subMeshCount", {
            /**
             * 获取子网格数量。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "vertexCount", {
            /**
             *
             */
            get: function () {
                return this._vertexCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "attributeNames", {
            /**
             *
             */
            get: function () {
                return this._attributeNames;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseMesh.prototype, "glTFMesh", {
            /**
             * 获取 glTFMesh 数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        return BaseMesh;
    }(egret3d.GLTFAsset));
    egret3d.BaseMesh = BaseMesh;
    __reflect(BaseMesh.prototype, "egret3d.BaseMesh");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 纹理资源。
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        Texture.prototype.caclByteLength = function () {
            return 0;
        };
        return Texture;
    }(paper.Asset));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 事件派发器
         */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.__z_e_listeners = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                var list = this.__z_e_listeners[type];
                if (list === undefined) {
                    list = [];
                    this.__z_e_listeners[type] = list;
                }
                var item = {
                    func: fun,
                    context: thisObj,
                    level: level
                };
                list.push(item);
                list.sort(function (a, b) {
                    return b.level - a.level;
                });
            };
            EventDispatcher.prototype.removeEventListener = function (type, fun, thisObj) {
                var list = this.__z_e_listeners[type];
                if (list !== undefined) {
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var obj = list[i];
                        if (obj.func === fun && obj.context === thisObj) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var list = this.__z_e_listeners[event.type];
                if (list !== undefined) {
                    list.forEach(function (ef) {
                        ef['___dirty___'] = true;
                    });
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var ef = list[i];
                        if (ef['___dirty___']) {
                            var fun = ef.func;
                            var context = ef.context;
                            if (context) {
                                fun.call(context, event);
                            }
                            else {
                                fun(event);
                            }
                            ef['___dirty___'] = false;
                        }
                        if (size != list.length) {
                            size = list.length;
                            i = 0;
                        }
                    }
                }
            };
            return EventDispatcher;
        }());
        editor.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "paper.editor.EventDispatcher", ["paper.editor.IEventDispatcher"]);
        /**
         * 事件
         */
        var BaseEvent = (function () {
            function BaseEvent(type, data) {
                this.type = type;
                this.data = data;
            }
            return BaseEvent;
        }());
        editor.BaseEvent = BaseEvent;
        __reflect(BaseEvent.prototype, "paper.editor.BaseEvent");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    egret3d.RAD_DEG = 180.0 / Math.PI;
    /**
     *
     */
    egret3d.DEG_RAD = Math.PI / 180.0;
    /**
     *
     */
    egret3d.EPSILON = 2.220446049250313e-16; // Number.EPSILON
    function sign(value) {
        if (value === 0 || value !== value) {
            return value;
        }
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    function floatClamp(v, min, max) {
        if (min === void 0) { min = 0.0; }
        if (max === void 0) { max = 1.0; }
        if (v < min)
            return min;
        else if (v > max)
            return max;
        else
            return v;
    }
    egret3d.floatClamp = floatClamp;
    function numberLerp(fromV, toV, v) {
        return fromV * (1 - v) + toV * v;
    }
    egret3d.numberLerp = numberLerp;
    function getNormal(a, b, c, out) {
        out.subtract(c, b);
        egret3d.helpVector3A.subtract(a, b);
        out.cross(egret3d.helpVector3A);
        var squaredLength = out.squaredLength;
        if (squaredLength > 0.0) {
            return out.multiplyScalar(1.0 / Math.sqrt(squaredLength));
        }
        return out.set(0.0, 0.0, 1.0);
    }
    egret3d.getNormal = getNormal;
    function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
        var vp1 = planeVector.x;
        var vp2 = planeVector.y;
        var vp3 = planeVector.z;
        var n1 = planePoint.x;
        var n2 = planePoint.y;
        var n3 = planePoint.z;
        var v1 = lineVector.x;
        var v2 = lineVector.y;
        var v3 = lineVector.z;
        var m1 = linePoint.x;
        var m2 = linePoint.y;
        var m3 = linePoint.z;
        var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
        if (vpt === 0) {
            out = null;
        }
        else {
            var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
            out.x = m1 + v1 * t;
            out.y = m2 + v2 * t;
            out.z = m3 + v3 * t;
        }
        return out;
    }
    egret3d.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
    function triangleIntersectsPlane() {
    }
    egret3d.triangleIntersectsPlane = triangleIntersectsPlane;
    function satForAxes(axes) {
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        var extents = egret3d.helpVector3H;
        var testAxis = egret3d.helpVector3A;
        for (var i = 0, l = axes.length - 3; i <= l; i += 3) {
            testAxis.fromArray(axes, i);
            // project the aabb onto the seperating axis
            var r = extents.x * Math.abs(testAxis.x) + extents.y * Math.abs(testAxis.y) + extents.z * Math.abs(testAxis.z);
            // project all 3 vertices of the triangle onto the seperating axis
            var p0 = v0.dot(testAxis);
            var p1 = v1.dot(testAxis);
            var p2 = v2.dot(testAxis);
            // actual test, basically see if either of the most extreme of the triangle points intersects r
            if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
                // points of the projected triangle are outside the projected half-length of the aabb
                // the axis is seperating and we can exit
                return false;
            }
        }
        return true;
    }
    function triangleIntersectsAABB(triangle, aabb) {
        if (aabb.isEmpty) {
            return false;
        }
        var v0 = egret3d.helpVector3A;
        var v1 = egret3d.helpVector3B;
        var v2 = egret3d.helpVector3C;
        // triangle edge vectors
        var f0 = egret3d.helpVector3D;
        var f1 = egret3d.helpVector3E;
        var f2 = egret3d.helpVector3F;
        var center = egret3d.helpVector3G;
        var extents = egret3d.helpVector3H;
        // compute box center and extents
        extents.subtract(this.max, aabb.center);
        // translate triangle to aabb origin
        v0.subtract(triangle.a, center);
        v1.subtract(triangle.b, center);
        v2.subtract(triangle.c, center);
        // compute edge vectors for triangle
        f0.subtract(v1, v0);
        f1.subtract(v2, v1);
        f2.subtract(v0, v2);
        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [
            0, -f0.z, f0.y, 0, -f1.z, f1.y, 0, -f2.z, f2.y,
            f0.z, 0, -f0.x, f1.z, 0, -f1.x, f2.z, 0, -f2.x,
            -f0.y, f0.x, 0, -f1.y, f1.x, 0, -f2.y, f2.x, 0
        ];
        if (!satForAxes(axes)) {
            return false;
        }
        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes)) {
            return false;
        }
        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        egret3d.helpVector3A.cross(f0, f1);
        axes = [egret3d.helpVector3A.x, egret3d.helpVector3A.y, egret3d.helpVector3A.z];
        return satForAxes(axes);
    }
    egret3d.triangleIntersectsAABB = triangleIntersectsAABB;
    function planeIntersectsAABB(plane, aabb) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.
        var vMin;
        var vMax;
        var min = aabb.minimum;
        var max = aabb.maximum;
        if (plane.normal.x > 0.0) {
            vMin = plane.normal.x * min.x;
            vMax = plane.normal.x * max.x;
        }
        else {
            vMin = plane.normal.x * max.x;
            vMax = plane.normal.x * min.x;
        }
        if (plane.normal.y > 0.0) {
            vMin += plane.normal.y * min.y;
            vMax += plane.normal.y * max.y;
        }
        else {
            vMin += plane.normal.y * max.y;
            vMax += plane.normal.y * min.y;
        }
        if (plane.normal.z > 0.0) {
            vMin += plane.normal.z * min.z;
            vMax += plane.normal.z * max.z;
        }
        else {
            vMin += plane.normal.z * max.z;
            vMax += plane.normal.z * min.z;
        }
        return vMin <= plane.constant && vMax >= plane.constant;
    }
    egret3d.planeIntersectsAABB = planeIntersectsAABB;
    function planeIntersectsSphere(plane, sphere) {
        return Math.abs(plane.getDistance(sphere.center)) <= sphere.radius;
    }
    egret3d.planeIntersectsSphere = planeIntersectsSphere;
    function aabbIntersectsSphere(aabb, sphere) {
        // Find the point on the AABB closest to the sphere center.
        egret3d.helpVector3A.copy(sphere.center).clamp(aabb.minimum, aabb.maximum);
        // If that point is inside the sphere, the AABB and sphere intersect.
        return egret3d.helpVector3A.getSquaredDistance(sphere.center) <= (sphere.radius * sphere.radius);
    }
    egret3d.aabbIntersectsSphere = aabbIntersectsSphere;
    function aabbIntersectsAABB(valueA, valueB) {
        var minA = valueA.minimum;
        var maxA = valueA.maximum;
        var minB = valueB.minimum;
        var maxB = valueB.maximum;
        // using 6 splitting planes to rule out intersections.
        return maxA.x < minB.x || minA.x > maxB.x ||
            maxA.y < minB.y || minA.y > maxB.y ||
            maxA.z < minB.z || minA.z > maxB.z ? false : true;
    }
    egret3d.aabbIntersectsAABB = aabbIntersectsAABB;
    function sphereIntersectsSphere(valueA, valueB) {
        var radiusSum = valueA.radius + valueB.radius;
        return valueA.center.getSquaredDistance(valueB.center) <= (radiusSum * radiusSum);
    }
    egret3d.sphereIntersectsSphere = sphereIntersectsSphere;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var BaseGeo = (function () {
            function BaseGeo() {
                this.helpVec3_1 = new egret3d.Vector3();
                this.helpVec3_2 = new egret3d.Vector3();
                this.helpVec3_3 = new egret3d.Vector3();
                this.helpQuat_1 = new egret3d.Quaternion();
                this.helpQuat_2 = new egret3d.Quaternion();
                this.forward = new egret3d.Vector3(0, 0, 1);
                this.up = new egret3d.Vector3(0, 1, 0);
                this.right = new egret3d.Vector3(1, 0, 0);
                this._dragOffset = new egret3d.Vector3();
                this._delta = new egret3d.Vector3();
                this._newPosition = new egret3d.Vector3();
                this._ctrlPos = new egret3d.Vector3();
                this._ctrlRot = new egret3d.Quaternion();
                this._dragPlanePoint = new egret3d.Vector3();
                this._dragPlaneNormal = new egret3d.Vector3();
                this._initRotation = new egret3d.Quaternion();
                this._oldLocalScale = new egret3d.Vector3();
                this.onSet();
                if (this.geo) {
                    if (this.geo.getComponent(egret3d.MeshRenderer))
                        this.baseColor = this.geo.getComponent(egret3d.MeshRenderer).materials[0];
                }
            }
            BaseGeo.prototype.onSet = function () {
            };
            BaseGeo.prototype._checkIntersect = function (ray) {
                var mesh = this.geo.getComponent(egret3d.MeshFilter).mesh;
                var temp = mesh.raycast(ray, this.geo.transform.getWorldMatrix());
                if (temp) {
                    return this;
                }
            };
            BaseGeo.prototype.changeColor = function (color) {
                if (color == "origin") {
                    this.geo.getComponent(egret3d.MeshRenderer).materials = [this.baseColor];
                }
                else if (color == "yellow") {
                    if (this.yellowColor) {
                        this.geo.getComponent(egret3d.MeshRenderer).materials = [this.greyColor];
                    }
                    var mat = this.geo.getComponent(egret3d.MeshRenderer).materials[0].clone();
                    var color1 = new Float32Array([0.8, 0.8, 0.3]);
                    var alpha = new Float32Array([0.3]);
                    mat.setFloatv("opacity", alpha);
                    mat.setVector3v("diffuse", color1);
                    this.geo.getComponent(egret3d.MeshRenderer).materials = [mat];
                }
                else if (color == "grey") {
                    if (this.greyColor) {
                        this.geo.getComponent(egret3d.MeshRenderer).materials = [this.greyColor];
                    }
                    var mat = this.geo.getComponent(egret3d.MeshRenderer).materials[0].clone();
                    var color1 = new Float32Array([0.3, 0.3, 0.3]);
                    var alpha = new Float32Array([0.2]);
                    mat.setFloatv("opacity", alpha);
                    mat.setVector3v("diffuse", color1);
                    this.geo.getComponent(egret3d.MeshRenderer).materials = [mat];
                }
            };
            BaseGeo.prototype._createAxis = function (color, type) {
                var gizmoAxis = new paper.GameObject("", "", paper.Application.sceneManager.editorScene);
                var mesh = gizmoAxis.addComponent(egret3d.MeshFilter);
                switch (type) {
                    case 0:
                        mesh.mesh = egret3d.DefaultMeshes.CUBE;
                        break;
                    case 1:
                        mesh.mesh = this._createCircleLine();
                        break;
                    case 2:
                        mesh.mesh = egret3d.DefaultMeshes.CUBE;
                        break;
                    case 3:
                        mesh.mesh = egret3d.DefaultMeshes.PLANE;
                        break;
                }
                var renderer = gizmoAxis.addComponent(egret3d.MeshRenderer);
                var mat = new egret3d.Material(egret3d.DefaultShaders.LINEDASHED);
                var color1 = new Float32Array([color.x, color.y, color.z]);
                var alpha = new Float32Array([color.w]);
                var technique = mat.glTFTechnique;
                var funs = technique.states.functions;
                var enables = technique.states.enable;
                mat.setFloatv("opacity", alpha);
                mat.setVector3v("diffuse", color1);
                mat.setCullFace(false);
                mat.setBlend(1 /* Blend */);
                mat.renderQueue = paper.RenderQueue.Overlay;
                // funs.depthMask = [true];
                funs.depthFunc = [519 /* ALWAYS */];
                renderer.materials = [mat];
                return gizmoAxis;
            };
            BaseGeo.prototype._createCircleLine = function () {
                var vertexCount = 1;
                var triangleFan = [];
                var indices = [];
                for (var angle = 0; angle <= 360; angle += 1) {
                    var x = Math.cos(angle / 180.0 * 3.14) / 1.03;
                    var y = Math.sin(angle / 180.0 * 3.14) / 1.03;
                    var z = 0.0;
                    triangleFan.push(x, y, z);
                    var x = Math.cos(angle / 180.0 * 3.14);
                    var y = Math.sin(angle / 180.0 * 3.14);
                    var z = 0.0;
                    triangleFan.push(x, y, z);
                    vertexCount++;
                }
                console.log(vertexCount);
                for (var angle = 0; angle <= vertexCount * 2 - 3; angle += 1) {
                    indices.push(angle, angle + 1, angle + 2);
                }
                var mesh = new egret3d.Mesh(vertexCount * 2, (vertexCount * 2 - 3) * 3);
                mesh.setIndices(indices);
                mesh.setAttributes("POSITION" /* POSITION */, triangleFan);
                return mesh;
            };
            BaseGeo.prototype.createFan = function (maxAngle, _mesh) {
                if (_mesh) {
                    mesh = _mesh;
                }
                var mesh;
                var vertexCount = 1;
                var triangleFan = [0, 0, 0];
                var indices = [];
                if (maxAngle >= 0) {
                    for (var angle = 0; angle <= maxAngle; angle += 1) {
                        var x = Math.cos(angle / 180.0 * 3.14);
                        var y = Math.sin(angle / 180.0 * 3.14);
                        var z = 0.0;
                        triangleFan.push(x, y, z);
                        vertexCount++;
                    }
                }
                else {
                    for (var angle = 0; angle >= maxAngle; angle -= 1) {
                        var x = Math.cos(angle / 180.0 * 3.14);
                        var y = Math.sin(angle / 180.0 * 3.14);
                        var z = 0.0;
                        triangleFan.push(x, y, z);
                        vertexCount++;
                    }
                }
                console.log(vertexCount);
                for (var angle = 0; angle <= (vertexCount - 1) * 3; angle += 1) {
                    indices.push(0, angle, angle + 1);
                }
                mesh = new egret3d.Mesh(vertexCount, (vertexCount - 1) * 3);
                mesh.setIndices(indices);
                mesh.setAttributes("POSITION" /* POSITION */, triangleFan);
                return mesh;
            };
            return BaseGeo;
        }());
        editor.BaseGeo = BaseGeo;
        __reflect(BaseGeo.prototype, "paper.editor.BaseGeo");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var BaseState = (function () {
            function BaseState() {
                this.autoClear = false;
                this.batchIndex = 0;
                this._isDone = false;
            }
            BaseState.prototype.undo = function () {
                if (this._isDone) {
                    this._isDone = false;
                    return true;
                }
                return false;
            };
            BaseState.prototype.redo = function () {
                if (this._isDone) {
                    return false;
                }
                this._isDone = true;
                this.editorModel.dirty = true;
                return true;
            };
            Object.defineProperty(BaseState.prototype, "isDone", {
                get: function () {
                    return this._isDone;
                },
                set: function (value) {
                    this._isDone = value;
                },
                enumerable: true,
                configurable: true
            });
            BaseState.prototype.dispatchEditorModelEvent = function (type, data) {
                this.editorModel.dispatchEvent(new editor.EditorModelEvent(type, data));
            };
            BaseState.prototype.serialize = function () {
                return null;
            };
            BaseState.prototype.deserialize = function (data) {
            };
            return BaseState;
        }());
        editor.BaseState = BaseState;
        __reflect(BaseState.prototype, "paper.editor.BaseState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var ContactColliders = (function (_super) {
        __extends(ContactColliders, _super);
        function ContactColliders() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.begin = [];
            /**
             *
             */
            _this.stay = [];
            /**
             *
             */
            _this.end = [];
            return _this;
        }
        /**
         * @internal
         */
        ContactColliders.prototype.clear = function () {
            this.begin.length = 0;
            this.end.length = 0;
        };
        return ContactColliders;
    }(paper.SingletonComponent));
    paper.ContactColliders = ContactColliders;
    __reflect(ContactColliders.prototype, "paper.ContactColliders");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var DisposeCollecter = (function (_super) {
        __extends(DisposeCollecter, _super);
        function DisposeCollecter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 移除的场景数组。
             */
            _this.scenes = [];
            /**
             * 移除的实体数组。
             */
            _this.gameObjects = [];
            /**
             * 移除的组件数组。
             */
            _this.components = [];
            return _this;
        }
        /**
         * @internal
         */
        DisposeCollecter.prototype.clear = function () {
            this.scenes.length = 0;
            this.gameObjects.length = 0;
            this.components.length = 0;
        };
        return DisposeCollecter;
    }(paper.SingletonComponent));
    paper.DisposeCollecter = DisposeCollecter;
    __reflect(DisposeCollecter.prototype, "paper.DisposeCollecter");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Sphere = (function () {
        /**
         * 请使用 `egret3d.Sphere.create()` 创建实例。
         * @see egret3d.Sphere.create()
         */
        function Sphere() {
            /**
             *
             */
            this.radius = 0.0;
            /**
             *
             */
            this.center = egret3d.Vector3.create();
        }
        /**
         *
         * @param center
         * @param radius
         */
        Sphere.create = function (center, radius) {
            if (center === void 0) { center = egret3d.Vector3.ZERO; }
            if (radius === void 0) { radius = 0.0; }
            if (this._instances.length > 0) {
                return this._instances.pop();
            }
            return new Sphere().set(center, radius);
        };
        Sphere.prototype.release = function () {
            if (Sphere._instances.indexOf(this) < 0) {
                Sphere._instances.push(this);
            }
            return this;
        };
        Sphere.prototype.serialize = function () {
            return [this.center.x, this.center.y, this.center.z, this.radius];
        };
        Sphere.prototype.deserialize = function (value) {
            this.radius = value[3];
            this.center.fromArray(value);
            return this;
        };
        Sphere.prototype.clone = function () {
            return Sphere.create(this.center, this.radius);
        };
        Sphere.prototype.copy = function (value) {
            return this.set(value.center, value.radius);
        };
        Sphere.prototype.set = function (center, radius) {
            this.radius = radius;
            this.center.copy(center);
            return this;
        };
        Sphere.prototype.fromPoints = function (points, center) {
            if (center) {
                this.center.copy(center);
            }
            else {
                this.center.copy(egret3d.helpAABBA.fromPoints(points).center);
            }
            var maxRadiusSqrt = 0.0;
            for (var i = 0, l = points.length; i < l; i++) {
                maxRadiusSqrt = Math.max(maxRadiusSqrt, this.center.getDistance(points[i]));
            }
            this.radius = Math.sqrt(maxRadiusSqrt);
            return this;
        };
        Sphere.prototype.applyMatrix = function (matrix) {
            this.center.applyMatrix(matrix);
            this.radius = this.radius * matrix.getMaxScaleOnAxis();
            return this;
        };
        Sphere.prototype.contains = function (value) {
            if (value instanceof Sphere) {
                var radiusDelta = this.radius - value.radius;
                if (radiusDelta >= 0.0) {
                    this.center.getSquaredDistance(value.center) <= (radiusDelta * radiusDelta);
                }
                return false;
            }
            return this.center.getSquaredDistance(value) <= this.radius * this.radius;
        };
        Sphere.prototype.getDistance = function (value) {
            return this.center.getDistance(value) - this.radius;
        };
        Sphere.prototype.clampPoint = function (point, out) {
            var squaredDistance = this.center.getSquaredDistance(point);
            if (squaredDistance > (this.radius * this.radius)) {
                out.subtract(this.center, point).normalize();
                out.multiplyScalar(this.radius).add(this.center);
            }
            else {
                out.copy(point);
            }
            return out;
        };
        Sphere._instances = [];
        return Sphere;
    }());
    egret3d.Sphere = Sphere;
    __reflect(Sphere.prototype, "egret3d.Sphere", ["paper.IRelease", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _points = [
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
        egret3d.Vector3.create(),
    ];
    /**
     * aabb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 轴对称包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var AABB = (function () {
        /**
         * 请使用 `egret3d.AABB.create()` 创建实例。
         * @see egret3d.AABB.create()
         */
        function AABB() {
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            this._boundingSphereRadius = 0.0;
            this._minimum = egret3d.Vector3.create(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum = egret3d.Vector3.create(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._center = egret3d.Vector3.create();
        }
        AABB.create = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(minimum, maximum);
            }
            return new AABB().set(minimum, maximum);
        };
        AABB.prototype.release = function () {
            if (AABB._instances.indexOf(this) < 0) {
                AABB._instances.push(this);
            }
            return this;
        };
        AABB.prototype.serialize = function () {
            return [this._minimum.x, this._minimum.y, this._minimum.z, this._maximum.x, this._maximum.y, this._maximum.z];
        };
        AABB.prototype.deserialize = function (value) {
            return this.fromArray(value);
        };
        AABB.prototype.clone = function () {
            return AABB.create(this.minimum, this.maximum);
        };
        AABB.prototype.copy = function (value) {
            return this.set(value.minimum, value.maximum);
        };
        AABB.prototype.clear = function () {
            this._minimum.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this._maximum.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.set = function (minimum, maximum) {
            if (minimum === void 0) { minimum = null; }
            if (maximum === void 0) { maximum = null; }
            if (minimum && minimum !== this._minimum) {
                this._minimum.copy(minimum);
            }
            if (maximum && maximum !== this._maximum) {
                this._maximum.copy(maximum);
            }
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            return this;
        };
        AABB.prototype.fromArray = function (value, offset) {
            if (offset === void 0) { offset = 0; }
            this._minimum.fromArray(value, offset);
            this._maximum.fromArray(value, offset + 3);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.fromPoints = function (value) {
            this.clear();
            for (var _i = 0, _a = value; _i < _a.length; _i++) {
                var point = _a[_i];
                this.add(point);
            }
            return this;
        };
        AABB.prototype.applyMatrix = function (value, source) {
            if (!source) {
                source = this;
            }
            // transform of empty box is an empty box.
            if (source.isEmpty) {
                if (source !== this) {
                    this.copy(source);
                }
                return this;
            }
            var min = source.minimum;
            var max = source.maximum;
            // NOTE: I am using a binary pattern to specify all 2^3 combinations below
            _points[0].set(min.x, min.y, min.z).applyMatrix(value); // 000
            _points[1].set(min.x, min.y, max.z).applyMatrix(value); // 001
            _points[2].set(min.x, max.y, min.z).applyMatrix(value); // 010
            _points[3].set(min.x, max.y, max.z).applyMatrix(value); // 011
            _points[4].set(max.x, min.y, min.z).applyMatrix(value); // 100
            _points[5].set(max.x, min.y, max.z).applyMatrix(value); // 101
            _points[6].set(max.x, max.y, min.z).applyMatrix(value); // 110
            _points[7].set(max.x, max.y, max.z).applyMatrix(value); // 111
            this.fromPoints(_points);
            return this;
        };
        /**
         *
         */
        AABB.prototype.add = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (value instanceof AABB) {
                this._minimum.min(value._minimum, min);
                this._maximum.max(value._maximum, max);
            }
            else {
                this._minimum.min(value, min);
                this._maximum.max(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.expand = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(-value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.subtract(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            return this;
        };
        /**
         *
         */
        AABB.prototype.offset = function (value, source) {
            if (!source) {
                source = this;
            }
            var min = source.minimum;
            var max = source.maximum;
            if (typeof value === "number") {
                this._minimum.addScalar(value, min);
                this._maximum.addScalar(value, max);
            }
            else {
                this._minimum.add(value, min);
                this._maximum.add(value, max);
            }
            this._dirtyRadius = true;
            this._dirtyCenter = true;
            return this;
        };
        /**
         * check contains vector
         * @param value a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否包含点
         * @param value 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.contains = function (value) {
            var min = this._minimum;
            var max = this._maximum;
            if (value instanceof AABB) {
                var vMin = value.minimum;
                var vMax = value.maximum;
                return min.x <= vMin.x && vMax.x <= max.x &&
                    min.y <= vMin.y && vMax.y <= max.y &&
                    min.z <= vMin.z && vMax.z <= max.z;
            }
            return (value.x > min.x) && (value.x < max.x) &&
                (value.y > min.y) && (value.x < max.y) &&
                (value.z > min.z) && (value.z < max.z);
        };
        AABB.prototype.getDistance = function (value) {
            return egret3d.helpVector3A.clamp(this._minimum, this._maximum, value).subtract(value).length;
        };
        AABB.prototype.clampPoints = function (value, out) {
            return out.clamp(this._minimum, this._maximum, value);
        };
        Object.defineProperty(AABB.prototype, "isEmpty", {
            get: function () {
                // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
                return (this._maximum.x < this._minimum.x) || (this._maximum.y < this._minimum.y) || (this._maximum.z < this._minimum.z);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "boundingSphereRadius", {
            /**
             * Bounding sphere radius.
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.helpVector3A.subtract(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._boundingSphereRadius = egret3d.helpVector3A.length;
                    this._dirtyRadius = false;
                }
                return this._boundingSphereRadius;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "minimum", {
            /**
             *
             */
            get: function () {
                return this._minimum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "maximum", {
            /**
             *
             */
            get: function () {
                return this._maximum;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "center", {
            /**
             * get center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取中心点位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyCenter) {
                    this._center.add(this._maximum, this._minimum).multiplyScalar(0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        AABB._instances = [];
        return AABB;
    }());
    egret3d.AABB = AABB;
    __reflect(AABB.prototype, "egret3d.AABB", ["paper.IRelease", "paper.ISerializable"]);
    egret3d.helpAABBA = AABB.create();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var InterestType;
    (function (InterestType) {
        /**
         *
         */
        InterestType[InterestType["Extends"] = 1] = "Extends";
        /**
         *
         */
        InterestType[InterestType["Exculde"] = 2] = "Exculde";
        /**
         *
         */
        InterestType[InterestType["Unessential"] = 4] = "Unessential";
    })(InterestType = paper.InterestType || (paper.InterestType = {}));
    /**
     *
     */
    var Group = (function () {
        function Group(interestConfig) {
            /**
             *
             */
            this.locked = false;
            this.name = "";
            this._isRemoved = false;
            this._isBehaviour = false;
            this._bufferedGameObjects = [];
            /**
             * @internal
             */
            this._addedGameObjects = [];
            this._gameObjects = [];
            this._bufferedComponents = [];
            /**
             * @internal
             */
            this._addedComponents = [];
            this._components = [];
            this._interestConfig = null;
            this._globalGameObject = paper.Application.sceneManager.globalGameObject;
            this._isBehaviour = interestConfig.length === 1 && interestConfig[0].type !== undefined && interestConfig[0].type !== 0;
            this._interestConfig = interestConfig;
            this._onAddComponent = this._onAddComponent.bind(this);
            this._onRemoveComponent = this._onRemoveComponent.bind(this);
            this._onAddUnessentialComponent = this._onAddUnessentialComponent.bind(this);
            this._onRemoveUnessentialComponent = this._onRemoveUnessentialComponent.bind(this);
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                var isUnessential = config.type && (config.type & 4 /* Unessential */);
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveUnessentialComponent);
                        if (!isUnessential) {
                            paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddComponent);
                            paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveComponent);
                        }
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddUnessentialComponent);
                    }
                }
                else {
                    paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveUnessentialComponent);
                    if (!isUnessential) {
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddComponent);
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveComponent);
                    }
                    paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddUnessentialComponent);
                }
            }
            for (var _d = 0, _e = paper.Application.sceneManager.scenes; _d < _e.length; _d++) {
                var scene = _e[_d];
                for (var _f = 0, _g = scene.gameObjects; _f < _g.length; _f++) {
                    var gameObject = _g[_f];
                    this._addGameObject(gameObject);
                }
            }
        }
        /**
         * @internal
         */
        Group.create = function (interestConfig) {
            interestConfig = Array.isArray(interestConfig) ? interestConfig : [interestConfig];
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group_1 = _a[_i];
                if (group_1._interestConfig.length !== interestConfig.length) {
                    continue;
                }
                var isSame = true;
                for (var i = 0, l = interestConfig.length; i < l; ++i) {
                    var configA = interestConfig[i];
                    var configB = group_1._interestConfig[i];
                    if (configA.type !== configB.type) {
                        isSame = false;
                        break;
                    }
                    if (Array.isArray(configA.componentClass) && Array.isArray(configB.componentClass)) {
                        if (configA.componentClass.length !== configB.componentClass.length) {
                            isSame = false;
                            break;
                        }
                    }
                    else if (configA.componentClass !== configB.componentClass) {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) {
                    return group_1;
                }
            }
            var group = new Group(interestConfig);
            this._groups.push(group);
            return group;
        };
        /**
         * @internal
         */
        Group.update = function () {
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                group._update();
            }
        };
        Group.prototype._onAddComponent = function (component) {
            this._addGameObject(component.gameObject);
        };
        Group.prototype._onAddUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (!this._isBehaviour) {
                if (gameObject === this._globalGameObject) {
                    return;
                }
                if (this._bufferedGameObjects.indexOf(gameObject) < 0 && this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
            }
            if (this._bufferedComponents.indexOf(component) >= 0 || this._components.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        Group.prototype._onRemoveUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            var index = this._bufferedComponents.indexOf(component);
            if (index >= 0) {
                this._bufferedComponents.splice(index, 1);
                return;
            }
            if (this._isBehaviour) {
                index = this._components.indexOf(component);
                if (index < 0) {
                    return;
                }
                this._isRemoved = true;
                this._components[index] = null;
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            else {
                if (gameObject === this._globalGameObject) {
                    return;
                }
                if (this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (!system.onRemoveComponent || system.groups.indexOf(this) < 0) {
                    continue;
                }
                system.onRemoveComponent(component, this);
            }
        };
        Group.prototype._onRemoveComponent = function (component) {
            this._removeGameObject(component.gameObject);
        };
        Group.prototype._addGameObject = function (gameObject) {
            if (!this._isBehaviour && gameObject === this._globalGameObject) {
                return;
            }
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0 ||
                this._gameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    continue;
                }
                var isExtends = config.type && (config.type & 1 /* Extends */) !== 0;
                var isExculde = config.type && (config.type & 2 /* Exculde */) !== 0;
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, isExtends);
                        if (insterestComponent) {
                            break;
                        }
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, isExtends);
                }
                if (isExculde ? insterestComponent : !insterestComponent) {
                    return;
                }
            }
            this._bufferedGameObjects.push(gameObject);
        };
        Group.prototype._removeGameObject = function (gameObject) {
            var index = this._bufferedGameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._bufferedGameObjects.splice(index, 1);
            }
            else {
                index = this._gameObjects.indexOf(gameObject);
                if (index >= 0) {
                    if (this.locked) {
                        this.locked = false;
                        this._gameObjects = this._gameObjects.concat();
                    }
                    this._gameObjects.splice(index, 1);
                    index = this._addedGameObjects.indexOf(gameObject);
                    if (index >= 0) {
                        this._addedGameObjects[index] = null;
                    }
                    for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                        var system = _a[_i];
                        if (!system.onRemoveGameObject || system.groups.indexOf(this) < 0) {
                            continue;
                        }
                        system.onRemoveGameObject(gameObject, this);
                    }
                }
            }
        };
        Group.prototype._update = function () {
            this.locked = false;
            if (this._addedGameObjects.length > 0) {
                this._addedGameObjects.length = 0;
            }
            if (this._addedComponents.length > 0) {
                this._addedComponents.length = 0;
            }
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                this._isRemoved = false;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (removeCount > 0) {
                            this._components[index - removeCount] = component;
                            this._components[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    this._components.length -= removeCount;
                }
            }
            if (this._bufferedGameObjects.length > 0) {
                for (var _b = 0, _c = this._bufferedGameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (!gameObject) {
                        continue;
                    }
                    this._addedGameObjects.push(gameObject);
                    this._gameObjects.push(gameObject);
                }
                this._bufferedGameObjects.length = 0;
            }
            if (this._bufferedComponents.length > 0) {
                for (var _d = 0, _e = this._bufferedComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    if (!component) {
                        continue;
                    }
                    this._addedComponents.push(component);
                    this._components.push(component);
                }
                this._bufferedComponents.length = 0;
            }
        };
        /**
         * 判断实体是否被收集。
         */
        Group.prototype.hasGameObject = function (gameObject) {
            return this._gameObjects.indexOf(gameObject) >= 0;
        };
        Object.defineProperty(Group.prototype, "gameObjects", {
            /**
             *
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "components", {
            /**
             *
             */
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        Group._groups = [];
        return Group;
    }());
    paper.Group = Group;
    __reflect(Group.prototype, "paper.Group");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = new egret3d.Vector3();
    var _helpVector3B = new egret3d.Vector3();
    /**
     * obb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 定向包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var OBB = (function () {
        function OBB() {
            /**
             * center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒中心
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.center = new egret3d.Vector3();
            /**
             * size
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒各轴向长
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.size = new egret3d.Vector3();
            /**
             * vectors
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒世界空间下各个点坐标
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.vectors = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
            this._directions = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
        }
        OBB.prototype._computeBoxExtents = function (axis, box, out) {
            var p = egret3d.Vector3.dot(box.center, axis);
            //
            var r0 = Math.abs(egret3d.Vector3.dot(box._directions[0], axis)) * box.size.x * 0.5;
            var r1 = Math.abs(egret3d.Vector3.dot(box._directions[1], axis)) * box.size.y * 0.5;
            var r2 = Math.abs(egret3d.Vector3.dot(box._directions[2], axis)) * box.size.z * 0.5;
            //
            var r = r0 + r1 + r2;
            out.x = p - r;
            out.y = p + r;
            return out;
        };
        OBB.prototype._axisOverlap = function (axis, a, b) {
            var resultA = this._computeBoxExtents(axis, a, _helpVector3A);
            var resultB = this._computeBoxExtents(axis, b, _helpVector3B);
            return !(resultA.x > resultA.y || resultB.x > resultB.y);
        };
        /**
         * clone a obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 克隆一个obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.clone = function () {
            var value = new OBB();
            egret3d.Vector3.copy(this.center, value.center);
            egret3d.Vector3.copy(this.center, value.size);
            for (var key in this._directions) {
                egret3d.Vector3.copy(this._directions[key], value._directions[key]);
            }
            return value;
        };
        /**
         * build by min point and max point
         * @param minimum min point
         * @param maximum max point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由最大最小点构建定向包围盒
         * @param minimum 最小点坐标
         * @param maximum 最大点坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByMaxMin = function (minimum, maximum) {
            egret3d.Vector3.copy(minimum, this.vectors[0]);
            egret3d.Vector3.copy(minimum, this.vectors[1]);
            egret3d.Vector3.copy(minimum, this.vectors[2]);
            egret3d.Vector3.copy(maximum, this.vectors[3]);
            egret3d.Vector3.copy(minimum, this.vectors[4]);
            egret3d.Vector3.copy(maximum, this.vectors[5]);
            egret3d.Vector3.copy(maximum, this.vectors[6]);
            egret3d.Vector3.copy(maximum, this.vectors[7]);
            //
            this.vectors[1].z = maximum.z;
            this.vectors[2].x = maximum.x;
            this.vectors[3].y = minimum.y;
            this.vectors[4].y = maximum.y;
            this.vectors[5].x = minimum.x;
            this.vectors[6].z = minimum.z;
            //
            egret3d.Vector3.add(maximum, minimum, this.center);
            egret3d.Vector3.scale(this.center, 0.5);
            egret3d.Vector3.subtract(maximum, minimum, this.size);
        };
        /**
         * build by center and size
         * @param center center
         * @param size size
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由中心点和各轴向长度构建定向包围盒
         * @param center 中心点坐标
         * @param size 各轴向长度
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByCenterSize = function (center, size) {
            egret3d.Vector3.copy(center, this.center);
            egret3d.Vector3.copy(size, this.size);
            //
            var hsx = this.size.x * 0.5;
            var hsy = this.size.y * 0.5;
            var hsz = this.size.z * 0.5;
            var cenx = this.center.x;
            var ceny = this.center.y;
            var cenz = this.center.z;
            //
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz - hsz, this.vectors[0]);
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz + hsz, this.vectors[1]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz - hsz, this.vectors[2]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz + hsz, this.vectors[3]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz - hsz, this.vectors[4]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz + hsz, this.vectors[5]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz - hsz, this.vectors[6]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz + hsz, this.vectors[7]);
        };
        /**
         * update by world matrix
         * @param worldmatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 刷新定向包围盒
         * @param worldmatrix 世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.update = function (matrix) {
            matrix.decompose(this.center);
            this._directions[0].fromArray(matrix.rawData, 0);
            this._directions[0].fromArray(matrix.rawData, 4);
            this._directions[0].fromArray(matrix.rawData, 8);
        };
        /**
         * intersect width obb
         * @param value obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * obb的碰撞检测
         * @param value 待检测obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.intersects = function (value) {
            var a = this;
            var b = value;
            //
            if (!this._axisOverlap(a._directions[0], a, b))
                return false;
            if (!this._axisOverlap(a._directions[1], a, b))
                return false;
            if (!this._axisOverlap(a._directions[2], a, b))
                return false;
            if (!this._axisOverlap(b._directions[0], a, b))
                return false;
            if (!this._axisOverlap(b._directions[1], a, b))
                return false;
            if (!this._axisOverlap(b._directions[2], a, b))
                return false;
            var result = _helpVector3A;
            egret3d.Vector3.cross(a._directions[0], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            return true;
        };
        /**
         * update vectors by world matrix
         * @param vectors vectors
         * @param matrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 计算世界空间下各点坐标
         * @param vectors 结果数组
         * @param matrix 物体的世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.caclWorldVectors = function (vectors, matrix) {
            for (var i = 0; i < 8; ++i) {
                matrix.transformVector3(this.vectors[i], vectors[i]);
            }
        };
        OBB.prototype.deserialize = function (element) {
            this.center.deserialize(element.center);
            this.size.deserialize(element.size);
            return this;
        };
        return OBB;
    }());
    egret3d.OBB = OBB;
    __reflect(OBB.prototype, "egret3d.OBB");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        EnableSystem.prototype.onAddComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */) {
                if (!component.constructor.executeInEditMode) {
                    return;
                }
                if (!component._isReseted) {
                    component._isReseted = true;
                    component.onReset && component.onReset();
                }
            }
            component.onEnable && component.onEnable();
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        StartSystem.prototype.onAddComponent = function (component) {
            if (!component || component._isStarted) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._isStarted = true;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        UpdateSystem.prototype.onUpdate = function (deltaTime) {
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_2 = components; _a < components_2.length; _a++) {
                    var component = components_2[_a];
                    if (component) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.onUpdate = function (deltaTime) {
            // Update behaviours.
            var components = this._groups[0].components;
            if (paper.Application.playerMode === 2 /* Editor */) {
                for (var _i = 0, components_3 = components; _i < components_3.length; _i++) {
                    var component = components_3[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_4 = components; _a < components_4.length; _a++) {
                    var component = components_4[_a];
                    if (component) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            if (this._laterCalls.length > 0) {
                for (var _b = 0, _c = this._laterCalls; _b < _c.length; _b++) {
                    var callback = _c[_b];
                    callback();
                }
                this._laterCalls.length = 0;
            }
        };
        /**
         *
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._contactColliders = paper.ContactColliders.getInstance(paper.ContactColliders);
            _this._disposeCollecter = paper.DisposeCollecter.getInstance(paper.DisposeCollecter);
            return _this;
        }
        DisableSystem.prototype.onRemoveComponent = function (component) {
            if (!component) {
                return;
            }
            if (paper.Application.playerMode === 2 /* Editor */ &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component.onDisable && component.onDisable();
        };
        DisableSystem.prototype.onUpdate = function () {
            //
            var begin = this._contactColliders.begin;
            var stay = this._contactColliders.stay;
            var end = this._contactColliders.end;
            if (begin.length > 0) {
                for (var _i = 0, begin_1 = begin; _i < begin_1.length; _i++) {
                    var contact = begin_1[_i];
                    stay.push(contact);
                }
            }
            if (end.length > 0) {
                for (var _a = 0, end_1 = end; _a < end_1.length; _a++) {
                    var contact = end_1[_a];
                    var index = stay.indexOf(contact);
                    if (index >= 0) {
                        stay.splice(index, 1);
                    }
                }
            }
            //
            var gameObjectPool = paper.GameObject._instances;
            for (var _b = 0, _c = this._disposeCollecter.scenes; _b < _c.length; _b++) {
                var scene = _c[_b];
            }
            for (var _d = 0, _e = this._disposeCollecter.gameObjects; _d < _e.length; _d++) {
                var gameObject = _e[_d];
                gameObjectPool.push(gameObject);
            }
            for (var _f = 0, _g = this._disposeCollecter.components; _f < _g.length; _f++) {
                var component = _g[_f];
                component.uninitialize();
            }
            this._contactColliders.clear();
            this._disposeCollecter.clear();
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        13: "paper.Compatible",
        14: "paper.Compatible",
    };
    /**
     * @internal
     */
    var Compatible = (function () {
        function Compatible() {
        }
        Compatible.prototype.serialize = function () {
            throw new Error("Never");
        };
        Compatible.prototype.deserialize = function (element, data) {
            if (!data) {
                throw new Error("Never");
            }
            return data.getAssetOrComponent(element._glTFAsset);
        };
        return Compatible;
    }());
    paper.Compatible = Compatible;
    __reflect(Compatible.prototype, "paper.Compatible", ["paper.ISerializable"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    function _getDeserializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || {};
            for (var key in serializeKeys) {
                if (serializeKeys[key]) {
                    keys[serializeKeys[key]] = key;
                }
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _getDeserializedIgnoreKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        if (serializedClass.__deserializeIgnore) {
            keys = keys || [];
            for (var _i = 0, _a = serializedClass.__deserializeIgnore; _i < _a.length; _i++) {
                var key = _a[_i];
                keys.push(key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getDeserializedIgnoreKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    /**
     *
     */
    var Deserializer = (function () {
        function Deserializer() {
            /**
             *
             */
            this.assets = [];
            /**
             *
             */
            this.objects = {};
            /**
             *
             */
            this.components = {};
            this._deserializers = {};
            this._target = null;
        }
        Deserializer.prototype._deserializeObject = function (source, target) {
            var deserializedKeys = _getDeserializedKeys(target.constructor);
            var deserializedIgnoreKeys = _getDeserializedIgnoreKeys(target.constructor);
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (!this._keepUUID && k === KEY_UUID) {
                    continue;
                }
                var kk = (deserializedKeys && k in deserializedKeys) ? deserializedKeys[k] : k;
                if (deserializedIgnoreKeys &&
                    deserializedIgnoreKeys.indexOf(kk) >= 0) {
                    continue;
                }
                target[kk] = this._deserializeChild(source[k], target[kk]);
            }
            return target;
        };
        Deserializer.prototype._createComponent = function (componentSource, source, target) {
            var className = paper.serializeClassMap[componentSource.class] || componentSource.class;
            var clazz = egret.getDefinitionByName(className);
            var componentTarget = undefined;
            if (clazz) {
                var hasLink = KEY_EXTRAS in componentSource && componentSource[KEY_EXTRAS].linkedID;
                if (clazz === egret3d.Transform) {
                    componentTarget = this.components[componentSource.uuid];
                    if (KEY_CHILDREN in componentSource) {
                        for (var _i = 0, _a = componentSource[KEY_CHILDREN]; _i < _a.length; _i++) {
                            var childUUID = _a[_i];
                            var child = this.components[childUUID.uuid];
                            if (child._parent !== componentTarget) {
                                child._parent = componentTarget;
                                componentTarget._children.push(child);
                            }
                        }
                    }
                }
                else {
                    if (hasLink && source) {
                        var componentExtras = componentSource[KEY_EXTRAS];
                        var extras = source[KEY_EXTRAS];
                        var linkedID = componentExtras.linkedID;
                        var prefabDeserializer = this._deserializers[extras.prefab ? source.uuid : extras.rootID];
                        componentTarget = prefabDeserializer.components[linkedID];
                        if (!componentTarget) {
                            console.error("Deserialize prefab error.");
                        }
                    }
                    if (!hasLink || !componentTarget) {
                        componentTarget = (target || this._target).addComponent(clazz);
                    }
                    // if (clazz === Behaviour) { TODO
                    //     (componentTarget as Behaviour)._isReseted = true;
                    // }
                }
                if (!hasLink && this._makeLink) {
                    componentTarget.extras.linkedID = componentSource.uuid;
                }
            }
            else {
                componentTarget = (target || this._target).addComponent(paper.MissingComponent);
                componentTarget.missingObject = componentSource;
                console.warn("Class " + className + " is not defined.");
            }
            this.components[componentSource.uuid] = componentTarget;
            return componentTarget;
        };
        Deserializer.prototype._deserializeChild = function (source, target) {
            if (source === null || source === undefined) {
                return source;
            }
            switch (typeof source) {
                case "function":
                    return undefined;
                case "object": {
                    if (target) {
                        if (ArrayBuffer.isView(target)) {
                            for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                                target[i] = source[i];
                            }
                            return target;
                        }
                        else if (Array.isArray(target) && target.length === 0) {
                            for (var i = 0, l = source.length; i < l; ++i) {
                                target[i] = this._deserializeChild(source[i]);
                            }
                            return target;
                        }
                        else if (target[KEY_DESERIALIZE]) {
                            return target.deserialize(source, this);
                        }
                        else {
                            // console.info("Deserialize can be optimized.");
                        }
                    }
                    if (Array.isArray(source)) {
                        target = [];
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = this._deserializeChild(source[i]);
                        }
                        return target;
                    }
                    var classCodeOrName = source[KEY_CLASS];
                    if (KEY_ASSET in source) {
                        var assetIndex = source.asset;
                        if (assetIndex >= 0) {
                            return paper.Asset.find(this.assets[assetIndex]);
                        }
                        return null;
                    }
                    else if (KEY_UUID in source) {
                        var uuid = source.uuid;
                        if (uuid in this.objects) {
                            return this.objects[uuid];
                        }
                        else if (uuid in this.components) {
                            return this.components[uuid];
                        }
                        else if (classCodeOrName) {
                            var scene = this._target instanceof paper.GameObject ? this._target.scene : this._target;
                            if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                                for (var _i = 0, _a = scene.gameObjects; _i < _a.length; _i++) {
                                    var gameObject = _a[_i];
                                    if (gameObject.uuid === uuid) {
                                        return gameObject;
                                    }
                                }
                            }
                            else {
                                for (var _b = 0, _c = scene.gameObjects; _b < _c.length; _b++) {
                                    var gameObject = _c[_b];
                                    for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                        var component = _e[_d];
                                        if (component && component.uuid === uuid) {
                                            return component;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else if (classCodeOrName) {
                        var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                        if (clazz) {
                            target = new clazz();
                            return target.deserialize(source, this);
                        }
                    }
                    else {
                        target = {};
                        for (var k in source) {
                            target[k] = this._deserializeChild(source[k]);
                        }
                        return target;
                    }
                    console.warn("Deserialize error.", source);
                    return undefined;
                }
                default:
                    return source;
            }
        };
        Deserializer.prototype.getAssetOrComponent = function (source) {
            if (KEY_ASSET in source) {
                var assetIndex = source.asset;
                if (assetIndex >= 0) {
                    return paper.Asset.find(this.assets[assetIndex]);
                }
                return null;
            }
            var uuid = source.uuid;
            return this.components[uuid] || this.objects[uuid];
        };
        /**
         * @internal
         */
        Deserializer.prototype.deserialize = function (data, keepUUID, makeLink, target) {
            if (keepUUID === void 0) { keepUUID = false; }
            if (makeLink === void 0) { makeLink = false; }
            if (target === void 0) { target = null; }
            if (data.assets) {
                for (var _i = 0, _a = data.assets; _i < _a.length; _i++) {
                    var assetName = _a[_i];
                    this.assets.push(assetName);
                }
            }
            this._keepUUID = keepUUID;
            this._makeLink = makeLink;
            this._target = target;
            var sceneClassName = egret.getQualifiedClassName(paper.Scene);
            var transformClassName = egret.getQualifiedClassName(egret3d.Transform);
            var components = {};
            var root = null;
            if (data.components) {
                for (var _b = 0, _c = data.components; _b < _c.length; _b++) {
                    var componentSource = _c[_b];
                    components[componentSource.uuid] = componentSource;
                }
            }
            if (data.objects) {
                for (var _d = 0, _e = data.objects; _d < _e.length; _d++) {
                    var source = _e[_d];
                    var className = paper.serializeClassMap[source.class] || source.class;
                    var target_1 = undefined;
                    if (className === sceneClassName) {
                        target_1 = paper.Scene.createEmpty(source.name);
                        this._target = target_1;
                    }
                    else {
                        if (!this._target) {
                            this._target = paper.Application.sceneManager.activeScene;
                        }
                        var hasLink = KEY_EXTRAS in source && source[KEY_EXTRAS].linkedID;
                        if (hasLink) {
                            var extras = source[KEY_EXTRAS];
                            var linkedID = extras.linkedID;
                            var prefab = extras.prefab;
                            if (prefab) {
                                var assetIndex = prefab.asset;
                                if (assetIndex >= 0) {
                                    var assetName = this.assets[assetIndex];
                                    target_1 = paper.Prefab.create(assetName, this._target);
                                    if (target_1) {
                                        this._deserializers[source.uuid] = Deserializer._lastDeserializer;
                                    }
                                }
                            }
                            else {
                                var prefabDeserializer = this._deserializers[extras.rootID];
                                target_1 = prefabDeserializer.objects[linkedID];
                            }
                            if (!target_1) {
                                console.error("Deserialize prefab error.");
                            }
                        }
                        if (!hasLink || !target_1) {
                            target_1 = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, this._target);
                        }
                        if (!hasLink && this._makeLink) {
                            target_1.extras.linkedID = source.uuid;
                            if (root) {
                                target_1.extras.rootID = root.uuid;
                            }
                        }
                        if (KEY_COMPONENTS in source) {
                            for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                                var componentUUID = _g[_f];
                                var uuid = componentUUID.uuid;
                                var componentSource = components[uuid];
                                if ((paper.serializeClassMap[componentSource.class] || componentSource.class) === transformClassName) {
                                    this.components[uuid] = target_1.transform;
                                }
                            }
                        }
                    }
                    this.objects[source.uuid] = target_1;
                    root = root || target_1;
                }
                var i = data.objects.length;
                while (i--) {
                    var source = data.objects[i];
                    var target_2 = this.objects[source.uuid];
                    this._deserializeObject(source, target_2); // 场景或实体属性反序列化。
                    if (target_2.constructor === paper.GameObject && KEY_COMPONENTS in source) {
                        for (var _h = 0, _j = source[KEY_COMPONENTS]; _h < _j.length; _h++) {
                            var componentUUID = _j[_h];
                            this._createComponent(components[componentUUID.uuid], source, target_2);
                        }
                    }
                }
            }
            if (data.components) {
                for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                    var componentSource = _l[_k];
                    var uuid = componentSource.uuid;
                    var component = this.components[uuid];
                    if (component) {
                        if (component.constructor === paper.MissingComponent) {
                            continue;
                        }
                        this._deserializeObject(componentSource, component);
                    }
                    else if (target) {
                        component = this._createComponent(componentSource);
                        root = root || component;
                        this._deserializeObject(componentSource, component);
                    }
                }
            }
            Deserializer._lastDeserializer = this;
            return root;
        };
        return Deserializer;
    }());
    paper.Deserializer = Deserializer;
    __reflect(Deserializer.prototype, "paper.Deserializer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    paper.DATA_VERSION = 3;
    /**
     *
     */
    paper.DATA_VERSIONS = [paper.DATA_VERSION];
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_EXTRAS = "extras";
    var KEY_CHILDREN = "children";
    var _inline = false;
    var _serializeds = [];
    var _deserializers = {};
    var _ignoreKeys = ["extras"];
    var _rootIgnoreKeys = ["name", "localPosition", "localRotation", "extras"];
    var _serializeData = null;
    var _defaultGameObject = null;
    /**
     *
     */
    function serialize(source, inline) {
        if (inline === void 0) { inline = false; }
        if (_serializeData) {
            console.debug("The deserialization is not complete.");
        }
        if (!_defaultGameObject) {
            _defaultGameObject = paper.GameObject.create("NoName" /* NoName */, "" /* Untagged */, paper.Application.sceneManager.globalScene);
            _defaultGameObject.parent = paper.Application.sceneManager.globalGameObject;
        }
        _inline = inline;
        _serializeData = { version: paper.DATA_VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        for (var k in _deserializers) {
            delete _deserializers[k];
        }
        var children = _defaultGameObject.transform.children.concat(); // Clone.
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var child = children_1[_i];
            child.gameObject.destroy();
        }
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     *
     */
    function clone(object) {
        var data = serialize(object, true);
        var deserializer = new paper.Deserializer();
        return deserializer.deserialize(data);
    }
    paper.clone = clone;
    /**
     *
     */
    function equal(source, target) {
        var typeSource = typeof source;
        var typeTarget = typeof target;
        if (typeSource !== typeTarget) {
            return false;
        }
        if (source === null && target === null) {
            return true;
        }
        if (source === null || target === null) {
            return false;
        }
        switch (typeSource) {
            case "undefined":
            case "boolean":
            case "number":
            case "string":
            case "symbol":
            case "function":
                return source === target;
            case "object":
            default:
                break;
        }
        if ((Array.isArray(source) || ArrayBuffer.isView(source)) &&
            (Array.isArray(target) || ArrayBuffer.isView(target))) {
            var sl = source.length;
            if (sl !== target.length) {
                return false;
            }
            if (sl === 0) {
                return true;
            }
            for (var i = 0; i < sl; ++i) {
                if (!equal(source[i], target[i])) {
                    return false;
                }
            }
            return true;
        }
        if (source.constructor !== target.constructor) {
            return false;
        }
        if (source instanceof paper.Asset ||
            source.constructor === paper.GameObject ||
            source instanceof paper.BaseComponent) {
            return source === target;
        }
        if (source.constructor === Object) {
            for (var _i = 0, source_1 = source; _i < source_1.length; _i++) {
                var k = source_1[_i];
                if (!equal(source[k], target[k])) {
                    return false;
                }
            }
            return true;
        }
        if (egret.is(source, "paper.ISerializable")) {
            return equal(source.serialize(), target.serialize());
        }
        if (source instanceof paper.BaseObject) {
            return equal(serializeStruct(source), serializeStruct(target));
        }
        throw new Error("Unsupported data.");
    }
    paper.equal = equal;
    /**
     *
     */
    function serializeAsset(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData && _serializeData.assets) {
            var index = _serializeData.assets.indexOf(source.name);
            if (index < 0) {
                index = _serializeData.assets.length;
                _serializeData.assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.serializeAsset = serializeAsset;
    /**
     * 创建指定对象的结构体。
     */
    function serializeStruct(source) {
        var className = egret.getQualifiedClassName(source);
        var target = { class: _findClassCode(className) || className };
        _serializeChildren(source, target, null, null);
        return target;
    }
    paper.serializeStruct = serializeStruct;
    function _getSerializedKeys(serializedClass, keys) {
        if (keys === void 0) { keys = null; }
        var serializeKeys = serializedClass.__serializeKeys;
        if (serializeKeys) {
            keys = keys || [];
            for (var key in serializeKeys) {
                keys.push(serializeKeys[key] || key);
            }
        }
        if (serializedClass.prototype && serializedClass.prototype.__proto__.constructor !== Object) {
            _getSerializedKeys(serializedClass.prototype.__proto__.constructor, keys);
        }
        return keys;
    }
    function _findClassCode(name) {
        for (var key in paper.serializeClassMap) {
            if (paper.serializeClassMap[key] === name) {
                return key;
            }
        }
        return "";
    }
    function _serializeReference(source) {
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: _findClassCode(className) || className };
    }
    function _findPrefabRoot(gameObject) {
        while (!gameObject.extras.prefab) {
            gameObject = gameObject.parent;
        }
        return gameObject;
    }
    function _serializeObject(source) {
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return true;
        }
        var target = _serializeReference(source);
        var temp = null;
        var ignoreKeys = _ignoreKeys;
        if (source instanceof paper.GameObject) {
            if (source.isDestroyed) {
                console.warn("Missing game object.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.objects[source.extras.linkedID];
                if (source.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject;
            }
            _serializeData.objects.push(target);
        }
        else if (source instanceof paper.BaseComponent) {
            if (source.isDestroyed) {
                console.warn("Missing component.");
                return false;
            }
            if (source.extras && source.extras.linkedID) {
                var rootPrefabObject = _findPrefabRoot(source.gameObject);
                var prefabName = rootPrefabObject.extras.prefab.name;
                if (!(prefabName in _deserializers)) {
                    var prefabGameObject = paper.Prefab.create(prefabName, _defaultGameObject.scene);
                    prefabGameObject.parent = _defaultGameObject;
                    _deserializers[prefabName] = paper.Deserializer._lastDeserializer;
                }
                var deserializer = _deserializers[prefabName];
                temp = deserializer.components[source.extras.linkedID];
                if (source.gameObject.extras.prefab) {
                    ignoreKeys = _rootIgnoreKeys;
                }
            }
            else {
                temp = _defaultGameObject.getOrAddComponent(source.constructor);
            }
            _serializeData.components.push(target);
        }
        else {
            _serializeData.objects.push(target);
        }
        _serializeds.push(source.uuid);
        _serializeChildren(source, target, temp, ignoreKeys);
        return true;
    }
    function _serializeChildren(source, target, temp, ignoreKeys) {
        var serializedKeys = _getSerializedKeys(source.constructor);
        if (!serializedKeys) {
            return;
        }
        for (var _i = 0, serializedKeys_1 = serializedKeys; _i < serializedKeys_1.length; _i++) {
            var k = serializedKeys_1[_i];
            if (temp && (!ignoreKeys || ignoreKeys.indexOf(k) < 0) && equal(source[k], temp[k])) {
                continue;
            }
            target[k] = _serializeChild(source[k], source, k);
        }
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        var result = _serializeChild(element, parent, key);
                        if (result !== undefined) {
                            target.push(result);
                        }
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        var result = _serializeChild(source[k], parent, key);
                        if (result !== undefined) {
                            target[k] = result;
                        }
                    }
                    return target;
                }
                if (egret.is(source, "paper.ISerializable")) {
                    return source.serialize();
                }
                if (source instanceof paper.BaseObject) {
                    if (source.constructor === paper.Scene) {
                        return undefined; // Pass.
                    }
                    if (source instanceof paper.Asset) {
                        return serializeAsset(source);
                    }
                    if (source.constructor === paper.GameObject || source instanceof paper.BaseComponent) {
                        if (source.constructor === paper.GameObject && source.hideFlags === 3 /* HideAndDontSave */) {
                            return undefined; // Pass.
                        }
                        if (parent) {
                            if (parent.constructor === paper.Scene) {
                                if (key === KEY_GAMEOBJECTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === paper.GameObject) {
                                if (key === KEY_COMPONENTS) {
                                    return _serializeObject(source) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                            else if (parent.constructor === egret3d.Transform) {
                                if (key === KEY_CHILDREN) {
                                    return _serializeObject(source.gameObject) ? { uuid: source.uuid } : undefined; // Pass.
                                }
                            }
                        }
                        return _serializeReference(source);
                    }
                    return serializeStruct(source);
                }
                console.warn("Serialize error.", source);
                return undefined; // Pass.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        function Curve3(points, nbPoints) {
            this._beizerPoints = points;
            this._bezierPointNum = nbPoints;
        }
        Object.defineProperty(Curve3.prototype, "beizerPoints", {
            get: function () {
                return this._beizerPoints;
            },
            set: function (value) {
                this._beizerPoints = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Curve3.prototype, "bezierPointNum", {
            get: function () {
                return this._bezierPointNum;
            },
            set: function (value) {
                this._bezierPointNum = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 线性贝塞尔曲线
         */
        Curve3.CreateLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param nbPoints 将贝塞尔曲线拆分nbPoints段，一共有nbPoints + 1个点
         */
        Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0
         * @param v1
         * @param v2
         * @param v3
         * @param nbPoints
         */
        Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 贝塞尔曲线上的点
         */
        Curve3.prototype.getPoints = function () {
            return this._beizerPoints;
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var BeginSystem = (function (_super) {
        __extends(BeginSystem, _super);
        function BeginSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BeginSystem.prototype.onAwake = function () {
            this._globalGameObject.getOrAddComponent(egret3d.DefaultTextures);
            this._globalGameObject.getOrAddComponent(egret3d.DefaultMeshes);
            this._globalGameObject.getOrAddComponent(egret3d.DefaultShaders);
            this._globalGameObject.getOrAddComponent(egret3d.DefaultMaterials);
            this._globalGameObject.getOrAddComponent(egret3d.WebGLCapabilities);
            paper.Time = this._globalGameObject.getOrAddComponent(paper.Clock);
        };
        BeginSystem.prototype.onUpdate = function () {
            //
            egret3d.Performance.startCounter("all" /* All */);
            //
            egret3d.stage.update();
        };
        return BeginSystem;
    }(paper.BaseSystem));
    egret3d.BeginSystem = BeginSystem;
    __reflect(BeginSystem.prototype, "egret3d.BeginSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var EndSystem = (function (_super) {
        __extends(EndSystem, _super);
        function EndSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EndSystem.prototype.onUpdate = function (deltaTime) {
            //
            egret3d.InputManager.update(deltaTime);
            //
            egret3d.Performance.updateFPS();
            egret3d.Performance.endCounter("all" /* All */);
        };
        return EndSystem;
    }(paper.BaseSystem));
    egret3d.EndSystem = EndSystem;
    __reflect(EndSystem.prototype, "egret3d.EndSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3 = egret3d.Vector3.create();
    var _helpRotation = egret3d.Quaternion.create();
    var _helpMatrix = egret3d.Matrix4.create();
    /**
     * Transform Class
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * Transform实例可以被添加到3D场景中，并持有一个GameObejct实例
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            // private _dirtyLocalT: boolean = true;
            // private _dirtyLocalRS: boolean = true;
            // private _dirtyWorldT: boolean = true;
            // private _dirtyWorldRS: boolean = true;
            _this._dirtyLocal = true;
            _this._dirtyWorld = true;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this._localMatrix = egret3d.Matrix4.create();
            _this._worldMatrix = egret3d.Matrix4.create();
            _this._localPosition = egret3d.Vector3.create();
            _this._localRotation = egret3d.Quaternion.create();
            _this._localEulerAngles = egret3d.Vector3.create();
            _this._localScale = egret3d.Vector3.ONE.clone();
            _this._position = egret3d.Vector3.create();
            _this._rotation = egret3d.Quaternion.create();
            _this._eulerAngles = egret3d.Vector3.create();
            _this._scale = egret3d.Vector3.ONE.clone();
            /**
             * @internal
             */
            _this._children = [];
            /**
             * @internal
             */
            _this._parent = null;
            return _this;
        }
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._dirtify = function (isLocalDirty) {
            if (isLocalDirty) {
                this._dirtyLocal = true;
            }
            if (!this._dirtyWorld) {
                this._dirtyWorld = true;
                for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    if (child._dirtyWorld) {
                        continue;
                    }
                    child._dirtify(false);
                }
            }
            if (this.gameObject.renderer) {
                this.gameObject.renderer._boundingSphereDirty = true;
            }
        };
        // private _dirtify(isLocalDirty: boolean, isTranslateDirty: boolean) {
        //     if (isLocalDirty) {
        //         if (isTranslateDirty) {
        //             this._dirtyLocalT = true;
        //         }
        //         else {
        //             this._dirtyLocalRS = true;
        //         }
        //     }
        //     if (isTranslateDirty) {
        //         if (!this._dirtyWorldT) {
        //             this._dirtyWorldT = true;
        //             for (const child of this._children) {
        //                 if (child._dirtyWorldT) {
        //                     continue;
        //                 }
        //                 child._dirtify(false, isTranslateDirty);
        //             }
        //         }
        //     }
        //     else if (!this._dirtyWorldRS) {
        //         this._dirtyWorldRS = true;
        //         for (const child of this._children) {
        //             if (child._dirtyWorldRS) {
        //                 continue;
        //             }
        //             child._dirtify(false, isTranslateDirty);
        //         }
        //     }
        //     if (this.gameObject.renderer) {
        //         this.gameObject.renderer._boundingSphereDirty = true;
        //     }
        // }
        /**
         * 父节点发生改变的回调方法
         * 子类可通过重载此方法进行标脏状态传递
         */
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            // this._dirtify(false, false);
            this._dirtify(false);
        };
        Transform.prototype._getAllChildren = function (children) {
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                children.push(child);
                child._getAllChildren(children);
            }
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function () {
            var children = [];
            this._getAllChildren(children);
            return children;
        };
        /**
         * 设置父节点
         */
        Transform.prototype.setParent = function (newParent, worldPositionStays) {
            if (worldPositionStays === void 0) { worldPositionStays = false; }
            var oldParent = this._parent;
            if (oldParent === newParent) {
                return;
            }
            if (newParent &&
                this.gameObject.scene !== newParent.gameObject.scene) {
                console.warn("Cannot change the parent to a different scene.");
                return;
            }
            if (worldPositionStays) {
                _helpVector3.copy(this.getPosition());
            }
            if (oldParent) {
                oldParent._removeFromChildren(this);
            }
            if (newParent) {
                newParent._children.push(this);
            }
            this._parent = newParent;
            this._onParentChange(newParent, oldParent);
            if (worldPositionStays) {
                this.setPosition(_helpVector3);
            }
            return this;
        };
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         * 获取对象下标的子集对象
         * @param index
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * Finds a child by name or path and returns it.
         * @param nameOrPath
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                if (!name_1) {
                    return ancestor;
                }
                var prevAncestor = ancestor;
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        ancestor = child;
                        break;
                    }
                }
                if (prevAncestor === ancestor) {
                    return null;
                }
            }
            return ancestor;
        };
        /**
         * get local position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalPosition = function () {
            return this._localPosition;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.copy(p1);
            }
            else {
                this._localPosition.set(p1, p2 || 0.0, p3 || 0.0);
            }
            // if (!this._dirtyLocalT) {
            //     this._dirtify(true, true);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        Object.defineProperty(Transform.prototype, "localPosition", {
            /**
             *
             */
            get: function () {
                return this._localPosition;
            },
            set: function (value) {
                this._localPosition.copy(value);
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * get local rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalRotation = function () {
            return this._localRotation;
        };
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this._localRotation.copy(p1);
            }
            else {
                this._localRotation.set(p1, p2 || 0.0, p3 || 0.0, p4 !== undefined ? p4 : 1.0);
            }
            // if (!this._dirtyLocalRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        Object.defineProperty(Transform.prototype, "localRotation", {
            /**
             *
             */
            get: function () {
                return this._localRotation;
            },
            set: function (value) {
                this._localRotation.copy(value);
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * get local euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalEulerAngles = function (order) {
            // if (this._dirtyLocalRS) {
            if (this._dirtyLocal) {
                this.getLocalMatrix().toEuler(this._localEulerAngles, order).multiplyScalar(egret3d.RAD_DEG);
            }
            return this._localEulerAngles;
        };
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                _helpVector3.multiplyScalar(egret3d.DEG_RAD, p1);
                this._localRotation.fromEuler(_helpVector3, p2);
            }
            else {
                _helpVector3.set(p1 * egret3d.DEG_RAD, p2 * egret3d.DEG_RAD, p3 * egret3d.DEG_RAD);
                this._localRotation.fromEuler(_helpVector3, p4);
            }
            // if (!this._dirtyLocalRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        Object.defineProperty(Transform.prototype, "localEulerAngles", {
            /**
             *
             */
            get: function () {
                return this.getLocalEulerAngles();
            },
            set: function (value) {
                _helpVector3.multiplyScalar(egret3d.DEG_RAD, value);
                this._localRotation.fromEuler(_helpVector3);
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * get local scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalScale = function () {
            return this._localScale;
        };
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.copy(p1);
            }
            else {
                this._localScale.set(p1, p2 !== undefined ? p2 : 1.0, p3 !== undefined ? p3 : 1.0);
            }
            // if (!this._dirtyLocalRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        Object.defineProperty(Transform.prototype, "localScale", {
            /**
             *
             */
            get: function () {
                return this._localScale;
            },
            set: function (value) {
                this._localScale.copy(value);
                if (!this._dirtyLocal) {
                    this._dirtify(true);
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * get local matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalMatrix = function () {
            // if (this._dirtyLocalRS) {
            //     this._localMatrix.compose(this.localPosition, this.localRotation, this.localScale);
            //     this._dirtyLocalT = false;
            //     this._dirtyLocalRS = false;
            // }
            // else if (this._dirtyLocalT) {
            //     this._localMatrix.fromTranslate(this.localPosition, true);
            //     this._dirtyLocalT = false;
            // }
            if (this._dirtyLocal) {
                this._localMatrix.compose(this._localPosition, this._localRotation, this._localScale);
                this._dirtyLocal = false;
            }
            return this._localMatrix;
        };
        /**
         * get position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getPosition = function () {
            // if (this._dirtyWorldT) {
            // if (this._dirtyWorld) {
            //     this.getWorldMatrix().decompose(this._position, this._rotation, this._scale);
            // }
            this.getWorldMatrix().decompose(this._position, null, null);
            return this._position;
        };
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localPosition.copy(p1);
            }
            else {
                this._localPosition.set(p1, p2 || 0.0, p3 || 0.0);
            }
            if (this._parent) {
                this._localPosition.applyMatrix(_helpMatrix.inverse(this._parent.getWorldMatrix()));
            }
            // if (!this._dirtyWorldT) {
            //     this._dirtify(true, true);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        /**
         * get rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRotation = function () {
            // if (this._dirtyWorldRS) {
            // if (this._dirtyWorld) {
            //     this.getWorldMatrix().decompose(this._position, this._rotation, this._scale);
            // }
            this.getWorldMatrix().decompose(null, this._rotation, null);
            return this._rotation;
        };
        Transform.prototype.setRotation = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                this._localRotation.copy(q1);
            }
            else {
                this._localRotation.set(q1, q2 || 0.0, q3 || 0.0, q4 !== undefined ? q4 : 1.0);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.getRotation()));
            }
            // if (!this._dirtyWorldRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        /**
         * get euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getEulerAngles = function (order) {
            // if (this._dirtyWorldRS) {
            // if (this._dirtyWorld) {
            //     this.getWorldMatrix().decompose(this._position, this._rotation, this._scale).toEuler(this._eulerAngles).multiplyScalar(RAD_DEG);
            // }
            this.getWorldMatrix().toEuler(this._eulerAngles, order).multiplyScalar(egret3d.RAD_DEG);
            return this._eulerAngles;
        };
        Transform.prototype.setEulerAngles = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                _helpVector3.multiplyScalar(egret3d.DEG_RAD, q1);
                this._localRotation.fromEuler(_helpVector3, q2);
            }
            else {
                _helpVector3.set(q1 * egret3d.DEG_RAD, q2 * egret3d.DEG_RAD, q3 * egret3d.DEG_RAD);
                this._localRotation.fromEuler(_helpVector3, q4);
            }
            if (this._parent) {
                this._localRotation.premultiply(_helpRotation.inverse(this._parent.getRotation()));
            }
            // if (!this._dirtyWorldRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        /**
         * get scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getScale = function () {
            // if (this._dirtyWorldRS) {
            // if (this._dirtyWorld) {
            //     this.getWorldMatrix().decompose(this._position, this._rotation, this._scale);
            // }
            this.getWorldMatrix().decompose(null, null, this._scale);
            return this._scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                this._localScale.copy(p1);
            }
            else {
                this._localScale.set(p1, p2 !== undefined ? p2 : 1.0, p3 !== undefined ? p3 : 1.0);
            }
            if (this._parent) {
                this._localScale.applyDirection(_helpMatrix.inverse(this._parent.getWorldMatrix()));
            }
            // if (!this._dirtyWorldRS) {
            //     this._dirtify(true, false);
            // }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
            return this;
        };
        /**
         * get world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getWorldMatrix = function () {
            // if (this._dirtyWorldT || this._dirtyWorldRS) {
            //     const localMatrix = this.getLocalMatrix();
            //     if (this._parent) {
            //         this._worldMatrix.multiply(this._parent.getWorldMatrix(), localMatrix);
            //     }
            //     else {
            //         this._worldMatrix.copy(localMatrix);
            //     }
            //     this._worldMatrixDeterminant = this._worldMatrix.determinant();
            //     this._dirtyWorldT = false;
            //     this._dirtyWorldRS = false;
            // }
            if (this._dirtyWorld) {
                var localMatrix = this.getLocalMatrix();
                if (this._parent) {
                    this._worldMatrix.multiply(this._parent.getWorldMatrix(), localMatrix);
                }
                else {
                    this._worldMatrix.copy(localMatrix);
                }
                this._worldMatrixDeterminant = this._worldMatrix.determinant();
                this._dirtyWorld = false;
            }
            return this._worldMatrix;
        };
        /**
         * x-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前x轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRight = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.getWorldMatrix(), egret3d.Vector3.RIGHT).normalize();
        };
        /**
         * y-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前y轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getUp = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.getWorldMatrix(), egret3d.Vector3.UP).normalize();
        };
        /**
         * z-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前z轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getForward = function (out) {
            if (!out) {
                out = egret3d.Vector3.create();
            }
            return out.applyDirection(this.getWorldMatrix(), egret3d.Vector3.FORWARD).normalize();
        };
        /**
         * look at a target
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 旋转当前transform 到指定的目标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.lookAt = function (target, up) {
            if (target instanceof Transform) {
                _helpVector3.copy(target.getPosition());
            }
            else {
                _helpVector3.copy(target);
            }
            if (up) {
                this._localRotation.fromMatrix(_helpMatrix.lookAt(this.getPosition(), _helpVector3, up));
            }
            else {
                this._localRotation.lookAt(this.getPosition(), _helpVector3);
            }
            this.setRotation(this._localRotation);
            return this;
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 当前子集对象的数量
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * children list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 子物体列表
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * instance of parent transform
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 父元素实例
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField("localPosition")
        ], Transform.prototype, "_localPosition", void 0);
        __decorate([
            paper.serializedField("localRotation")
        ], Transform.prototype, "_localRotation", void 0);
        __decorate([
            paper.serializedField("localScale")
        ], Transform.prototype, "_localScale", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.VECTOR3)
        ], Transform.prototype, "localPosition", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.VECTOR4)
        ], Transform.prototype, "localRotation", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.VECTOR3)
        ], Transform.prototype, "localEulerAngles", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.VECTOR3)
        ], Transform.prototype, "localScale", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Transform.prototype, "children", null);
        return Transform;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _attributesB = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    /**
     *
     */
    var DefaultMeshes = (function (_super) {
        __extends(DefaultMeshes, _super);
        function DefaultMeshes() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMeshes.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            {
                var mesh = new egret3d.Mesh(6, 0, ["POSITION" /* POSITION */, "COLOR_0" /* COLOR_0 */]);
                mesh._isBuiltin = true;
                mesh.name = "builtin/axises.mesh.bin";
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                paper.Asset.register(mesh);
                DefaultMeshes.AXISES = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0.0, 0.0, 0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1.0, 0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
                    0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
                    0.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0, 1.0,
                ]);
            }
            {
                var mesh = new egret3d.Mesh(4, 6);
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    -0.5, 0.5, 0,
                    -0.5, -0.5, 0,
                    0.5, 0.5, 0,
                    0.5, -0.5, 0,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                ]);
                mesh.setAttributes("TANGENT" /* TANGENT */, [
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 2, 2, 1, 3,
                ]);
            }
            {
                var mesh = new egret3d.Mesh(4, 6);
                mesh._isBuiltin = true;
                mesh.name = "builtin/quad_particle.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.QUAD_PARTICLE = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0, 0.5, 0,
                    0, -0.5, 0,
                    1, 0.5, 0,
                    1, -0.5, 0,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                ]);
                mesh.setAttributes("TANGENT" /* TANGENT */, [
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 2, 2, 1, 3,
                ]);
            }
            {
                var mesh = new egret3d.Mesh(4, 6);
                mesh._isBuiltin = true;
                mesh.name = "builtin/plane.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PLANE = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    -5, 0, 5,
                    -5, 0, -5,
                    5, 0, 5,
                    5, 0, -5,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                ]);
                mesh.setAttributes("TANGENT" /* TANGENT */, [
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                ]);
                mesh.setIndices([
                    0, 1, 2, 2, 1, 3,
                ]);
            }
            {
                var mesh = new egret3d.Mesh(24, 36);
                mesh._isBuiltin = true;
                mesh.name = "builtin/cube.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CUBE = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    -0.5, -0.5, -0.5,
                    -0.5, -0.5, 0.5,
                    0.5, -0.5, -0.5,
                    0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                    -0.5, 0.5, -0.5,
                    0.5, 0.5, 0.5,
                    0.5, 0.5, -0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, 0.5, 0.5,
                    0.5, -0.5, 0.5,
                    0.5, 0.5, 0.5,
                    -0.5, 0.5, -0.5,
                    -0.5, -0.5, -0.5,
                    0.5, 0.5, -0.5,
                    0.5, -0.5, -0.5,
                    0.5, -0.5, -0.5,
                    0.5, -0.5, 0.5,
                    0.5, 0.5, -0.5,
                    0.5, 0.5, 0.5,
                    -0.5, -0.5, 0.5,
                    -0.5, -0.5, -0.5,
                    -0.5, 0.5, 0.5,
                    -0.5, 0.5, -0.5,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 1, 0,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, 1,
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1,
                    0, 0, -1,
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,
                    1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,
                    -1, 0, 0,
                ]);
                mesh.setAttributes("TANGENT" /* TANGENT */, [
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    -1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    1, 0, 0, 1,
                    0, 0, 1, 1,
                    0, 0, 1, 1,
                    0, 0, 1, 1,
                    0, 0, 1, 1,
                    0, 0, -1, 1,
                    0, 0, -1, 1,
                    0, 0, -1, 1,
                    0, 0, -1, 1,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                    1, 1,
                    1, 0,
                    0, 1,
                    0, 0,
                    0, 0,
                    0, 1,
                    1, 0,
                    1, 1,
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0,
                    0, 1,
                    1, 1,
                    0, 0,
                    1, 0,
                ]);
                mesh.setIndices([
                    0, 1, 2, 2, 1, 3,
                    4, 5, 6, 6, 5, 7,
                    8, 9, 10, 10, 9, 11,
                    12, 13, 14, 14, 13, 15,
                    16, 17, 18, 18, 17, 19,
                    20, 21, 22, 22, 21, 23
                ]);
            }
            {
                var mesh = new egret3d.Mesh(16, 18);
                mesh._isBuiltin = true;
                mesh.name = "builtin/pyramid.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.PYRAMID = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    -0.5, -1, -0.5,
                    0, 1, 0,
                    0.5, -1, -0.5,
                    0.5, -1, -0.5,
                    0, 1, 0,
                    0.5, -1, 0.5,
                    0.5, -1, 0.5,
                    0, 1, 0,
                    -0.5, -1, 0.5,
                    -0.5, -1, 0.5,
                    0, 1, 0,
                    -0.5, -1, -0.5,
                    -0.5, -1, -0.5,
                    0.5, -1, -0.5,
                    0.5, -1, 0.5,
                    -0.5, -1, 0.5,
                ]);
                mesh.setAttributes("NORMAL" /* NORMAL */, [
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, 0, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                    0, -1, 0,
                ]);
                mesh.setAttributes("TANGENT" /* TANGENT */, [
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                    0, 0, 0, 1,
                ]);
                mesh.setAttributes("COLOR_0" /* COLOR_0 */, [
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                    1, 1, 1, 1,
                ]);
                mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, [
                    0, 0,
                    0.5, 0.5,
                    0, 1,
                    0, 1,
                    0.5, 0.5,
                    1, 1,
                    1, 1,
                    0.5, 0.5,
                    1, 0,
                    1, 0,
                    0.5, 0.5,
                    0, 0,
                    0, 0,
                    1, 0,
                    1, 1,
                    0, 1,
                ]);
                mesh.setIndices([
                    0, 2, 1, 3, 5, 4,
                    6, 8, 7, 9, 11, 10,
                    12, 14, 13, 15, 14, 12
                ]);
            }
            {
                var mesh = DefaultMeshes.createSphereCCW();
                mesh._isBuiltin = true;
                mesh.name = "builtin/sphere.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.SPHERE = mesh;
            }
            {
                var mesh = DefaultMeshes.createCylinderCCW();
                mesh._isBuiltin = true;
                mesh.name = "builtin/cylinder.mesh.bin";
                paper.Asset.register(mesh);
                DefaultMeshes.CYLINDER = mesh;
            }
        };
        DefaultMeshes.createCylinderCCW = function (height, radius, segment) {
            if (height === void 0) { height = 1.0; }
            if (radius === void 0) { radius = 0.5; }
            if (segment === void 0) { segment = 20; }
            var index = 0;
            var normal = new egret3d.Vector3(0.0, 1.0, 0.0);
            var mesh = new egret3d.Mesh(4 * segment + 2, 3 * 4 * segment, _attributesB);
            var vertices = mesh.getVertices();
            var uvs = mesh.getUVs();
            var normals = mesh.getNormals();
            var indices = mesh.getIndices();
            for (var s = 0; s < 4; s++) {
                var y = (s < 2 ? 0.5 : -0.5) * height;
                if (s === 3) {
                    normal.x = 0.0;
                    normal.y = -1.0;
                    normal.z = 0.0;
                }
                for (var i = 0; i < segment; i++) {
                    var r = i / segment * Math.PI * 2.0;
                    var x = Math.sin(r);
                    var z = Math.cos(r);
                    if (s === 1 || s === 2) {
                        normal.x = x;
                        normal.y = 0.0;
                        normal.z = z;
                    }
                    vertices[index * 3] = x * radius;
                    vertices[index * 3 + 1] = y;
                    vertices[index * 3 + 2] = z * radius;
                    normals[index * 3] = normal.x;
                    normals[index * 3 + 1] = normal.y;
                    normals[index * 3 + 2] = normal.z;
                    if (s === 0 || s === 3) {
                        uvs[index * 2] = x * 0.5 + 0.5;
                        uvs[index * 2 + 1] = z * 0.5 + 0.5;
                    }
                    else {
                        uvs[index * 2] = i / segment;
                        uvs[index * 2 + 1] = y < 0.0 ? 0.0 : 1.0;
                    }
                    index++;
                }
            }
            // Top
            vertices[index * 3] = 0.0;
            vertices[index * 3 + 1] = 0.5 * height;
            vertices[index * 3 + 2] = 0.0;
            normals[index * 3] = normal.x;
            normals[index * 3 + 1] = normal.y;
            normals[index * 3 + 2] = normal.z;
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            index = 0;
            var iTop = 4 * segment;
            var iBottom = 4 * segment + 1;
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            for (var i = 0; i < segment; i++) {
                // Top
                indices[index++] = iTop;
                indices[index++] = i === segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1;
                indices[index++] = segment * 0 + i + 0;
                // Bottom
                indices[index++] = iBottom;
                indices[index++] = segment * 3 + i + 0;
                indices[index++] = i === segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1;
                // Side
                var t = segment * 1 + i;
                var t2 = i === segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                var b = segment * 2 + i;
                var b2 = i === segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                indices[index++] = t;
                indices[index++] = t2;
                indices[index++] = b;
                indices[index++] = t2;
                indices[index++] = b2;
                indices[index++] = b;
            }
            return mesh;
        };
        DefaultMeshes.createSphereCCW = function (radius, widthSegments, heightSegments) {
            if (radius === void 0) { radius = 0.5; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var mesh = new egret3d.Mesh((widthSegments + 1) * (heightSegments + 1), widthSegments * heightSegments * 6 - 6, _attributesB);
            //
            var index = 0;
            var vertex = new egret3d.Vector3();
            var normal = new egret3d.Vector3();
            var grid = new Array();
            var vertices = [];
            var normals = [];
            var uvs = [];
            for (var iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = new Array();
                var v = iy / heightSegments;
                for (var ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments;
                    // Vertex.
                    vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertex.y = radius * Math.cos(v * Math.PI);
                    vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertices.push(vertex.x, vertex.y, vertex.z);
                    // Normal.
                    normal.x = vertex.x;
                    normal.y = vertex.y;
                    normal.z = vertex.z;
                    var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (num > Number.MIN_VALUE) {
                        normals.push(normal.x / num, normal.y / num, normal.z / num);
                    }
                    else {
                        normals.push(0.0, 0.0, 0.0);
                    }
                    uvs.push(0, 1.0 - u, v);
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            mesh.setAttributes("POSITION" /* POSITION */, vertices);
            mesh.setAttributes("NORMAL" /* NORMAL */, normals);
            mesh.setAttributes("TEXCOORD_0" /* TEXCOORD_0 */, uvs);
            // Indices.
            var tris = new Array();
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0) {
                        tris.push(a, d, b);
                    }
                    if (iy !== heightSegments - 1) {
                        tris.push(b, d, c);
                    }
                }
            }
            var indices = mesh.getIndices();
            for (var i = 0, l = tris.length; i < l; i++) {
                indices[i] = tris[i];
            }
            return mesh;
        };
        return DefaultMeshes;
    }(paper.SingletonComponent));
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultTextures = (function (_super) {
        __extends(DefaultTextures, _super);
        function DefaultTextures() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultTextures.prototype.initialize = function () {
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/white.image.json", 255, 255, 255);
                texture._isBuiltin = true;
                DefaultTextures.WHITE = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/gray.image.json", 128, 128, 128);
                texture._isBuiltin = true;
                DefaultTextures.GRAY = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createGridTexture("builtin/grid.image.json");
                texture._isBuiltin = true;
                DefaultTextures.GRID = texture;
                paper.Asset.register(texture);
            }
            {
                var texture = egret3d.GLTexture2D.createColorTexture("builtin/missing.image.json", 255, 0, 255);
                texture._isBuiltin = true;
                DefaultTextures.MISSING = texture;
                paper.Asset.register(texture);
            }
        };
        return DefaultTextures;
    }(paper.SingletonComponent));
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultShaders = (function (_super) {
        __extends(DefaultShaders, _super);
        function DefaultShaders() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultShaders.prototype._createShader = function (name, config, renderQueue, states, defines) {
            var shader = new egret3d.Shader(config, name);
            shader._isBuiltin = true;
            if (renderQueue) {
                shader._renderQueue = renderQueue;
            }
            if (defines) {
                shader._defines = defines;
            }
            if (states) {
                var shaderStates = egret3d.GLTFAsset.copyTechniqueStates(states);
                if (shaderStates) {
                    shader._states = shaderStates;
                }
            }
            paper.Asset.register(shader);
            return shader;
        };
        DefaultShaders.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            //
            var helpMaterial = new egret3d.Material(new egret3d.Shader(egret3d.ShaderLib.meshbasic, ""));
            //
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_BASIC = this._createShader("builtin/meshbasic.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_BASIC_DOUBLESIDE = this._createShader("builtin/meshbasic_doubleside.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_LAMBERT = this._createShader("builtin/meshlambert.shader.json", egret3d.ShaderLib.meshlambert, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_LAMBERT_DOUBLESIDE = this._createShader("builtin/meshlambert_doubleside.shader.json", egret3d.ShaderLib.meshlambert, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHONG = this._createShader("builtin/meshphong.shader.json", egret3d.ShaderLib.meshphong, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHONE_DOUBLESIDE = this._createShader("builtin/meshphong_doubleside.shader.json", egret3d.ShaderLib.meshphong, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.MESH_PHYSICAL = this._createShader("builtin/meshphysical.shader.json", egret3d.ShaderLib.meshphysical, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MESH_PHYSICAL_DOUBLESIDE = this._createShader("builtin/meshphysical_doubleside.shader.json", egret3d.ShaderLib.meshphysical, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT = this._createShader("builtin/transparent.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.TRANSPARENT_DOUBLESIDE = this._createShader("builtin/transparent_doubleside.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, false).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE = this._createShader("builtin/transparent_additive.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.TRANSPARENT_ADDITIVE_DOUBLESIDE = this._createShader("builtin/transparent_additive_doubleside.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.LINEDASHED = this._createShader("builtin/linedashed.shader.json", egret3d.ShaderLib.linedashed, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            DefaultShaders.VERTEX_COLOR = this._createShader("builtin/vertcolor.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP", "USE_COLOR"]);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.MATERIAL_COLOR = this._createShader("builtin/materialcolor.shader.json", egret3d.ShaderLib.meshbasic, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.PARTICLE = this._createShader("builtin/particle.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, false).setBlend(1 /* Blend */);
            DefaultShaders.PARTICLE_BLEND = this._createShader("builtin/particle_blend.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true).setBlend(1 /* Blend */);
            helpMaterial.glTFTechnique.states.functions.depthFunc = [514 /* EQUAL */]; //TODO
            DefaultShaders.PARTICLE_BLEND1 = this._createShader("builtin/particle_blend1.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, false).setBlend(3 /* Add */);
            DefaultShaders.PARTICLE_ADDITIVE = this._createShader("builtin/particle_additive.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, false).setBlend(2 /* Blend_PreMultiply */);
            DefaultShaders.PARTICLE_BLEND_PREMULTIPLY = this._createShader("builtin/particle_blend_premultiply.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, false).setBlend(4 /* Add_PreMultiply */);
            DefaultShaders.PARTICLE_ADDITIVE_PREMULTIPLY = this._createShader("builtin/particle_additive_premultiply.shader.json", egret3d.ShaderLib.particle, paper.RenderQueue.Transparent, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.CUBE = this._createShader("builtin/cube.shader.json", egret3d.ShaderLib.cube, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DEPTH = this._createShader("builtin/depth.shader.json", egret3d.ShaderLib.depth, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.DISTANCE_RGBA = this._createShader("builtin/distanceRGBA.shader.json", egret3d.ShaderLib.distanceRGBA, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.EQUIRECT = this._createShader("builtin/equirect.shader.json", egret3d.ShaderLib.equirect, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.NORMAL = this._createShader("builtin/normal.shader.json", egret3d.ShaderLib.normal, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.POINTS = this._createShader("builtin/points.shader.json", egret3d.ShaderLib.points, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SHADOW = this._createShader("builtin/shadow.shader.json", egret3d.ShaderLib.shadow, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            helpMaterial.clearStates().setDepth(true, true);
            DefaultShaders.SPRITE = this._createShader("builtin/sprite.shader.json", egret3d.ShaderLib.sprite, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states);
            // TODO
            helpMaterial.clearStates().setDepth(true, true).setCullFace(true, 2305 /* CCW */, 1029 /* BACK */);
            this._createShader("obsolete/shaders/diffuse.shader.json", egret3d.ShaderLib.diffuse, paper.RenderQueue.Geometry, helpMaterial.glTFTechnique.states, ["USE_MAP"]);
            helpMaterial.dispose();
        };
        return DefaultShaders;
    }(paper.SingletonComponent));
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials.prototype._createMaterial = function (name, shader, renderQueue) {
            if (renderQueue === void 0) { renderQueue = paper.RenderQueue.Geometry; }
            var material = new egret3d.Material(shader);
            material.name = name;
            material.renderQueue = renderQueue;
            material._isBuiltin = true;
            paper.Asset.register(material);
            return material;
        };
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials.MESH_BASIC = this._createMaterial("builtin/meshbasic.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setTexture("map", egret3d.DefaultTextures.WHITE);
            DefaultMaterials.LINEDASHED_COLOR = this._createMaterial("builtin/linedashed_color.mat.json", egret3d.DefaultShaders.LINEDASHED)
                .addDefine("USE_COLOR");
            DefaultMaterials.MISSING = this._createMaterial("builtin/missing.mat.json", egret3d.DefaultShaders.MESH_BASIC)
                .setVector3v("diffuse", new Float32Array([1.0, 0.0, 1.0]));
            DefaultMaterials.SHADOW_DEPTH = this._createMaterial("builtin/shadow_depth.mat.json", egret3d.DefaultShaders.DEPTH)
                .addDefine("DEPTH_PACKING 3201");
            DefaultMaterials.SHADOW_DISTANCE = this._createMaterial("builtin/shadow_distance.mat.json", egret3d.DefaultShaders.DISTANCE_RGBA);
        };
        return DefaultMaterials;
    }(paper.SingletonComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var CamerasAndLights = (function (_super) {
        __extends(CamerasAndLights, _super);
        function CamerasAndLights() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cameras = [];
            _this.lights = [];
            return _this;
        }
        CamerasAndLights.prototype._sortCameras = function (a, b) {
            return a.order - b.order;
        };
        CamerasAndLights.prototype.updateCamera = function (gameObjects) {
            this.cameras.length = 0;
            for (var _i = 0, gameObjects_1 = gameObjects; _i < gameObjects_1.length; _i++) {
                var gameObject = gameObjects_1[_i];
                this.cameras.push(gameObject.getComponent(egret3d.Camera));
            }
        };
        CamerasAndLights.prototype.updateLight = function (gameObjects) {
            this.lights.length = 0;
            for (var _i = 0, gameObjects_2 = gameObjects; _i < gameObjects_2.length; _i++) {
                var gameObject = gameObjects_2[_i];
                this.lights.push(gameObject.getComponent(egret3d.BaseLight, true));
            }
        };
        CamerasAndLights.prototype.sortCameras = function () {
            this.cameras.sort(this._sortCameras);
        };
        return CamerasAndLights;
    }(paper.SingletonComponent));
    egret3d.CamerasAndLights = CamerasAndLights;
    __reflect(CamerasAndLights.prototype, "egret3d.CamerasAndLights");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DrawCalls = (function (_super) {
        __extends(DrawCalls, _super);
        function DrawCalls() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 参与渲染的渲染器列表。
             */
            _this.renderers = [];
            /**
             * 所有的 draw call 列表。
             */
            _this.drawCalls = [];
            /**
             * 非透明列表
             */
            _this.opaqueCalls = [];
            /**
             * 透明列表
             */
            _this.transparentCalls = [];
            /**
             * 阴影列表
             */
            _this.shadowCalls = [];
            return _this;
        }
        /**
         * 所有非透明的, 按照从近到远排序
         * @param a
         * @param b
         */
        DrawCalls.prototype._sortOpaque = function (a, b) {
            var aMat = a.material;
            var bMat = b.material;
            if (aMat.renderQueue !== bMat.renderQueue) {
                return aMat.renderQueue - bMat.renderQueue;
            }
            else if (aMat._glTFTechnique.program !== bMat._glTFTechnique.program) {
                return aMat._glTFTechnique.program - bMat._glTFTechnique.program;
            }
            else if (aMat._id !== bMat._id) {
                return aMat._id - bMat._id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         * @param a
         * @param b
         */
        DrawCalls.prototype._sortFromFarToNear = function (a, b) {
            if (a.material.renderQueue === b.material.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return a.material.renderQueue - b.material.renderQueue;
            }
        };
        DrawCalls.prototype.shadowFrustumCulling = function (camera) {
            this.shadowCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var drawTarget = drawCall.renderer.gameObject;
                var visible = (camera.cullingMask & drawTarget.layer) !== 0;
                if (visible && drawCall.renderer.castShadows) {
                    if (!drawCall.frustumTest || (drawCall.frustumTest && camera.testFrustumCulling(drawTarget.renderer))) {
                        this.shadowCalls.push(drawCall);
                    }
                }
            }
            this.shadowCalls.sort(this._sortFromFarToNear);
        };
        DrawCalls.prototype.sortAfterFrustumCulling = function (camera) {
            //每次根据视锥裁切填充TODO，放到StartSystem
            this.opaqueCalls.length = 0;
            this.transparentCalls.length = 0;
            var cameraPos = camera.gameObject.transform.getPosition();
            //
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var drawTarget = drawCall.renderer.gameObject;
                var visible = ((camera.cullingMask & drawTarget.layer) !== 0 && (!drawCall.frustumTest || (drawCall.frustumTest && camera.testFrustumCulling(drawTarget.renderer))));
                //裁切没通过
                if (visible) {
                    var objPos = drawTarget.transform.getPosition();
                    drawCall.zdist = objPos.getDistance(cameraPos);
                    if (drawCall.material.renderQueue >= paper.RenderQueue.Transparent && drawCall.material.renderQueue < paper.RenderQueue.Overlay) {
                        this.transparentCalls.push(drawCall);
                    }
                    else {
                        this.opaqueCalls.push(drawCall);
                    }
                }
            }
            //
            this.opaqueCalls.sort(this._sortOpaque);
            this.transparentCalls.sort(this._sortFromFarToNear);
        };
        /**
         * 移除指定渲染器的 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.removeDrawCalls = function (renderer) {
            var index = this.renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = this.drawCalls.length;
            while (i--) {
                if (this.drawCalls[i].renderer === renderer) {
                    this.drawCalls.splice(i, 1);
                }
            }
            this.renderers.splice(index, 1);
        };
        /**
         * 指定渲染器是否生成了 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        return DrawCalls;
    }(paper.SingletonComponent));
    egret3d.DrawCalls = DrawCalls;
    __reflect(DrawCalls.prototype, "egret3d.DrawCalls");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Camera系统
     */
    var CameraSystem = (function (_super) {
        __extends(CameraSystem, _super);
        function CameraSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.PointLight, egret3d.SpotLight] }
                ]
            ];
            _this._camerasAndLights = egret3d.CamerasAndLights.getInstance(egret3d.CamerasAndLights);
            return _this;
        }
        CameraSystem.prototype.onAddGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCamera(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLight(this._groups[1].gameObjects);
            }
        };
        CameraSystem.prototype.onRemoveGameObject = function (_gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCamera(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLight(this._groups[1].gameObjects);
            }
        };
        CameraSystem.prototype.onUpdate = function (deltaTime) {
            var cameras = this._camerasAndLights.cameras;
            if (cameras.length > 0) {
                var camerasScene = paper.Application.sceneManager.camerasScene || paper.Application.sceneManager.activeScene;
                this._camerasAndLights.sortCameras();
                for (var _i = 0, cameras_1 = cameras; _i < cameras_1.length; _i++) {
                    var component = cameras_1[_i];
                    if (component.gameObject.scene !== camerasScene) {
                        continue;
                    }
                    component.update(deltaTime);
                }
            }
        };
        return CameraSystem;
    }(paper.BaseSystem));
    egret3d.CameraSystem = CameraSystem;
    __reflect(CameraSystem.prototype, "egret3d.CameraSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpRectA = new egret3d.Rectangle();
    /**
     * 相机组件
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否清除颜色缓冲区
             */
            _this.clearOption_Color = true;
            /**
             * 是否清除深度缓冲区
             */
            _this.clearOption_Depth = true;
            /**
             * 相机的渲染剔除，对应GameObject的层级
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * 相机渲染排序
             */
            _this.order = 0;
            /**
             * 透视投影的fov
             */
            _this.fov = Math.PI * 0.25;
            /**
             * 正交投影的竖向size
             */
            _this.size = 2.0;
            /**
             * 0=正交，1=透视 中间值可以在两种相机间过度
             */
            _this.opvalue = 1.0;
            /**
             * 背景色
             */
            _this.backgroundColor = egret3d.Color.create(0.13, 0.28, 0.51, 1);
            /**
             * 相机视窗
             */
            _this.viewport = new egret3d.Rectangle(0, 0, 1, 1);
            /**
             * TODO 功能完善后开放此接口
             */
            _this.postQueues = [];
            /**
             * 相机渲染上下文
             */
            _this.context = null;
            /**
             * 渲染目标，如果为null，则为画布
             */
            _this.renderTarget = null;
            _this._near = 0.01;
            _this._far = 1000;
            _this._matProjP = egret3d.Matrix4.create();
            _this._matProjO = egret3d.Matrix4.create();
            _this._frameVecs = [
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create(),
                egret3d.Vector3.create()
            ];
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * 当前场景的主相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.activeScene.findWithTag("MainCamera" /* MainCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("MainCamera" /* MainCamera */, "MainCamera" /* MainCamera */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera, "edit", {
            /**
             * 编辑相机。
             * - 如果没有则创建一个。
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.editorScene.find("EditorCamera" /* EditorCamera */);
                if (!gameObject) {
                    gameObject = paper.GameObject.create("EditorCamera" /* EditorCamera */, "EditorOnly" /* EditorOnly */);
                    gameObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    gameObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                return gameObject.getOrAddComponent(Camera);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 计算相机视锥区域
         */
        Camera.prototype._calcCameraFrame = function () {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var farLD = this._frameVecs[0];
            var nearLD = this._frameVecs[1];
            var farRD = this._frameVecs[2];
            var nearRD = this._frameVecs[3];
            var farLT = this._frameVecs[4];
            var nearLT = this._frameVecs[5];
            var farRT = this._frameVecs[6];
            var nearRT = this._frameVecs[7];
            var near_h = this.near * Math.tan(this.fov * 0.5);
            var asp = vpp.w / vpp.h;
            var near_w = near_h * asp;
            nearLT.set(-near_w, near_h, this.near);
            nearLD.set(-near_w, -near_h, this.near);
            nearRT.set(near_w, near_h, this.near);
            nearRD.set(near_w, -near_h, this.near);
            var far_h = this.far * Math.tan(this.fov * 0.5);
            var far_w = far_h * asp;
            farLT.set(-far_w, far_h, this.far);
            farLD.set(-far_w, -far_h, this.far);
            farRT.set(far_w, far_h, this.far);
            farRD.set(far_w, -far_h, this.far);
            var matrix = this.gameObject.transform.getWorldMatrix();
            matrix.transformVector3(farLD);
            matrix.transformVector3(nearLD);
            matrix.transformVector3(farRD);
            matrix.transformVector3(nearRD);
            matrix.transformVector3(farLT);
            matrix.transformVector3(nearLT);
            matrix.transformVector3(farRT);
            matrix.transformVector3(nearRT);
        };
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.context = new egret3d.RenderContext();
        };
        /**
         *
         */
        Camera.prototype.update = function (_delta) {
            this._calcCameraFrame();
            this.context.updateCamera(this, this.gameObject.transform.getWorldMatrix());
        };
        /**
         * 计算相机的 project matrix（投影矩阵）
         */
        Camera.prototype.calcProjectMatrix = function (asp, matrix) {
            if (this.opvalue > 0) {
                egret3d.Matrix4.perspectiveProjectLH(this.fov, asp, this.near, this.far, this._matProjP);
            }
            if (this.opvalue < 1) {
                egret3d.Matrix4.orthoProjectLH(this.size * asp, this.size, this.near, this.far, this._matProjO);
            }
            if (this.opvalue === 0.0) {
                matrix.copy(this._matProjO);
            }
            else if (this.opvalue === 1.0) {
                matrix.copy(this._matProjP);
            }
            else {
                matrix.lerp(this.opvalue, this._matProjO, this._matProjP);
            }
            return matrix;
        };
        /**
         * 计算相机视口像素rect
         */
        Camera.prototype.calcViewPortPixel = function (viewPortPixel) {
            var w;
            var h;
            var renderTarget = this.renderTarget;
            var viewport = this.viewport;
            if (renderTarget) {
                w = renderTarget.width;
                h = renderTarget.height;
            }
            else {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
            }
            viewPortPixel.x = w * viewport.x;
            viewPortPixel.y = h * viewport.y;
            viewPortPixel.w = w * viewport.w;
            viewPortPixel.h = h * viewport.h;
            //asp = this.viewPortPixel.w / this.viewPortPixel.h;
        };
        /**
         * 由屏幕坐标发射射线
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY) {
            var src1 = egret3d.helpVector3C;
            src1.x = screenPosX;
            src1.y = screenPosY;
            src1.z = 0.0;
            var src2 = egret3d.helpVector3D;
            src2.x = screenPosX;
            src2.y = screenPosY;
            src2.z = 1.0;
            var dest1 = egret3d.helpVector3E;
            var dest2 = egret3d.helpVector3F;
            this.calcWorldPosFromScreenPos(src1, dest1);
            this.calcWorldPosFromScreenPos(src2, dest2);
            var dir = egret3d.helpVector3G;
            egret3d.Vector3.subtract(dest2, dest1, dir);
            egret3d.Vector3.normalize(dir);
            var ray = egret3d.Ray.create(dest1, dir);
            return ray;
        };
        /**
         * 由屏幕坐标得到世界坐标
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var vppos = egret3d.helpVector3A;
            vppos.x = screenPos.x / vpp.w * 2.0 - 1.0;
            vppos.y = 1.0 - screenPos.y / vpp.h * 2.0;
            vppos.z = screenPos.z;
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            matrixView.inverse(this.gameObject.transform.getWorldMatrix());
            this.calcProjectMatrix(asp, matrixProject);
            egret3d.helpMatrixC.multiply(matrixProject, matrixView)
                .inverse()
                .transformVector3(vppos, outWorldPos);
        };
        /**
         * 由世界坐标得到屏幕坐标
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            matrixView.inverse(this.gameObject.transform.getWorldMatrix());
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC.multiply(matrixProject, matrixView);
            var ndcPos = egret3d.helpVector3A;
            matrixViewProject.transformVector3(worldPos, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * vpp.w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * vpp.h * 0.5;
        };
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - vpp.w * 0.5;
            nearpos.y = vpp.h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        Camera.prototype._intersectPlane = function (boundingSphere, v0, v1, v2) {
            var subV0 = egret3d.helpVector3A;
            var subV1 = egret3d.helpVector3B;
            var cross = egret3d.helpVector3C;
            var hitPoint = egret3d.helpVector3D;
            var distVec = egret3d.helpVector3E;
            var center = boundingSphere.center;
            subV0.subtract(v1, v0);
            subV1.subtract(v2, v1);
            cross.cross(subV0, subV1);
            egret3d.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
            distVec.subtract(hitPoint, center);
            var val = distVec.dot(cross);
            if (val <= 0) {
                return true;
            }
            var dist = hitPoint.getDistance(center);
            if (dist < boundingSphere.radius) {
                return true;
            }
            return false;
        };
        Camera.prototype.testFrustumCulling = function (node) {
            var boundingSphere = node.boundingSphere;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[0], this._frameVecs[1], this._frameVecs[5]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[1], this._frameVecs[3], this._frameVecs[7]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[3], this._frameVecs[2], this._frameVecs[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[2], this._frameVecs[0], this._frameVecs[4]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[5], this._frameVecs[7], this._frameVecs[6]))
                return false;
            if (!this._intersectPlane(boundingSphere, this._frameVecs[0], this._frameVecs[2], this._frameVecs[3]))
                return false;
            return true;
        };
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * 相机到近裁剪面距离
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 1.0;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                this._near = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * 相机到远裁剪面距离
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this.near) {
                    value = this.near + 1.0;
                }
                if (value >= 1000.0) {
                    value = 1000.0;
                }
                this._far = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Color", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Depth", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.extraProperty(paper.editor.EditType.LIST, { listItems: paper.editor.getItemsFromEnum(paper.CullingMask) })
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.extraProperty(paper.editor.EditType.NUMBER)
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.extraProperty(paper.editor.EditType.NUMBER)
        ], Camera.prototype, "fov", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.extraProperty(paper.editor.EditType.NUMBER)
        ], Camera.prototype, "size", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "opvalue", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "viewport", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_near", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_far", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.NUMBER)
        ], Camera.prototype, "near", null);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.NUMBER)
        ], Camera.prototype, "far", null);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var CameraPostQueueDepth = (function () {
        function CameraPostQueueDepth() {
            this.renderTarget = null;
        }
        CameraPostQueueDepth.prototype.render = function (camera, renderSystem) {
            // camera.context.drawtype = "_depth";
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(true, true, Color.BLACK);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueDepth;
    }());
    egret3d.CameraPostQueueDepth = CameraPostQueueDepth;
    __reflect(CameraPostQueueDepth.prototype, "egret3d.CameraPostQueueDepth", ["egret3d.ICameraPostQueue"]);
    // /**
    //  * framebuffer绘制通道
    //  * 
    //  */
    // export class CameraPostQueueQuad implements ICameraPostQueue {
    //     /**
    //      * shader & uniform
    //      */
    //     public readonly material: Material = new Material();
    //     /**
    //      * @inheritDoc
    //      */
    //     public renderTarget: GlRenderTarget = null as any;
    //     /**
    //      * @inheritDoc
    //      */
    //     public render(camera: Camera, _renderSystem: CameraSystem) {
    //         const webgl = WebGLKit.webgl;
    //         camera._targetAndViewport(this.renderTarget, true);
    //         WebGLKit.zWrite(true);
    //         // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
    //         webgl.clearColor(0, 0.3, 0, 0);
    //         webgl.clearDepth(1.0);
    //         webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
    //         const mesh = DefaultMeshes.QUAD;
    //         camera.context.drawtype = "";
    //         WebGLKit.draw(camera.context, this.material, mesh, 0, "quad");
    //     }
    // }
    /**
     * 颜色绘制通道
     *
     */
    var CameraPostQueueColor = (function () {
        function CameraPostQueueColor() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueColor.prototype.render = function (camera, renderSystem) {
            // renderSystem._targetAndViewport(camera.viewport, this.renderTarget);
            // renderSystem._cleanBuffer(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
            // renderSystem._renderCamera(camera);
            // GlRenderTarget.useNull();
        };
        return CameraPostQueueColor;
    }());
    egret3d.CameraPostQueueColor = CameraPostQueueColor;
    __reflect(CameraPostQueueColor.prototype, "egret3d.CameraPostQueueColor", ["egret3d.ICameraPostQueue"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 缓存场景通用数据
     * 包括矩阵信息，灯光，光照贴图，viewport尺寸等等
     */
    var RenderContext = (function () {
        function RenderContext() {
            this.DIRECT_LIGHT_SIZE = 12;
            this.POINT_LIGHT_SIZE = 15;
            this.SPOT_LIGHT_SIZE = 18;
            /**
             *
             */
            this.version = 0;
            /**
             *
             */
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            this.shaderContextDefine = "";
            /**
             *
             */
            this.lightmap = null;
            this.lightmapUV = 1;
            this.lightmapIntensity = 1.0;
            this.lightmapOffset = null;
            this.boneData = null;
            // 15: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, shadow, shadowBias, shadowRadius, shadowCameraNear, shadowCameraFar, shadowMapSizeX, shadowMapSizeY
            this.pointLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.pointShadowMatrix = new Float32Array(0); //TODO
            this.matrix_m = new egret3d.Matrix4();
            this.matrix_mvp = new egret3d.Matrix4();
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            this.ambientLightColor = new Float32Array([0, 0, 0]);
            this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            //
            this.cameraPosition = new Float32Array(3);
            this.cameraForward = new Float32Array(3);
            this.cameraUp = new Float32Array(3);
            // transforms
            this.matrix_v = new egret3d.Matrix4();
            this.matrix_p = new egret3d.Matrix4();
            this.matrix_mv = new egret3d.Matrix4();
            this.matrix_vp = new egret3d.Matrix4();
            this.matrix_mv_inverse = new egret3d.Matrix3(); //INVERS
            this.lightPosition = new Float32Array([0.0, 0.0, 0.0, 1.0]);
            this.lightShadowCameraNear = 0;
            this.lightShadowCameraFar = 0;
        }
        RenderContext.prototype.updateLightmap = function (texture, uv, offset, intensity) {
            this.lightmap = texture;
            this.lightmapUV = uv;
            this.lightmapOffset = offset;
            this.lightmapIntensity = intensity;
            this.version++;
        };
        RenderContext.prototype.updateCamera = function (camera, matrix) {
            camera.calcViewPortPixel(this.viewPortPixel); // update viewport
            camera.calcProjectMatrix(this.viewPortPixel.w / this.viewPortPixel.h, this.matrix_p);
            this.matrix_v.inverse(matrix);
            this.matrix_vp.multiply(this.matrix_p, this.matrix_v);
            var rawData = matrix.rawData;
            if (this.cameraPosition[0] !== rawData[12] ||
                this.cameraPosition[1] !== rawData[13] ||
                this.cameraPosition[2] !== rawData[14]) {
                this.cameraPosition[0] = rawData[12];
                this.cameraPosition[1] = rawData[13];
                this.cameraPosition[2] = rawData[14];
                this.version++;
            }
            if (this.cameraUp[0] !== rawData[4] ||
                this.cameraUp[1] !== rawData[5] ||
                this.cameraUp[2] !== rawData[6]) {
                this.cameraUp[0] = rawData[4];
                this.cameraUp[1] = rawData[5];
                this.cameraUp[2] = rawData[6];
                this.version++;
            }
            if (this.cameraForward[0] !== rawData[8] ||
                this.cameraForward[1] !== rawData[9] ||
                this.cameraForward[2] !== rawData[10]) {
                this.cameraForward[0] = -rawData[8];
                this.cameraForward[1] = -rawData[9];
                this.cameraForward[2] = -rawData[10];
                this.version++;
            }
        };
        RenderContext.prototype.updateLights = function (lights, ambientLightColor) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            if (lights.length > 0) {
                this.ambientLightColor[0] = ambientLightColor.r;
                this.ambientLightColor[1] = ambientLightColor.g;
                this.ambientLightColor[2] = ambientLightColor.b;
            }
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectionalLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * this.DIRECT_LIGHT_SIZE) {
                this.directLightArray = new Float32Array(directLightCount * this.DIRECT_LIGHT_SIZE);
            }
            if (this.pointLightArray.length !== pointLightCount * this.POINT_LIGHT_SIZE) {
                this.pointLightArray = new Float32Array(pointLightCount * this.POINT_LIGHT_SIZE);
            }
            if (this.spotLightArray.length !== spotLightCount * this.SPOT_LIGHT_SIZE) {
                this.spotLightArray = new Float32Array(spotLightCount * this.SPOT_LIGHT_SIZE);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.pointShadowMatrix.length !== pointLightCount * 16) {
                this.pointShadowMatrix = new Float32Array(pointLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0;
            var lightArray = this.directLightArray;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                switch (light.constructor) {
                    case egret3d.DirectionalLight: {
                        light.gameObject.transform.getForward(dirHelper);
                        dirHelper.applyDirection(this.matrix_v).normalize();
                        lightArray = this.directLightArray;
                        index = directLightIndex * this.DIRECT_LIGHT_SIZE;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -dirHelper.x; // Left-hand.
                        lightArray[index++] = -dirHelper.y;
                        lightArray[index++] = -dirHelper.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        break;
                    }
                    case egret3d.PointLight: {
                        var position = light.gameObject.transform.getPosition();
                        lightArray = this.pointLightArray;
                        index = pointLightIndex * this.POINT_LIGHT_SIZE;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        lightArray[index++] = light.distance;
                        lightArray[index++] = light.decay;
                        break;
                    }
                    case egret3d.SpotLight: {
                        var position = light.gameObject.transform.getPosition();
                        light.gameObject.transform.getForward(dirHelper);
                        dirHelper.applyDirection(this.matrix_v).normalize();
                        lightArray = this.spotLightArray;
                        index = spotLightIndex * this.SPOT_LIGHT_SIZE;
                        lightArray[index++] = position.x;
                        lightArray[index++] = position.y;
                        lightArray[index++] = position.z;
                        // lightArray[index++] = dirHelper.x; // Right-hand.
                        // lightArray[index++] = dirHelper.y;
                        // lightArray[index++] = dirHelper.z;
                        lightArray[index++] = -dirHelper.x; // Left-hand.
                        lightArray[index++] = -dirHelper.y;
                        lightArray[index++] = -dirHelper.z;
                        lightArray[index++] = light.color.r * light.intensity;
                        lightArray[index++] = light.color.g * light.intensity;
                        lightArray[index++] = light.color.b * light.intensity;
                        lightArray[index++] = light.distance;
                        lightArray[index++] = light.decay;
                        lightArray[index++] = Math.cos(light.angle);
                        lightArray[index++] = Math.cos(light.angle * (1 - light.penumbra));
                        break;
                    }
                }
                if (light.castShadows) {
                    lightArray[index++] = 1;
                    // lightArray[index++] = light.shadowBias; // Right-hand.
                    lightArray[index++] = -light.shadowBias; // Left-hand.
                    lightArray[index++] = light.shadowRadius;
                    lightArray[index++] = light.shadowSize;
                    lightArray[index++] = light.shadowSize;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMatrix.set(light.matrix.rawData, directLightIndex * 16);
                            this.directShadowMaps[directLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = light.shadowCameraNear;
                            lightArray[index++] = light.shadowCameraFar;
                            this.pointShadowMatrix.set(light.matrix.rawData, pointLightIndex * 16);
                            this.pointShadowMaps[pointLightIndex++] = light.renderTarget.texture;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMatrix.set(light.matrix.rawData, spotLightIndex * 16);
                            this.spotShadowMaps[spotLightIndex++] = light.renderTarget.texture;
                            break;
                    }
                }
                else {
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    lightArray[index++] = 0;
                    switch (light.constructor) {
                        case egret3d.DirectionalLight:
                            this.directShadowMaps[directLightIndex++] = null;
                            break;
                        case egret3d.PointLight:
                            lightArray[index++] = 0;
                            lightArray[index++] = 0;
                            this.pointShadowMaps[pointLightIndex++] = null;
                            break;
                        case egret3d.SpotLight:
                            this.spotShadowMaps[spotLightIndex++] = null;
                            break;
                    }
                }
            }
            this.version++;
        };
        RenderContext.prototype.updateModel = function (matrix) {
            this.matrix_m.copy(matrix); // clone matrix because getWorldMatrix returns a reference
            this.matrix_mv.multiply(this.matrix_v, this.matrix_m);
            this.matrix_mvp.multiply(this.matrix_vp, this.matrix_m);
            this.matrix_mv_inverse.getNormalMatrix(this.matrix_mv);
            this.version++;
        };
        RenderContext.prototype.updateBones = function (data) {
            this.boneData = data;
            this.version++;
        };
        RenderContext.prototype.updateLightDepth = function (light) {
            var position = light.gameObject.transform.getPosition();
            if (this.lightPosition[0] !== position.x ||
                this.lightPosition[1] !== position.y ||
                this.lightPosition[2] !== position.z) {
                //
                this.lightPosition[0] = position.x;
                this.lightPosition[1] = position.y;
                this.lightPosition[2] = position.z;
                this.version++;
            }
            if (this.lightShadowCameraNear !== light.shadowCameraNear ||
                this.lightShadowCameraNear !== light.shadowCameraFar) {
                //
                this.lightShadowCameraNear = light.shadowCameraNear;
                this.lightShadowCameraFar = light.shadowCameraFar;
                this.version++;
            }
        };
        RenderContext.prototype.update = function (drawCall) {
            this.shaderContextDefine = "";
            var renderer = drawCall.renderer;
            this.updateModel(drawCall.matrix || renderer.gameObject.transform.getWorldMatrix());
            if (drawCall.boneData) {
                this.updateBones(drawCall.boneData);
            }
            //
            if (renderer.lightmapIndex >= 0) {
                var activeScene = paper.Application.sceneManager.activeScene;
                if (activeScene.lightmaps.length > renderer.lightmapIndex) {
                    this.updateLightmap(activeScene.lightmaps[renderer.lightmapIndex], drawCall.mesh.glTFMesh.primitives[drawCall.subMeshIndex].attributes.TEXCOORD_1 ? 1 : 0, renderer.lightmapScaleOffset, activeScene.lightmapIntensity);
                    this.shaderContextDefine += "#define USE_LIGHTMAP \n";
                }
            }
            if (this.lightCount > 0) {
                // this.shaderContextDefine += "#define USE_LIGHT " + this.lightCount + "\n";
                if (this.directLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_DIR_LIGHTS " + this.directLightCount + "\n";
                }
                if (this.pointLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_POINT_LIGHTS " + this.pointLightCount + "\n";
                }
                if (this.spotLightCount > 0) {
                    this.shaderContextDefine += "#define NUM_SPOT_LIGHTS " + this.spotLightCount + "\n";
                }
                if (renderer.receiveShadows) {
                    this.shaderContextDefine += "#define USE_SHADOWMAP \n";
                    this.shaderContextDefine += "#define SHADOWMAP_TYPE_PCF \n";
                }
            }
        };
        return RenderContext;
    }());
    egret3d.RenderContext = RenderContext;
    __reflect(RenderContext.prototype, "egret3d.RenderContext");
    var dirHelper = new egret3d.Vector3();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否使用视锥剔除
             */
            _this.frustumTest = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._catchedEvent = {};
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this.renderer) {
                this.renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            //
            egret.web.$cacheTextAdapter(paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput, stage, egret3d.WebGLCapabilities.canvas.parentNode, egret3d.WebGLCapabilities.canvas);
            egret3d.InputManager.touch.addEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.addEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.addEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.addEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.addEventListener("mousemove", this._onTouchMove, this);
        };
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            egret3d.InputManager.touch.removeEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.removeEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.removeEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.removeEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.removeEventListener("mousemove", this._onTouchMove, this);
            // this.stage.removeChild(this.root);
        };
        Egret2DRenderer.prototype.recalculateAABB = function () {
            // TODO
        };
        /**
         * 检查屏幕接触事件是否能够穿透此2D层
         */
        Egret2DRenderer.prototype.checkEventThrough = function (x, y) {
            return !!this._catchedEvent[x + "_" + y];
        };
        Egret2DRenderer.prototype._onTouchStart = function (event) {
            // console.log(event);
            if (this.stage.$onTouchBegin(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchMove = function (event) {
            // console.log(event);
            if (this.stage.$onTouchMove(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchEnd = function (event) {
            // console.log(event);
            if (this.stage.$onTouchEnd(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (delta) {
            var stage2d = this.stage;
            var _a = egret3d.stage.screenViewport, w = _a.w, h = _a.h;
            if (this._stageWidth != w || this._stageHeight != h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // clear catched events
            this._catchedEvent = {};
        };
        /**
         *
         */
        Egret2DRenderer.prototype.render = function (context, camera) {
            this.renderer.beforeRender();
            this.stage.drawToSurface();
            // WebGLRenderUtils.resetState(); // 清除3D渲染器中的标脏
        };
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            /**
             * @internal
             */
            _this.webInput = new egret.web.HTMLInput();
            return _this;
        }
        Egret2DRendererSystem.prototype.onAwake = function () {
            this.webInput._initStageDelegateDiv(egret3d.WebGLCapabilities.canvas.parentNode, egret3d.WebGLCapabilities.canvas);
        };
        Egret2DRendererSystem.prototype.onUpdate = function (deltaTime) {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.getComponent(egret3d.Egret2DRenderer).update(deltaTime);
            }
        };
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
                this.currentProgram = null;
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this._activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this._activatedBuffer && this._activatedBuffer.$computeDrawCall) {
                            this._activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this._activatedBuffer) {
                            var target = this._activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this._activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this._activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                if (program != this.currentProgram) {
                    gl.useProgram(program.id);
                    // 目前所有attribute buffer的绑定方法都是一致的
                    var attribute = program.attributes;
                    for (var key in attribute) {
                        if (key === "aVertexPosition") {
                            gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                        }
                        else if (key === "aTextureCoord") {
                            gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                        }
                        else if (key === "aColor") {
                            gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                            gl.enableVertexAttribArray(attribute["aColor"].location);
                        }
                        else if (key === "aParticlePosition") {
                            gl.vertexAttribPointer(attribute["aParticlePosition"].location, 2, gl.FLOAT, false, 22 * 4, 0);
                            gl.enableVertexAttribArray(attribute["aParticlePosition"].location);
                        }
                        else if (key === "aParticleTextureCoord") {
                            gl.vertexAttribPointer(attribute["aParticleTextureCoord"].location, 2, gl.FLOAT, false, 22 * 4, 2 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTextureCoord"].location);
                        }
                        else if (key === "aParticleScale") {
                            gl.vertexAttribPointer(attribute["aParticleScale"].location, 2, gl.FLOAT, false, 22 * 4, 4 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleScale"].location);
                        }
                        else if (key === "aParticleRotation") {
                            gl.vertexAttribPointer(attribute["aParticleRotation"].location, 2, gl.FLOAT, false, 22 * 4, 6 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRotation"].location);
                        }
                        else if (key === "aParticleRed") {
                            gl.vertexAttribPointer(attribute["aParticleRed"].location, 2, gl.FLOAT, false, 22 * 4, 8 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleRed"].location);
                        }
                        else if (key === "aParticleGreen") {
                            gl.vertexAttribPointer(attribute["aParticleGreen"].location, 2, gl.FLOAT, false, 22 * 4, 10 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleGreen"].location);
                        }
                        else if (key === "aParticleBlue") {
                            gl.vertexAttribPointer(attribute["aParticleBlue"].location, 2, gl.FLOAT, false, 22 * 4, 12 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleBlue"].location);
                        }
                        else if (key === "aParticleAlpha") {
                            gl.vertexAttribPointer(attribute["aParticleAlpha"].location, 2, gl.FLOAT, false, 22 * 4, 14 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleAlpha"].location);
                        }
                        else if (key === "aParticleEmitRotation") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRotation"].location, 2, gl.FLOAT, false, 22 * 4, 16 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRotation"].location);
                        }
                        else if (key === "aParticleEmitRadius") {
                            gl.vertexAttribPointer(attribute["aParticleEmitRadius"].location, 2, gl.FLOAT, false, 22 * 4, 18 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleEmitRadius"].location);
                        }
                        else if (key === "aParticleTime") {
                            gl.vertexAttribPointer(attribute["aParticleTime"].location, 2, gl.FLOAT, false, 22 * 4, 20 * 4);
                            gl.enableVertexAttribArray(attribute["aParticleTime"].location);
                        }
                        //===== particle end =====
                    }
                    this.currentProgram = program;
                }
            };
            Renderer.prototype.syncUniforms = function (program, filter, data) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: data.textureWidth, y: data.textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else if (key === "uGlobalMatrix") {
                        uniforms[key].setValue([data.a, data.c, data.tx, data.b, data.d, data.ty, 0, 0, 1]);
                    }
                    else if (key === "uGlobalAlpha") {
                        uniforms[key].setValue(data.alpha);
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                gl.bindTexture(gl.TEXTURE_2D, data.texture);
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this._activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 场景类
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        function Scene(name) {
            var _this = _super.call(this) || this;
            /**
             * lightmap强度
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 场景名称。
             */
            _this.name = "";
            /**
             * 场景的light map列表。
             */
            _this.lightmaps = [];
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            /**
             * @internal
             */
            _this._gameObjects = [];
            /**
             * 环境光
             */
            _this.ambientColor = egret3d.Color.create(0.21, 0.22, 0.25, 1);
            _this.name = name;
            return _this;
        }
        /**
         *
         */
        Scene.createEmpty = function (name, isActive) {
            // const exScene = Application.sceneManager.getSceneByName(name);
            // if (exScene) {
            //     console.warn("The scene with the same name already exists.");
            //     return exScene;
            // }
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (isActive === void 0) { isActive = true; }
            var scene = new Scene(name);
            paper.Application.sceneManager._addScene(scene, isActive);
            return scene;
        };
        /**
         *
         */
        Scene.create = function (name, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var exScene = paper.Application.sceneManager.getSceneByName(name);
            if (exScene) {
                console.warn("The scene with the same name already exists.");
                return exScene;
            }
            var rawScene = paper.Asset.find(name);
            if (rawScene) {
                var scene = rawScene.createInstance();
                if (scene) {
                    if (combineStaticObjects && paper.Application.playerMode !== 2 /* Editor */) {
                        egret3d.combine(scene.gameObjects);
                    }
                    return scene;
                }
            }
            return null;
        };
        /**
         * @internal
         */
        Scene.prototype._addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) >= 0) {
                console.debug("Add game object error.", gameObject.path);
            }
            this._gameObjects.push(gameObject);
        };
        /**
         * @internal
         */
        Scene.prototype._removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index < 0) {
                console.debug("Remove game object error.", gameObject.path);
            }
            this._gameObjects.splice(index, 1);
        };
        /**
         *
         */
        Scene.prototype.destroy = function () {
            if (!paper.Application.sceneManager._removeScene(this)) {
                return;
            }
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            this.lightmaps.length = 0;
            this._gameObjects.length = 0;
        };
        /**
         *
         */
        Scene.prototype.find = function (nameOrPath) {
            var index = nameOrPath.indexOf("/");
            if (index > 0) {
                var firstName = nameOrPath.slice(0, index);
                for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    if (gameObject.name === firstName) {
                        var child = gameObject.transform.find(nameOrPath.slice(index + 1));
                        return child ? child.gameObject : null;
                    }
                }
            }
            else {
                for (var _b = 0, _c = this._gameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (gameObject.name === nameOrPath) {
                        return gameObject;
                    }
                }
            }
            return null;
        };
        /**
         *
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         *
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 所有根实体。
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            /**
             *
             */
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 所有实体。
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "ambientColor", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        return Scene;
    }(paper.BaseObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DirectionalLight = (function (_super) {
        __extends(DirectionalLight, _super);
        function DirectionalLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.renderTarget = new egret3d.GlRenderTarget(1024, 1024, true); // TODO
            return _this;
        }
        DirectionalLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = Math.PI * 0.25;
            camera.opvalue = 0.0;
            // camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return DirectionalLight;
    }(egret3d.BaseLight));
    egret3d.DirectionalLight = DirectionalLight;
    __reflect(DirectionalLight.prototype, "egret3d.DirectionalLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _ups = [
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    /**
     *
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            _this.renderTarget = new egret3d.GlRenderTarget(1024, 1024, true); // TODO
            return _this;
        }
        PointLight.prototype.update = function (camera, faceIndex) {
            var position = this.gameObject.transform.getPosition();
            egret3d.helpVector3A.set(position.x + _targets[faceIndex].x, position.y + _targets[faceIndex].y, position.z + _targets[faceIndex].z);
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = Math.PI * 0.5;
            camera.opvalue = 1.0;
            camera.gameObject.transform.setPosition(position); // TODO support copy matrix.
            camera.gameObject.transform.setRotation(this.gameObject.transform.getRotation());
            camera.gameObject.transform.lookAt(egret3d.helpVector3A, _ups[faceIndex]);
            _super.prototype.update.call(this, camera, faceIndex);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], PointLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], PointLight.prototype, "distance", void 0);
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.decay = 2.0;
            /**
             *
             */
            _this.distance = 0.0;
            /**
             *
             */
            _this.angle = Math.PI / 3.0;
            /**
             *
             */
            _this.penumbra = 0.0;
            return _this;
        }
        SpotLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowCameraSize;
            camera.fov = this.angle;
            camera.opvalue = 1.0;
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], SpotLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], SpotLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], SpotLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], SpotLight.prototype, "penumbra", void 0);
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshFilterEventType;
    (function (MeshFilterEventType) {
        MeshFilterEventType["Mesh"] = "mesh";
    })(MeshFilterEventType = egret3d.MeshFilterEventType || (egret3d.MeshFilterEventType = {}));
    /**
     * MeshFilter 组件
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                // this._mesh.dispose();//TODO shaderdMesh暂时没法dispose
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 组件挂载的 mesh 模型
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose();//TODO shaderdMesh暂时没法dispose
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshFilter.prototype, "_mesh", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MESH)
        ], MeshFilter.prototype, "mesh", null);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 可以挂载Component的实体类。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * @deprecated
         */
        function GameObject(name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态，启用这个属性可以提升性能
             */
            _this.isStatic = false;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 层级
             */
            _this.layer = 2 /* Default */;
            /**
             * 名称
             */
            _this.name = "";
            /**
             * 标签
             */
            _this.tag = "";
            /**
             * 变换组件
             */
            _this.transform = null;
            /**
             *
             */
            _this.renderer = null;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = paper.Application.playerMode === 2 /* Editor */ ? {} : undefined;
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            _this._components = [];
            _this._cachedComponents = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            //
            _this._addToScene(scene || paper.Application.sceneManager.activeScene);
            //
            _this.addComponent(egret3d.Transform);
            return _this;
        }
        /**
         * 创建 GameObject，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName" /* NoName */; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect;
            // if (this._instances.length > 0) {
            //     gameObect = this._instances.pop()!;
            //     gameObect.name = name;
            //     gameObect.tag = tag;
            //     gameObect._addToScene(scene);
            //     gameObect.addComponent(egret3d.Transform);
            // }
            // else {
            gameObect = new GameObject(name, tag, scene);
            // gameObect = new GameObject();
            // }
            // gameObect.name = name;
            // gameObect.tag = tag;
            // gameObect._addToScene(Application.sceneManager.activeScene);
            // gameObect.addComponent(egret3d.Transform);
            return gameObect;
        };
        GameObject.prototype._destroy = function () {
            this._scene._removeGameObject(this);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                if (!component) {
                    continue;
                }
                this._removeComponent(component, null);
            }
            paper.DisposeCollecter.getInstance(paper.DisposeCollecter).gameObjects.push(this);
            this.isStatic = false;
            this.hideFlags = 0 /* None */;
            this.layer = 2 /* Default */;
            this.name = "";
            this.tag = "";
            this.transform = null;
            this.renderer = null;
            if (this.extras) {
                this.extras = {};
            }
            this._activeSelf = true;
            this._activeInHierarchy = true;
            this._activeDirty = true;
            this._components.length = 0;
            this._cachedComponents.length = 0;
            this._scene = null;
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene._removeGameObject(this);
            }
            this._scene = value;
            this._scene._addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    component = component.components[0]; // 只检查第一个。
                }
                var requireComponents = component.constructor.requireComponents;
                if (requireComponents && requireComponents.indexOf(value.constructor) >= 0) {
                    console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + egret.getQualifiedClassName(component) + " component.");
                    return false;
                }
            }
            return true;
        };
        GameObject.prototype._removeComponent = function (value, groupComponent) {
            value.enabled = false;
            value.gameObject = null;
            if (value === this.renderer) {
                this.renderer = null;
            }
            paper.DisposeCollecter.getInstance(paper.DisposeCollecter).components.push(value);
            if (groupComponent) {
                groupComponent._removeComponent(value);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (value.constructor === paper.GroupComponent) {
                groupComponent = value;
                delete this._components[groupComponent.componentIndex];
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
            }
            else {
                delete this._components[value.constructor.__index];
            }
        };
        GameObject.prototype._getComponentsInChildren = function (componentClass, child, components, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            for (var _i = 0, _a = child._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ? groupComponent.components[0] instanceof componentClass : groupComponent.componentClass === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            for (var _d = 0, _e = child.transform.children; _d < _e.length; _d++) {
                var childOfChild = _e[_d];
                this._getComponentsInChildren(componentClass, childOfChild.gameObject, components, isExtends);
            }
        };
        GameObject.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.__index;
            return componentIndex < 0 ? null : this._components[componentIndex];
        };
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.enabled) {
                        paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, component);
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.enabled) {
                                paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, componentInGroup);
                            }
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        /**
         *
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object (" + this.path + ") has been destroyed.");
                return;
            }
            if (this === paper.Application.sceneManager.globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
        };
        /**
         * 添加组件。
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            paper.registerClass(componentClass);
            // SingletonComponent.
            if (componentClass.__isSingleton && this !== paper.Application.sceneManager.globalGameObject) {
                return paper.Application.sceneManager.globalGameObject.getOrAddComponent(componentClass, config);
            }
            var componentIndex = componentClass.__index;
            var existedComponent = this._components[componentIndex];
            // disallowMultipleComponents.
            if (!componentClass.allowMultiple && existedComponent) {
                console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                return existedComponent;
            }
            // requireComponents.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getOrAddComponent(requireComponentClass);
                }
            }
            // Linked reference.
            var component = paper.BaseComponent.create(componentClass, this);
            if (componentClass === egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            // Add component.
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent._addComponent(component);
                }
                else {
                    paper.registerClass(paper.GroupComponent);
                    var groupComponent = paper.BaseComponent.create(paper.GroupComponent, this);
                    groupComponent.initialize();
                    groupComponent.componentIndex = componentIndex;
                    groupComponent.componentClass = componentClass;
                    groupComponent._addComponent(existedComponent);
                    groupComponent._addComponent(component);
                    this._components[componentIndex] = groupComponent;
                }
            }
            else {
                this._components[componentIndex] = component;
            }
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (component.isActiveAndEnabled) {
                paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
            }
            return component;
        };
        /**
         * 移除组件。
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                if (!this._canRemoveComponent(componentInstanceOrClass)) {
                    return;
                }
                this._removeComponent(componentInstanceOrClass, null);
            }
            else if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    var groupComponent = null;
                    if (component.constructor === paper.GroupComponent) {
                        groupComponent = component;
                        component = groupComponent.components[0];
                    }
                    if (groupComponent) {
                        if (!(groupComponent.components[0] instanceof componentInstanceOrClass) ||
                            (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0]))) {
                            continue;
                        }
                    }
                    else if (!(component instanceof componentInstanceOrClass) ||
                        !this._canRemoveComponent(component)) {
                        continue;
                    }
                    this._removeComponent(component, groupComponent);
                }
            }
            else {
                var component = this._getComponent(componentInstanceOrClass);
                if (!component) {
                    return;
                }
                var groupComponent = null;
                if (component.constructor === paper.GroupComponent) {
                    groupComponent = component;
                    component = groupComponent.components[0];
                }
                if (groupComponent) {
                    if (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0])) {
                        return;
                    }
                }
                else if (!this._canRemoveComponent(component)) {
                    return;
                }
                this._removeComponent(component, groupComponent);
            }
        };
        /**
         * 移除所有组件。
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (component.constructor === paper.GroupComponent) {
                            var groupComponent = component;
                            if (!(groupComponent.components[0] instanceof componentClass) ||
                                !this._canRemoveComponent(groupComponent.components[0])) {
                                continue;
                            }
                        }
                        else if (!this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, null);
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (!component) {
                        return;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (!this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, null);
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component || component.constructor === egret3d.Transform) {
                        continue;
                    }
                    this._removeComponent(component, null);
                }
            }
        };
        /**
         * 获取组件。
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component_1 = _a[_i];
                    if (!component_1) {
                        continue;
                    }
                    if (component_1.constructor === paper.GroupComponent) {
                        var groupComponent = component_1;
                        if (groupComponent.components[0] instanceof componentClass) {
                            return groupComponent.components[0];
                        }
                    }
                    else if (component_1 instanceof componentClass) {
                        return component_1;
                    }
                }
                return null;
            }
            var componentClassIndex = componentClass.__index;
            if (componentClassIndex < 0) {
                return null;
            }
            var component = this._components[componentClassIndex];
            if (!component) {
                return null;
            }
            if (component.constructor === paper.GroupComponent) {
                return component.components[0];
            }
            return component;
        };
        /**
         *
         */
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                            var componentInGroup = _e[_d];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        /**
         * 搜索自己和父节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends); // 
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 搜索自己和子节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            this._getComponentsInChildren(componentClass, this, components, isExtends);
            return components;
        };
        /**
         * 获取组件，如果未添加该组件，则添加该组件。
         */
        GameObject.prototype.getOrAddComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass, isExtends);
        };
        /**
         * 针对同级的组件发送消息
         * @param methodName
         * @param parameter``
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.isActiveAndEnabled && component.constructor instanceof paper.Behaviour) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 针对直接父级发送消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 群发消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             *
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                if (this.transform.parent && this.transform.parent.gameObject.dontDestroy !== value) {
                    this.transform.parent = null;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === paper.Application.sceneManager.globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 当前GameObject对象自身激活状态
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 获取当前GameObject对象在场景中激活状态。
             * 如果当前对象父级的activeSelf为false，那么当前GameObject对象在场景中为禁用状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             *
             */
            get: function () {
                this._cachedComponents.length = 0;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            this._cachedComponents.push(componentInGroup);
                        }
                    }
                    else {
                        this._cachedComponents.push(component);
                    }
                }
                return this._cachedComponents;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "parent", {
            /**
             *
             */
            get: function () {
                return this.transform.parent ? this.transform.parent.gameObject : null;
            },
            set: function (gameObject) {
                this.transform.parent = gameObject ? gameObject.transform : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 获取物体所在场景实例。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "globalGameObject", {
            /**
             *
             */
            get: function () {
                return paper.Application.sceneManager.globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        /**
         * @internal
         */
        GameObject._instances = [];
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.LIST, { listItems: paper.editor.getItemsFromEnum(paper.HideFlags) })
        ], GameObject.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.LIST, { listItems: paper.editor.getItemsFromEnum(paper.Layer) })
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.TEXT)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.LIST, { listItems: paper.editor.getItemsFromEnum(paper.DefaultTags) })
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], GameObject.prototype, "activeSelf", null);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.BaseObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [
                        {
                            type: "mesh" /* Mesh */, listener: function (component) {
                                _this._updateDrawCalls(component.gameObject);
                                if (component.gameObject.renderer) {
                                    component.gameObject.renderer.recalculateAABB();
                                }
                            }
                        }
                    ]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
            ];
            _this._drawCalls = egret3d.DrawCalls.getInstance(egret3d.DrawCalls);
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var filter = gameObject.getComponent(egret3d.MeshFilter);
            var renderer = gameObject.renderer;
            var materials = renderer.materials;
            this._drawCalls.removeDrawCalls(renderer);
            if (!filter.mesh || materials.length === 0) {
                return;
            }
            filter.mesh._createBuffer();
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: filter.mesh,
                    material: materials[primitive.material] || egret3d.DefaultMaterials.MISSING,
                    frustumTest: false,
                    zdist: -1,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderType;
    (function (ShaderType) {
        ShaderType[ShaderType["SQT"] = 0] = "SQT";
        ShaderType[ShaderType["Matrix"] = 1] = "Matrix";
    })(ShaderType || (ShaderType = {}));
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var helpVec3_6 = new egret3d.Vector3();
    var helpVec3_7 = new egret3d.Vector3();
    // const helpVec3_8: Vector3 = new Vector3();
    var helpMat4_1 = new egret3d.Matrix4();
    var helpMat4_2 = new egret3d.Matrix4();
    var helpMat4_3 = new egret3d.Matrix4();
    var helpMat4_4 = new egret3d.Matrix4();
    var helpMat4_5 = new egret3d.Matrix4();
    var helpMat4_6 = new egret3d.Matrix4();
    var SkinnedMeshRendererEventType;
    (function (SkinnedMeshRendererEventType) {
        SkinnedMeshRendererEventType["Mesh"] = "mesh";
        SkinnedMeshRendererEventType["Bones"] = "bones";
    })(SkinnedMeshRendererEventType = egret3d.SkinnedMeshRendererEventType || (egret3d.SkinnedMeshRendererEventType = {}));
    /**
     * Skinned Mesh Renderer Component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 蒙皮网格的渲染组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            _this._bones = [];
            _this.center = new egret3d.Vector3();
            _this.size = new egret3d.Vector3();
            /**
             *
             */
            _this._boneDirty = true;
            _this._maxBoneCount = 0;
            /**
             *
             */
            _this._retargetBoneNames = null;
            _this._efficient = true; // 是否高效模式
            _this._joints = null;
            _this._weights = null;
            return _this;
        }
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * mesh instance
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * mesh实例
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose(); TODO
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        SkinnedMeshRenderer.prototype._getMatByIndex = function (index, out) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var blendIndices = egret3d.helpVector4E;
            if (!this._joints) {
                this._joints = mesh.getAttributes("JOINTS_0" /* JOINTS_0 */);
            }
            blendIndices.set(this._joints[index * 4], this._joints[index * 4 + 1], this._joints[index * 4 + 2], this._joints[index * 4 + 3]);
            if (blendIndices.x >= this._maxBoneCount || blendIndices.y >= this._maxBoneCount || blendIndices.z >= this._maxBoneCount || blendIndices.w >= this._maxBoneCount) {
                return null;
            }
            if (!this._weights) {
                this._weights = mesh.getAttributes("WEIGHTS_0" /* WEIGHTS_0 */);
            }
            var blendWeights = egret3d.helpVector4F;
            blendWeights.set(this._weights[index * 4], this._weights[index * 4 + 1], this._weights[index * 4 + 2], this._weights[index * 4 + 3]);
            if (this._efficient) {
                var vec40r = egret3d.helpVector4A;
                var vec30p = egret3d.helpVector3A;
                vec40r.x = this._skeletonMatrixData[8 * blendIndices.x + 0]; // TODO
                vec40r.y = this._skeletonMatrixData[8 * blendIndices.x + 1];
                vec40r.z = this._skeletonMatrixData[8 * blendIndices.x + 2];
                vec40r.w = this._skeletonMatrixData[8 * blendIndices.x + 3];
                vec30p.x = this._skeletonMatrixData[8 * blendIndices.x + 4];
                vec30p.y = this._skeletonMatrixData[8 * blendIndices.x + 5];
                vec30p.z = this._skeletonMatrixData[8 * blendIndices.x + 6];
                var vec41r = egret3d.helpVector4B;
                var vec31p = egret3d.helpVector3B;
                vec41r.x = this._skeletonMatrixData[8 * blendIndices.y + 0];
                vec41r.y = this._skeletonMatrixData[8 * blendIndices.y + 1];
                vec41r.z = this._skeletonMatrixData[8 * blendIndices.y + 2];
                vec41r.w = this._skeletonMatrixData[8 * blendIndices.y + 3];
                vec31p.x = this._skeletonMatrixData[8 * blendIndices.y + 4];
                vec31p.y = this._skeletonMatrixData[8 * blendIndices.y + 5];
                vec31p.z = this._skeletonMatrixData[8 * blendIndices.y + 6];
                var vec42r = egret3d.helpVector4C;
                var vec32p = egret3d.helpVector3C;
                vec42r.x = this._skeletonMatrixData[8 * blendIndices.z + 0];
                vec42r.y = this._skeletonMatrixData[8 * blendIndices.z + 1];
                vec42r.z = this._skeletonMatrixData[8 * blendIndices.z + 2];
                vec42r.w = this._skeletonMatrixData[8 * blendIndices.z + 3];
                vec32p.x = this._skeletonMatrixData[8 * blendIndices.z + 4];
                vec32p.y = this._skeletonMatrixData[8 * blendIndices.z + 5];
                vec32p.z = this._skeletonMatrixData[8 * blendIndices.z + 6];
                var vec43r = egret3d.helpVector4D;
                var vec33p = egret3d.helpVector3D;
                vec43r.x = this._skeletonMatrixData[8 * blendIndices.w + 0];
                vec43r.y = this._skeletonMatrixData[8 * blendIndices.w + 1];
                vec43r.z = this._skeletonMatrixData[8 * blendIndices.w + 2];
                vec43r.w = this._skeletonMatrixData[8 * blendIndices.w + 3];
                vec33p.x = this._skeletonMatrixData[8 * blendIndices.w + 4];
                vec33p.y = this._skeletonMatrixData[8 * blendIndices.w + 5];
                vec33p.z = this._skeletonMatrixData[8 * blendIndices.w + 6];
                var mat0 = egret3d.helpMatrixA;
                var mat1 = egret3d.helpMatrixB;
                var mat2 = egret3d.helpMatrixC;
                var mat3 = egret3d.helpMatrixD;
                mat0.compose(vec30p, vec40r, egret3d.Vector3.ONE);
                mat1.compose(vec31p, vec41r, egret3d.Vector3.ONE);
                mat2.compose(vec32p, vec42r, egret3d.Vector3.ONE);
                mat3.compose(vec33p, vec43r, egret3d.Vector3.ONE);
                mat0.scale(blendWeights.x);
                mat1.scale(blendWeights.y);
                mat2.scale(blendWeights.z);
                mat3.scale(blendWeights.w);
                out.add(mat0, mat1);
                out.add(mat2);
                out.add(mat3);
            }
            else {
                // TODO
                // const mat0 = helpMatrixA;
                // const mat1 = helpMatrixB;
                // const mat2 = helpMatrixC;
                // const mat3 = helpMatrixD;
                // mat0.rawData = this._skeletonMatrixData.slice(16 * blendIndices.x, 16 * blendIndices.x + 16);
                // mat1.rawData = this._skeletonMatrixData.slice(16 * blendIndices.y, 16 * blendIndices.y + 16);
                // mat2.rawData = this._skeletonMatrixData.slice(16 * blendIndices.z, 16 * blendIndices.z + 16);
                // mat3.rawData = this._skeletonMatrixData.slice(16 * blendIndices.w, 16 * blendIndices.w + 16);
                // egret3d.Matrix.scale(blendWeights.x, mat0);
                // egret3d.Matrix.scale(blendWeights.y, mat1);
                // egret3d.Matrix.scale(blendWeights.z, mat2);
                // egret3d.Matrix.scale(blendWeights.w, mat3);
                // egret3d.Matrix.add(mat0, mat1, out);
                // egret3d.Matrix.add(out, mat2, out);
                // egret3d.Matrix.add(out, mat3, out);
            }
            return out;
        };
        SkinnedMeshRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var shaderType = 0 /* SQT */;
            //TODO 不支持 pass结构，这里会有影响?
            // if (this._materials.length > 0) {
            //     const materialPasses = this._materials[0].getShader().passes["skin"];
            //     if (!materialPasses || materialPasses.length === 0) {
            //         shaderType = ShaderType.Matrix;
            //     }
            // }
            // TODO _bonePoses 应该是动态长度
            switch (shaderType) {
                // case ShaderType.Matrix:
                //     this._maxBoneCount = 24;
                //     this._skeletonMatrixData = new Float32Array(16 * this._maxBoneCount);
                //     break;
                case 0 /* SQT */:
                    this._maxBoneCount = 55;
                    this._skeletonMatrixData = new Float32Array(8 * this._maxBoneCount);
                    for (var i = 0; i < this._maxBoneCount; ++i) {
                        var iA = i * 8;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                    }
                    break;
            }
            // TODO 如果layer发生改变，需要重新刷新在renderList中的层级。 可以依赖 event
            // if (this.materials != null && this.materials.length > 0) {
            //     let _mat = this.materials[0];
            //     if (_mat) {
            //         this.layer = _mat.getLayer();
            //         if (!this.issetq) {
            //             this._queue = _mat.getQueue();
            //         }
            //     }
            // }
        };
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                // this._mesh.dispose();
            }
            this._bones.length = 0;
            this._mesh = null;
        };
        SkinnedMeshRenderer.prototype.recalculateAABB = function () {
            this.aabb.clear();
            if (this._mesh) {
                var vertices = this._mesh.getVertices();
                var position = egret3d.helpVector3A;
                for (var i = 0, l = vertices.length; i < l; i += 3) {
                    position.set(vertices[i], vertices[i + 1], vertices[i + 2]);
                    this.aabb.add(position);
                }
            }
        };
        /**
         * ray intersects
         * @param ray ray
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 射线检测
         * @param ray 射线
         * @version paper 1.0
         * @platform Web
         * @language
         */
        SkinnedMeshRenderer.prototype.intersects = function (ray) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var mvpmat = this.gameObject.transform.getWorldMatrix();
            var pickinfo = null;
            // let data = this.mesh.data;
            var subMeshIndex = 0;
            for (var _i = 0, _a = mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var _primitive = _a[_i];
                var mat0 = helpMat4_1;
                var mat1 = helpMat4_2;
                var mat2 = helpMat4_3;
                var mat00 = helpMat4_4;
                var mat11 = helpMat4_5;
                var mat22 = helpMat4_6;
                var indices = mesh.getIndices(subMeshIndex);
                if (indices) {
                    var t0 = helpVec3_1;
                    var t1 = helpVec3_2;
                    var t2 = helpVec3_3;
                    var vertices = mesh.getVertices(subMeshIndex);
                    for (var i = 0; i < indices.length; i += 3) {
                        // TODO
                        var verindex0 = indices[i];
                        var verindex1 = indices[i + 1];
                        var verindex2 = indices[i + 2];
                        var p0 = helpVec3_4;
                        var p1 = helpVec3_5;
                        var p2 = helpVec3_6;
                        var index = indices[i] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p0);
                        index = indices[i + 1] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p1);
                        index = indices[i + 2] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p2);
                        this._getMatByIndex(verindex0, mat0);
                        this._getMatByIndex(verindex1, mat1);
                        this._getMatByIndex(verindex2, mat2);
                        if (mat0 === null || mat1 === null || mat2 === null)
                            continue;
                        mat00.multiply(mvpmat, mat0);
                        mat11.multiply(mvpmat, mat1);
                        mat22.multiply(mvpmat, mat2);
                        mat00.transformVector3(p0, t0);
                        mat11.transformVector3(p1, t1);
                        mat22.transformVector3(p2, t2);
                        var result = ray.intersectTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.triangleIndex = i / 3;
                                pickinfo.subMeshIndex = subMeshIndex;
                                var tdir = helpVec3_7;
                                egret3d.Vector3.copy(ray.direction, tdir);
                                egret3d.Vector3.scale(tdir, result.distance);
                                egret3d.Vector3.add(ray.origin, tdir, pickinfo.position);
                            }
                        }
                    }
                }
                subMeshIndex++;
            }
            return pickinfo;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 骨骼列表
             *
             */
            get: function () {
                return this._bones;
            },
            set: function (value) {
                if (value !== this._bones) {
                    this._bones.length = 0;
                    for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                        var bone = value_2[_i];
                        this._bones.push(bone);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "boneBuffer", {
            /**
             *
             */
            get: function () {
                return this.cacheData || this._skeletonMatrixData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        SkinnedMeshRenderer.dataCaches = [];
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_mesh", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_bones", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "rootBone", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "center", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "size", void 0);
        return SkinnedMeshRenderer;
    }(egret3d.MeshRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 需要完善
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        { type: "mesh" /* Mesh */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                    ]
                }
            ];
            _this._drawCalls = egret3d.DrawCalls.getInstance(egret3d.DrawCalls);
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var renderer = gameObject.renderer;
            this._drawCalls.removeDrawCalls(renderer);
            if (!renderer.mesh || renderer.materials.length === 0) {
                return;
            }
            renderer.mesh._createBuffer();
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var material = renderer.materials[primitive.material];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: renderer.mesh,
                    material: material || egret3d.DefaultMaterials.MISSING,
                    frustumTest: false,
                    zdist: -1,
                    boneData: renderer.boneBuffer,
                };
                material.addDefine("SKINNING");
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            // TODO
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BoneBlendLayer = (function () {
        function BoneBlendLayer() {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0;
            this.layerWeight = 0;
            this.blendWeight = 0;
            this.target = null;
        }
        BoneBlendLayer.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (animationState.additive && this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.leftWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = animationWeight * this.leftWeight;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.layerWeight = animationWeight;
            this.blendWeight = animationWeight;
        };
        return BoneBlendLayer;
    }());
    egret3d.BoneBlendLayer = BoneBlendLayer;
    __reflect(BoneBlendLayer.prototype, "egret3d.BoneBlendLayer");
    /**
     *
     */
    var AnimationChannel = (function () {
        function AnimationChannel() {
            this.update = null;
        }
        return AnimationChannel;
    }());
    __reflect(AnimationChannel.prototype, "AnimationChannel");
    /**
     * 动画混合节点。
     */
    var BlendNode = (function () {
        function BlendNode() {
            /**
             * @private
             */
            this.additive = false;
            /**
             * 动画混合模式。（根节点有效）
             */
            this.layer = 0;
            /**
             * 节点权重。
             */
            this.weight = 1.0;
            /**
             * 淡入淡出的时间。
             */
            this.fadeTime = 1.0;
            /**
             * 父节点。
             */
            this.parent = null;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             */
            this._fadeState = -1;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             */
            this._subFadeState = -1;
            /**
             * 累计权重。
             * @internal
             */
            this._globalWeight = 0.0;
            /**
             * 融合进度。
             * @internal
             */
            this._fadeProgress = 0.0;
            /**
             * 全局融合时间标记。
             */
            this._fadeTimeStart = 0.0;
        }
        BlendNode.prototype._onFadeStateChange = function () {
        };
        BlendNode.prototype.update = function (globalTime) {
            var isFadeOut = this._fadeState > 0;
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._subFadeState < 0) {
                this._subFadeState = 0;
                this._onFadeStateChange();
            }
            if (localFadeTime >= this.fadeTime) {
                this._subFadeState = 1;
                this._fadeProgress = isFadeOut ? 0.0 : 1.0;
            }
            else if (localFadeTime > 0.0) {
                this._fadeProgress = isFadeOut ? (1.0 - localFadeTime / this.fadeTime) : (localFadeTime / this.fadeTime);
            }
            else {
                this._fadeProgress = isFadeOut ? 1.0 : 0.0;
            }
            if (this._subFadeState > 0) {
                if (!isFadeOut) {
                    this._fadeState = 0;
                    this._onFadeStateChange();
                }
            }
            this._globalWeight = this.weight * this._fadeProgress;
            if (this.parent) {
                this._globalWeight *= this.parent._globalWeight;
            }
        };
        BlendNode.prototype.fadeOut = function (fadeTime) {
            var globalTime = paper.Time.time; //
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._fadeState > 0) {
                if (fadeTime > this.fadeTime - localFadeTime) {
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
            }
            this.fadeTime = this._fadeProgress > 0.000001 ? fadeTime / this._fadeProgress : 0.0;
            this._fadeTimeStart = globalTime - this.fadeTime * (1.0 - this._fadeProgress);
        };
        return BlendNode;
    }());
    egret3d.BlendNode = BlendNode;
    __reflect(BlendNode.prototype, "egret3d.BlendNode");
    /**
     * 动画混合树节点。
     */
    var BlendTree = (function (_super) {
        __extends(BlendTree, _super);
        function BlendTree() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._blendNodes = [];
            return _this;
        }
        return BlendTree;
    }(BlendNode));
    egret3d.BlendTree = BlendTree;
    __reflect(BlendTree.prototype, "egret3d.BlendTree");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.layer = 0;
            /**
             * 动画总播放次数。
             */
            _this.playTimes = 0;
            /**
             * 动画当前播放次数。
             */
            _this.currentPlayTimes = 0;
            /**
             * 播放速度。
             */
            _this.timeScale = 1.0;
            /**
             * @private
             */
            _this.animationAsset = null;
            /**
             * 播放的动画数据。
             */
            _this.animation = null;
            /**
             * 播放的动画剪辑。
             */
            _this.animationClip = null;
            /**
             * 是否允许播放。
             */
            _this._isPlaying = true;
            /**
             * 播放状态。
             * -1: start, 0: playing, 1: complete;
             */
            _this._playState = -1;
            /**
             * 帧率。
             */
            _this._frameRate = 0;
            /**
             * 起始帧。
             */
            _this._frameStart = 0;
            /**
             * 总帧数。
             */
            _this._frameCount = 0;
            /**
             * 全局播放时间标记。
             */
            _this._playTimeStart = 0.0;
            /**
             * 本地播放时间。
             */
            _this._playTime = 0.0;
            /**
             * 帧插值进度。
             */
            _this._frameProgress = 0.0;
            _this._animationComponent = null;
            // TODO
            _this._channels = [];
            // TODO
            _this._retargetBoneIndices = [];
            _this._delta = [];
            _this._frameBuffer = null;
            _this._frameOffset = -1;
            _this._nextFrameOffset = -1;
            _this._frameOffsets = null;
            return _this;
        }
        AnimationState.prototype._onArriveAtFrame = function () {
        };
        AnimationState.prototype._onUpdateFrame = function () {
            var delta = this._delta;
            var result = this._animationComponent._skinnedMeshRenderer._skeletonMatrixData;
            var boneBlendLayers = this._animationComponent._boneBlendLayers;
            var frameBuffer = this._frameBuffer;
            for (var i = 0, l = this._retargetBoneIndices.length; i < l; ++i) {
                var boneIndex = this._retargetBoneIndices[i];
                if (boneIndex < 0) {
                    continue;
                }
                var poseBoneOffsetA = i * 7;
                var poseBoneOffsetC = boneIndex * 8;
                var frameOffset = this._frameOffset + poseBoneOffsetA;
                var boneBlendNode = boneBlendLayers[boneIndex];
                if (boneBlendNode.update(this)) {
                    for (var j = 0; j < 7; ++j) {
                        result[poseBoneOffsetC + j] = frameBuffer[frameOffset + j];
                    }
                    result[poseBoneOffsetC + 7] = 1.0;
                }
            }
        };
        AnimationState.prototype._onUpdateTranslation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalPosition(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalPosition(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateRotation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 4;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            var w = outputBuffer[offset + 3];
            if (isInterpolation) {
                var nextIndex = offset + 4;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalRotation(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress, w + (outputBuffer[nextIndex + 3] - w) * progress);
            }
            else {
                transform.setLocalRotation(x, y, z, w);
            }
        };
        AnimationState.prototype._onUpdateScale = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalScale(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalScale(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateActive = function (channel) {
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            transform.gameObject.activeSelf = outputBuffer[offset] !== 0;
        };
        /**
         *
         */
        AnimationState.prototype.initialize = function (animationComponent, animationAsset, animationClip) {
            var globalTime = paper.Time.time; //
            var assetConfig = animationAsset.config;
            //
            this.animationAsset = animationAsset;
            this.animationClip = animationClip;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            //
            var paperAnimation = this.animation.extensions.paper;
            var dataAccessor = this.animationAsset.getAccessor(paperAnimation.data);
            //
            this._frameRate = paperAnimation.frameRate;
            this._frameStart = Math.floor(this.animationClip.position * paperAnimation.frameRate);
            this._frameCount = Math.floor(this.animationClip.duration * paperAnimation.frameRate); // ceil.
            this._fadeTimeStart = globalTime;
            this._playTimeStart = globalTime;
            this._animationComponent = animationComponent;
            //
            var skinnedMeshRenderer = this._animationComponent._skinnedMeshRenderer;
            if (skinnedMeshRenderer) {
                // Retargeting.
                var skeletonRetarget = skinnedMeshRenderer._retargetBoneNames || skinnedMeshRenderer.bones.map(function (bone) { return bone.gameObject.name; });
                var animationRetarget = paperAnimation.retarget ? paperAnimation.retarget.joints : paperAnimation.joints;
                //
                this._delta.length = skeletonRetarget.length * 7;
                this._frameBuffer = this.animationAsset.createTypeArrayFromAccessor(dataAccessor);
                this._frameOffsets = this.animation.extensions.paper.frames;
                for (var _i = 0, animationRetarget_1 = animationRetarget; _i < animationRetarget_1.length; _i++) {
                    var boneName = animationRetarget_1[_i];
                    var index = skeletonRetarget.indexOf(boneName);
                    this._retargetBoneIndices.push(index);
                }
                // if (assetConfig.extensions.paper.skeletons) {
                //     for (const skeleton of assetConfig.extensions.paper.skeletons) {
                //         if (skeleton.name === this.animationAsset.name) {
                //             this._skeleton = skeleton;
                //             if (this._skeleton && !this._skeleton.do) {
                //                 const tPose = this._skeleton.tPose;
                //                 let iA = 0;
                //                 let iB = 0;
                //                 for (let i = 0; i < skeletonRetarget.length; i++) {
                //                     helpQuaternionA.x = tPose[iA++];
                //                     helpQuaternionA.y = tPose[iA++];
                //                     helpQuaternionA.z = tPose[iA++];
                //                     helpQuaternionA.w = tPose[iA++];
                //                     helpVec3A.x = tPose[iA++];
                //                     helpVec3A.y = tPose[iA++];
                //                     helpVec3A.z = tPose[iA++];
                //                     Quaternion.inverse(helpQuaternionA);
                //                     Quaternion.transformVector3(helpQuaternionA, helpVec3A, helpVec3A);
                //                     helpVec3A.x *= -1;
                //                     helpVec3A.y *= -1;
                //                     helpVec3A.z *= -1;
                //                     tPose[iB++] = helpQuaternionA.x;
                //                     tPose[iB++] = helpQuaternionA.y;
                //                     tPose[iB++] = helpQuaternionA.z;
                //                     tPose[iB++] = helpQuaternionA.w;
                //                     tPose[iB++] = helpVec3A.x;
                //                     tPose[iB++] = helpVec3A.y;
                //                     tPose[iB++] = helpVec3A.z;
                //                 }
                //             }
                //         }
                //     }
                // }
            }
            else if (this.animation.channels) {
                var rootGameObject = this._animationComponent.gameObject;
                var transforms = rootGameObject.transform.getAllChildren();
                var gameObjects = {};
                gameObjects[rootGameObject.name] = gameObjects["__root__"] = rootGameObject;
                for (var _a = 0, transforms_1 = transforms; _a < transforms_1.length; _a++) {
                    var gameObject = transforms_1[_a].gameObject;
                    gameObjects[gameObject.name] = gameObject;
                }
                for (var _b = 0, _c = this.animation.channels; _b < _c.length; _b++) {
                    var glTFChannel = _c[_b];
                    var node = this.animationAsset.getNode(glTFChannel.target.node || 0);
                    var gameObject = gameObjects[node.name];
                    if (!gameObject) {
                        continue;
                    }
                    var channel = new AnimationChannel(); // TODO cache.
                    channel.glTFChannel = glTFChannel;
                    channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                    channel.gameObject = gameObject;
                    channel.component = gameObject.transform; // TODO 更多组件
                    channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                    channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                    switch (channel.glTFChannel.target.path) {
                        case "translation":
                            channel.update = this._onUpdateTranslation.bind(this);
                            break;
                        case "rotation":
                            channel.update = this._onUpdateRotation.bind(this);
                            break;
                        case "scale":
                            channel.update = this._onUpdateScale.bind(this);
                            break;
                        case "weights":
                            // TODO
                            break;
                        case "custom":
                            switch (channel.glTFChannel.extensions.paper.type) {
                                case "paper.GameObject":
                                    switch (channel.glTFChannel.extensions.paper.property) {
                                        case "activeSelf":
                                            channel.update = this._onUpdateActive.bind(this);
                                            break;
                                    }
                                    break;
                            }
                            break;
                        default:
                            console.debug("Unknown animation channel.", channel.glTFChannel.target.path);
                            break;
                    }
                    this._channels.push(channel);
                }
            }
        };
        /**
         *
         */
        AnimationState.prototype.update = function (globalTime) {
            _super.prototype.update.call(this, globalTime);
            var prevPlayTimes = this.currentPlayTimes;
            var prevPlayState = this._playState;
            var timeScale = this.timeScale * this._animationComponent.timeScale;
            var timeScaleR = timeScale === 0.0 ? 0.0 : 1.0 / timeScale;
            var position = this.animationClip.position;
            var duration = this.animationClip.duration;
            var totalTime = this.playTimes * duration;
            var localPlayTime = (globalTime - this._playTimeStart) * timeScaleR;
            var currentTime = 0.0;
            if (this.playTimes > 0 && (timeScale >= 0.0 ? localPlayTime >= totalTime : localPlayTime <= 0.0)) {
                if (this._playState <= 0 && this._isPlaying) {
                    this._playState = 1;
                }
                this.currentPlayTimes = this.playTimes;
                if (localPlayTime >= totalTime) {
                    currentTime = duration + 0.000001; // Precision problem.
                }
                else {
                    currentTime = 0.0;
                }
            }
            else {
                if (this._playState !== 0 && this._isPlaying) {
                    this._playState = 0;
                }
                if (localPlayTime < 0.0) {
                    localPlayTime = -localPlayTime;
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = duration - (localPlayTime % duration);
                }
                else {
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = localPlayTime % duration;
                }
            }
            currentTime += position;
            this._playTime = currentTime;
            if (this._channels.length > 0) {
                for (var _i = 0, _a = this._channels; _i < _a.length; _i++) {
                    var channel = _a[_i];
                    if (channel.update) {
                        channel.update(channel);
                    }
                }
            }
            else if (this._animationComponent._skinnedMeshRenderer) {
                // Clear frame flag when timeline start or loopComplete.
                if ((prevPlayState < 0 && this._playState !== prevPlayState) ||
                    (this._playState <= 0 && this.currentPlayTimes !== prevPlayTimes)) {
                    this._frameOffset = -1;
                }
                if (this._frameCount > 1) {
                    var frameIndexF = this._playTime * this._frameRate;
                    var frameIndex = Math.min(Math.floor(frameIndexF), this._frameStart + this._frameCount - 1);
                    var frameOffset = this._frameOffsets[frameIndex];
                    if (this._frameOffset !== frameOffset) {
                        this._frameOffset = frameOffset;
                        this._nextFrameOffset = this._frameOffsets[frameIndex + 1];
                        this._onArriveAtFrame();
                    }
                    this._frameProgress = frameIndexF - frameIndex;
                    this._onUpdateFrame();
                }
                else if (this._frameOffset < 0) {
                    this._frameOffset = this._frameOffsets[0];
                    this._nextFrameOffset = -1;
                    this._onArriveAtFrame();
                }
            }
            if (prevPlayState !== this._playState && this._playState === 1) {
                this._animationComponent._dispatchEvent("complete", this);
                var animationNames = this._animationComponent._animationNames;
                if (animationNames.length > 0) {
                    var animationName = animationNames.shift();
                    this._animationComponent.play(animationName);
                }
            }
        };
        AnimationState.prototype.fateOut = function () {
            this._fadeState = 1;
            this._subFadeState = -1;
        };
        return AnimationState;
    }(BlendNode));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * @internal
             */
            _this._addToSystem = false;
            /**
             * 动画数据列表。
             */
            _this._animations = [];
            /**
             * 骨骼姿势列表。
             * @internal
             */
            _this._boneBlendLayers = [];
            /**
             * 混合节点列表。
             */
            _this._blendNodes = [];
            /**
             * @internal
             */
            _this._animationNames = [];
            _this._fadeInParamter = null;
            /**
             * 最后一个播放的动画状态。
             * 当进行动画混合时，该值通常没有任何意义。
             */
            _this._lastAnimationState = null;
            /**
             * @internal
             */
            _this._skinnedMeshRenderer = null;
            return _this;
        }
        /**
         * @internal
         */
        Animation.prototype._dispatchEvent = function (type, animationState, eventObject) {
            for (var _i = 0, _a = this.gameObject.getComponents(paper.Behaviour, true); _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.onAnimationEvent) {
                    component.onAnimationEvent(type, animationState, eventObject);
                }
            }
        };
        /**
         *
         */
        Animation.prototype.update = function (globalTime) {
            if (this._fadeInParamter) {
                this.fadeIn.apply(this, this._fadeInParamter);
                this._fadeInParamter = null;
            }
            var blendNodes = this._blendNodes;
            var blendNodeCount = blendNodes.length;
            if (blendNodeCount === 1) {
                var blendNode = blendNodes[0];
                if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                    blendNodes.length = 0;
                    if (this._lastAnimationState === blendNode) {
                        this._lastAnimationState = null;
                    }
                }
                else {
                    blendNode.update(globalTime);
                }
                // if (this._lastAnimationState) {
                //     const skeleton = this._lastAnimationState._skeleton;
                //     if (skeleton) {
                //         const result = this._skinnedMeshRenderer._skeletonMatrixData;
                //         const bones = this._skinnedMeshRenderer.bones;
                //         let iA = 0;
                //         let iB = 0;
                //         for (let i = 0, l = this._boneBlendLayers.length; i < l; ++i) {
                //             const boneBlendLayer = this._boneBlendLayers[i];
                //             boneBlendLayer.dirty = false;
                //             if (i < bones.length) {
                //                 const bone = bones[i];
                //                 const dir = helpVec3A;
                //                 const dirtran = helpVec3B;
                //                 helpQuaternionB.x = skeleton.tPose[iA++];
                //                 helpQuaternionB.y = skeleton.tPose[iA++];
                //                 helpQuaternionB.z = skeleton.tPose[iA++];
                //                 helpQuaternionB.w = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.y = skeleton.tPose[iA++];
                //                 helpQuaternionA.x = result[iB];
                //                 helpQuaternionA.y = result[iB];
                //                 helpQuaternionA.z = result[iB];
                //                 helpQuaternionA.w = result[iB];
                //                 Quaternion.transformVector3(helpQuaternionA, dir, dirtran);
                //                 dirtran.x += result[iB];
                //                 dirtran.y += result[iB];
                //                 dirtran.z += result[iB];
                //                 iB++;
                //                 Quaternion.multiply(helpQuaternionA, helpQuaternionB, helpQuaternionC);
                //                 const position = helpVec3A;
                //                 const rotation = helpQuaternionA;
                //                 Vector3.add(bone.getPosition(), dirtran, position);
                //                 Quaternion.multiply(helpQuaternionC, bone.getRotation(), rotation);
                //                 bone.setPosition(position);
                //                 bone.setRotation(rotation);
                //             }
                //         }
                //     }
                // }
            }
            else if (blendNodeCount > 1) {
                for (var i = 0, r = 0; i < blendNodeCount; ++i) {
                    var blendNode = blendNodes[i];
                    if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                        r++;
                        if (this._lastAnimationState === blendNode) {
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            blendNodes[i - r] = blendNode;
                        }
                        blendNode.update(globalTime);
                    }
                    if (i === blendNodeCount - 1 && r > 0) {
                        blendNodes.length -= r;
                        if (this._lastAnimationState === null && blendNodes.length > 0) {
                            var blendNode_1 = blendNodes[blendNodes.length - 1];
                            if (blendNode_1 instanceof AnimationState) {
                                this._lastAnimationState = blendNode_1;
                            }
                        }
                    }
                }
            }
            else {
            }
        };
        Animation.prototype.fadeIn = function (animationName, fadeTime, playTimes, layer, additive) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (additive === void 0) { additive = false; }
            if (!this._addToSystem) {
                // console.warn("The animation component is not add to system yet.");
                this._fadeInParamter = arguments;
                return null;
            }
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                animationAsset = animation;
                if (animationName) {
                    animationClip = animation.getAnimationClip(animationName);
                    if (animationClip !== null) {
                        break;
                    }
                }
                else {
                    animationClip = animation.getAnimationClip("");
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                return null;
            }
            for (var _b = 0, _c = this._blendNodes; _b < _c.length; _b++) {
                var blendNode = _c[_b];
                if ((!blendNode.parent && blendNode.layer === layer)) {
                    blendNode.fadeOut(fadeTime);
                }
            }
            var animationState = new AnimationState();
            animationState.initialize(this, animationAsset, animationClip);
            animationState.additive = additive;
            animationState.fadeTime = fadeTime;
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            // TODO sort by layer and blend tree.
            this._blendNodes.push(animationState);
            this._lastAnimationState = animationState;
            return animationState;
        };
        Animation.prototype.play = function (animationNameOrNames, playTimes) {
            if (animationNameOrNames === void 0) { animationNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationNames.length = 0;
            if (Array.isArray(animationNameOrNames)) {
                if (animationNameOrNames.length > 0) {
                    for (var _i = 0, animationNameOrNames_1 = animationNameOrNames; _i < animationNameOrNames_1.length; _i++) {
                        var animationName = animationNameOrNames_1[_i];
                        this._animationNames.push(animationName);
                    }
                    return this.fadeIn(this._animationNames.shift(), 0.0, playTimes);
                }
                return this.fadeIn(null, 0.0, playTimes);
            }
            return this.fadeIn(animationNameOrNames, 0.0, playTimes);
        };
        Animation.prototype.stop = function () {
            for (var _i = 0, _a = this._blendNodes; _i < _a.length; _i++) {
                var blendNode = _a[_i];
                if (!blendNode.parent) {
                    blendNode.fadeOut(0.0);
                }
            }
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            get: function () {
                return this._animations;
            },
            /**
             * 动画数据列表。
             */
            set: function (animations) {
                for (var i = 0, l = animations.length; i < l; i++) {
                    this._animations[i] = animations[i];
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animations", void 0);
        Animation = __decorate([
            paper.allowMultiple
        ], Animation);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Animation }
            ];
            return _this;
        }
        AnimationSystem.prototype.onAddComponent = function (component) {
            component._addToSystem = true;
            if (component.animations.length > 0) {
                var animaitonClip = component.animations[0].config.animations[0];
                if (!animaitonClip.channels || animaitonClip.channels.length < 0) {
                    component._skinnedMeshRenderer = component.gameObject.getComponentsInChildren(egret3d.SkinnedMeshRenderer)[0];
                    if (component._skinnedMeshRenderer) {
                        for (var _i = 0, _a = component._skinnedMeshRenderer.bones; _i < _a.length; _i++) {
                            var bone = _a[_i];
                            var boneBlendLayer = new egret3d.BoneBlendLayer();
                            component._boneBlendLayers.push(boneBlendLayer);
                        }
                    }
                }
            }
            if (component.autoPlay) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function () {
            var globalTime = this._clock.time;
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                for (var _b = 0, _c = gameObject.getComponents(egret3d.Animation); _b < _c.length; _b++) {
                    var animation = _c[_b];
                    animation.update(globalTime);
                }
            }
        };
        AnimationSystem.prototype.onRemoveComponent = function (component) {
            component._addToSystem = false;
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         * @private
         * 渲染类型为Mesh的属性格式
         */
        var MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * @private
         * 渲染类型为Billboard的属性格式
         */
        var BillboardShaderAttributeFormat = [
            { key: "_CORNER" /* _CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "_START_POSITION" /* _START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_START_VELOCITY" /* _START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "_START_COLOR" /* _START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "_START_SIZE" /* _START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "_START_ROTATION" /* _START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "_TIME" /* _TIME */, type: "VEC2" /* VEC2 */ },
            { key: "_RANDOM0" /* _RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "_RANDOM1" /* _RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "_WORLD_POSITION" /* _WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "_WORLD_ROTATION" /* _WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = {};
            if (renderer._renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType[attribute.key] = attribute.type;
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, meshAttributes, meshAttributesType, 35048 /* Dynamic */);
                var cornerBuffer = batchMesh.getAttributes("_CORNER" /* _CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            if (!shape.enable) {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1.0;
                return;
            }
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
                default:
                    {
                        position.x = position.y = position.z = 0;
                        direction.x = direction.y = 0;
                        direction.z = 1;
                    }
            }
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (!shape.spherizeDirection) {
                if (shape.shapeType == 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 10 /* Circle */) {
                _randomPositionInsideArcCircle(shape.radiusSpread, temp);
            }
            else {
                _randomPositionArcCircle(shape.radiusSpread, temp);
            }
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var colorHelper1 = egret3d.Color.create();
        var colorHelper2 = egret3d.Color.create();
        var CurveMode;
        (function (CurveMode) {
            CurveMode[CurveMode["Constant"] = 0] = "Constant";
            CurveMode[CurveMode["Curve"] = 1] = "Curve";
            CurveMode[CurveMode["TwoCurves"] = 2] = "TwoCurves";
            CurveMode[CurveMode["TwoConstants"] = 3] = "TwoConstants";
        })(CurveMode = particle.CurveMode || (particle.CurveMode = {}));
        var ColorGradientMode;
        (function (ColorGradientMode) {
            ColorGradientMode[ColorGradientMode["Color"] = 0] = "Color";
            ColorGradientMode[ColorGradientMode["Gradient"] = 1] = "Gradient";
            ColorGradientMode[ColorGradientMode["TwoColors"] = 2] = "TwoColors";
            ColorGradientMode[ColorGradientMode["TwoGradients"] = 3] = "TwoGradients";
            ColorGradientMode[ColorGradientMode["RandomColor"] = 4] = "RandomColor";
        })(ColorGradientMode = particle.ColorGradientMode || (particle.ColorGradientMode = {}));
        var SimulationSpace;
        (function (SimulationSpace) {
            SimulationSpace[SimulationSpace["Local"] = 0] = "Local";
            SimulationSpace[SimulationSpace["World"] = 1] = "World";
            SimulationSpace[SimulationSpace["Custom"] = 2] = "Custom";
        })(SimulationSpace = particle.SimulationSpace || (particle.SimulationSpace = {}));
        var ScalingMode;
        (function (ScalingMode) {
            ScalingMode[ScalingMode["Hierarchy"] = 0] = "Hierarchy";
            ScalingMode[ScalingMode["Local"] = 1] = "Local";
            ScalingMode[ScalingMode["Shape"] = 2] = "Shape";
        })(ScalingMode = particle.ScalingMode || (particle.ScalingMode = {}));
        var ShapeType;
        (function (ShapeType) {
            ShapeType[ShapeType["None"] = -1] = "None";
            ShapeType[ShapeType["Sphere"] = 0] = "Sphere";
            ShapeType[ShapeType["SphereShell"] = 1] = "SphereShell";
            ShapeType[ShapeType["Hemisphere"] = 2] = "Hemisphere";
            ShapeType[ShapeType["HemisphereShell"] = 3] = "HemisphereShell";
            ShapeType[ShapeType["Cone"] = 4] = "Cone";
            ShapeType[ShapeType["Box"] = 5] = "Box";
            ShapeType[ShapeType["Mesh"] = 6] = "Mesh";
            ShapeType[ShapeType["ConeShell"] = 7] = "ConeShell";
            ShapeType[ShapeType["ConeVolume"] = 8] = "ConeVolume";
            ShapeType[ShapeType["ConeVolumeShell"] = 9] = "ConeVolumeShell";
            ShapeType[ShapeType["Circle"] = 10] = "Circle";
            ShapeType[ShapeType["CircleEdge"] = 11] = "CircleEdge";
            ShapeType[ShapeType["SingleSidedEdge"] = 12] = "SingleSidedEdge";
            ShapeType[ShapeType["MeshRenderer"] = 13] = "MeshRenderer";
            ShapeType[ShapeType["SkinnedMeshRenderer"] = 14] = "SkinnedMeshRenderer";
            ShapeType[ShapeType["BoxShell"] = 15] = "BoxShell";
            ShapeType[ShapeType["BoxEdge"] = 16] = "BoxEdge";
        })(ShapeType = particle.ShapeType || (particle.ShapeType = {}));
        var ShapeMultiModeValue;
        (function (ShapeMultiModeValue) {
            ShapeMultiModeValue[ShapeMultiModeValue["Random"] = 0] = "Random";
            ShapeMultiModeValue[ShapeMultiModeValue["Loop"] = 1] = "Loop";
            ShapeMultiModeValue[ShapeMultiModeValue["PingPong"] = 2] = "PingPong";
            ShapeMultiModeValue[ShapeMultiModeValue["BurstSpread"] = 3] = "BurstSpread";
        })(ShapeMultiModeValue = particle.ShapeMultiModeValue || (particle.ShapeMultiModeValue = {}));
        var AnimationType;
        (function (AnimationType) {
            AnimationType[AnimationType["WholeSheet"] = 0] = "WholeSheet";
            AnimationType[AnimationType["SingleRow"] = 1] = "SingleRow";
        })(AnimationType = particle.AnimationType || (particle.AnimationType = {}));
        var UVChannelFlags;
        (function (UVChannelFlags) {
            UVChannelFlags[UVChannelFlags["UV0"] = 1] = "UV0";
            UVChannelFlags[UVChannelFlags["UV1"] = 2] = "UV1";
            UVChannelFlags[UVChannelFlags["UV2"] = 4] = "UV2";
            UVChannelFlags[UVChannelFlags["UV3"] = 8] = "UV3";
        })(UVChannelFlags = particle.UVChannelFlags || (particle.UVChannelFlags = {}));
        var GradientMode;
        (function (GradientMode) {
            GradientMode[GradientMode["Blend"] = 0] = "Blend";
            GradientMode[GradientMode["Fixed"] = 1] = "Fixed";
        })(GradientMode = particle.GradientMode || (particle.GradientMode = {}));
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
                return this;
            };
            Keyframe.prototype.clone = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
                return this;
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.numberLerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.clone = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        var GradientColorKey = (function (_super) {
            __extends(GradientColorKey, _super);
            function GradientColorKey() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = egret3d.Color.create();
                return _this;
            }
            GradientColorKey.prototype.deserialize = function (element) {
                this.color.deserialize(element.color);
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "time", void 0);
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "color", void 0);
            return GradientColorKey;
        }(paper.BaseObject));
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey");
        var GradientAlphaKey = (function (_super) {
            __extends(GradientAlphaKey, _super);
            function GradientAlphaKey() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
                return this;
            };
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "alpha", void 0);
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "time", void 0);
            return GradientAlphaKey;
        }(paper.BaseObject));
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey");
        var Gradient = (function (_super) {
            __extends(Gradient, _super);
            function Gradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Blend */;
                _this.alphaKeys = new Array();
                _this.colorKeys = new Array();
                _this._alphaValue = new Float32Array(8);
                _this._colorValue = new Float32Array(16);
                return _this;
            }
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
                return this;
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.numberLerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.numberLerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.numberLerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.numberLerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "alphaKeys", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "colorKeys", void 0);
            return Gradient;
        }(paper.BaseObject));
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient");
        var MinMaxCurve = (function (_super) {
            __extends(MinMaxCurve, _super);
            function MinMaxCurve() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Constant */;
                _this.curve = new AnimationCurve();
                _this.curveMin = new AnimationCurve();
                _this.curveMax = new AnimationCurve();
                return _this;
            }
            MinMaxCurve.prototype.deserialize = function (element) {
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
                return this;
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.clone = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.clone(source.curve);
                this.curveMin.clone(source.curveMin);
                this.curveMax.clone(source.curveMax);
            };
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constant", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curve", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMax", void 0);
            return MinMaxCurve;
        }(paper.BaseObject));
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve");
        var MinMaxGradient = (function (_super) {
            __extends(MinMaxGradient, _super);
            function MinMaxGradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 1 /* Gradient */;
                _this.color = egret3d.Color.create();
                _this.colorMin = egret3d.Color.create();
                _this.colorMax = egret3d.Color.create();
                _this.gradient = new Gradient();
                _this.gradientMin = new Gradient();
                _this.gradientMax = new Gradient();
                return _this;
            }
            MinMaxGradient.prototype.deserialize = function (element) {
                // super.deserialize(element);
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
                return this;
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, colorHelper1);
                    this.gradientMax.evaluate(t, colorHelper2);
                    out.r = (Math.random() * (colorHelper1.r - colorHelper2.r) + colorHelper1.r);
                    out.g = (Math.random() * (colorHelper1.g - colorHelper2.g) + colorHelper1.g);
                    out.b = (Math.random() * (colorHelper1.b - colorHelper2.b) + colorHelper1.b);
                    out.a = (Math.random() * (colorHelper1.a - colorHelper2.a) + colorHelper1.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradient", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMax", void 0);
            return MinMaxGradient;
        }(paper.BaseObject));
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient");
        var Burst = (function () {
            function Burst() {
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
                return this;
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        var ParticleSystemModule = (function (_super) {
            __extends(ParticleSystemModule, _super);
            function ParticleSystemModule(comp) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._comp = comp;
                return _this;
            }
            /**
             * @internal
             */
            ParticleSystemModule.prototype.initialize = function () { };
            ParticleSystemModule.prototype.deserialize = function (element) {
                this.enable = true;
                return this;
            };
            __decorate([
                paper.serializedField
            ], ParticleSystemModule.prototype, "enable", void 0);
            return ParticleSystemModule;
        }(paper.BaseObject));
        particle.ParticleSystemModule = ParticleSystemModule;
        __reflect(ParticleSystemModule.prototype, "egret3d.particle.ParticleSystemModule");
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.duration = 0.0;
                _this.loop = false;
                //
                _this.startDelay = new MinMaxCurve();
                //
                _this.startLifetime = new MinMaxCurve();
                //
                _this.startSpeed = new MinMaxCurve();
                //
                _this.startSizeX = new MinMaxCurve();
                _this.startSizeY = new MinMaxCurve();
                _this.startSizeZ = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startRotation3D = false;
                _this.startRotationX = new MinMaxCurve();
                _this.startRotationY = new MinMaxCurve();
                _this.startRotationZ = new MinMaxCurve();
                //
                _this.startColor = new MinMaxGradient();
                //
                _this.gravityModifier = new MinMaxCurve(); //TODO
                /**
                 * @internal
                 */
                _this._simulationSpace = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._scaleMode = 0 /* Hierarchy */;
                //
                _this.playOnAwake = false;
                /**
                 * @internal
                 */
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
                return this;
            };
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D !== value) {
                        this._startRotation3D = value;
                        paper.EventPool.dispatchEvent("rotation3DChanged" /* StartRotation3DChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace !== value) {
                        this._simulationSpace = value;
                        paper.EventPool.dispatchEvent("simulationSpace" /* SimulationSpaceChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode !== value) {
                        this._scaleMode = value;
                        paper.EventPool.dispatchEvent("scaleMode" /* ScaleModeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles !== value) {
                        this._maxParticles = value;
                        paper.EventPool.dispatchEvent("maxParticles" /* MaxParticlesChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleSystemModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.rateOverTime = new MinMaxCurve();
                _this.bursts = new Array();
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
                return this;
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleSystemModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.shapeType = 0 /* Sphere */;
                _this.radius = 0.0;
                _this.angle = 0.0;
                _this.length = 0.0;
                _this.arcSpeed = new MinMaxCurve();
                _this.arcMode = 0 /* Random */;
                _this.radiusMode = 0 /* Random */;
                _this.box = new egret3d.Vector3();
                _this.randomDirection = false;
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
                return this;
            };
            ShapeModule.prototype.invalidUpdate = function () {
                paper.EventPool.dispatchEvent("shapeChanged" /* ShapeChanged */, this._comp);
            };
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleSystemModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._mode = 0 /* Constant */;
                /**
                 * @internal
                 */
                _this._space = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode !== value) {
                        this._mode = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space !== value) {
                        this._space = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleSystemModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._color = new MinMaxGradient();
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
                return this;
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    if (this._color !== value) {
                        this._color = value;
                        paper.EventPool.dispatchEvent("colorChanged" /* ColorChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleSystemModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._separateAxes = false;
                /**
                 * @internal
                 */
                _this._size = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._size !== value) {
                        this._size.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleSystemModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
                return this;
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleSystemModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._animation = 0 /* WholeSheet */;
                /**
                 * @internal
                 */
                _this._frameOverTime = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
                return this;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX !== value) {
                        this._numTilesX = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY !== value) {
                        this._numTilesY = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation !== value) {
                        this._animation = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow !== value) {
                        this._useRandomRow = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    if (this._frameOverTime !== value) {
                        this._frameOverTime.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    if (this._startFrame !== value) {
                        this._startFrame.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount !== value) {
                        this._cycleCount = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex !== value) {
                        this._rowIndex = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            return TextureSheetAnimationModule;
        }(ParticleSystemModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Matrix3 = (function () {
        function Matrix3(rawData) {
            if (rawData === void 0) { rawData = null; }
            if (rawData) {
                this.rawData = rawData;
            }
            else {
                this.rawData = new Float32Array([
                    1.0, 0.0, 0.0,
                    0.0, 1.0, 0.0,
                    0.0, 0.0, 1.0,
                ]);
            }
        }
        Matrix3.create = function () {
            if (this._instances.length > 0) {
                return this._instances.pop();
            }
            return new Matrix3();
        };
        Matrix3.release = function (value) {
            if (this._instances.indexOf(value) >= 0) {
                return;
            }
            this._instances.push(value);
        };
        Matrix3.prototype.copy = function (value) {
            var fromRawData = value.rawData;
            var toRawData = this.rawData;
            toRawData[0] = fromRawData[0];
            toRawData[1] = fromRawData[1];
            toRawData[2] = fromRawData[2];
            toRawData[3] = fromRawData[3];
            toRawData[4] = fromRawData[4];
            toRawData[5] = fromRawData[5];
            toRawData[6] = fromRawData[6];
            toRawData[7] = fromRawData[7];
            toRawData[8] = fromRawData[8];
            return this;
        };
        Matrix3.prototype.clone = function () {
            var value = new Matrix3();
            value.copy(this);
            return value;
        };
        Matrix3.prototype.set = function (n11, n12, n13, n21, n22, n23, n31, n32, n33) {
            this.rawData[0] = n11;
            this.rawData[3] = n12;
            this.rawData[6] = n13;
            this.rawData[1] = n21;
            this.rawData[4] = n22;
            this.rawData[7] = n23;
            this.rawData[2] = n31;
            this.rawData[5] = n32;
            this.rawData[8] = n33;
            return this;
        };
        Matrix3.prototype.identity = function () {
            this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
            return this;
        };
        Matrix3.prototype.inverse = function (matrix) {
            var me = matrix.rawData, te = this.rawData, n11 = me[0], n21 = me[1], n31 = me[2], n12 = me[3], n22 = me[4], n32 = me[5], n13 = me[6], n23 = me[7], n33 = me[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
            if (det === 0) {
                var msg = "can't invert matrix, determinant is 0";
                console.warn(msg);
                return this.identity();
            }
            var detInv = 1 / det;
            te[0] = t11 * detInv;
            te[1] = (n31 * n23 - n33 * n21) * detInv;
            te[2] = (n32 * n21 - n31 * n22) * detInv;
            te[3] = t12 * detInv;
            te[4] = (n33 * n11 - n31 * n13) * detInv;
            te[5] = (n31 * n12 - n32 * n11) * detInv;
            te[6] = t13 * detInv;
            te[7] = (n21 * n13 - n23 * n11) * detInv;
            te[8] = (n22 * n11 - n21 * n12) * detInv;
            return this;
        };
        Matrix3.prototype.getNormalMatrix = function (matrix4) {
            return this.setFromMatrix4(matrix4).inverse(this).transpose();
        };
        Matrix3.prototype.transpose = function () {
            var tmp, m = this.rawData;
            tmp = m[1];
            m[1] = m[3];
            m[3] = tmp;
            tmp = m[2];
            m[2] = m[6];
            m[6] = tmp;
            tmp = m[5];
            m[5] = m[7];
            m[7] = tmp;
            return this;
        };
        Matrix3.prototype.setFromMatrix4 = function (m) {
            var me = m.rawData;
            this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
            // this.set(
            //     me[0], me[1], me[2],
            //     me[4], me[5], me[6],
            //     me[8], me[9], me[10]
            // );
            return this;
        };
        Matrix3.prototype.determinant = function () {
            var te = this.rawData;
            var a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i = te[8];
            return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
        };
        Matrix3._instances = [];
        return Matrix3;
    }());
    egret3d.Matrix3 = Matrix3;
    __reflect(Matrix3.prototype, "egret3d.Matrix3");
    var helpMat_1 = new Matrix3();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var ParticleCompEventType;
        (function (ParticleCompEventType) {
            ParticleCompEventType["MainChanged"] = "mainChanged";
            ParticleCompEventType["ColorChanged"] = "colorChanged";
            ParticleCompEventType["VelocityChanged"] = "velocityChanged";
            ParticleCompEventType["SizeChanged"] = "sizeChanged";
            ParticleCompEventType["RotationChanged"] = "rotationChanged";
            ParticleCompEventType["TextureSheetChanged"] = "textureSheetChanged";
            ParticleCompEventType["ShapeChanged"] = "shapeChanged";
            ParticleCompEventType["StartRotation3DChanged"] = "rotation3DChanged";
            ParticleCompEventType["SimulationSpaceChanged"] = "simulationSpace";
            ParticleCompEventType["ScaleModeChanged"] = "scaleMode";
            ParticleCompEventType["MaxParticlesChanged"] = "maxParticles";
        })(ParticleCompEventType = particle.ParticleCompEventType || (particle.ParticleCompEventType = {}));
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                //主模块
                _this.main = new particle.MainModule(_this);
                //发射模块
                _this.emission = new particle.EmissionModule(_this);
                //发射形状模块
                _this.shape = new particle.ShapeModule(_this);
                //速率变换模块
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                //旋转变换模块
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                //尺寸变化模块
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                //颜色变化模块
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                //序列帧变化模块
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            /**
             * @internal
             */
            ParticleComponent.prototype._clean = function () {
                //
                this._batcher.clean();
                this._isPlaying = false;
                this._isPaused = false;
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function () {
                this._clean();
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_5 = children; _i < children_5.length; _i++) {
                        var child = children_5[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var ParticleRendererEventType;
        (function (ParticleRendererEventType) {
            ParticleRendererEventType["Mesh"] = "mesh";
            ParticleRendererEventType["Materials"] = "materials";
            ParticleRendererEventType["RenderMode"] = "renderMode";
            ParticleRendererEventType["LengthScaleChanged"] = "lengthScale";
            ParticleRendererEventType["VelocityScaleChanged"] = "velocityScale";
        })(ParticleRendererEventType = particle.ParticleRendererEventType || (particle.ParticleRendererEventType = {}));
        var ParticleRenderMode;
        (function (ParticleRenderMode) {
            ParticleRenderMode[ParticleRenderMode["Billboard"] = 0] = "Billboard";
            ParticleRenderMode[ParticleRenderMode["Stretch"] = 1] = "Stretch";
            ParticleRenderMode[ParticleRenderMode["HorizontalBillboard"] = 2] = "HorizontalBillboard";
            ParticleRenderMode[ParticleRenderMode["VerticalBillboard"] = 3] = "VerticalBillboard";
            ParticleRenderMode[ParticleRenderMode["Mesh"] = 4] = "Mesh";
            ParticleRenderMode[ParticleRenderMode["None"] = 5] = "None";
        })(ParticleRenderMode = particle.ParticleRenderMode || (particle.ParticleRenderMode = {}));
        /**
         * 粒子着色器用到的变量
         */
        var ParticleMaterialUniform;
        (function (ParticleMaterialUniform) {
            ParticleMaterialUniform["WORLD_POSITION"] = "u_worldPosition";
            ParticleMaterialUniform["WORLD_ROTATION"] = "u_worldRotation";
            ParticleMaterialUniform["POSITION_SCALE"] = "u_positionScale";
            ParticleMaterialUniform["SIZE_SCALE"] = "u_sizeScale";
            ParticleMaterialUniform["SCALING_MODE"] = "u_scalingMode";
            ParticleMaterialUniform["GRAVIT"] = "u_gravity";
            ParticleMaterialUniform["START_ROTATION3D"] = "u_startRotation3D";
            ParticleMaterialUniform["SIMULATION_SPACE"] = "u_simulationSpace";
            ParticleMaterialUniform["CURRENTTIME"] = "u_currentTime";
            ParticleMaterialUniform["ALPHAS_GRADIENT"] = "u_alphaGradient[0]";
            ParticleMaterialUniform["COLOR_GRADIENT"] = "u_colorGradient[0]";
            ParticleMaterialUniform["ALPHA_GRADIENT_MAX"] = "u_alphaGradientMax[0]";
            ParticleMaterialUniform["COLOR_GRADIENT_MAX"] = "u_colorGradientMax[0]";
            ParticleMaterialUniform["VELOCITY_CONST"] = "u_velocityConst";
            ParticleMaterialUniform["VELOCITY_CURVE_X"] = "u_velocityCurveX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Y"] = "u_velocityCurveY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_Z"] = "u_velocityCurveZ[0]";
            ParticleMaterialUniform["VELOCITY_CONST_MAX"] = "u_velocityConstMax";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_X"] = "u_velocityCurveMaxX[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Y"] = "u_velocityCurveMaxY[0]";
            ParticleMaterialUniform["VELOCITY_CURVE_MAX_Z"] = "u_velocityCurveMaxZ[0]";
            ParticleMaterialUniform["SPACE_TYPE"] = "u_spaceType";
            ParticleMaterialUniform["SIZE_CURVE"] = "u_sizeCurve[0]";
            ParticleMaterialUniform["SIZE_CURVE_X"] = "u_sizeCurveX[0]";
            ParticleMaterialUniform["SIZE_CURVE_Y"] = "u_sizeCurveY[0]";
            ParticleMaterialUniform["SIZE_CURVE_Z"] = "u_sizeCurveZ[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX"] = "u_sizeCurveMax[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_X"] = "u_sizeCurveMaxX[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Y"] = "u_sizeCurveMaxY[0]";
            ParticleMaterialUniform["SIZE_CURVE_MAX_Z"] = "u_sizeCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CONST"] = "u_rotationConst";
            ParticleMaterialUniform["ROTATION_CONST_SEPRARATE"] = "u_rotationConstSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE"] = "u_rotationCurve[0]";
            ParticleMaterialUniform["ROTATE_CURVE_X"] = "u_rotationCurveX[0]";
            ParticleMaterialUniform["ROTATE_CURVE_y"] = "u_rotationCurveY[0]";
            ParticleMaterialUniform["ROTATE_CURVE_Z"] = "u_rotationCurveZ[0]";
            ParticleMaterialUniform["ROTATE_CURVE_W"] = "u_rotationCurveW[0]";
            ParticleMaterialUniform["ROTATION_CONST_MAX"] = "u_rotationConstMax";
            ParticleMaterialUniform["ROTATION_CONST_MAX_SEPRARATE"] = "u_rotationConstMaxSeprarate";
            ParticleMaterialUniform["ROTATION_CURVE_MAX"] = "u_rotationCurveMax[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_X"] = "u_rotationCurveMaxX[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Y"] = "u_rotationCurveMaxY[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_Z"] = "u_rotationCurveMaxZ[0]";
            ParticleMaterialUniform["ROTATION_CURVE_MAX_W"] = "u_rotationCurveMaxW[0]";
            ParticleMaterialUniform["CYCLES"] = "u_cycles";
            ParticleMaterialUniform["SUB_UV"] = "u_subUV";
            ParticleMaterialUniform["UV_CURVE"] = "u_uvCurve[0]";
            ParticleMaterialUniform["UV_CURVE_MAX"] = "u_uvCurveMax[0]";
            ParticleMaterialUniform["LENGTH_SCALE"] = "u_lengthScale";
            ParticleMaterialUniform["SPEED_SCALE"] = "u_speeaScale";
        })(ParticleMaterialUniform = particle.ParticleMaterialUniform || (particle.ParticleMaterialUniform = {}));
        /**
         * 粒子着色器用到的宏定义
         */
        var ParticleMaterialDefine;
        (function (ParticleMaterialDefine) {
            ParticleMaterialDefine["SPHERHBILLBOARD"] = "SPHERHBILLBOARD";
            ParticleMaterialDefine["STRETCHEDBILLBOARD"] = "STRETCHEDBILLBOARD";
            ParticleMaterialDefine["HORIZONTALBILLBOARD"] = "HORIZONTALBILLBOARD";
            ParticleMaterialDefine["VERTICALBILLBOARD"] = "VERTICALBILLBOARD";
            ParticleMaterialDefine["ROTATIONOVERLIFETIME"] = "ROTATIONOVERLIFETIME";
            ParticleMaterialDefine["ROTATIONCONSTANT"] = "ROTATIONCONSTANT";
            ParticleMaterialDefine["ROTATIONTWOCONSTANTS"] = "ROTATIONTWOCONSTANTS";
            ParticleMaterialDefine["ROTATIONSEPERATE"] = "ROTATIONSEPERATE";
            ParticleMaterialDefine["ROTATIONCURVE"] = "ROTATIONCURVE";
            ParticleMaterialDefine["ROTATIONTWOCURVES"] = "ROTATIONTWOCURVES";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONCURVE"] = "TEXTURESHEETANIMATIONCURVE";
            ParticleMaterialDefine["TEXTURESHEETANIMATIONTWOCURVE"] = "TEXTURESHEETANIMATIONTWOCURVE";
            ParticleMaterialDefine["VELOCITYCONSTANT"] = "VELOCITYCONSTANT";
            ParticleMaterialDefine["VELOCITYCURVE"] = "VELOCITYCURVE";
            ParticleMaterialDefine["VELOCITYTWOCONSTANT"] = "VELOCITYTWOCONSTANT";
            ParticleMaterialDefine["VELOCITYTWOCURVE"] = "VELOCITYTWOCURVE";
            ParticleMaterialDefine["COLOROGRADIENT"] = "COLOROGRADIENT";
            ParticleMaterialDefine["COLORTWOGRADIENTS"] = "COLORTWOGRADIENTS";
            ParticleMaterialDefine["SIZECURVE"] = "SIZECURVE";
            ParticleMaterialDefine["SIZETWOCURVES"] = "SIZETWOCURVES";
            ParticleMaterialDefine["SIZECURVESEPERATE"] = "SIZECURVESEPERATE";
            ParticleMaterialDefine["SIZETWOCURVESSEPERATE"] = "SIZETWOCURVESSEPERATE";
            ParticleMaterialDefine["RENDERMESH"] = "RENDERMESH";
            ParticleMaterialDefine["SHAPE"] = "SHAPE";
        })(ParticleMaterialDefine = particle.ParticleMaterialDefine || (particle.ParticleMaterialDefine = {}));
        /**
         *
         */
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._materials = [];
                _this._renderMode = 0 /* Billboard */;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._mesh = null;
                this._materials.length = 0;
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
            };
            ParticleRenderer.prototype.recalculateAABB = function () {
                this.aabb.clear();
                // TODO
            };
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    this._renderMode = value;
                    paper.EventPool.dispatchEvent("renderMode" /* RenderMode */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 * mesh model
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 组件挂载的 mesh 模型
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh === mesh) {
                        return;
                    }
                    this._mesh = mesh;
                    paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "materials", {
                /**
                 * material list
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 材质数组
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._materials;
                },
                set: function (value) {
                    if (value === this._materials) {
                        return;
                    }
                    this._materials.length = 0;
                    for (var _i = 0, value_3 = value; _i < value_3.length; _i++) {
                        var material = value_3[_i];
                        this._materials.push(material);
                    }
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_mesh", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_materials", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.editor.property(paper.editor.EditType.MESH)
            ], ParticleRenderer.prototype, "mesh", null);
            __decorate([
                paper.editor.property(paper.editor.EditType.ARRAY)
            ], ParticleRenderer.prototype, "materials", null);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: "rotation3DChanged" /* StartRotation3DChanged */, listener: function (comp) { _this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */); } },
                            { type: "simulationSpace" /* SimulationSpaceChanged */, listener: function (comp) { _this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */); } },
                            { type: "scaleMode" /* ScaleModeChanged */, listener: function (comp) { _this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */); } },
                            { type: "velocityChanged" /* VelocityChanged */, listener: _this._onVelocityOverLifetime.bind(_this) },
                            { type: "colorChanged" /* ColorChanged */, listener: _this._onColorOverLifetime.bind(_this) },
                            { type: "sizeChanged" /* SizeChanged */, listener: _this._onSizeOverLifetime.bind(_this) },
                            { type: "rotationChanged" /* RotationChanged */, listener: _this._onRotationOverLifetime.bind(_this) },
                            { type: "textureSheetChanged" /* TextureSheetChanged */, listener: _this._onTextureSheetAnimation.bind(_this) },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: "mesh" /* Mesh */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "materials" /* Materials */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "lengthScale" /* LengthScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "lengthScale" /* LengthScaleChanged */); } },
                            { type: "velocityScale" /* VelocityScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "velocityScale" /* VelocityScaleChanged */); } },
                            { type: "renderMode" /* RenderMode */, listener: function (comp) { _this._onRenderUpdate(comp, "renderMode" /* RenderMode */); } },
                        ]
                    }
                ];
                _this._drawCalls = egret3d.DrawCalls.getInstance(egret3d.DrawCalls);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp) {
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher();
                //
                this._onRenderUpdate(renderer, "renderMode" /* RenderMode */);
                this._onRenderUpdate(renderer, "lengthScale" /* LengthScaleChanged */);
                this._onRenderUpdate(renderer, "velocityScale" /* VelocityScaleChanged */);
                //
                this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */);
                this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */);
                this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                var material = render.batchMaterial;
                switch (type) {
                    case "renderMode" /* RenderMode */: {
                        this._onRenderMode(render);
                        break;
                    }
                    case "lengthScale" /* LengthScaleChanged */: {
                        material.setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case "velocityScale" /* VelocityScaleChanged */: {
                        material.setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                var material = render.batchMaterial;
                material.removeDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                material.removeDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                material.removeDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                material.removeDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                material.removeDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        material.addDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        material.addDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        material.addDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        material.addDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        material.addDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                var mainModule = component.main;
                switch (type) {
                    case "rotation3DChanged" /* StartRotation3DChanged */: {
                        material.setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule._startRotation3D);
                        break;
                    }
                    case "simulationSpace" /* SimulationSpaceChanged */: {
                        material.setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule._simulationSpace);
                        break;
                    }
                    case "scaleMode" /* ScaleModeChanged */: {
                        material.setInt("u_scalingMode" /* SCALING_MODE */, mainModule._scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    material.addDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                material.removeDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                material.removeDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                material.removeDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule._mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule._x.evaluate(), velocityModule._y.evaluate(), velocityModule._z.evaluate());
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curve.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curve.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule._x.constantMin, velocityModule._y.constantMin, velocityModule._z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule._x.constantMax, velocityModule._y.constantMax, velocityModule._z.constantMax);
                            material.setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            material.setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            material.setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curveMin.floatValues);
                            material.setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule._x.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule._y.curveMax.floatValues);
                            material.setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule._z.curveMax.floatValues);
                            break;
                        }
                    }
                    material.setInt("u_spaceType" /* SPACE_TYPE */, velocityModule._space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                material.removeDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule._color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            material.addDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            material.addDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            material.setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            material.setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            material.setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            material.setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("SIZECURVE" /* SIZECURVE */);
                material.removeDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                material.removeDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                material.removeDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule._separateAxes;
                    var mode = sizeModule._x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                material.addDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curve.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curve.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curve.floatValues);
                            }
                            else {
                                material.addDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                material.addDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                material.setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule._x.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule._y.curveMax.floatValues);
                                material.setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule._z.curveMax.floatValues);
                            }
                            else {
                                material.addDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                material.setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curveMin.floatValues);
                                material.setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule._size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                material.removeDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                material.removeDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                material.removeDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                material.removeDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                material.removeDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime._x.mode;
                    var separateAxes = rotationModule._separateAxes;
                    if (separateAxes) {
                        material.addDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        material.addDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            material.addDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constant, rotationModule._y.constant, rotationModule._z.constant));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            material.addDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                material.setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMin, rotationModule._y.constantMin, rotationModule._z.constantMin));
                                material.setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMax, rotationModule._y.constantMax, rotationModule._z.constantMax));
                            }
                            else {
                                material.setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constantMin);
                                material.setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule._z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            material.addDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curve.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curve.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curve.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                material.setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule._x.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule._y.curveMax.floatValues);
                                material.setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule._z.curveMax.floatValues);
                            }
                            else {
                                material.setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curveMin.floatValues);
                                material.setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule._z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                var material = renderer.batchMaterial;
                material.removeDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                material.removeDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module._frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            material.addDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            material.addDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            material.setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curveMin.floatValues);
                            material.setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module._frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        material.setFloat("u_cycles" /* CYCLES */, module._cycleCount);
                        material.setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject) {
                if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                this._onUpdateBatchMesh(component);
                this._drawCalls.removeDrawCalls(renderer);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                if (renderer._renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                renderer.batchMesh._createBuffer();
                this._drawCalls.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                for (var _i = 0, _a = renderer.batchMesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var drawCall = {
                        renderer: renderer,
                        subMeshIndex: subMeshIndex++,
                        mesh: renderer.batchMesh,
                        material: renderer.batchMaterial || egret3d.DefaultMaterials.MISSING,
                        frustumTest: false,
                        zdist: -1,
                    };
                    this._drawCalls.drawCalls.push(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._updateDrawCalls(gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject, _group) {
                this._updateDrawCalls(gameObject);
                var component = gameObject.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                this._drawCalls.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function (deltaTime) {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    gameObject.getComponent(particle.ParticleComponent).update(deltaTime);
                }
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._drawCalls.removeDrawCalls(gameObject.renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Audio = (function (_super) {
        __extends(Audio, _super);
        function Audio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Audio;
    }(paper.BaseComponent));
    egret3d.Audio = Audio;
    __reflect(Audio.prototype, "egret3d.Audio");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL窗口信息
     */
    var Stage3D = (function () {
        function Stage3D() {
            this.screenViewport = { x: 0, y: 0, w: 0, h: 0 };
            this.absolutePosition = { x: 0, y: 0, w: 0, h: 0 };
            this._resizeDirty = true;
        }
        /**
         * @internal
         */
        Stage3D.prototype.init = function (canvas, options) {
            var _this = this;
            this._canvas = canvas;
            window.addEventListener("resize", function () { return _this._resizeDirty = true; }, false);
            this.isLandscape = options.contentWidth > options.contentHeight;
            this.contentWidth = options.contentWidth;
            this.contentHeight = options.contentHeight;
        };
        Stage3D.prototype.update = function () {
            if (this._resizeDirty) {
                this._resize();
                this._resizeDirty = false;
            }
        };
        Stage3D.prototype._resize = function () {
            var displayWidth = window.innerWidth;
            var displayHeight = window.innerHeight;
            var absolutePosition = this.absolutePosition;
            absolutePosition.w = displayWidth;
            absolutePosition.h = displayHeight;
            // 计算视口区域
            var screenViewport = this.screenViewport;
            var shouldRotate = (this.isLandscape && window.innerHeight > window.innerWidth)
                || (!this.isLandscape && window.innerWidth > window.innerHeight);
            if (shouldRotate) {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayHeight * displayWidth);
                screenViewport.h = screenH;
            }
            else {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayWidth * displayHeight);
                screenViewport.h = screenH;
            }
            var canvas = this._canvas;
            canvas.width = screenViewport.w;
            canvas.height = screenViewport.h;
            // 设置canvas.style
            var x = absolutePosition.x, y = absolutePosition.y, w = absolutePosition.w, h = absolutePosition.h;
            canvas.style.top = y + "px";
            canvas.style.position = "absolute";
            canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
            if (shouldRotate) {
                // canvas.style.width = h + "px";
                // canvas.style.height = w + "px";
                canvas.style.left = window.innerWidth + "px";
                var transform = "matrix(0," + h / canvas.width + "," + -w / canvas.height + ",0,0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            else {
                // canvas.style.width = w + "px";
                // canvas.style.height = h + "px";
                // canvas.style[egret.web.getPrefixStyleName("transform")] = null;
                canvas.style.left = x + "px";
                var transform = "matrix(" + w / canvas.width + ",0,0," + h / canvas.height + ",0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            // 更新触摸信息
            var touchScaleX;
            var touchScaleY;
            if (shouldRotate) {
                touchScaleX = egret3d.stage.screenViewport.w / h;
                touchScaleY = egret3d.stage.screenViewport.h / w;
            }
            else {
                touchScaleX = egret3d.stage.screenViewport.w / w;
                touchScaleY = egret3d.stage.screenViewport.h / h;
            }
            egret3d.InputManager.touch.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            egret3d.InputManager.mouse.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            paper.Application.systemManager.getSystem(egret3d.Egret2DRendererSystem).webInput.$updateSize();
        };
        return Stage3D;
    }());
    egret3d.Stage3D = Stage3D;
    __reflect(Stage3D.prototype, "egret3d.Stage3D");
    egret3d.stage = new Stage3D();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    function parseIncludes(string) {
        var pattern = /#include +<([\w\d.]+)>/g;
        //
        function replace(_match, include) {
            var replace = egret3d.ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        //
        return string.replace(pattern, replace);
    }
    function getWebGLShader(type, gl, info, defines) {
        var shader = gl.createShader(type);
        //
        gl.shaderSource(shader, WebGLCapabilities.commonDefines + defines + parseIncludes(info.uri));
        gl.compileShader(shader);
        var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!parameter) {
            if (confirm("shader compile:" + info.name + " " + type + " error! ->" + gl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                gl.deleteShader(shader);
                alert(info.uri);
            }
            return null;
        }
        return shader;
    }
    /**
     * extract attributes
     */
    function extractAttributes(gl, program) {
        var webglProgram = program.program;
        var totalAttributes = gl.getProgramParameter(webglProgram, gl.ACTIVE_ATTRIBUTES);
        //
        var attributes = [];
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(webglProgram, i);
            var location_1 = gl.getAttribLocation(webglProgram, attribData.name);
            attributes.push({ name: attribData.name, type: attribData.type, size: attribData.size, location: location_1 });
        }
        program.attributes = attributes;
    }
    /**
     * extract uniforms
     */
    function extractUniforms(gl, program, technique) {
        var webglProgram = program.program;
        var totalUniforms = gl.getProgramParameter(webglProgram, gl.ACTIVE_UNIFORMS);
        //
        var contextUniforms = [];
        var uniforms = [];
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(webglProgram, i);
            var tUniform = technique.uniforms[uniformData.name];
            if (!tUniform) {
                console.warn("缺少Uniform定义：" + uniformData.name);
            }
            var location_2 = gl.getUniformLocation(webglProgram, uniformData.name);
            if (tUniform.semantic) {
                contextUniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
            else {
                uniforms.push({ name: uniformData.name, type: uniformData.type, size: uniformData.size, location: location_2 });
            }
        }
        program.contextUniforms = contextUniforms;
        program.uniforms = uniforms;
    }
    /**
     * extract texUnits
     */
    function extractTexUnits(program) {
        var activeUniforms = program.contextUniforms.concat(program.uniforms);
        var samplerArrayKeys = [];
        var samplerKeys = [];
        //排序
        for (var _i = 0, activeUniforms_1 = activeUniforms; _i < activeUniforms_1.length; _i++) {
            var uniform = activeUniforms_1[_i];
            var key = uniform.name;
            if (uniform.type == 35678 /* SAMPLER_2D */ || uniform.type == 35680 /* SAMPLER_CUBE */) {
                if (key.indexOf("[") > -1) {
                    samplerArrayKeys.push(key);
                }
                else {
                    samplerKeys.push(key);
                }
            }
        }
        var allKeys = samplerKeys.concat(samplerArrayKeys);
        var unitNumber = 0;
        for (var _a = 0, activeUniforms_2 = activeUniforms; _a < activeUniforms_2.length; _a++) {
            var uniform = activeUniforms_2[_a];
            if (allKeys.indexOf(uniform.name) < 0) {
                continue;
            }
            if (!uniform.textureUnits) {
                uniform.textureUnits = [];
            }
            uniform.textureUnits.length = uniform.size;
            for (var i = 0; i < uniform.size; i++) {
                uniform.textureUnits[i] = unitNumber++;
            }
        }
    }
    /**
     * get max precision
     * @param gl
     * @param precision {string} the expect precision, can be: "highp"|"mediump"|"lowp"
     */
    function getMaxPrecision(gl, precision) {
        if (precision === void 0) { precision = "highp"; }
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
            }
        }
        return 'lowp';
    }
    function getExtension(gl, name) {
        var browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_"
        ];
        for (var ii = 0; ii < browserPrefixes.length; ++ii) {
            var prefixedName = browserPrefixes[ii] + name;
            var ext = gl.getExtension(prefixedName);
            if (ext) {
                return ext;
            }
        }
        return null;
    }
    function getConstDefines(maxPrecision) {
        var defines = "precision " + maxPrecision + " float; \n";
        defines += "precision " + maxPrecision + " int; \n";
        // defines += '#extension GL_OES_standard_derivatives : enable \n';
        return defines;
    }
    var WebGLCapabilities = (function (_super) {
        __extends(WebGLCapabilities, _super);
        function WebGLCapabilities() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.precision = "highp";
            return _this;
        }
        WebGLCapabilities.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.webgl = WebGLCapabilities.webgl;
            var gl = this.webgl;
            this.version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
            this.maxPrecision = getMaxPrecision(gl, this.precision);
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.floatTextures = !!getExtension(gl, 'OES_texture_float');
            this.anisotropyExt = getExtension(gl, 'EXT_texture_filter_anisotropic');
            this.shaderTextureLOD = getExtension(gl, 'EXT_shader_texture_lod');
            this.maxAnisotropy = (this.anisotropyExt !== null) ? gl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            // use dfdx and dfdy must enable OES_standard_derivatives
            getExtension(gl, "OES_standard_derivatives");
            // GL_OES_standard_derivatives
            getExtension(gl, "GL_OES_standard_derivatives");
            //TODO
            WebGLCapabilities.commonDefines = getConstDefines(this.maxPrecision);
        };
        return WebGLCapabilities;
    }(paper.SingletonComponent));
    egret3d.WebGLCapabilities = WebGLCapabilities;
    __reflect(WebGLCapabilities.prototype, "egret3d.WebGLCapabilities");
    /**
     * @internal
     */
    var WebGLRenderState = (function (_super) {
        __extends(WebGLRenderState, _super);
        function WebGLRenderState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.programMap = {};
            _this.vsShaderMap = {};
            _this.fsShaderMap = {};
            _this._stateEnables = [3042 /* BLEND */, 2884 /* CULL_FACE */, 2929 /* DEPTH_TEST */]; // TODO
            _this._cacheStateEnable = {};
            return _this;
        }
        WebGLRenderState.prototype._getWebGLProgram = function (gl, vs, fs, defines) {
            var program = gl.createProgram();
            var key = vs.name + defines;
            var vertexShader = this.vsShaderMap[key];
            if (!vertexShader) {
                vertexShader = getWebGLShader(gl.VERTEX_SHADER, gl, vs, defines);
                this.vsShaderMap[key] = vertexShader;
            }
            key = fs.name + defines;
            var fragmentShader = this.fsShaderMap[key];
            if (!fragmentShader) {
                fragmentShader = getWebGLShader(gl.FRAGMENT_SHADER, gl, fs, defines);
                this.fsShaderMap[key] = fragmentShader;
            }
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            var parameter = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!parameter) {
                alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        };
        WebGLRenderState.prototype.clearState = function () {
            for (var key in this._cacheStateEnable) {
                delete this._cacheStateEnable[key];
            }
            this._cacheProgram = undefined;
            this._cacheState = undefined;
        };
        WebGLRenderState.prototype.updateState = function (state) {
            if (this._cacheState === state) {
                return;
            }
            this._cacheState = state;
            var webgl = WebGLCapabilities.webgl;
            var stateEnables = this._stateEnables;
            var cacheStateEnable = this._cacheStateEnable;
            //TODO WebGLKit.draw(context, drawCall.material, drawCall.mesh, drawCall.subMeshIndex, drawType, transform._worldMatrixDeterminant < 0);
            for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                var e = stateEnables_1[_i];
                var b = state && state.enable && state.enable.indexOf(e) >= 0;
                if (cacheStateEnable[e] !== b) {
                    cacheStateEnable[e] = b;
                    b ? webgl.enable(e) : webgl.disable(e);
                }
            }
            // Functions.
            if (state) {
                var functions = state.functions;
                if (functions) {
                    for (var fun in functions) {
                        webgl[fun].apply(webgl, functions[fun]);
                    }
                }
            }
        };
        WebGLRenderState.prototype.useProgram = function (program) {
            if (this._cacheProgram !== program) {
                this._cacheProgram = program;
                WebGLCapabilities.webgl.useProgram(program.program);
                return true;
            }
            return false;
        };
        WebGLRenderState.prototype.getProgram = function (material, technique, defines) {
            var shader = material._shader;
            var extensions = shader.config.extensions.KHR_techniques_webgl;
            var vertexShader = extensions.shaders[0];
            var fragShader = extensions.shaders[1];
            var name = vertexShader.name + "_" + fragShader.name + "_" + defines; //TODO材质标脏可以优化
            var program = this.programMap[name];
            var webgl = WebGLCapabilities.webgl;
            if (!program) {
                var webglProgram = this._getWebGLProgram(webgl, vertexShader, fragShader, defines);
                program = new egret3d.GlProgram(webglProgram);
                this.programMap[name] = program;
                extractAttributes(webgl, program);
                extractUniforms(webgl, program, technique);
                extractTexUnits(program);
            }
            //
            if (technique.program !== program.id) {
                technique.program = program.id;
            }
            return program;
        };
        /**
         * 设置render target与viewport
         * @param target render target
         *
         */
        WebGLRenderState.prototype.targetAndViewport = function (viewport, target) {
            var webgl = WebGLCapabilities.webgl;
            var w;
            var h;
            if (!target) {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
                webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
            }
            else {
                w = target.width;
                h = target.height;
                target.use();
            }
            webgl.viewport(w * viewport.x, h * viewport.y, w * viewport.w, h * viewport.h);
            webgl.depthRange(0, 1);
        };
        /**
         * 清除缓存
         * @param camera
         */
        WebGLRenderState.prototype.cleanBuffer = function (clearOptColor, clearOptDepath, clearColor) {
            var webgl = WebGLCapabilities.webgl;
            if (clearOptColor && clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptDepath) {
                webgl.depthMask(true);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.DEPTH_BUFFER_BIT);
            }
            else if (clearOptColor) {
                webgl.clearColor(clearColor.r, clearColor.g, clearColor.b, clearColor.a);
                webgl.clear(webgl.COLOR_BUFFER_BIT);
            }
        };
        return WebGLRenderState;
    }(paper.SingletonComponent));
    egret3d.WebGLRenderState = WebGLRenderState;
    __reflect(WebGLRenderState.prototype, "egret3d.WebGLRenderState");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Plane = (function () {
        /**
         * 请使用 `egret3d.Plane.create()` 创建实例。
         * @see egret3d.Plane.create()
         */
        function Plane() {
            /**
             *
             */
            this.constant = 0.0;
            /**
             *
             */
            this.normal = egret3d.Vector3.create();
        }
        /**
         *
         */
        Plane.create = function (normal, constant) {
            if (normal === void 0) { normal = egret3d.Vector3.ZERO; }
            if (constant === void 0) { constant = 0.0; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(normal, constant);
            }
            return new Plane().set(normal, constant);
        };
        Plane.prototype.release = function () {
            if (Plane._instances.indexOf(this) < 0) {
                Plane._instances.push(this);
            }
            return this;
        };
        Plane.prototype.serialize = function () {
            return [this.normal.x, this.normal.y, this.normal.z, this.constant];
        };
        Plane.prototype.deserialize = function (value) {
            this.constant = value[3];
            this.normal.fromArray(value);
            return this;
        };
        Plane.prototype.clone = function () {
            return Plane.create(this.normal, this.constant);
        };
        Plane.prototype.copy = function (value) {
            return this.set(value.normal, value.constant);
        };
        Plane.prototype.set = function (normal, constant) {
            this.constant = constant;
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoint = function (value, normal) {
            if (normal === void 0) { normal = egret3d.Vector3.UP; }
            this.constant = -egret3d.helpVector3A.dot(normal, value);
            this.normal.copy(normal);
            return this;
        };
        Plane.prototype.fromPoints = function (valueA, valueB, valueC) {
            var normal = egret3d.helpVector3A.subtract(valueC, valueB).cross(egret3d.helpVector3B.subtract(valueA, valueB)).normalize();
            this.fromPoint(valueA, normal);
            return this;
        };
        Plane.prototype.normalize = function (source) {
            if (!source) {
                source = this;
            }
            this.constant = source.constant * (1.0 / source.normal.length);
            this.normal.normalize(source.normal);
            return this;
        };
        Plane.prototype.negate = function (source) {
            if (!source) {
                source = this;
            }
            this.constant = source.constant * -1.0;
            this.normal.negate(source.normal);
            return this;
        };
        Plane.prototype.getDistance = function (value) {
            return this.normal.dot(value) + this.constant;
        };
        Plane._instances = [];
        return Plane;
    }());
    egret3d.Plane = Plane;
    __reflect(Plane.prototype, "egret3d.Plane", ["paper.IRelease", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件事件。
     */
    var EventPool;
    (function (EventPool) {
        /**
         * @internal
         */
        var EventType;
        (function (EventType) {
            EventType["Enabled"] = "__enabled__";
            EventType["Disabled"] = "__disabled__";
        })(EventType = EventPool.EventType || (EventPool.EventType = {}));
        var _behaviourComponentType = egret.getQualifiedClassName(paper.Behaviour);
        var _componentListeners = {};
        function _dispatchEvent(type, componentType, component, extend) {
            var componentListeners = _componentListeners[componentType];
            if (type in componentListeners) {
                var eventListeners = componentListeners[type];
                for (var _i = 0, eventListeners_1 = eventListeners; _i < eventListeners_1.length; _i++) {
                    var listener = eventListeners_1[_i];
                    // 监听直接派发，所以监听都应注意 bind 问题。
                    if (extend) {
                        listener(component, extend);
                    }
                    else {
                        listener(component);
                    }
                }
            }
        }
        /**
         * 添加事件监听
         */
        function addEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            var componentListeners = componentType in _componentListeners ? _componentListeners[componentType] : _componentListeners[componentType] = {};
            var eventListeners = eventType in componentListeners ? componentListeners[eventType] : componentListeners[eventType] = [];
            eventListeners.push(callback);
        }
        EventPool.addEventListener = addEventListener;
        /**
         * 移除事件监听
         */
        function removeEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType in componentListeners) {
                    var eventListeners = componentListeners[eventType];
                    for (var i = 0, l = eventListeners.length; i < l; i++) {
                        if (eventListeners[i] === callback) {
                            eventListeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        EventPool.removeEventListener = removeEventListener;
        /**
         * 移除所有该类型的事件监听
         */
        function removeAllEventListener(eventType, componentClass) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType) {
                    if (eventType in componentListeners) {
                        componentListeners[eventType].length = 0;
                    }
                }
                else {
                    delete _componentListeners[componentType];
                }
            }
        }
        EventPool.removeAllEventListener = removeAllEventListener;
        /**
         * 发送组件事件:
         * @param type event type:
         * @param component component
         */
        function dispatchEvent(type, component, extend) {
            // 如果是组件的添加或删除事件，并且该组件派生自 Behaviour 组件，则需要使用基类的组件类型，这些组件发出的添加或删除事件都能被生命周期系统收到。 
            if (type === "__enabled__" /* Enabled */ || type === "__disabled__" /* Disabled */) {
                if (egret.is(component, _behaviourComponentType)) {
                    _dispatchEvent(type, _behaviourComponentType, component);
                }
            }
            var componentType = egret.getQualifiedClassName(component);
            if (componentType in _componentListeners) {
                _dispatchEvent(type, componentType, component, extend);
            }
        }
        EventPool.dispatchEvent = dispatchEvent;
    })(EventPool = paper.EventPool || (paper.EventPool = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var PlayerMode;
    (function (PlayerMode) {
        PlayerMode[PlayerMode["Player"] = 0] = "Player";
        PlayerMode[PlayerMode["DebugPlayer"] = 1] = "DebugPlayer";
        PlayerMode[PlayerMode["Editor"] = 2] = "Editor";
    })(PlayerMode = paper.PlayerMode || (paper.PlayerMode = {}));
    /**
     *
     */
    var ECS = (function () {
        function ECS() {
            /**
             *
             */
            this.version = "0.9.000";
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            this._isFocused = false;
            this._isRunning = false;
            this._playerMode = 0 /* Player */;
            this._bindUpdate = null;
        }
        /**
         *
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        ECS.prototype._update = function () {
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            paper.Time && paper.Time.update();
            paper.Group.update();
            this.systemManager.update();
        };
        ECS.prototype.init = function (_a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.playerMode, playerMode = _c === void 0 ? 0 /* Player */ : _c, _d = _b.systems, systems = _d === void 0 ? [] : _d, _e = _b.option, option = _e === void 0 ? {} : _e, _f = _b.canvas, canvas = _f === void 0 ? {} : _f, _g = _b.webgl, webgl = _g === void 0 ? {} : _g;
            this._playerMode = playerMode;
            this._option = option;
            this._canvas = canvas;
            this._webgl = webgl;
            for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {
                var systemClass = systems_1[_i];
                this.systemManager.register(systemClass, null);
            }
            this.resume();
        };
        /**
         *
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
        };
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        ECS.prototype.callLater = function (callback) {
            (this.systemManager.getSystem(paper.LateUpdateSystem)).callLater(callback);
        };
        Object.defineProperty(ECS.prototype, "isFocused", {
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "playerMode", {
            get: function () {
                return this._playerMode;
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Triangle = (function () {
        /**
         * 请使用 `egret3d.Triangle.create()` 创建实例。
         * @see egret3d.Triangle.create()
         */
        function Triangle() {
            this.a = egret3d.Vector3.create();
            this.b = egret3d.Vector3.create();
            this.c = egret3d.Vector3.create();
        }
        Triangle.create = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            if (this._instances.length > 0) {
                return this._instances.pop().set(a, b, c);
            }
            return new Triangle().set(a, b, c);
        };
        Triangle.prototype.release = function () {
            if (Triangle._instances.indexOf(this) < 0) {
                Triangle._instances.push(this);
            }
            return this;
        };
        Triangle.prototype.serialize = function () {
            return [
                this.a.x, this.a.y, this.a.z,
                this.b.x, this.b.y, this.b.z,
                this.c.x, this.c.y, this.c.z,
            ];
        };
        Triangle.prototype.deserialize = function (element) {
            return this.fromArray(element);
        };
        Triangle.prototype.copy = function (value) {
            return this.set(value.a, value.b, value.c);
        };
        Triangle.prototype.clone = function () {
            return Triangle.create(this.a, this.b, this.c);
        };
        Triangle.prototype.set = function (a, b, c) {
            if (a === void 0) { a = egret3d.Vector3.ZERO; }
            if (b === void 0) { b = egret3d.Vector3.ZERO; }
            if (c === void 0) { c = egret3d.Vector3.ZERO; }
            this.a.copy(a);
            this.b.copy(b);
            this.c.copy(c);
            return this;
        };
        Triangle.prototype.fromArray = function (value, offsetA, offsetB, offsetC) {
            if (offsetA === void 0) { offsetA = 0; }
            if (offsetB === void 0) { offsetB = -1; }
            if (offsetC === void 0) { offsetC = -1; }
            this.a.fromArray(value, offsetA);
            this.b.fromArray(value, offsetB >= 0 ? offsetB : offsetA + 3);
            this.c.fromArray(value, offsetC >= 0 ? offsetC : offsetA + 6);
        };
        Triangle.prototype.getCenter = function (value) {
            return value.add(this.a, this.b).add(this.c).multiplyScalar(1.0 / 3.0);
        };
        Triangle.prototype.getNormal = function (value) {
            return egret3d.getNormal(this.a, this.b, this.c, value);
        };
        Triangle.prototype.getArea = function () {
            egret3d.helpVector3A.subtract(this.c, this.b);
            egret3d.helpVector3B.subtract(this.a, this.b);
            return egret3d.helpVector3A.cross(egret3d.helpVector3B).length * 0.5;
        };
        Triangle._instances = [];
        return Triangle;
    }());
    egret3d.Triangle = Triangle;
    __reflect(Triangle.prototype, "egret3d.Triangle", ["paper.IRelease", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Shader = (function (_super) {
        __extends(Shader, _super);
        /**
         * @internal
         */
        function Shader(config, name) {
            var _this = _super.call(this, name) || this;
            _this.config = config;
            return _this;
        }
        return Shader;
    }(egret3d.GLTFAsset));
    egret3d.Shader = Shader;
    __reflect(Shader.prototype, "egret3d.Shader");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    //兼容老的Uniform键值
    // let _compatible: { [key: string]: string } = { "_MainColor": "diffuse", "_MainTex": "map", "_MainTex_ST": "uvTransform" };
    /**
     * 材质资源
     */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material(shaderOrConfig, name) {
            var _this = _super.call(this, name) || this;
            /**
             *
             */
            _this.renderQueue = paper.RenderQueue.Geometry;
            /**
              * @internal
              */
            _this._id = _hashCode++;
            /**
              * @internal
              */
            _this._version = 0;
            _this._cacheDefines = "";
            _this._defines = [];
            _this._textures = []; //TODO
            /**
             * @internal
             */
            _this._shader = null;
            /**
            * @internal
            */
            _this._glTFTechnique = null;
            if (!shaderOrConfig) {
                _this._reset(egret3d.DefaultShaders.MESH_BASIC);
            }
            else if (typeof shaderOrConfig === "string") {
                var shader = paper.Asset.find(shaderOrConfig);
                if (!shader) {
                    console.error("Cannot find shader.", shaderOrConfig);
                }
                _this._reset(shader || egret3d.DefaultShaders.MESH_BASIC);
            }
            else {
                _this._reset(shaderOrConfig);
            }
            return _this;
        }
        Material.create = function (shaderOrConfig, name) {
            return new Material(shaderOrConfig, name);
        };
        Material.prototype._reset = function (shaderOrConfig) {
            var glTFMaterial;
            if (shaderOrConfig instanceof egret3d.Shader) {
                this.config = egret3d.GLTFAsset.createGLTFExtensionsConfig(); // TODO
                //
                glTFMaterial = this.config.materials[0] = {
                    extensions: {
                        KHR_techniques_webgl: { technique: shaderOrConfig.name, values: {} },
                        paper: { renderQueue: shaderOrConfig._renderQueue || this.renderQueue }
                    }
                };
                //
                this._shader = shaderOrConfig;
            }
            else {
                this.config = shaderOrConfig;
                //
                glTFMaterial = this.config.materials[0];
                //
                var shaderName = glTFMaterial.extensions.KHR_techniques_webgl.technique;
                var shader = paper.Asset.find(shaderName);
                if (!shader) {
                    console.error("Cannot find shader.", shaderName);
                }
                this._shader = shader || egret3d.DefaultShaders.MESH_BASIC;
            }
            this.renderQueue = glTFMaterial.extensions.paper.renderQueue;
            //
            this._glTFTechnique = egret3d.GLTFAsset.createTechnique(this._shader.config.extensions.KHR_techniques_webgl.techniques[0]);
            //
            var uniformValues = glTFMaterial.extensions.KHR_techniques_webgl.values;
            var uniforms = this._glTFTechnique.uniforms;
            //使用Shader替换Material中没有默认值的Uniform
            for (var k in uniformValues) {
                if (k in uniforms) {
                    var value = uniformValues[k];
                    if (Array.isArray(value)) {
                        uniforms[k].value = value.concat();
                    }
                    else {
                        uniforms[k].value = value;
                    }
                }
            }
            if (glTFMaterial.extensions.paper.states) {
                this._glTFTechnique.states = glTFMaterial.extensions.paper.states; // TODO
            }
            else if (this._shader._states) {
                this._glTFTechnique.states = egret3d.GLTFAsset.copyTechniqueStates(this._shader._states);
            }
            if (glTFMaterial.extensions.paper.defines) {
                for (var _i = 0, _a = glTFMaterial.extensions.paper.defines; _i < _a.length; _i++) {
                    var define = _a[_i];
                    this.addDefine(define);
                }
            }
            else if (this._shader._defines) {
                for (var _b = 0, _c = this._shader._defines; _b < _c.length; _b++) {
                    var define = _c[_b];
                    this.addDefine(define);
                }
            }
        };
        Material.prototype.dispose = function (disposeChildren) {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (disposeChildren) {
                for (var _i = 0, _a = this._textures; _i < _a.length; _i++) {
                    var texture = _a[_i];
                    texture.dispose();
                }
            }
            this._version++;
            this._cacheDefines = "";
            this._defines.length = 0;
            this._textures.length = 0;
            this._glTFTechnique = null;
            this._shader = null;
        };
        Material.prototype.copy = function (value) {
            this.renderQueue = value.renderQueue;
            var sourceUniforms = value._glTFTechnique.uniforms;
            var targetUniforms = this._glTFTechnique.uniforms;
            for (var k in sourceUniforms) {
                var uniform = sourceUniforms[k];
                var value_4 = Array.isArray(uniform.value) ? uniform.value.concat() : uniform.value; // TODO TypeArray
                targetUniforms[k] = { type: uniform.type, semantic: uniform.semantic, value: value_4 };
            }
            var sourceStates = value._glTFTechnique.states;
            var targetStates = this._glTFTechnique.states;
            if (sourceStates.enable) {
                targetStates.enable = sourceStates.enable.concat();
            }
            if (sourceStates.functions) {
                if (!targetStates.functions) {
                    targetStates.functions = {};
                }
                for (var k in sourceStates.functions) {
                    if (Array.isArray(sourceStates.functions[k])) {
                        targetStates.functions[k] = sourceStates.functions[k].concat();
                    }
                    else {
                        targetStates.functions[k] = sourceStates.functions[k];
                    }
                }
            }
            return this;
        };
        /**
         * 克隆材质资源。
         */
        Material.prototype.clone = function () {
            return new Material(this._shader).copy(this);
        };
        Material.prototype.addDefine = function (key) {
            if (this._defines.indexOf(key) < 0) {
                this._defines.push(key);
                this._defines.sort();
                this._version++;
            }
            return this;
        };
        Material.prototype.removeDefine = function (key) {
            var delIndex = this._defines.indexOf(key);
            if (delIndex >= 0) {
                this._defines.splice(delIndex, 1);
                this._version++;
            }
            return this;
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4 = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform"]) {
                id = "uvTransform";
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value.x, 0, 0, 0, value.y, 0, value.z, value.w, 1];
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse"]) {
                id = "diffuse";
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value.x, value.y, value.z];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z || uniform.value[3] !== value.w) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    uniform.value[3] = value.w;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setVector4v = function (id, value) {
            //兼容老键值
            if (id === "_MainTex_ST" && this._glTFTechnique.uniforms["uvTransform"]) {
                id = "uvTransform";
                console.warn("已废弃的键值_MainTex_ST，建议改为:uvTransform-Matrix3");
                this._glTFTechnique.uniforms[id].value = [value[0], 0, 0, 0, value[1], 0, value[2], value[3], 1];
                ;
                return;
            }
            else if ((id === "_MainColor" || id === "_Color") && this._glTFTechnique.uniforms["diffuse"]) {
                id = "diffuse";
                console.warn("已废弃的键值_MainColor、_Color，建议改为:diffuse-Vector3");
                this._glTFTechnique.uniforms[id].value = [value[0], value[1], value[2]];
                return;
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this._version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            return this;
        };
        Material.prototype.setTexture = function (id, value) {
            value = value || egret3d.DefaultTextures.WHITE;
            //兼容老键值
            if (id === "_MainTex" && this._glTFTechnique.uniforms["map"]) {
                id = "map";
                console.warn("已废弃的键值_MainTex，建议改为:map");
            }
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value) {
                    var index = this._textures.indexOf(uniform.value);
                    if (index > -1) {
                        this._textures.splice(index, 1);
                    }
                }
                if (uniform.value !== value) {
                    uniform.value = value;
                    this._version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            if (value) {
                this._textures.push(value);
            }
            return this;
        };
        /**
         *
         * @param blend
         */
        Material.prototype.setBlend = function (blend) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            switch (blend) {
                case 3 /* Add */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                    break;
                case 4 /* Add_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                    break;
                case 1 /* Blend */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case 2 /* Blend_PreMultiply */:
                    functions.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    functions.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                    break;
                default:
                    delete functions.blendEquationSeparate;
                    delete functions.blendFuncSeparate;
                    break;
            }
            var index = enables.indexOf(3042 /* BLEND */);
            if (blend === 0 /* None */) {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            else {
                if (index < 0) {
                    enables.push(3042 /* BLEND */);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setCullFace = function (cull, frontFace, cullFace) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2884 /* CULL_FACE */);
            if (cull && frontFace && cullFace) {
                functions.frontFace = [frontFace];
                functions.cullFace = [cullFace];
                if (index < 0) {
                    enables.push(2884 /* CULL_FACE */);
                }
            }
            else {
                delete functions.frontFace;
                delete functions.cullFace;
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.setDepth = function (zTest, zWrite) {
            if (!this._glTFTechnique.states) {
                this._glTFTechnique.states = { enable: [], functions: {} };
            }
            var enables = this._glTFTechnique.states.enable;
            var functions = this._glTFTechnique.states.functions;
            var index = enables.indexOf(2929 /* DEPTH_TEST */);
            if (zTest) {
                if (index < 0) {
                    enables.push(2929 /* DEPTH_TEST */);
                }
                functions.depthFunc = [515 /* LEQUAL */];
            }
            else {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            if (zWrite) {
                functions.depthMask = [true];
            }
            else {
                functions.depthMask = [false];
            }
            return this;
        };
        /**
         *
         */
        Material.prototype.clearStates = function () {
            if (this._glTFTechnique.states) {
                // const enables = this._glTFTechnique.states.enable!;
                // const functions = this._glTFTechnique.states.functions!;
                // enables.length = 0;
                // for (const k in functions) {
                //     delete functions[k];
                // }
                delete this._glTFTechnique.states;
            }
            return this;
        };
        Object.defineProperty(Material.prototype, "shaderDefine", {
            /**
             * TODO
             * @internal
             */
            get: function () {
                this._cacheDefines = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    this._cacheDefines += "#define " + key + " \n";
                }
                return this._cacheDefines;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shader", {
            get: function () {
                return this._shader;
            },
            set: function (value) {
                if (!value) {
                    console.warn("Set shader error.");
                    value = egret3d.DefaultShaders.MESH_BASIC;
                }
                if (this._shader === value) {
                    return;
                }
                this._reset(value);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "glTFTechnique", {
            get: function () {
                return this._glTFTechnique;
            },
            enumerable: true,
            configurable: true
        });
        return Material;
    }(egret3d.GLTFAsset));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Primitive;
    (function (Primitive) {
        /**
         *
         */
        var Type;
        (function (Type) {
            Type[Type["Axises"] = 0] = "Axises";
            Type[Type["Quad"] = 1] = "Quad";
            Type[Type["QuadParticle"] = 2] = "QuadParticle";
            Type[Type["Plane"] = 3] = "Plane";
            Type[Type["Cube"] = 4] = "Cube";
            Type[Type["Pyramid"] = 5] = "Pyramid";
            Type[Type["Cylinder"] = 6] = "Cylinder";
            Type[Type["Sphere"] = 7] = "Sphere";
        })(Type = Primitive.Type || (Primitive.Type = {}));
        /**
         *
         */
        function create(type, name, tag, scene) {
            var gameObject = paper.GameObject.create(name, tag, scene);
            var meshFilter = gameObject.addComponent(egret3d.MeshFilter);
            var renderer = gameObject.addComponent(egret3d.MeshRenderer);
            switch (type) {
                case 0 /* Axises */: {
                    meshFilter.mesh = egret3d.DefaultMeshes.AXISES;
                    renderer.material = egret3d.DefaultMaterials.LINEDASHED_COLOR;
                    break;
                }
                case 1 /* Quad */:
                    meshFilter.mesh = egret3d.DefaultMeshes.QUAD;
                    break;
                case 2 /* QuadParticle */:
                    meshFilter.mesh = egret3d.DefaultMeshes.QUAD_PARTICLE;
                    break;
                case 3 /* Plane */:
                    meshFilter.mesh = egret3d.DefaultMeshes.PLANE;
                    break;
                case 4 /* Cube */:
                    meshFilter.mesh = egret3d.DefaultMeshes.CUBE;
                    break;
                case 5 /* Pyramid */:
                    meshFilter.mesh = egret3d.DefaultMeshes.PYRAMID;
                    break;
                case 6 /* Cylinder */:
                    meshFilter.mesh = egret3d.DefaultMeshes.CYLINDER;
                    break;
                case 7 /* Sphere */:
                    meshFilter.mesh = egret3d.DefaultMeshes.SPHERE;
                    break;
                default:
                    throw new Error(); // Never.
            }
            return gameObject;
        }
        Primitive.create = create;
    })(Primitive = egret3d.Primitive || (egret3d.Primitive = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.cube = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "cube_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n" }, { "name": "cube_frag", "type": 35632, "uri": "uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n" }], "techniques": [{ "name": "cube", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tCube": { "type": 35680 }, "tFlip": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.depth = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "depth_vert", "type": 35633, "uri": "#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n" }, { "name": "depth_frag", "type": 35632, "uri": "#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n" }], "techniques": [{ "name": "depth", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.diffuse = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "diffuse_vert", "type": 35633, "uri": "#include <common>\r\n#include <skinning_pars_vert>\r\n#include <lightmap_pars_vert> \r\nattribute vec4 position;\r\nattribute vec4 uv;\r\nuniform highp mat4 modelViewProjectionMatrix;\r\nuniform highp mat3 uvTransform;  \r\nvarying highp vec2 xlv_TEXCOORD0;\r\n\r\nvoid main() {\r\n    #include <skinning_base_vert>\r\n    xlv_TEXCOORD0 = ( uvTransform * vec3( uv.xy, 1 ) ).xy;\r\n    #include <lightmap_vert>\r\n    gl_Position = (modelViewProjectionMatrix * tmpVertex);\r\n}" }, { "name": "diffuse_frag", "type": 35632, "uri": "#include <common>\r\n#include <lightmap_pars_frag>\r\nuniform vec3 diffuse;\r\nuniform sampler2D map;\r\nuniform lowp float _AlphaCut;\r\nvarying highp vec2 xlv_TEXCOORD0;\r\nvoid main() {\r\n    lowp vec4 outColor = texture2D(map, xlv_TEXCOORD0) * vec4(diffuse, 1.0);\r\n    if(outColor.a < _AlphaCut)\r\n        discard;\r\n    #include <lightmap_frag>    \r\n}" }], "techniques": [{ "name": "diffuse", "attributes": { "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" }, "position": { "semantic": "POSITION" }, "uv": { "semantic": "TEXCOORD_0" } }, "uniforms": { "glstate_vec4_bones[0]": { "type": 35666, "semantic": "_BONESVEC4" }, "lightMapOffset": { "type": 35666, "semantic": "_LIGHTMAPOFFSET" }, "lightMapUV": { "type": 5126, "semantic": "_LIGHTMAPUV" }, "modelViewProjectionMatrix": { "type": 35676, "semantic": "MODELVIEWPROJECTION" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "map": { "type": 35678 }, "_AlphaCut": { "type": 5126, "value": [] } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.distanceRGBA = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "distanceRGBA_vert", "type": 35633, "uri": "#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n" }, { "name": "distanceRGBA_frag", "type": 35632, "uri": "#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n" }], "techniques": [{ "name": "distanceRGBA", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "referencePosition": { "type": 35665, "semantic": "_REFERENCEPOSITION" }, "nearDistance": { "type": 5126, "semantic": "_NEARDICTANCE" }, "farDistance": { "type": 5126, "semantic": "_FARDISTANCE" }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.equirect = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "equirect_vert", "type": 35633, "uri": "varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n" }, { "name": "equirect_frag", "type": 35632, "uri": "uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n" }], "techniques": [{ "name": "equirect", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "tEquirect": { "type": 35678 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.linedashed = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "linedashed_vert", "type": 35633, "uri": "uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "linedashed_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "linedashed", "attributes": { "lineDistance": { "semantic": "Unknown" }, "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "scale": { "type": 5126 }, "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "dashSize": { "type": 5126 }, "totalSize": { "type": 5126 }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.meshbasic = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshbasic_vert", "type": 35633, "uri": "#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshbasic_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\t\t   lowp vec4 lightmapTex = texture2D(lightMap, vUv2);\r\n\t\t   highp float power =pow( 2.0 ,lightmapTex.a * 255.0 - 128.0);\r\n\t\t   reflectedLight.indirectDiffuse +=lightmapTex.rgb * power * lightMapIntensity * 1.2;//EGRET\r\n\t\t// reflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshbasic", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.meshlambert = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshlambert_vert", "type": 35633, "uri": "#define LAMBERT\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshlambert_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshlambert", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "refractionRatio": { "type": 5126, "value": [] }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.meshphong = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphong_vert", "type": 35633, "uri": "#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphong_frag", "type": 35632, "uri": "#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphong", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "refractionRatio": { "type": 5126, "value": [] }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "specular": { "type": 35665, "value": [1, 1, 1] }, "shininess": { "type": 5126, "value": 1 }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "gradientMap": { "type": 35678 }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "specularMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.meshphysical = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "meshphysical_vert", "type": 35633, "uri": "#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "meshphysical_frag", "type": 35632, "uri": "#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "meshphysical", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" }, "uv2": { "semantic": "TEXCOORD_1" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "emissive": { "type": 35665, "value": [0, 0, 0] }, "roughness": { "type": 5126 }, "metalness": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "clearCoat": { "type": 5126 }, "clearCoatRoughness": { "type": 5126 }, "map": { "type": 35678 }, "alphaMap": { "type": 35678 }, "aoMap": { "type": 35678 }, "aoMapIntensity": { "type": 5126, "value": 1 }, "lightMap": { "type": 35678, "semantic": "_LIGHTMAPTEX" }, "lightMapIntensity": { "type": 5126, "semantic": "_LIGHTMAPINTENSITY" }, "emissiveMap": { "type": 35678 }, "reflectivity": { "type": 5126, "value": [] }, "envMapIntensity": { "type": 5126, "value": 1 }, "envMap": { "type": 35678 }, "flipEnvMap": { "type": 5126, "value": 1 }, "maxMipLevel": { "type": 5124, "value": [] }, "refractionRatio": { "type": 5126, "value": [] }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 }, "roughnessMap": { "type": 35678 }, "metalnessMap": { "type": 35678 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.normal = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "normal_vert", "type": 35633, "uri": "#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n" }, { "name": "normal_frag", "type": 35632, "uri": "#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n" }], "techniques": [{ "name": "normal", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "displacementMap": { "type": 35678 }, "displacementScale": { "type": 5126 }, "displacementBias": { "type": 5126 }, "morphTargetInfluences[0]": { "type": 5126 }, "bindMatrix": { "type": 35676, "semantic": "_BINDMATRIX" }, "bindMatrixInverse": { "type": 35676, "semantic": "_BINDMATRIXINVERSE" }, "boneTexture": { "type": 35678 }, "boneTextureSize": { "type": 5124 }, "boneMatrices[0]": { "type": 35676 }, "logDepthBufFC": { "type": 5126 }, "opacity": { "type": 5126, "value": 1 }, "bumpMap": { "type": 35678 }, "bumpScale": { "type": 5126 }, "normalMap": { "type": 35678 }, "normalScale": { "type": 35664 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.particle = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "particle_vert", "type": 35633, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\r\n#include <common>\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec2 corner;\r\n#endif\r\n#ifdef RENDERMESH\r\n\tattribute vec3 position;\r\n\tattribute vec4 color;\r\n#endif\r\nattribute vec2 uv;\r\nattribute vec3 startPosition;\r\nattribute vec3 startVelocity;\r\nattribute vec4 startColor;\r\nattribute vec3 startSize;\r\nattribute vec3 startRotation;\r\nattribute vec2 time;\r\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\r\n  attribute vec4 random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\r\n  attribute vec4 random1;\r\n#endif\r\nattribute vec3 startWorldPosition;\r\nattribute vec4 startWorldRotation;\r\n\r\n#include <particle_common>\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_currentTime - time.y;\r\n\tfloat t = age/time.x;\r\n\tif(t>1.0){ \t\t\t\r\n\t\t\tv_discard=1.0;\r\n\t\t\treturn;\r\n  }\r\n\t  \r\n\t#include <particle_affector>\r\n\tgl_Position=viewProjectionMatrix*vec4(center,1.0);\r\n\tv_color = computeColor(startColor, t);\r\n\tv_texcoord =computeUV(uv, t);\r\n\tv_discard=0.0;\r\n}\r\n\r\n" }, { "name": "particle_frag", "type": 35632, "uri": "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\r\n#include <common>\r\nuniform sampler2D map;\r\nuniform vec3 diffuse;\r\nuniform float opacity;\r\nvarying float v_discard;\r\nvarying vec4 v_color;\r\nvarying vec2 v_texcoord;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_mesh_color;\r\n#endif\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_mesh_color;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\r\n\tif(v_discard!=0.0)\r\n\t\tdiscard;\r\n\tgl_FragColor*=texture2D(map,v_texcoord)*vec4(diffuse, opacity)*v_color*2.0;\r\n}" }], "techniques": [{ "name": "particle", "attributes": { "corner": { "semantic": "_CORNER" }, "position": { "semantic": "POSITION" }, "color": { "semantic": "COLOR_0" }, "uv": { "semantic": "TEXCOORD_0" }, "startPosition": { "semantic": "_START_POSITION" }, "startVelocity": { "semantic": "_START_VELOCITY" }, "startColor": { "semantic": "_START_COLOR" }, "startSize": { "semantic": "_START_SIZE" }, "startRotation": { "semantic": "_START_ROTATION" }, "time": { "semantic": "_TIME" }, "random0": { "semantic": "_RANDOM0" }, "random1": { "semantic": "_RANDOM1" }, "startWorldPosition": { "semantic": "_WORLD_POSITION" }, "startWorldRotation": { "semantic": "_WORLD_ROTATION" } }, "uniforms": { "u_currentTime": { "type": 5126 }, "u_gravity": { "type": 35665 }, "u_worldPosition": { "type": 35665, "value": [0, 0, 0] }, "u_worldRotation": { "type": 35666, "value": [0, 0, 0, 1] }, "u_startRotation3D": { "type": 35670 }, "u_scalingMode": { "type": 5124 }, "u_positionScale": { "type": 35665 }, "u_sizeScale": { "type": 35665 }, "viewProjectionMatrix": { "type": 35676, "semantic": "_VIEWPROJECTION" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "cameraForward": { "type": 35665, "semantic": "_CAMERA_FORWARD" }, "cameraUp": { "type": 35665, "semantic": "CAMERA_UP" }, "u_lengthScale": { "type": 5126 }, "u_speeaScale": { "type": 5126 }, "u_simulationSpace": { "type": 5124 }, "u_spaceType": { "type": 5124 }, "u_velocityConst": { "type": 35665 }, "u_velocityCurveX[0]": { "type": 35664 }, "u_velocityCurveY[0]": { "type": 35664 }, "u_velocityCurveZ[0]": { "type": 35664 }, "u_velocityConstMax": { "type": 35665 }, "u_velocityCurveMaxX[0]": { "type": 35664 }, "u_velocityCurveMaxY[0]": { "type": 35664 }, "u_velocityCurveMaxZ[0]": { "type": 35664 }, "u_colorGradient[0]": { "type": 35666 }, "u_alphaGradient[0]": { "type": 35664 }, "u_colorGradientMax[0]": { "type": 35666 }, "u_alphaGradientMax[0]": { "type": 35664 }, "u_sizeCurve[0]": { "type": 35664 }, "u_sizeCurveMax[0]": { "type": 35664 }, "u_sizeCurveX[0]": { "type": 35664 }, "u_sizeCurveY[0]": { "type": 35664 }, "u_sizeCurveZ[0]": { "type": 35664 }, "u_sizeCurveMaxX[0]": { "type": 35664 }, "u_sizeCurveMaxY[0]": { "type": 35664 }, "u_sizeCurveMaxZ[0]": { "type": 35664 }, "u_rotationConst": { "type": 5126 }, "u_rotationConstMax": { "type": 5126 }, "u_rotationCurve[0]": { "type": 35664 }, "u_rotationCurveMax[0]": { "type": 35664 }, "u_rotationConstSeprarate": { "type": 35665 }, "u_rotationConstMaxSeprarate": { "type": 35665 }, "u_rotationCurveX[0]": { "type": 35664 }, "u_rotationCurveY[0]": { "type": 35664 }, "u_rotationCurveZ[0]": { "type": 35664 }, "u_rotationCurveW[0]": { "type": 35664 }, "u_rotationCurveMaxX[0]": { "type": 35664 }, "u_rotationCurveMaxY[0]": { "type": 35664 }, "u_rotationCurveMaxZ[0]": { "type": 35664 }, "u_rotationCurveMaxW[0]": { "type": 35664 }, "u_cycles": { "type": 5126 }, "u_subUV": { "type": 35666 }, "u_uvCurve[0]": { "type": 35664 }, "u_uvCurveMax[0]": { "type": 35664 }, "map": { "type": 35678 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.points = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "points_vert", "type": 35633, "uri": "uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_PointSize = size;\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "points_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "points", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "size": { "type": 5126 }, "scale": { "type": 5126 }, "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "morphTargetInfluences[0]": { "type": 5126 }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "map": { "type": 35678 }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.shadow = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "shadow_vert", "type": 35633, "uri": "\r\n#include <common2>\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "shadow_frag", "type": 35632, "uri": "uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "shadow", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "directionalShadowMatrix[0]": { "type": 35676, "semantic": "_DIRECTIONSHADOWMAT" }, "spotShadowMatrix[0]": { "type": 35676, "semantic": "_SPOTSHADOWMAT" }, "pointShadowMatrix[0]": { "type": 35676, "semantic": "_POINTSHADOWMAT" }, "color": { "type": 35665 }, "opacity": { "type": 5126, "value": 1 }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "ambientLightColor": { "type": 35665, "semantic": "_AMBIENTLIGHTCOLOR" }, "directionalLights[0]": { "type": 5126, "semantic": "_DIRECTLIGHTS" }, "pointLights[0]": { "type": 5126, "semantic": "_POINTLIGHTS" }, "spotLights[0]": { "type": 5126, "semantic": "_SPOTLIGHTS" }, "ltc_1": { "type": 35678, "semantic": "Unknown" }, "ltc_2": { "type": 35678, "semantic": "Unknown" }, "rectAreaLights[0]": { "type": -1, "semantic": "Unknown" }, "hemisphereLights[0]": { "type": -1, "semantic": "Unknown" }, "directionalShadowMap[0]": { "type": 35678, "semantic": "_DIRECTIONSHADOWMAP" }, "spotShadowMap[0]": { "type": 35678, "semantic": "_SPOTSHADOWMAP" }, "pointShadowMap[0]": { "type": 35678, "semantic": "_POINTSHADOWMAT" } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
        ShaderLib.sprite = { "version": "3", "asset": { "version": "2.0" }, "extensions": { "KHR_techniques_webgl": { "shaders": [{ "name": "sprite_vert", "type": 35633, "uri": "uniform float rotation;\r\nuniform vec2 center;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\tvec2 scale;\r\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\r\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\r\n\r\n\t#ifndef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\r\n\r\n\t#endif\r\n\r\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\r\n\r\n\tvec2 rotatedPosition;\r\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\r\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\r\n\r\n\tmvPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n" }, { "name": "sprite_frag", "type": 35632, "uri": "uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n" }], "techniques": [{ "name": "sprite", "attributes": { "position": { "semantic": "POSITION" }, "normal": { "semantic": "NORMAL" }, "uv": { "semantic": "TEXCOORD_0" }, "color": { "semantic": "COLOR_0" }, "morphTarget0": { "semantic": "WEIGHTS_0" }, "morphTarget1": { "semantic": "WEIGHTS_1" }, "morphTarget2": { "semantic": "WEIGHTS_2" }, "morphTarget3": { "semantic": "WEIGHTS_3" }, "morphNormal0": { "semantic": "MORPHNORMAL_0" }, "morphNormal1": { "semantic": "MORPHNORMAL_1" }, "morphNormal2": { "semantic": "MORPHNORMAL_2" }, "morphNormal3": { "semantic": "MORPHNORMAL_3" }, "morphTarget4": { "semantic": "WEIGHTS_4" }, "morphTarget5": { "semantic": "WEIGHTS_5" }, "morphTarget6": { "semantic": "WEIGHTS_6" }, "morphTarget7": { "semantic": "WEIGHTS_7" }, "skinIndex": { "semantic": "JOINTS_0" }, "skinWeight": { "semantic": "WEIGHTS_0" } }, "uniforms": { "rotation": { "type": 5126 }, "center": { "type": 35664 }, "modelMatrix": { "type": 35676, "semantic": "MODEL" }, "modelViewMatrix": { "type": 35676, "semantic": "MODELVIEW" }, "projectionMatrix": { "type": 35676, "semantic": "PROJECTION" }, "viewMatrix": { "type": 35676, "semantic": "VIEW" }, "normalMatrix": { "type": 35675, "semantic": "MODELVIEWINVERSE" }, "cameraPosition": { "type": 35665, "semantic": "_CAMERA_POS" }, "uvTransform": { "type": 35675, "value": [1, 0, 0, 0, 1, 0, 0, 0, 1] }, "logDepthBufFC": { "type": 5126 }, "diffuse": { "type": 35665, "value": [1, 1, 1] }, "opacity": { "type": 5126, "value": 1 }, "map": { "type": 35678 }, "fogColor": { "type": 35665 }, "fogDensity": { "type": 5126 }, "fogNear": { "type": 5126 }, "fogFar": { "type": 5126 }, "clippingPlanes[0]": { "type": 35666 } }, "states": { "enable": [], "functions": {} } }] }, "paper": {} }, "extensionsRequired": ["paper"], "extensionsUsed": ["paper"], "materials": [] };
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n\n diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n\n#endif\n";
        ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\n uniform sampler2D alphaMap;\n\n#endif\n";
        ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n\n if ( diffuseColor.a < ALPHATEST ) discard;\n\n#endif\n";
        ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n\n // reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\n reflectedLight.indirectDiffuse *= ambientOcclusion;\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n  reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\n #endif\n\n#endif\n";
        ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n\n uniform sampler2D aoMap;\n uniform float aoMapIntensity;\n\n#endif";
        ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
        ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n";
        ShaderChunk.bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n if( decayExponent > 0.0 ) {\n\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n  // based upon Frostbite 3 Moving to Physically-based Rendering\n  // page 32, equation 26: E[window1]\n  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n  // this is intended to be used on spot and point lights who are represented as luminous intensity\n  // but who must be converted to luminous irradiance for surface lighting calculation\n  float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n  float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n  return distanceFalloff * maxDistanceCutoffFactor;\n\n#else\n\n  return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n#endif\n\n }\n\n return 1.0;\n\n}\n\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\n return RECIPROCAL_PI * diffuseColor;\n\n} // validated\n\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\n // Original approximation by Christophe Schlick '94\n // float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n\n} // validated\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term (normalized) = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n // also see #12151\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n} // validated\n\n// Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2\n// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// Rect Area Light\n\n// Real-Time Polygonal-Light Shading with Linearly Transformed Cosines\n// by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt\n// code: https://github.com/selfshadow/ltc_code/\n\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n float dotNV = saturate( dot( N, V ) );\n\n // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )\n vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n return uv;\n\n}\n\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\n // Real-Time Area Lighting: a Journey from Research to Production (p.102)\n // An approximation of the form factor of a horizon-clipped rectangle.\n\n float l = length( f );\n\n return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n\n}\n\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\n float x = dot( v1, v2 );\n\n float y = abs( x );\n\n // rational polynomial approximation to theta / sin( theta ) / 2PI\n float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n float b = 3.4175940 + ( 4.1616724 + y ) * y;\n float v = a / b;\n\n float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\n return cross( v1, v2 ) * theta_sintheta;\n\n}\n\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\n // bail if point is on back side of plane of light\n // assumes ccw winding order of light vertices\n vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n vec3 lightNormal = cross( v1, v2 );\n\n if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\n // construct orthonormal basis around N\n vec3 T1, T2;\n T1 = normalize( V - N * dot( V, N ) );\n T2 = - cross( N, T1 ); // negated from paper; possibly due to a different handedness of world coordinate system\n\n // compute transform\n mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\n // transform rect\n vec3 coords[ 4 ];\n coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\n // project rect onto sphere\n coords[ 0 ] = normalize( coords[ 0 ] );\n coords[ 1 ] = normalize( coords[ 1 ] );\n coords[ 2 ] = normalize( coords[ 2 ] );\n coords[ 3 ] = normalize( coords[ 3 ] );\n\n // calculate vector form factor\n vec3 vectorFormFactor = vec3( 0.0 );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\n // adjust for horizon clipping\n float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\n/*\n // alternate method of adjusting for horizon clipping (see referece)\n // refactoring required\n float len = length( vectorFormFactor );\n float z = vectorFormFactor.z / len;\n\n const float LUT_SIZE  = 64.0;\n const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n const float LUT_BIAS  = 0.5 / LUT_SIZE;\n\n // tabulated horizon-clipped sphere, apparently...\n vec2 uv = vec2( z * 0.5 + 0.5, len );\n uv = uv * LUT_SCALE + LUT_BIAS;\n\n float scale = texture2D( ltc_2, uv ).w;\n\n float result = len * scale;\n*/\n\n return vec3( result );\n\n}\n\n// End Rect Area Light\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n} // validated\n\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n\n}\n\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n\n}\n\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\n vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\n //float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n //float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n float dotNH = saturate( dot( geometry.normal, halfDir ) );\n float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\n vec3 F = F_Schlick( specularColor, dotLH );\n\n float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n float D = D_BlinnPhong( shininess, dotNH );\n\n return F * ( G * D );\n\n} // validated\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd() {\n\n  vec2 dSTdx = dFdx( vUv );\n  vec2 dSTdy = dFdy( vUv );\n\n  float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\n  // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n  vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n  vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  fDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.clipping_planes_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n vec4 plane;\n\n // #pragma unroll_loop\n for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\n  plane = clippingPlanes[ i ];\n  if ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\n }\n\n #if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\n  bool clipped = true;\n\n  // #pragma unroll_loop\n  for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\n   plane = clippingPlanes[ i ];\n   clipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\n  }\n\n  if ( clipped ) discard;\n\n #endif\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_fragment = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0\n\n #if ! defined( PHYSICAL ) && ! defined( PHONG )\n  varying vec3 vViewPosition;\n #endif\n\n uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n\n#endif\n";
        ShaderChunk.clipping_planes_pars_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n varying vec3 vViewPosition;\n#endif\n";
        ShaderChunk.clipping_planes_vertex = "#if defined(NUM_CLIPPING_PLANES) && NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n vViewPosition = - mvPosition.xyz;\n#endif\n\n";
        ShaderChunk.color_fragment = "#ifdef USE_COLOR\n\n diffuseColor.rgb *= vColor;\n\n#endif";
        ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif\n";
        ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n\n varying vec3 vColor;\n\n#endif";
        ShaderChunk.color_vertex = "#ifdef USE_COLOR\n\n vColor.xyz = color.xyz;\n\n#endif";
        ShaderChunk.common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( const in vec2 uv ) {\n const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n return fract(sin(sn) * c);\n}\n\nstruct IncidentLight {\n vec3 color;\n vec3 direction;\n bool visible;\n};\n\nstruct ReflectedLight {\n vec3 directDiffuse;\n vec3 directSpecular;\n vec3 indirectDiffuse;\n vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n vec3 position;\n vec3 normal;\n vec3 viewDir;\n};\n\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n}\n\n// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\n return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n\n}\n\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n float distance = dot( planeNormal, point - pointOnPlane );\n\n return - distance * planeNormal + point;\n\n}\n\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return sign( dot( point - pointOnPlane, planeNormal ) );\n\n}\n\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\n return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n\n}\n\nmat3 transposeMat3( const in mat3 m ) {\n\n mat3 tmp;\n\n tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\n return tmp;\n\n}\n\n// https://en.wikipedia.org/wiki/Relative_luminance\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\n vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\n return dot( weights, color.rgb );\n\n}\n";
        ShaderChunk.common2 = "//------------------------------------------------\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;\n\nattribute vec3 position;\nattribute vec3 normal;\nattribute vec2 uv;\n\n#ifdef USE_COLOR\n\n attribute vec3 color;\n#endif\n#ifdef USE_MORPHTARGETS\n attribute vec3 morphTarget0;\n attribute vec3 morphTarget1;\n attribute vec3 morphTarget2;\n attribute vec3 morphTarget3;\n #ifdef USE_MORPHNORMALS\n  attribute vec3 morphNormal0;\n  attribute vec3 morphNormal1;\n  attribute vec3 morphNormal2;\n  attribute vec3 morphNormal3;\n #else\n  attribute vec3 morphTarget4;\n  attribute vec3 morphTarget5;\n  attribute vec3 morphTarget6;\n  attribute vec3 morphTarget7;\n #endif\n#endif\n#ifdef USE_SKINNING\n attribute vec4 skinIndex;\n attribute vec4 skinWeight;\n#endif\n//------------------------------------------------";
        ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\n#define cubeUV_textureSize (1024.0)\n\nint getFaceFromDirection(vec3 direction) {\n vec3 absDirection = abs(direction);\n int face = -1;\n if( absDirection.x > absDirection.z ) {\n  if(absDirection.x > absDirection.y )\n   face = direction.x > 0.0 ? 0 : 3;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n else {\n  if(absDirection.z > absDirection.y )\n   face = direction.z > 0.0 ? 2 : 5;\n  else\n   face = direction.y > 0.0 ? 1 : 4;\n }\n return face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\n\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n float dxRoughness = dFdx(roughness);\n float dyRoughness = dFdy(roughness);\n vec3 dx = dFdx( vec * scale * dxRoughness );\n vec3 dy = dFdy( vec * scale * dyRoughness );\n float d = max( dot( dx, dx ), dot( dy, dy ) );\n // Clamp the value to the max mip level counts. hard coded to 6 mips\n d = clamp(d, 1.0, cubeUV_rangeClamp);\n float mipLevel = 0.5 * log2(d);\n return vec2(floor(mipLevel), fract(mipLevel));\n}\n\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\n\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n float a = 16.0 * cubeUV_rcpTextureSize;\n\n vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n // float powScale = exp2(roughnessLevel + mipLevel);\n float powScale = exp2_packed.x * exp2_packed.y;\n // float scale =  1.0 / exp2(roughnessLevel + 2.0 + mipLevel);\n float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n // float mipOffset = 0.75*(1.0 - 1.0/exp2(mipLevel))/exp2(roughnessLevel);\n float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\n bool bRes = mipLevel == 0.0;\n scale =  bRes && (scale < a) ? a : scale;\n\n vec3 r;\n vec2 offset;\n int face = getFaceFromDirection(direction);\n\n float rcpPowScale = 1.0 / powScale;\n\n if( face == 0) {\n  r = vec3(direction.x, -direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 1) {\n  r = vec3(direction.y, direction.x, direction.z);\n  offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 2) {\n  r = vec3(direction.z, direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n }\n else if( face == 3) {\n  r = vec3(direction.x, direction.z, direction.y);\n  offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else if( face == 4) {\n  r = vec3(direction.y, direction.x, -direction.z);\n  offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n else {\n  r = vec3(direction.z, -direction.x, direction.y);\n  offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n  offset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n }\n r = normalize(r);\n float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n vec2 base = offset + vec2( texelOffset );\n return base + s * ( scale - 2.0 * texelOffset );\n}\n\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\n\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n float roughnessVal = roughness* cubeUV_maxLods3;\n float r1 = floor(roughnessVal);\n float r2 = r1 + 1.0;\n float t = fract(roughnessVal);\n vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n float s = mipInfo.y;\n float level0 = mipInfo.x;\n float level1 = level0 + 1.0;\n level1 = level1 > 5.0 ? 5.0 : level1;\n\n // round to nearest mipmap if we are not interpolating.\n level0 += min( floor( s + 0.5 ), 5.0 );\n\n // Tri linear interpolation.\n vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\n vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\n vec4 result = mix(color10, color20, t);\n\n return vec4(result.rgb, 1.0);\n}\n\n#endif\n";
        ShaderChunk.defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n\n#ifdef FLIP_SIDED\n\n transformedNormal = - transformedNormal;\n\n#endif\n";
        ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n uniform sampler2D displacementMap;\n uniform float displacementScale;\n uniform float displacementBias;\n\n#endif\n";
        ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\n transformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n\n#endif\n";
        ShaderChunk.dithering_fragment = "#if defined( DITHERING )\n\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.dithering_pars_fragment = "#if defined( DITHERING )\n\n // based on https://www.shadertoy.com/view/MslGR8\n vec3 dithering( vec3 color ) {\n  //Calculate grid position\n  float grid_position = rand( gl_FragCoord.xy );\n\n  //Shift the individual colors differently, thus making it even harder to see the dithering pattern\n  vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\n  //modify shift acording to grid position.\n  dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\n  //shift the color by dither_shift\n  return color + dither_shift_RGB;\n }\n\n#endif\n";
        ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\n vec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n totalEmissiveRadiance *= emissiveColor.rgb;\n\n#endif\n";
        ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\n uniform sampler2D emissiveMap;\n\n#endif\n";
        ShaderChunk.encodings_fragment = "  // gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
        ShaderChunk.encodings_pars_fragment = "// For a discussion of what this is, please read this: http://lousodrome.net/blog/light/2013/05/26/gamma-correct-and-hdr-rendering-in-a-32-bits-buffer/\n\nvec4 LinearToLinear( in vec4 value ) {\n return value;\n}\n\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\n\nvec4 sRGBToLinear( in vec4 value ) {\n return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\n\nvec4 RGBEToLinear( in vec4 value ) {\n return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n float maxComponent = max( max( value.r, value.g ), value.b );\n float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n//  return vec4( value.brg, ( 3.0 + 128.0 ) / 256.0 );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n M            = ceil( M * 255.0 ) / 255.0;\n return vec4( value.rgb / ( M * maxRange ), M );\n}\n\n// reference: http://iwasbeingirony.blogspot.ca/2010/06/difference-between-rgbm-and-rgbd.html\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n float maxRGB = max( value.x, max( value.g, value.b ) );\n float D      = max( maxRange / maxRGB, 1.0 );\n D            = min( floor( D ) / 255.0, 1.0 );\n return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\n\n// LogLuv reference: http://graphicrants.blogspot.ca/2009/04/rgbm-color-encoding.html\n\n// M matrix, for encoding\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n vec4 vResult;\n vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n vResult.w = fract(Le);\n vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n return vResult;\n}\n\n// Inverse M matrix, for decoding\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n float Le = value.z * 255.0 + value.w;\n vec3 Xp_Y_XYZp;\n Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n return vec4( max(vRGB, 0.0), 1.0 );\n}\n";
        ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\n  // Transforming Normal Vectors with the Inverse Transformation\n  vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #else\n\n  vec3 reflectVec = vReflect;\n\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n\n  vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\n #elif defined( ENVMAP_TYPE_EQUIREC )\n\n  vec2 sampleUV;\n\n  reflectVec = normalize( reflectVec );\n\n  sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\n  sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n  vec4 envColor = texture2D( envMap, sampleUV );\n\n #elif defined( ENVMAP_TYPE_SPHERE )\n\n  reflectVec = normalize( reflectVec );\n\n  vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\n  vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\n #else\n\n  vec4 envColor = vec4( 0.0 );\n\n #endif\n\n envColor = envMapTexelToLinear( envColor );\n\n #ifdef ENVMAP_BLENDING_MULTIPLY\n\n  outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_MIX )\n\n  outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\n #elif defined( ENVMAP_BLENDING_ADD )\n\n  outgoingLight += envColor.xyz * specularStrength * reflectivity;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n uniform float reflectivity;\n uniform float envMapIntensity;\n#endif\n\n#ifdef USE_ENVMAP\n\n #if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n  varying vec3 vWorldPosition;\n #endif\n\n #ifdef ENVMAP_TYPE_CUBE\n  uniform samplerCube envMap;\n #else\n  uniform sampler2D envMap;\n #endif\n uniform float flipEnvMap;\n uniform int maxMipLevel;\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n  uniform float refractionRatio;\n #else\n  varying vec3 vReflect;\n #endif\n\n#endif\n";
        ShaderChunk.envmap_pars_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n  varying vec3 vWorldPosition;\n\n #else\n\n  varying vec3 vReflect;\n  uniform float refractionRatio;\n\n #endif\n\n#endif\n";
        ShaderChunk.envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.envmap_vertex = "#ifdef USE_ENVMAP\n\n #if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\n  vWorldPosition = worldPosition.xyz;\n\n #else\n\n  vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\n  vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vReflect = reflect( cameraToVertex, worldNormal );\n\n  #else\n\n   vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\n  #endif\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_fragment = "#ifdef USE_FOG\n\n float fogDepth = length( vFogPosition );\n\n #ifdef FOG_EXP2\n\n  float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\n #else\n\n  float fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\n #endif\n\n gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n\n#endif\n";
        ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n\n uniform vec3 fogColor;\n varying vec3 vFogPosition;\n\n #ifdef FOG_EXP2\n\n  uniform float fogDensity;\n\n #else\n\n  uniform float fogNear;\n  uniform float fogFar;\n\n #endif\n\n#endif\n";
        ShaderChunk.fog_pars_vertex = "#ifdef USE_FOG\n\n varying vec3 vFogPosition;\n\n#endif\n";
        ShaderChunk.fog_vertex = "#ifdef USE_FOG\n\n vFogPosition = mvPosition.xyz;\n\n#endif\n";
        ShaderChunk.gradientmap_pars_fragment = "#ifdef TOON\n\n uniform sampler2D gradientMap;\n\n vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\n  // dotNL will be from -1.0 to 1.0\n  float dotNL = dot( normal, lightDirection );\n  vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\n  #ifdef USE_GRADIENTMAP\n\n   return texture2D( gradientMap, coord ).rgb;\n\n  #else\n\n   return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\n  #endif\n\n\n }\n\n#endif\n";
        ShaderChunk.lightmap_frag = "#ifdef USE_LIGHTMAP\n    lowp vec4 lightmap = texture2D(lightMap, xlv_TEXCOORD1);\n    outColor.xyz *= decode_hdr(lightmap, lightMapIntensity);\n    gl_FragData[0] = outColor;\n#else\n    gl_FragData[0] = outColor;\n#endif";
        ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n\n reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\n\n#endif\n";
        ShaderChunk.lightmap_pars_frag = "#ifdef USE_LIGHTMAP\n    uniform sampler2D lightMap;\n    uniform lowp float lightMapIntensity;\n    varying highp vec2 xlv_TEXCOORD1;\n\n    lowp vec3 decode_hdr(lowp vec4 data, lowp float intensity)\n    {\n        highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n        return data.rgb * power * intensity;\n    }\n#endif";
        ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\n uniform sampler2D lightMap;\n uniform float lightMapIntensity;\n\n#endif";
        ShaderChunk.lightmap_pars_vert = "#ifdef USE_LIGHTMAP\n    attribute vec4 uv2;\n    uniform highp vec4 lightMapOffset;\n    uniform lowp float lightMapUV;\n    varying highp vec2 xlv_TEXCOORD1;\n#endif";
        ShaderChunk.lightmap_vert = "#ifdef USE_LIGHTMAP\n    highp vec2 beforelightUV = uv2.xy;\n    if(lightMapUV == 0.0)\n    {\n        beforelightUV = uv.xy;\n    }\n    highp float u = beforelightUV.x * lightMapOffset.x + lightMapOffset.z;\n    highp float v = 1.0 - ((1.0 - beforelightUV.y) * lightMapOffset.y + lightMapOffset.w);\n    xlv_TEXCOORD1 = vec2(u,v);\n#endif";
        ShaderChunk.lights_fragment_begin = "/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. <---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\n\nIncidentLight directLight;\n\n#if (defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n SpotLight spotLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.direction = vec3(directionalLights[i * 12 + 0], directionalLights[i * 12 + 1], directionalLights[i * 12 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 12 + 3], directionalLights[i * 12 + 4], directionalLights[i * 12 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  #ifdef USE_SHADOWMAP\n  directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n  #endif\n\n  RE_Direct( directLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if (defined(NUM_RECT_AREA_LIGHTS) &&  NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n RectAreaLight rectAreaLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  rectAreaLight = rectAreaLights[ i ];\n  RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n }\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n #if (defined(NUM_HEMI_LIGHTS) &&  NUM_HEMI_LIGHTS > 0 )\n\n  // #pragma unroll_loop\n  for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n   irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  }\n\n #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n vec3 radiance = vec3( 0.0 );\n vec3 clearCoatRadiance = vec3( 0.0 );\n\n#endif\n";
        ShaderChunk.lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\n RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n RE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n\n#endif\n";
        ShaderChunk.lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\n #ifdef USE_LIGHTMAP\n\n  vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   lightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n  #endif\n\n  irradiance += lightMapIrradiance;\n\n #endif\n\n #if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\n  irradiance += getLightProbeIndirectIrradiance( /*lightProbe,*/ geometry, maxMipLevel );\n\n #endif\n\n#endif\n\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\n radiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\n #ifndef STANDARD\n  clearCoatRadiance += getLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n #endif\n\n#endif\n";
        ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\n\nvLightFront = vec3( 0.0 );\n\n#ifdef DOUBLE_SIDED\n vLightBack = vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n PointLight pointLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  pointLight.position = vec3(pointLights[i* 15 + 0], pointLights[i * 15 + 1], pointLights[i * 15 + 2]);\n  pointLight.color = vec3(pointLights[i* 15 + 3], pointLights[i * 15 + 4], pointLights[i * 15 + 5]);\n  pointLight.distance = pointLights[i * 15 + 6];\n  pointLight.decay = pointLights[i * 15 + 7];\n  getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n  spotLight.position = vec3(spotLights[i * 18 + 0], spotLights[i * 18 + 1], spotLights[i * 18 + 2]);\n  spotLight.direction = vec3(spotLights[i * 18 + 3], spotLights[i * 18 + 4], spotLights[i * 18 + 5]);\n  spotLight.color = vec3(spotLights[i * 18 + 6], spotLights[i * 18 + 7], spotLights[i * 18 + 8]);\n  spotLight.distance = spotLights[i * 18 + 9];\n  spotLight.decay = spotLights[i * 18 + 10];\n  spotLight.coneCos = spotLights[i * 18 + 11];\n  spotLight.penumbraCos = spotLights[i * 18 + 12];\n\n  getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n }\n\n#endif\n\n/*\n#if NUM_RECT_AREA_LIGHTS > 0\n\n for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  // TODO (abelnation): implement\n\n }\n\n#endif\n*/\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n DirectionalLight directionalLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  directionalLight.direction = vec3(directionalLights[i * 12 + 0], directionalLights[i * 12 + 1], directionalLights[i * 12 + 2]);\n  directionalLight.color = vec3(directionalLights[i * 12 + 3], directionalLights[i * 12 + 4], directionalLights[i * 12 + 5]);\n  getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n  dotNL = dot( geometry.normal, directLight.direction );\n  directLightColor_Diffuse = PI * directLight.color;\n  // directLightColor_Diffuse = directLight.color;\n\n  vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n  // vLightFront += directLightColor_Diffuse;\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\n  #endif\n\n }\n\n#endif\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n  vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n  #ifdef DOUBLE_SIDED\n\n   vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_begin = "uniform vec3 ambientLightColor;\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n vec3 irradiance = ambientLightColor;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI;\n\n #endif\n\n return irradiance;\n\n}\n\n#if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0\n\n struct DirectionalLight {\n  vec3 direction;\n  vec3 color;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float directionalLights[NUM_DIR_LIGHTS * 12];\n\n void getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n  directLight.direction = directionalLight.direction;\n  directLight.color = directionalLight.color;\n  directLight.visible = true;\n }\n\n#endif\n\n\n#if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0\n\n struct PointLight {\n  vec3 position;\n  vec3 color;\n  float distance;\n  float decay;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n  float shadowCameraNear;\n  float shadowCameraFar;\n };\n\n uniform float pointLights[NUM_POINT_LIGHTS * 15 ];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\n  vec3 lVector = pointLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n\n  directLight.color = pointLight.color;\n  directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n  directLight.visible = ( directLight.color != vec3( 0.0 ) );\n\n }\n\n#endif\n\n\n#if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0\n\n struct SpotLight {\n  vec3 position;\n  vec3 direction;\n  vec3 color;\n  float distance;\n  float decay;\n  float coneCos;\n  float penumbraCos;\n\n  int shadow;\n  float shadowBias;\n  float shadowRadius;\n  vec2 shadowMapSize;\n };\n\n uniform float spotLights[NUM_SPOT_LIGHTS * 18];\n\n // directLight is an out parameter as having it as a return value caused compiler errors on some devices\n void getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\n  vec3 lVector = spotLight.position - geometry.position;\n  directLight.direction = normalize( lVector );\n\n  float lightDistance = length( lVector );\n  float angleCos = dot( directLight.direction, spotLight.direction );\n\n  if ( angleCos > spotLight.coneCos ) {\n\n   float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n   directLight.color = spotLight.color;\n   directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n   directLight.visible = true;\n\n  } else {\n\n   directLight.color = vec3( 0.0 );\n   directLight.visible = false;\n\n  }\n }\n\n#endif\n\n\n#if defined(NUM_RECT_AREA_LIGHTS) && NUM_RECT_AREA_LIGHTS > 0\n\n struct RectAreaLight {\n  vec3 color;\n  vec3 position;\n  vec3 halfWidth;\n  vec3 halfHeight;\n };\n\n // Pre-computed values of LinearTransformedCosine approximation of BRDF\n // BRDF approximation Texture is 64x64\n uniform sampler2D ltc_1; // RGBA Float\n uniform sampler2D ltc_2; // RGBA Float\n\n uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if defined(NUM_HEMI_LIGHTS) && NUM_HEMI_LIGHTS > 0\n\n struct HemisphereLight {\n  vec3 direction;\n  vec3 skyColor;\n  vec3 groundColor;\n };\n\n uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\n  float dotNL = dot( geometry.normal, hemiLight.direction );\n  float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\n  vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n   irradiance *= PI;\n\n  #endif\n\n  return irradiance;\n\n }\n\n#endif\n";
        ShaderChunk.lights_pars_maps = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\n vec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\n\n  vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\n   // TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\n   // of a specular cubemap, or just the default level of a specially created irradiance cubemap.\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\n   #else\n\n    // force the bias high to get the last LOD level as it is the most blurred.\n    vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n   vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n  #else\n\n   vec4 envMapColor = vec4( 0.0 );\n\n  #endif\n\n  return PI * envMapColor.rgb * envMapIntensity;\n\n }\n\n // taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\n float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  //float envMapWidth = pow( 2.0, maxMIPLevelScalar );\n  //float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  float maxMIPLevelScalar = float( maxMIPLevel );\n  float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\n  // clamp to allowable LOD ranges.\n  return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\n }\n\n vec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\n  #ifdef ENVMAP_MODE_REFLECTION\n\n   vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n  #else\n\n   vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n  #endif\n\n  reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n  float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\n  #ifdef ENVMAP_TYPE_CUBE\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_CUBE_UV )\n\n   vec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n   vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\n  #elif defined( ENVMAP_TYPE_EQUIREC )\n\n   vec2 sampleUV;\n   sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n   sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #elif defined( ENVMAP_TYPE_SPHERE )\n\n   vec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\n   #ifdef TEXTURE_LOD_EXT\n\n    vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #else\n\n    vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\n   #endif\n\n   envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\n  #endif\n\n  return envMapColor.rgb * envMapIntensity;\n\n }\n\n#endif\n";
        ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
        ShaderChunk.lights_phong_pars_fragment = "varying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n varying vec3 vNormal;\n\n#endif\n\n\nstruct BlinnPhongMaterial {\n\n vec3 diffuseColor;\n vec3 specularColor;\n float specularShininess;\n float specularStrength;\n\n};\n\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifdef TOON\n\n  vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\n #else\n\n  float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n  vec3 irradiance = dotNL * directLight.color;\n\n #endif\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\n#define RE_Direct    RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong\n\n#define Material_LightProbeLOD( material ) (0)\n";
        ShaderChunk.lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n material.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n material.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n material.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
        ShaderChunk.lights_physical_pars_fragment = "struct PhysicalMaterial {\n\n vec3 diffuseColor;\n float specularRoughness;\n vec3 specularColor;\n\n #ifndef STANDARD\n  float clearCoat;\n  float clearCoatRoughness;\n #endif\n\n};\n\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\n\n// Clear coat directional hemishperical reflectance (this approximation should be improved)\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\n return DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n\n}\n\n#if NUM_RECT_AREA_LIGHTS > 0\n\n void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n  vec3 normal = geometry.normal;\n  vec3 viewDir = geometry.viewDir;\n  vec3 position = geometry.position;\n  vec3 lightPos = rectAreaLight.position;\n  vec3 halfWidth = rectAreaLight.halfWidth;\n  vec3 halfHeight = rectAreaLight.halfHeight;\n  vec3 lightColor = rectAreaLight.color;\n  float roughness = material.specularRoughness;\n\n  vec3 rectCoords[ 4 ];\n  rectCoords[ 0 ] = lightPos - halfWidth - halfHeight; // counterclockwise\n  rectCoords[ 1 ] = lightPos + halfWidth - halfHeight;\n  rectCoords[ 2 ] = lightPos + halfWidth + halfHeight;\n  rectCoords[ 3 ] = lightPos - halfWidth + halfHeight;\n\n  vec2 uv = LTC_Uv( normal, viewDir, roughness );\n\n  vec4 t1 = texture2D( ltc_1, uv );\n  vec4 t2 = texture2D( ltc_2, uv );\n\n  mat3 mInv = mat3(\n   vec3( t1.x, 0, t1.y ),\n   vec3(    0, 1,    0 ),\n   vec3( t1.z, 0, t1.w )\n  );\n\n  // LTC Fresnel Approximation by Stephen Hill\n  // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf\n  vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\n  reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\n  reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\n }\n\n#endif\n\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\n vec3 irradiance = dotNL * directLight.color;\n\n #ifndef PHYSICALLY_CORRECT_LIGHTS\n\n  irradiance *= PI; // punctual light\n\n #endif\n\n #ifndef STANDARD\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\n reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n #ifndef STANDARD\n\n  reflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\n}\n\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\n #ifndef STANDARD\n  float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n  float dotNL = dotNV;\n  float clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n #else\n  float clearCoatDHR = 0.0;\n #endif\n\n reflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\n #ifndef STANDARD\n\n  reflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\n #endif\n\n}\n\n#define RE_Direct    RE_Direct_Physical\n#define RE_Direct_RectArea  RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular  RE_IndirectSpecular_Physical\n\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\n\n// ref: https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\n return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n\n}\n";
        ShaderChunk.logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n gl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n\n#endif";
        ShaderChunk.logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\n uniform float logDepthBufFC;\n varying float vFragDepth;\n\n#endif\n";
        ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  varying float vFragDepth;\n\n #else\n\n  uniform float logDepthBufFC;\n\n #endif\n\n#endif\n";
        ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\n #ifdef USE_LOGDEPTHBUF_EXT\n\n  vFragDepth = 1.0 + gl_Position.w;\n\n #else\n\n  gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\n  gl_Position.z *= gl_Position.w;\n\n #endif\n\n#endif\n";
        ShaderChunk.map_fragment = "#ifdef USE_MAP\n\n vec4 texelColor = texture2D( map, vUv );\n\n // texelColor = mapTexelToLinear( texelColor );TODO\n diffuseColor *= texelColor;\n\n#endif\n";
        ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n\n vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n vec4 mapTexel = texture2D( map, uv );\n diffuseColor *= mapTexelToLinear( mapTexel );\n\n#endif\n";
        ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n\n uniform mat3 uvTransform;\n uniform sampler2D map;\n\n#endif\n";
        ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n\n#ifdef USE_METALNESSMAP\n\n vec4 texelMetalness = texture2D( metalnessMap, vUv );\n\n // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n metalnessFactor *= texelMetalness.b;\n\n#endif\n";
        ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\n uniform sampler2D metalnessMap;\n\n#endif";
        ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\n objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n\n#endif\n";
        ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\n #ifndef USE_MORPHNORMALS\n\n uniform float morphTargetInfluences[ 8 ];\n\n #else\n\n uniform float morphTargetInfluences[ 4 ];\n\n #endif\n\n#endif";
        ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\n transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\n #ifndef USE_MORPHNORMALS\n\n transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\n #endif\n\n#endif\n";
        ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\n uniform sampler2D normalMap;\n uniform vec2 normalScale;\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  uniform mat3 normalMatrix;\n\n #else\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\n   // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n   vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n   vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n   vec2 st0 = dFdx( vUv.st );\n   vec2 st1 = dFdy( vUv.st );\n\n   float scale = sign( st1.t * st0.s - st0.t * st1.s ); // we do not care about the magnitude\n\n   vec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n   vec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n   vec3 N = normalize( surf_norm );\n   mat3 tsn = mat3( S, T, N );\n\n   vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\n   mapN.xy *= normalScale;\n   mapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n   return normalize( tsn * mapN );\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_begin = "#ifdef FLAT_SHADED\n\n // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n\n vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n vec3 normal = normalize( cross( fdx, fdy ) );\n\n#else\n\n vec3 normal = normalize( vNormal );\n\n #ifdef DOUBLE_SIDED\n\n  normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n #endif\n\n#endif\n";
        ShaderChunk.normal_fragment_maps = "#ifdef USE_NORMALMAP\n\n #ifdef OBJECTSPACE_NORMALMAP\n\n  normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  #ifdef FLIP_SIDED\n\n   normal = - normal;\n\n  #endif\n\n  #ifdef DOUBLE_SIDED\n\n   normal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\n  #endif\n\n  normal = normalize( normalMatrix * normal );\n\n #else // tangent-space normal map\n\n  normal = perturbNormal2Arb( -vViewPosition, normal );\n\n #endif\n\n#elif defined( USE_BUMPMAP )\n\n normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n\n#endif\n";
        ShaderChunk.packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n return normalize( normal ) * 0.5 + 0.5;\n}\n\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n return 2.0 * rgb.xyz - 1.0;\n}\n\nconst float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n return r * PackUpscale;\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n return dot( v, UnpackFactors );\n}\n\n// NOTE: viewZ/eyeZ is < 0 when in front of the camera per OpenGL conventions\n\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n return linearClipZ * ( near - far ) - near;\n}\n\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\n\nvec3 center=computePosition(startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n   vec2 corner=corner.xy;\n      vec3 cameraUpVector =normalize(cameraUp);\n      vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,cameraForward));\n     corner*=computeBillbardSize(startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(startRotation.xy,computeRotation(startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,startRotation);\n   }\n   else{\n    float c = cos(startRotation.x);\n    float s = sin(startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=corner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-cameraPosition);\n    vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=corner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(cameraForward,cameraUpVector));\n  float rot = computeRotation(startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(startRotation.xy,-computeRotation(startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(startRotation.x, age,t);\n      if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(position*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*position*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(position*size,startRotation),worldRotation);\n  }\n  else{\n   if(startPosition.x>0.1 || startPosition.x < -0.1||startPosition.y>0.1 || startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(position*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(startPosition.xy,0.0))),startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,-1.0,0.0),startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*position*size,vec3(0.0,0.0,-1.0),startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(position*size,vec3(0.0,0.0,-1.0),startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=color;\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 viewProjectionMatrix;\n\n#ifdef STRETCHEDBILLBOARD\n uniform vec3 cameraPosition;\n#endif\nuniform vec3 cameraForward;\nuniform vec3 cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(random1.y,random1.z,random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 startPosition;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*startPosition.xyz+startPosition+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation)+lifePosition;\n   }\n    #else\n    startPosition=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(startPosition.xyz+startPosition),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*startPosition.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\n // Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\n gl_FragColor.rgb *= gl_FragColor.a;\n\n#endif\n";
        ShaderChunk.project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n\ngl_Position = projectionMatrix * mvPosition;\n";
        ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n\n#ifdef USE_ROUGHNESSMAP\n\n vec4 texelRoughness = texture2D( roughnessMap, vUv );\n\n // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n roughnessFactor *= texelRoughness.g;\n\n#endif\n";
        ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\n uniform sampler2D roughnessMap;\n\n#endif";
        ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): create uniforms for area light shadows\n\n #endif\n */\n\n float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n  return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n }\n\n float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\n  const vec2 offset = vec2( 0.0, 1.0 );\n\n  vec2 texelSize = vec2( 1.0 ) / size;\n  vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\n  float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n  float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n  float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n  float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\n  vec2 f = fract( uv * size + 0.5 );\n\n  float a = mix( lb, lt, f.y );\n  float b = mix( rb, rt, f.y );\n  float c = mix( a, b, f.x );\n\n  return c;\n\n }\n\n float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\n  float shadow = 1.0;\n\n  shadowCoord.xyz /= shadowCoord.w;\n  shadowCoord.z += shadowBias;//Egret Right-hand\n\n  // if ( something && something ) breaks ATI OpenGL shader compiler\n  // if ( all( something, something ) ) using this instead\n\n  bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n  bool inFrustum = all( inFrustumVec );\n\n  bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\n  bool frustumTest = all( frustumTestVec );\n\n  if ( frustumTest ) {\n\n  #if defined( SHADOWMAP_TYPE_PCF )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\n   float dx0 = - texelSize.x * shadowRadius;\n   float dy0 = - texelSize.y * shadowRadius;\n   float dx1 = + texelSize.x * shadowRadius;\n   float dy1 = + texelSize.y * shadowRadius;\n\n   shadow = (\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n    texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering:\n\n   shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\n  #endif\n\n  }\n\n  return shadow;\n\n }\n\n // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\n // vector suitable for 2D texture mapping. This code uses the following layout for the\n // 2D texture:\n //\n // xzXZ\n //  y Y\n //\n // Y - Positive y direction\n // y - Negative y direction\n // X - Positive x direction\n // x - Negative x direction\n // Z - Positive z direction\n // z - Negative z direction\n //\n // Source and test bed:\n // https://gist.github.com/tschw/da10c43c467ce8afd0c4\n\n vec2 cubeToUV( vec3 v, float texelSizeY ) {\n\n  // Number of texels to avoid at the edge of each square\n\n  vec3 absV = abs( v );\n\n  // Intersect unit cube\n\n  float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n  absV *= scaleToCube;\n\n  // Apply scale to avoid seams\n\n  // two texels less per square (one texel will do for NEAREST)\n  v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\n  // Unwrap\n\n  // space: -1 ... 1 range for each square\n  //\n  // #X##  dim    := ( 4 , 2 )\n  //  # #  center := ( 1 , 1 )\n\n  vec2 planar = v.xy;\n\n  float almostATexel = 1.5 * texelSizeY;\n  float almostOne = 1.0 - almostATexel;\n\n  if ( absV.z >= almostOne ) {\n\n   if ( v.z > 0.0 )\n    planar.x = 4.0 - v.x;\n\n  } else if ( absV.x >= almostOne ) {\n\n   float signX = sign( v.x );\n   planar.x = v.z * signX + 2.0 * signX;\n\n  } else if ( absV.y >= almostOne ) {\n\n   float signY = sign( v.y );\n   planar.x = v.x + 2.0 * signY + 2.0;\n   planar.y = v.z * signY - 2.0;\n\n  }\n\n  // Transform to UV space\n\n  // scale := 0.5 / dim\n  // translate := ( center + 0.5 ) / dim\n  return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\n }\n\n float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\n  vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\n  // for point lights, the uniform @vShadowCoord is re-purposed to hold\n  // the vector from the light to the world-space position of the fragment.\n  vec3 lightToPosition = shadowCoord.xyz;\n\n  // dp = normalized distance from light to fragment position\n  float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  dp += shadowBias;\n\n  // bd3D = base direction 3D\n  vec3 bd3D = normalize( lightToPosition );\n\n  #if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\n   vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\n   return (\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n    texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n   ) * ( 1.0 / 9.0 );\n\n  #else // no percentage-closer filtering\n\n   return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\n  #endif\n\n }\n\n#endif\n";
        ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n  uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n  varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n  uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n  varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n  uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n  varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): uniforms for area light shadows\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update vAreaShadowCoord with area light info\n\n #endif\n */\n\n#endif\n";
        ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n\n float shadow = 1.0;\n\n #ifdef USE_SHADOWMAP\n\n #if defined(NUM_DIR_LIGHTS) && NUM_DIR_LIGHTS > 0//Egret\n\n DirectionalLight directionalLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n  // directionalLight = directionalLights[ i ];\n  directionalLight.shadow = int(directionalLights[i * 12 + 6]);\n  directionalLight.shadowBias = directionalLights[i * 12 + 7];\n  directionalLight.shadowRadius = directionalLights[i * 12 + 8];\n  directionalLight.shadowMapSize = vec2(directionalLights[i * 12 + 9], directionalLights[i * 12 + 10]);\n  shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_SPOT_LIGHTS) && NUM_SPOT_LIGHTS > 0//Egret\n\n SpotLight spotLight;\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n  // spotLight = spotLights[ i ];\n  spotLight.shadow = int(spotLights[i * 18 + 13]);\n  spotLight.shadowBias = spotLights[i * 18 + 14];\n  spotLight.shadowRadius = spotLights[i * 18 + 15];\n  spotLight.shadowMapSize = vec2(spotLights[i * 18 + 16], spotLights[i * 18 + 17]);\n  shadow *= bool(spotLight.shadow) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\n }\n\n #endif\n\n #if defined(NUM_POINT_LIGHTS) && NUM_POINT_LIGHTS > 0//Egret\n\n PointLight pointLight;\n\n // #pragma unroll_loop\n for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n  // pointLight = pointLights[ i ];\n  pointLight.shadow = int(pointLights[i * 15 + 8]);\n  pointLight.shadowBias = pointLights[i * 15 * 9];\n  pointLight.shadowRadius = pointLights[i * 15 * 10];\n  pointLight.shadowMapSize = vec2(pointLights[i * 15 * 11],pointLights[i * 15 * 12]);\n  pointLight.shadowCameraNear = pointLights[i * 15 * 13];\n  pointLight.shadowCameraFar = pointLights[i * 15 * 14];\n  shadow *= bool(pointLight.shadow) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\n }\n\n #endif\n\n /*\n #if NUM_RECT_AREA_LIGHTS > 0\n\n  // TODO (abelnation): update shadow for Area light\n\n #endif\n */\n\n #endif\n\n return shadow;\n\n}\n";
        ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n\n mat4 boneMatX = getBoneMatrix( skinIndex.x );\n mat4 boneMatY = getBoneMatrix( skinIndex.y );\n mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n mat4 boneMatW = getBoneMatrix( skinIndex.w );\n\n#endif";
        ShaderChunk.skinning_base_vert = "#ifdef SKINNING\n    mat4 boneMatX = buildMat4(int(skinIndex.x));\n mat4 boneMatY = buildMat4(int(skinIndex.y));\n mat4 boneMatZ = buildMat4(int(skinIndex.z));\n mat4 boneMatW = buildMat4(int(skinIndex.w));\n \n    mat4 mat = boneMatX*skinWeight.x \n    + boneMatY*skinWeight.y \n    + boneMatZ*skinWeight.z \n    + boneMatW*skinWeight.w;\n    \n    highp vec4 tmpVertex = vec4((mat* position).xyz, 1.0);\n // highp vec4 tmpVertex = vec4(calcVertex(position,skinIndex,skinWeight).xyz, 1.0);\n#else\n    // tmpVertex.xyz = position.xyz;\n highp vec4 tmpVertex = vec4(position.xyz, 1.0);\n#endif";
        ShaderChunk.skinning_pars_vert = "#ifdef SKINNING\nattribute vec4 skinIndex;\nattribute vec4 skinWeight;\nuniform vec4 glstate_vec4_bones[110];\n\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n#endif";
        ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n\n uniform mat4 bindMatrix;\n uniform mat4 bindMatrixInverse;\n\n #ifdef BONE_TEXTURE\n\n  uniform sampler2D boneTexture;\n  uniform int boneTextureSize;\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   float j = i * 4.0;\n   float x = mod( j, float( boneTextureSize ) );\n   float y = floor( j / float( boneTextureSize ) );\n\n   float dx = 1.0 / float( boneTextureSize );\n   float dy = 1.0 / float( boneTextureSize );\n\n   y = dy * ( y + 0.5 );\n\n   vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n   vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n   vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n   vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\n   mat4 bone = mat4( v1, v2, v3, v4 );\n\n   return bone;\n\n  }\n\n #else\n\n  uniform mat4 boneMatrices[ MAX_BONES ];\n\n  mat4 getBoneMatrix( const in float i ) {\n\n   mat4 bone = boneMatrices[ int(i) ];\n   return bone;\n\n  }\n\n #endif\n\n#endif\n";
        ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n\n vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\n vec4 skinned = vec4( 0.0 );\n skinned += boneMatX * skinVertex * skinWeight.x;\n skinned += boneMatY * skinVertex * skinWeight.y;\n skinned += boneMatZ * skinVertex * skinWeight.z;\n skinned += boneMatW * skinVertex * skinWeight.w;\n\n transformed = ( bindMatrixInverse * skinned ).xyz;\n\n#endif\n";
        ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n\n mat4 skinMatrix = mat4( 0.0 );\n skinMatrix += skinWeight.x * boneMatX;\n skinMatrix += skinWeight.y * boneMatY;\n skinMatrix += skinWeight.z * boneMatZ;\n skinMatrix += skinWeight.w * boneMatW;\n skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\n objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\n#endif\n";
        ShaderChunk.specularmap_fragment = "float specularStrength;\n\n#ifdef USE_SPECULARMAP\n\n vec4 texelSpecular = texture2D( specularMap, vUv );\n specularStrength = texelSpecular.r;\n\n#else\n\n specularStrength = 1.0;\n\n#endif";
        ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\n uniform sampler2D specularMap;\n\n#endif";
        ShaderChunk.tbn = "mat3 tbn(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p.xyz);\n    vec3 dp2 = dFdy(p.xyz);\n    vec2 duv1 = dFdx(uv.st);\n    vec2 duv2 = dFdy(uv.st);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}";
        ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n\n#endif\n";
        ShaderChunk.tonemapping_pars_fragment = "#ifndef saturate\n #define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\n\n// exposure only\nvec3 LinearToneMapping( vec3 color ) {\n\n return toneMappingExposure * color;\n\n}\n\n// source: https://www.cs.utah.edu/~reinhard/cdrom/\nvec3 ReinhardToneMapping( vec3 color ) {\n\n color *= toneMappingExposure;\n return saturate( color / ( vec3( 1.0 ) + color ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\n // John Hable's filmic operator from Uncharted 2 video game\n color *= toneMappingExposure;\n return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n\n}\n\n// source: http://filmicgames.com/archives/75\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\n // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\n color *= toneMappingExposure;\n color = max( vec3( 0.0 ), color - 0.004 );\n return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n\n}\n";
        ShaderChunk.transpose = "mat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}";
        ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n attribute vec2 uv2;\n varying vec2 vUv2;\n\n#endif";
        ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\n vUv2 = uv2;\n\n#endif";
        ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n\n#endif";
        ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n varying vec2 vUv;\n uniform mat3 uvTransform;\n\n#endif\n";
        ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\n vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\n#endif";
        ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\n vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\n#endif\n";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var RES;
(function (RES) {
    var processor;
    (function (processor) {
        function promisify(loader, resource) {
            var _this = this;
            return new Promise(function (resolve, reject) {
                var onSuccess = function () {
                    var texture = loader['data'] ? loader['data'] : loader['response'];
                    resolve(texture);
                };
                var onError = function () {
                    var e = new RES.ResourceManagerError(1001, resource.url);
                    reject(e);
                };
                loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
            });
        }
        processor.ShaderProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var result, shaders, _i, shaders_1, shader, source, shaderSource, glTF;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, 'json')];
                            case 1:
                                result = _a.sent();
                                if (!(result.extensions.KHR_techniques_webgl.shaders && result.extensions.KHR_techniques_webgl.shaders.length === 2)) return [3 /*break*/, 6];
                                shaders = result.extensions.KHR_techniques_webgl.shaders;
                                _i = 0, shaders_1 = shaders;
                                _a.label = 2;
                            case 2:
                                if (!(_i < shaders_1.length)) return [3 /*break*/, 5];
                                shader = shaders_1[_i];
                                source = RES.host.resourceConfig["getResource"](shader.uri);
                                if (!source) return [3 /*break*/, 4];
                                return [4 /*yield*/, host.load(source)];
                            case 3:
                                shaderSource = _a.sent();
                                if (shaderSource) {
                                    shader.uri = shaderSource;
                                }
                                else {
                                    console.error("Load shader error.", shader.uri);
                                }
                                _a.label = 4;
                            case 4:
                                _i++;
                                return [3 /*break*/, 2];
                            case 5: return [3 /*break*/, 7];
                            case 6:
                                console.error("错误的Shader格式数据");
                                _a.label = 7;
                            case 7:
                                glTF = new egret3d.Shader(result, resource.name);
                                paper.Asset.register(glTF);
                                return [2 /*return*/, glTF];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.TextureDescProcessor = {
            onLoadStart: function (host, resource) {
                return host.load(resource, "json").then(function (data) {
                    var _name = data["name"];
                    var _filterMode = data["filterMode"];
                    var _format = data["format"];
                    var _mipmap = data["mipmap"];
                    var _wrap = data["wrap"];
                    var _textureFormat = 1 /* RGBA */;
                    if (_format == "RGB") {
                        _textureFormat = 2 /* RGB */;
                    }
                    else if (_format == "Gray") {
                        _textureFormat = 3 /* Gray */;
                    }
                    var _linear = true;
                    if (_filterMode.indexOf("linear") < 0) {
                        _linear = false;
                    }
                    var _repeat = false;
                    if (_wrap.indexOf("Repeat") >= 0) {
                        _repeat = true;
                    }
                    var imgResource = RES.host.resourceConfig["getResource"](_name);
                    var loader = new egret.ImageLoader();
                    loader.load(imgResource.root + imgResource.url);
                    return promisify(loader, imgResource)
                        .then(function (image) {
                        var texture = new egret3d.GLTexture2D(resource.name, image.source.width, image.source.height, _textureFormat);
                        texture.uploadImage(image.source, _mipmap, _linear, true, _repeat);
                        paper.Asset.register(texture);
                        return texture;
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.TextureProcessor = {
            onLoadStart: function (host, resource) {
                var loader = new egret.ImageLoader();
                loader.load(resource.root + resource.url);
                return promisify(loader, resource).then(function (image) {
                    var texture = new egret3d.GLTexture2D(resource.name, image.source.width, image.source.height, 1 /* RGBA */);
                    texture.uploadImage(image.source, true, true, true, true);
                    paper.Asset.register(texture);
                    return texture;
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.MaterialProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var result, _i, _a, mat, values, _b, _c, _d, key, value, r, texture, material;
                    return __generator(this, function (_e) {
                        switch (_e.label) {
                            case 0: return [4 /*yield*/, host.load(resource, 'json')];
                            case 1:
                                result = _e.sent();
                                if (!(result.materials && result.materials.length > 0)) return [3 /*break*/, 8];
                                _i = 0, _a = result.materials;
                                _e.label = 2;
                            case 2:
                                if (!(_i < _a.length)) return [3 /*break*/, 8];
                                mat = _a[_i];
                                values = mat.extensions.KHR_techniques_webgl.values;
                                _b = [];
                                for (_c in values)
                                    _b.push(_c);
                                _d = 0;
                                _e.label = 3;
                            case 3:
                                if (!(_d < _b.length)) return [3 /*break*/, 7];
                                key = _b[_d];
                                value = values[key];
                                if (!(value && typeof value === "string")) return [3 /*break*/, 6];
                                r = RES.host.resourceConfig["getResource"](value);
                                if (!r) return [3 /*break*/, 5];
                                return [4 /*yield*/, host.load(r, "TextureDesc")];
                            case 4:
                                texture = _e.sent();
                                values[key] = texture;
                                return [3 /*break*/, 6];
                            case 5:
                                console.log("Load image error.", value);
                                values[key] = egret3d.DefaultTextures.MISSING;
                                _e.label = 6;
                            case 6:
                                _d++;
                                return [3 /*break*/, 3];
                            case 7:
                                _i++;
                                return [3 /*break*/, 2];
                            case 8:
                                material = new egret3d.Material(result, resource.name);
                                paper.Asset.register(material);
                                return [2 /*return*/, material];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.MeshProcessor = {
            onLoadStart: function (host, resource) {
                return host.load(resource, RES.processor.BinaryProcessor).then(function (result) {
                    var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                    var glb;
                    if (parseResult.config.meshes) {
                        glb = new egret3d.Mesh(parseResult.config, parseResult.buffers, resource.name);
                    }
                    else {
                        glb = new egret3d.GLTFAsset();
                        glb.name = resource.name;
                        glb.config = parseResult.config;
                        for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                            var b = _a[_i];
                            glb.buffers.push(b);
                        }
                    }
                    paper.Asset.register(glb);
                    return glb;
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.AnimationProcessor = {
            onLoadStart: function (host, resource) {
                return host.load(resource, RES.processor.BinaryProcessor).then(function (result) {
                    var parseResult = egret3d.GLTFAsset.parseFromBinary(new Uint32Array(result));
                    var animation = new egret3d.GLTFAsset();
                    animation.name = resource.name;
                    animation.config = parseResult.config;
                    for (var _i = 0, _a = parseResult.buffers; _i < _a.length; _i++) {
                        var b = _a[_i];
                        animation.buffers.push(b);
                    }
                    paper.Asset.register(animation);
                    return animation;
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.PrefabProcessor = {
            onLoadStart: function (host, resource) {
                return host.load(resource, "json").then(function (data) {
                    var prefab = new paper.Prefab(resource.name);
                    return loadSubAssets(data, resource).then(function () {
                        prefab.$parse(data);
                        paper.Asset.register(prefab);
                        return prefab;
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        processor.SceneProcessor = {
            onLoadStart: function (host, resource) {
                return host.load(resource, "json").then(function (data) {
                    var rawScene = new paper.RawScene(resource.name);
                    return loadSubAssets(data, resource).then(function () {
                        rawScene.$parse(data);
                        paper.Asset.register(rawScene);
                        return rawScene;
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                var data = host.get(resource);
                data.dispose();
                return Promise.resolve();
            }
        };
        function loadSubAssets(data, resource) {
            return Promise.all(data.assets.map((function (item) {
                var r = RES.host.resourceConfig["getResource"](item);
                if (r) {
                    return RES.host.load(r);
                }
                else {
                    console.error("加载不存在的资源", item);
                    return Promise.resolve();
                }
            })));
        }
        RES.processor.map("Shader", processor.ShaderProcessor);
        RES.processor.map("Texture", processor.TextureProcessor);
        RES.processor.map("TextureDesc", processor.TextureDescProcessor);
        RES.processor.map("Material", processor.MaterialProcessor);
        RES.processor.map("Mesh", processor.MeshProcessor);
        RES.processor.map("Animation", processor.AnimationProcessor);
        RES.processor.map("Prefab", processor.PrefabProcessor);
        RES.processor.map("Scene", processor.SceneProcessor);
    })(processor = RES.processor || (RES.processor = {}));
})(RES || (RES = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var stats;
    var loop;
    /**
     * 显示调试面板
     */
    function show(container, refreshTime) {
        if (refreshTime === void 0) { refreshTime = 500; }
        if (stats == null) {
            stats = new Stats();
            stats.container.style.position = 'absolute';
            stats.container.style.left = '0px';
            stats.container.style.top = '0px';
            container.appendChild(stats.container);
        }
        else {
            container.appendChild(stats.container);
        }
        if (loop) {
            hide();
        }
        loop = setInterval(function () {
            stats.update();
        }, refreshTime);
        egret3d.Performance.enable = true;
    }
    Stats_1.show = show;
    /**
     * 关闭调试面板
     */
    function hide() {
        if (loop) {
            clearInterval(loop);
        }
        if (stats != null && stats.container.parentNode) {
            stats.container.parentNode.removeChild(stats.container);
        }
        egret3d.Performance.enable = false;
    }
    Stats_1.hide = hide;
    /**
     *
     * @author mrdoob / http://mrdoob.com/
     * @modify egret
     */
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.renderPanel = this.addPanel(new Panel('R%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            var fps = egret3d.Performance.getFPS();
            var fpsEntity = egret3d.Performance.getEntity("fps");
            var allEntity = egret3d.Performance.getEntity("all");
            var renderEntity = egret3d.Performance.getEntity("render");
            this.fpsPanel.update(fps, 100);
            this.msPanel.update(allEntity.delta, 200);
            this.renderPanel.update(Math.floor(renderEntity.delta / fpsEntity.delta * 100), 100);
            if (this.memPanel) {
                var memory = performance["memory"];
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        return Stats;
    }());
    __reflect(Stats.prototype, "Stats");
    /**
     *
     */
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    /**
     * device input manager
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 用户输入设备管理器
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var InputManager = (function () {
        function InputManager() {
        }
        /**
         *
         */
        InputManager.init = function (canvas) {
            if (this._isInit) {
                return;
            }
            this._isInit = true;
            this.keyboard = new egret3d.KeyboardDevice(window);
            this.mouse = new egret3d.MouseDevice(canvas);
            this.touch = new egret3d.TouchDevice(canvas);
        };
        /**
         *
         */
        InputManager.update = function (deltaTime) {
            this.keyboard.update();
            this.mouse.update();
            this.touch.update();
        };
        /**
         * is pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否正在被点击或者触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.isPressed = function () {
            if (this.mouse.isPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.MOVED || t.phase == egret3d.TouchPhase.STATIONARY) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次点击或触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasPressed = function () {
            if (this.mouse.wasPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.BEGAN) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was released
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次鼠标或触摸释放。
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasReleased = function () {
            if (this.mouse.wasReleased(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.ENDED || t.phase == egret3d.TouchPhase.CANCELED) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * get touch point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取点击或触摸位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.getTouchPoint = function () {
            var t = this.touch.getTouch(0);
            if (t) {
                this._touchPoint.x = t.position.x;
                this._touchPoint.y = t.position.y;
            }
            else {
                this._touchPoint.x = this.mouse.position.x;
                this._touchPoint.y = this.mouse.position.y;
            }
            return this._touchPoint;
        };
        InputManager._isInit = false;
        InputManager._touchPoint = new egret3d.Vector2();
        return InputManager;
    }());
    egret3d.InputManager = InputManager;
    __reflect(InputManager.prototype, "egret3d.InputManager");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _keyCodeToKeyIdentifier = {
        'TAB': 9,
        'ENTER': 13,
        'SHIFT': 16,
        'CONTROL': 17,
        'ALT': 18,
        'ESCAPE': 27,
        'LEFT': 37,
        'UP': 38,
        'RIGHT': 39,
        'DOWN': 40,
        'DELETE': 46,
        'WIN': 91
    };
    /**
     * keyboard input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 键盘输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var KeyboardDevice = (function () {
        /**
         *
         */
        function KeyboardDevice(element, options) {
            if (options === void 0) { options = { preventDefault: false, stopPropagation: false }; }
            this._element = null;
            this._keymap = {};
            this._lastmap = {};
            this._keyDownHandler = this._handleKeyDown.bind(this);
            this._keyUpHandler = this._handleKeyUp.bind(this);
            this._keyPressHandler = this._handleKeyPress.bind(this);
            this._cacheKeyCodeMap = {};
            this.attach(element);
            this.preventDefault = options.preventDefault;
            this.stopPropagation = options.stopPropagation;
        }
        KeyboardDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("keydown", this._keyDownHandler, false);
            this._element.addEventListener("keypress", this._keyPressHandler, false);
            this._element.addEventListener("keyup", this._keyUpHandler, false);
        };
        KeyboardDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("keydown", this._keyDownHandler, false);
            this._element.removeEventListener("keypress", this._keyPressHandler, false);
            this._element.removeEventListener("keyup", this._keyUpHandler, false);
            this._element = null;
        };
        KeyboardDevice.prototype._handleKeyDown = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            this._keymap[id] = true;
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyPress = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            // do nothing
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyUp = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            delete this._keymap[id];
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._toKeyIdentifier = function (keyCode) {
            var code;
            if (typeof (keyCode) == "string") {
                var upperCode = keyCode.toUpperCase();
                if (!this._cacheKeyCodeMap[keyCode]) {
                    var _code = _keyCodeToKeyIdentifier[upperCode] || upperCode.charCodeAt(0);
                    this._cacheKeyCodeMap[upperCode] = _code;
                }
                code = this._cacheKeyCodeMap[upperCode];
            }
            else {
                code = keyCode;
            }
            // Convert to hex and add leading 0's
            var hex = code.toString(16).toUpperCase();
            var length = hex.length;
            for (var count = 0; count < (4 - length); count++) {
                hex = '0' + hex;
            }
            return 'U+' + hex;
        };
        /**
         *
         */
        KeyboardDevice.prototype.update = function () {
            var prop;
            for (prop in this._lastmap) {
                delete this._lastmap[prop];
            }
            for (prop in this._keymap) {
                if (this._keymap.hasOwnProperty(prop)) {
                    this._lastmap[prop] = this._keymap[prop];
                }
            }
        };
        /**
         * is pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.isPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return this._keymap[id];
        };
        /**
         * was pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return (this._keymap[id] && !this._lastmap[id]);
        };
        /**
         * was released
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasReleased = function (key) {
            var id = this._toKeyIdentifier(key);
            return (!this._keymap[id] && this._lastmap[id]);
        };
        return KeyboardDevice;
    }());
    egret3d.KeyboardDevice = KeyboardDevice;
    __reflect(KeyboardDevice.prototype, "egret3d.KeyboardDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * mouse input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 鼠标输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MouseDevice = (function (_super) {
        __extends(MouseDevice, _super);
        /**
         *
         */
        function MouseDevice(element) {
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            /**
             * mouse position
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.position = new egret3d.Vector2();
            /**
             * mouse wheel value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标滚轮值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.wheel = 0;
            _this._buttons = [false, false, false];
            _this._lastbuttons = [false, false, false];
            _this._element = null;
            _this._upHandler = _this._handleUp.bind(_this);
            _this._moveHandler = _this._handleMove.bind(_this);
            _this._downHandler = _this._handleDown.bind(_this);
            _this._wheelHandler = _this._handleWheel.bind(_this);
            _this._contextMenuHandler = function (event) { event.preventDefault(); };
            _this.attach(element);
            return _this;
        }
        /**
         *
         */
        MouseDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        MouseDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        /**
         * disable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 禁用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.disableContextMenu = function () {
            if (!this._element)
                return;
            this._element.addEventListener("contextmenu", this._contextMenuHandler);
        };
        /**
         * enable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 启用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.enableContextMenu = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("contextmenu", this._contextMenuHandler);
        };
        MouseDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("mouseup", this._upHandler, false);
            this._element.addEventListener("mousemove", this._moveHandler, false);
            this._element.addEventListener("mousedown", this._downHandler, false);
            this._element.addEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.addEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
        };
        MouseDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("mouseup", this._upHandler, false);
            this._element.removeEventListener("mousemove", this._moveHandler, false);
            this._element.removeEventListener("mousedown", this._downHandler, false);
            this._element.removeEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.removeEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
            this._element = null;
        };
        /**
         *
         */
        MouseDevice.prototype.update = function () {
            // Copy current button state
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2];
            // set wheel to 0
            this.wheel = 0;
        };
        /**
         * is pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.isPressed = function (button) {
            return this._buttons[button];
        };
        /**
         * was pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasPressed = function (button) {
            return (this._buttons[button] && !this._lastbuttons[button]);
        };
        /**
         * was released
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasReleased = function (button) {
            return (!this._buttons[button] && this._lastbuttons[button]);
        };
        MouseDevice.prototype._handleUp = function (event) {
            // disable released button
            this._buttons[event.button] = false;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mouseup", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleMove = function (event) {
            this.convertPosition(event, this.position);
            if (this._buttons[event.button]) {
                this.dispatchEvent({ type: "mousemove", x: this.position.x, y: this.position.y, identifier: event.button });
            }
        };
        MouseDevice.prototype._handleDown = function (event) {
            // Store which button has affected
            this._buttons[event.button] = true;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mousedown", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleWheel = function (event) {
            // FF uses 'detail' and returns a value in 'no. of lines' to scroll
            // WebKit and Opera use 'wheelDelta', WebKit goes in multiples of 120 per wheel notch
            if (event.detail) {
                this.wheel = -1 * event.detail;
            }
            else if (event.wheelDelta) {
                this.wheel = event.wheelDelta / 120;
            }
            else {
                this.wheel = 0;
            }
        };
        return MouseDevice;
    }(egret3d.EventDispatcher));
    egret3d.MouseDevice = MouseDevice;
    __reflect(MouseDevice.prototype, "egret3d.MouseDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * touch phase type
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸状态
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPhase;
    (function (TouchPhase) {
        /**
         * touch began
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸开始
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["BEGAN"] = 0] = "BEGAN";
        /**
         * touch moved
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸移动
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["MOVED"] = 1] = "MOVED";
        /**
         * touch stationary
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸静止
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["STATIONARY"] = 2] = "STATIONARY";
        /**
         * touch ended
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸结束
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["ENDED"] = 3] = "ENDED";
        /**
         * touch canceled
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸取消
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["CANCELED"] = 4] = "CANCELED";
    })(TouchPhase = egret3d.TouchPhase || (egret3d.TouchPhase = {}));
    /**
     * touch point
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸点信息
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPoint = (function () {
        function TouchPoint() {
            this.altitudeAngle = Math.PI / 2; // Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.
            this.azimuthAngle = 0; // Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.
            this.deltaPosition = new egret3d.Vector2(); // The position delta since last change.
            // public deltaTime:number = 0; // TODO Amount of time that has passed since the last recorded change in Touch values.
            this.fingerId = 0; // The unique index for the touch.
            this.maximumPossiblePressure = 1.0; // The maximum possible pressure value for a platform. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.position = new egret3d.Vector2(); // The position of the touch in pixel coordinates.
            this.pressure = 1.0; //	The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.radius = new egret3d.Vector2(); // ADD: different from Unity
            // public radius:number = 0; // DELETE: An estimated value of the radius of a touch. Add radiusletiance to get the maximum touch size, subtract it to get the minimum touch size.
            // public radiusletiance:number = 0; // DELETE: The amount that the radius leties by for a touch.
            // public rawPosition:Vector2 = new Vector2(); // DELETE: The raw position used for the touch.
            // public tapCount:number = 0; // TODO Number of taps.
            this.type = "Direct"; // A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.
        }
        /**
         *
         */
        TouchPoint.prototype.set = function (touch, phase, device) {
            this.altitudeAngle = touch.rotationAngle;
            this.azimuthAngle = touch.rotationAngle;
            if (phase == TouchPhase.BEGAN || phase == TouchPhase.STATIONARY) {
                this.deltaPosition.x = 0;
                this.deltaPosition.y = 0;
            }
            else {
                device.convertPosition(touch, this.deltaPosition);
                egret3d.Vector2.subtract(this.deltaPosition, this.position, this.deltaPosition);
            }
            // this.deltaTime;
            this.fingerId = touch.identifier;
            this.phase = phase;
            device.convertPosition(touch, this.position);
            this.pressure = touch.force;
            this.radius.x = touch.radiusX;
            this.radius.y = touch.radiusY;
            // this.tapCount;
        };
        /**
         *
         */
        TouchPoint.create = function () {
            return this._pointPool.pop() || new TouchPoint();
        };
        /**
         *
         */
        TouchPoint.release = function (touchPoint) {
            this._pointPool.push(touchPoint);
        };
        TouchPoint._pointPool = [];
        return TouchPoint;
    }());
    egret3d.TouchPoint = TouchPoint;
    __reflect(TouchPoint.prototype, "egret3d.TouchPoint");
    /**
     * touch input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchDevice = (function (_super) {
        __extends(TouchDevice, _super);
        /**
         *
         */
        function TouchDevice(element, options) {
            if (options === void 0) { options = { preventDefault: true, stopPropagation: true }; }
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            _this._touchesMap = {};
            _this._touches = [];
            /**
             * touch count
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前触摸点的数量
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.touchCount = 0;
            _this._startHandler = _this._handleTouchStart.bind(_this);
            _this._endHandler = _this._handleTouchEnd.bind(_this);
            _this._moveHandler = _this._handleTouchMove.bind(_this);
            _this._cancelHandler = _this._handleTouchCancel.bind(_this);
            _this._element = null;
            _this.attach(element);
            _this.preventDefault = options.preventDefault;
            _this.stopPropagation = options.stopPropagation;
            return _this;
        }
        /**
         *
         */
        TouchDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        TouchDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        TouchDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener('touchstart', this._startHandler, false);
            this._element.addEventListener('touchend', this._endHandler, false);
            this._element.addEventListener('touchmove', this._moveHandler, false);
            this._element.addEventListener('touchcancel', this._cancelHandler, false);
        };
        TouchDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener('touchstart', this._startHandler, false);
            this._element.removeEventListener('touchend', this._endHandler, false);
            this._element.removeEventListener('touchmove', this._moveHandler, false);
            this._element.removeEventListener('touchcancel', this._cancelHandler, false);
            this._element = null;
        };
        /**
         *
         */
        TouchDevice.prototype.update = function () {
            for (var i in this._touchesMap) {
                var touch = this._touchesMap[i];
                if (touch.phase === TouchPhase.BEGAN) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.MOVED) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.ENDED || touch.phase === TouchPhase.CANCELED) {
                    delete this._touchesMap[i];
                    var index = this._touches.indexOf(touch);
                    if (index > -1) {
                        this._touches.splice(index, 1);
                    }
                    this.touchCount--;
                }
            }
        };
        /**
         * get touch point
         * @param index touch index
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取触摸点
         * @param index 触摸点的索引
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchDevice.prototype.getTouch = function (index) {
            return this._touches[index];
        };
        TouchDevice.prototype._getTouch = function (identifier) {
            var touchPoint = this._touchesMap[identifier];
            if (!touchPoint) {
                touchPoint = TouchPoint.create();
                this._touchesMap[identifier] = touchPoint;
                this._touches.push(touchPoint);
                this.touchCount++;
            }
            return touchPoint;
        };
        TouchDevice.prototype._handleTouchStart = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.BEGAN, this);
                this.dispatchEvent({ type: "touchstart", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchEnd = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.ENDED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchMove = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.MOVED, this);
                this.dispatchEvent({ type: "touchmove", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchCancel = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.CANCELED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault && event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        return TouchDevice;
    }(egret3d.EventDispatcher));
    egret3d.TouchDevice = TouchDevice;
    __reflect(TouchDevice.prototype, "egret3d.TouchDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._ibos = [];
            /**
             * @internal
             */
            _this._vbo = null;
            return _this;
        }
        Mesh.create = function (vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode) {
            return new Mesh(vertexCountOrConfig, indexCountOrBuffers, attributeNamesOrName, attributeTypes, drawMode);
        };
        Mesh.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            var webgl = egret3d.WebGLCapabilities.webgl;
            for (var _i = 0, _a = this._ibos; _i < _a.length; _i++) {
                var ibo = _a[_i];
                webgl.deleteBuffer(ibo);
            }
            if (this._vbo) {
                webgl.deleteBuffer(this._vbo);
            }
            this._ibos.length = 0;
            this._vbo = null;
            return true;
        };
        Mesh.prototype._createBuffer = function () {
            if (this._vbo) {
                return;
            }
            var vertexBufferViewAccessor = this.getAccessor(0);
            var vertexBuffer = this.createTypeArrayFromBufferView(this.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
            var webgl = egret3d.WebGLCapabilities.webgl;
            var vbo = webgl.createBuffer();
            if (vbo) {
                this._vbo = vbo;
                var attributeNames = [];
                for (var k in this._glTFMesh.primitives[0].attributes) {
                    attributeNames.push(k);
                }
                var subMeshIndex = 0;
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    if (primitive.indices !== undefined) {
                        if (this._ibos.length === subMeshIndex) {
                            var ibo = webgl.createBuffer();
                            if (ibo) {
                                this._ibos.push(ibo);
                                webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                                webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this.getBufferLength(this.getAccessor(primitive.indices)), this.drawMode);
                                this.uploadSubIndexBuffer(subMeshIndex);
                            }
                            else {
                                console.error("Create webgl element buffer error.");
                            }
                        }
                        else {
                            console.error("Error arguments.");
                        }
                    }
                    else if (this._ibos.length > 0) {
                        console.error("Error arguments.");
                    }
                    subMeshIndex++;
                }
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, vertexBuffer.byteLength, this.drawMode);
                this.uploadVertexBuffer(attributeNames);
            }
            else {
                console.error("Create webgl buffer error.");
            }
        };
        /**
         *
         */
        Mesh.prototype.uploadVertexBuffer = function (uploadAttributes, offset, count) {
            if (!this._vbo) {
                return;
            }
            offset = offset || 0;
            count = count || 0;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var attributes = this._glTFMesh.primitives[0].attributes;
            webgl.bindBuffer(webgl.ARRAY_BUFFER, this._vbo);
            if (!uploadAttributes) {
                uploadAttributes = [];
                for (var attributeName in this._glTFMesh.primitives[0].attributes) {
                    uploadAttributes.push(attributeName);
                }
            }
            if (Array.isArray(uploadAttributes)) {
                for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                    var attributeName = uploadAttributes_1[_i];
                    var accessorIndex = attributes[attributeName];
                    if (accessorIndex !== undefined) {
                        var accessor = this.getAccessor(accessorIndex);
                        var bufferOffset = this.getBufferOffset(accessor);
                        var subVertexBuffer = this.createTypeArrayFromAccessor(accessor, offset, count);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
            }
            else {
                var accessorIndex = attributes[uploadAttributes];
                if (accessorIndex !== undefined) {
                    var accessor = this.getAccessor(accessorIndex);
                    var bufferOffset = this.getBufferOffset(accessor);
                    var subVertexBuffer = this.createTypeArrayFromAccessor(accessor);
                    webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
        };
        /**
         *
         */
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                if (!this._vbo) {
                    return;
                }
                var webgl = egret3d.WebGLCapabilities.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                if (primitive.indices !== undefined) {
                    var accessor = this.getAccessor(primitive.indices);
                    var subIndexBuffer = this.createTypeArrayFromAccessor(accessor);
                    var ibo = this._ibos[subMeshIndex];
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                    webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                }
                else {
                    console.warn("Error arguments.");
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        return Mesh;
    }(egret3d.BaseMesh));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var TextureFormatEnum;
    (function (TextureFormatEnum) {
        TextureFormatEnum[TextureFormatEnum["RGBA"] = 1] = "RGBA";
        TextureFormatEnum[TextureFormatEnum["RGB"] = 2] = "RGB";
        TextureFormatEnum[TextureFormatEnum["Gray"] = 3] = "Gray";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGB"] = 4] = "PVRTC4_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC4_RGBA"] = 4] = "PVRTC4_RGBA";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGB"] = 4] = "PVRTC2_RGB";
        TextureFormatEnum[TextureFormatEnum["PVRTC2_RGBA"] = 4] = "PVRTC2_RGBA";
    })(TextureFormatEnum = egret3d.TextureFormatEnum || (egret3d.TextureFormatEnum = {}));
    var GLTexture = (function (_super) {
        __extends(GLTexture, _super);
        function GLTexture(name, width, height) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            var _this = _super.call(this, name) || this;
            _this._width = width;
            _this._height = height;
            _this._texture = egret3d.WebGLCapabilities.webgl.createTexture();
            return _this;
        }
        Object.defineProperty(GLTexture.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GLTexture.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return GLTexture;
    }(egret3d.Texture));
    egret3d.GLTexture = GLTexture;
    __reflect(GLTexture.prototype, "egret3d.GLTexture", ["egret3d.ITexture"]);
    /**
     *
     */
    var GLTexture2D = (function (_super) {
        __extends(GLTexture2D, _super);
        function GLTexture2D(name, width, height, format) {
            if (name === void 0) { name = ""; }
            if (width === void 0) { width = 0; }
            if (height === void 0) { height = 0; }
            if (format === void 0) { format = 1 /* RGBA */; }
            var _this = _super.call(this, name, width, height) || this;
            //
            _this._mipmap = false;
            //
            _this._format = format;
            return _this;
        }
        GLTexture2D.createColorTexture = function (name, r, g, b) {
            var mipmap = false;
            var linear = true;
            var width = 1;
            var height = 1;
            var data = new Uint8Array([r, g, b, 255]);
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, false);
            return texture;
        };
        GLTexture2D.createGridTexture = function (name) {
            var mipmap = false;
            var linear = true;
            var width = 256;
            var height = 256;
            var data = new Uint8Array(width * width * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    data[seek] = data[seek + 1] = data[seek + 2] = bool ? 0 : 255;
                    data[seek + 3] = 255;
                }
            }
            var texture = new GLTexture2D(name, width, height, 1 /* RGBA */);
            texture.uploadImage(data, mipmap, linear, true, false);
            return texture;
        };
        GLTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this._mipmap = mipmap;
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this._texture);
            var formatGL = webgl.RGBA;
            if (this._format == 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (this._format == 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            //
            if (ArrayBuffer.isView(img)) {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, this._width, this._height, 0, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            else {
                webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, formatGL, webgl.UNSIGNED_BYTE, img);
            }
            if (mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            var wrap_s_param = webgl.CLAMP_TO_EDGE;
            var wrap_t_param = webgl.CLAMP_TO_EDGE;
            if (repeat) {
                wrap_s_param = mirroredU ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
                wrap_t_param = mirroredV ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
            }
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrap_s_param);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrap_t_param);
        };
        GLTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this._format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this._format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            if (this._mipmap) {
                len = len * (1 - Math.pow(0.25, 10)) / 0.75;
            }
            return len;
        };
        GLTexture2D.prototype.dispose = function () {
            if (!_super.prototype.dispose.call(this)) {
                return false;
            }
            if (this._texture != null) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this._texture);
                this._texture = null;
            }
            return true;
        };
        GLTexture2D.prototype.getReader = function (redOnly) {
            if (redOnly === void 0) { redOnly = false; }
            if (this._reader != null) {
                if (this._reader.gray != redOnly) {
                    throw new Error("get param diff with this.reader");
                }
                return this._reader;
            }
            if (this._format != 1 /* RGBA */) {
                throw new Error("only rgba texture can read");
            }
            if (this._texture == null) {
                return null;
            }
            if (this._reader == null)
                this._reader = new TextureReader(this._texture, this._width, this._height, redOnly);
            return this._reader;
        };
        return GLTexture2D;
    }(GLTexture));
    egret3d.GLTexture2D = GLTexture2D;
    __reflect(GLTexture2D.prototype, "egret3d.GLTexture2D");
    var RenderTarget = (function () {
        function RenderTarget(width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            var webgl = egret3d.WebGLCapabilities.webgl;
            this._width = width;
            this._height = height;
            this._texture = webgl.createTexture();
            this._fbo = webgl.createFramebuffer();
            this._fbo["width"] = width;
            this._fbo["height"] = height;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            if (depth || stencil) {
                this._renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this._renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this._renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
        }
        RenderTarget.prototype.use = function () { };
        RenderTarget.prototype.dispose = function () {
            if (this._texture != null) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.deleteFramebuffer(this._renderbuffer);
                webgl.deleteTexture(this._texture);
                this._renderbuffer = null;
                this._texture = null;
            }
        };
        RenderTarget.prototype.caclByteLength = function () {
            return this.width * this.height * 4;
        };
        Object.defineProperty(RenderTarget.prototype, "texture", {
            get: function () {
                return this._texture;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderTarget.prototype, "width", {
            get: function () {
                return this._width;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(RenderTarget.prototype, "height", {
            get: function () {
                return this._height;
            },
            enumerable: true,
            configurable: true
        });
        return RenderTarget;
    }());
    egret3d.RenderTarget = RenderTarget;
    __reflect(RenderTarget.prototype, "egret3d.RenderTarget", ["egret3d.IRenderTarget", "egret3d.ITexture"]);
    var GlRenderTarget = (function (_super) {
        __extends(GlRenderTarget, _super);
        function GlRenderTarget(width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            var _this = _super.call(this, width, height, depth, stencil) || this;
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_2D, _this.texture);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, _this.texture, 0);
            return _this;
        }
        GlRenderTarget.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
        };
        return GlRenderTarget;
    }(RenderTarget));
    egret3d.GlRenderTarget = GlRenderTarget;
    __reflect(GlRenderTarget.prototype, "egret3d.GlRenderTarget");
    var GlRenderTargetCube = (function (_super) {
        __extends(GlRenderTargetCube, _super);
        function GlRenderTargetCube(width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            var _this = _super.call(this, width, height, depth, stencil) || this;
            _this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, _this.texture);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            for (var i = 0; i < 6; i++) {
                webgl.texImage2D(webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + _this.activeCubeFace, _this.texture, 0);
            return _this;
        }
        GlRenderTargetCube.prototype.use = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this._fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        };
        return GlRenderTargetCube;
    }(RenderTarget));
    egret3d.GlRenderTargetCube = GlRenderTargetCube;
    __reflect(GlRenderTargetCube.prototype, "egret3d.GlRenderTargetCube");
    var TextureReader = (function () {
        function TextureReader(texRGBA, width, height, gray) {
            if (gray === void 0) { gray = true; }
            this.gray = gray;
            this.width = width;
            this.height = height;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var fbo = webgl.createFramebuffer();
            var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
            var readData = new Uint8Array(this.width * this.height * 4);
            readData[0] = 2;
            webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
            webgl.deleteFramebuffer(fbo);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
            if (gray) {
                this.data = new Uint8Array(this.width * this.height);
                for (var i = 0; i < width * height; i++) {
                    this.data[i] = readData[i * 4];
                }
            }
            else {
                this.data = readData;
            }
        }
        TextureReader.prototype.getPixel = function (u, v) {
            var x = (u * this.width) | 0;
            var y = (v * this.height) | 0;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height) {
                return 0;
            }
            if (this.gray) {
                return this.data[y * this.width + x];
            }
            else {
                var i = (y * this.width + x) * 4;
                return egret3d.Color.create(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
            }
        };
        return TextureReader;
    }());
    egret3d.TextureReader = TextureReader;
    __reflect(TextureReader.prototype, "egret3d.TextureReader");
    var WriteableTexture2D = (function () {
        function WriteableTexture2D(format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = 0;
            this.height = 0;
            var webgl = egret3d.WebGLCapabilities.webgl;
            this.texture = webgl.createTexture();
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            this.format = format;
            var formatGL = webgl.RGBA;
            if (format == 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (format == 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            var data = null;
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, webgl.UNSIGNED_BYTE, data);
            if (linear) {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
            }
            if (repeat) {
                if (mirroredU) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.REPEAT);
                }
                if (mirroredV) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.REPEAT);
                }
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);
            }
        }
        WriteableTexture2D.prototype.dispose = function () {
            if (this.texture != null) {
                egret3d.WebGLCapabilities.webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        WriteableTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            return len;
        };
        return WriteableTexture2D;
    }());
    egret3d.WriteableTexture2D = WriteableTexture2D;
    __reflect(WriteableTexture2D.prototype, "egret3d.WriteableTexture2D", ["egret3d.ITexture"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0; //
    /**
     * @internal
     * WebGLProgram的包装类
     */
    var GlProgram = (function () {
        function GlProgram(webglProgram) {
            this.id = _hashCode++;
            this.attributes = [];
            this.contextUniforms = [];
            this.uniforms = [];
            this.program = webglProgram;
        }
        return GlProgram;
    }());
    egret3d.GlProgram = GlProgram;
    __reflect(GlProgram.prototype, "egret3d.GlProgram");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL 渲染系统
     */
    var WebGLRenderSystem = (function (_super) {
        __extends(WebGLRenderSystem, _super);
        function WebGLRenderSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: egret3d.Egret2DRenderer }
                ],
                [
                    { componentClass: [egret3d.DirectionalLight, egret3d.SpotLight, egret3d.PointLight] }
                ]
            ];
            _this._drawCalls = egret3d.DrawCalls.getInstance(egret3d.DrawCalls);
            _this._renderState = egret3d.WebGLRenderState.getInstance(egret3d.WebGLRenderState);
            _this._camerasAndLights = egret3d.CamerasAndLights.getInstance(egret3d.CamerasAndLights);
            _this._lightCamera = _this._globalGameObject.getOrAddComponent(egret3d.Camera);
            //
            _this._filteredLights = [];
            _this._cacheContextVersion = -1;
            _this._cacheSubMeshIndex = -1;
            _this._cacheMaterialVerision = -1;
            _this._cacheContext = null;
            _this._cacheMesh = null;
            _this._cacheMaterial = null;
            return _this;
        }
        WebGLRenderSystem.prototype._updateContextUniforms = function (program, context, technique, forceUpdate) {
            var needUpdate = this._cacheContext !== context || this._cacheContextVersion !== context.version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheContext = context;
            this._cacheContextVersion = context.version;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var uniforms = technique.uniforms;
            var glUniforms = program.contextUniforms;
            for (var _i = 0, glUniforms_1 = glUniforms; _i < glUniforms_1.length; _i++) {
                var glUniform = glUniforms_1[_i];
                var uniform = uniforms[glUniform.name];
                if (!uniform.semantic) {
                    continue;
                }
                var location_3 = glUniform.location;
                switch (uniform.semantic) {
                    case "MODEL" /* MODEL */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_m.rawData);
                        break;
                    case "VIEW" /* VIEW */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_v.rawData);
                        break;
                    case "PROJECTION" /* PROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_p.rawData);
                        break;
                    case "MODELVIEW" /* MODELVIEW */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_mv.rawData);
                        break;
                    case "MODELVIEWINVERSE" /* MODELVIEWINVERSE */:
                        webgl.uniformMatrix3fv(location_3, false, context.matrix_mv_inverse.rawData);
                        break;
                    case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_vp.rawData);
                        break;
                    case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_3, false, context.matrix_mvp.rawData);
                        break;
                    case "_CAMERA_POS" /* _CAMERA_POS */:
                        webgl.uniform3fv(location_3, context.cameraPosition);
                        break;
                    case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                        webgl.uniform3fv(location_3, context.cameraForward);
                        break;
                    case "CAMERA_UP" /* _CAMERA_UP */:
                        webgl.uniform3fv(location_3, context.cameraUp);
                        break;
                    case "_LIGHTCOUNT" /* _LIGHTCOUNT */:
                        webgl.uniform1f(location_3, context.lightCount);
                        break;
                    case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                        if (context.directLightCount > 0) {
                            webgl.uniform1fv(location_3, context.directLightArray);
                        }
                        break;
                    case "_POINTLIGHTS" /* _POINTLIGHTS */:
                        if (context.pointLightCount > 0) {
                            webgl.uniform1fv(location_3, context.pointLightArray);
                        }
                        break;
                    case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                        if (context.spotLightCount > 0) {
                            webgl.uniform1fv(location_3, context.spotLightArray);
                        }
                        break;
                    case "_AMBIENTLIGHTCOLOR" /* _AMBIENTLIGHTCOLOR */:
                        webgl.uniform3fv(location_3, context.ambientLightColor);
                        break;
                    case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.directShadowMatrix);
                        break;
                    case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.spotShadowMatrix);
                        break;
                    case "_POINTSHADOWMAT" /* _POINTSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_3, false, context.pointShadowMatrix);
                        break;
                    case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                        var directShadowLen = context.directShadowMaps.length;
                        if (directShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.directShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.directShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                        var pointShadowLen = context.pointShadowMaps.length;
                        if (pointShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.pointShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.pointShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                        var spotShadowLen = context.spotShadowMaps.length;
                        if (spotShadowLen > 0 && glUniform.textureUnits) {
                            var units = glUniform.textureUnits;
                            webgl.uniform1iv(location_3, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.spotShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.spotShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                        if (glUniform.textureUnits && glUniform.textureUnits.length === 1 && context.lightmap) {
                            var unit = glUniform.textureUnits[0];
                            webgl.uniform1i(location_3, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, context.lightmap._texture);
                        }
                        else {
                            console.error("Error texture unit");
                        }
                        break;
                    case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                        webgl.uniform1f(location_3, context.lightmapIntensity);
                        break;
                    case "_LIGHTMAPOFFSET" /* _LIGHTMAPOFFSET */:
                        if (context.lightmapOffset) {
                            webgl.uniform4fv(location_3, context.lightmapOffset);
                        }
                        else {
                            console.debug("Error light map scale and offset.");
                        }
                        break;
                    case "_LIGHTMAPUV" /* _LIGHTMAPUV */:
                        webgl.uniform1f(location_3, context.lightmapUV);
                        break;
                    case "_BONESVEC4" /* _BONESVEC4 */:
                        webgl.uniform4fv(location_3, context.boneData);
                        break;
                    case "_REFERENCEPOSITION" /* _REFERENCEPOSITION */:
                        webgl.uniform4fv(location_3, context.lightPosition);
                        break;
                    case "_NEARDICTANCE" /* _NEARDICTANCE */:
                        webgl.uniform1f(location_3, context.lightShadowCameraNear);
                        break;
                    case "_FARDISTANCE" /* _FARDISTANCE */:
                        webgl.uniform1f(location_3, context.lightShadowCameraFar);
                        break;
                    default:
                        console.warn("不识别的Uniform语义:" + uniform.semantic);
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateUniforms = function (program, material, technique, forceUpdate) {
            var needUpdate = this._cacheMaterial !== material || this._cacheMaterialVerision !== material._version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheMaterial = material;
            this._cacheMaterialVerision = material._version;
            var webgl = egret3d.WebGLCapabilities.webgl;
            var unifroms = technique.uniforms;
            var glUniforms = program.uniforms;
            for (var _i = 0, glUniforms_2 = glUniforms; _i < glUniforms_2.length; _i++) {
                var glUniform = glUniforms_2[_i];
                var uniform = unifroms[glUniform.name];
                if (uniform.semantic) {
                    continue;
                }
                var location_4 = glUniform.location;
                var value = uniform.value;
                switch (uniform.type) {
                    case 35670 /* BOOL */:
                    case 5124 /* INT */:
                        if (glUniform.size > 1) {
                            webgl.uniform1iv(location_4, value);
                        }
                        else {
                            webgl.uniform1i(location_4, value);
                        }
                        break;
                    case 35671 /* BOOL_VEC2 */:
                    case 35667 /* INT_VEC2 */:
                        webgl.uniform2iv(location_4, value);
                        break;
                    case 35672 /* BOOL_VEC3 */:
                    case 35668 /* INT_VEC3 */:
                        webgl.uniform3iv(location_4, value);
                        break;
                    case 35673 /* BOOL_VEC4 */:
                    case 35669 /* INT_VEC4 */:
                        webgl.uniform4iv(location_4, value);
                        break;
                    case 5126 /* FLOAT */:
                        if (glUniform.size > 1) {
                            webgl.uniform1fv(location_4, value);
                        }
                        else {
                            webgl.uniform1f(location_4, value);
                        }
                        break;
                    case 35664 /* FLOAT_VEC2 */:
                        webgl.uniform2fv(location_4, value);
                        break;
                    case 35665 /* FLOAT_VEC3 */:
                        webgl.uniform3fv(location_4, value);
                        break;
                    case 35666 /* FLOAT_VEC4 */:
                        webgl.uniform4fv(location_4, value);
                        break;
                    case 35674 /* FLOAT_MAT2 */:
                        webgl.uniformMatrix2fv(location_4, false, value);
                        break;
                    case 35675 /* FLOAT_MAT3 */:
                        webgl.uniformMatrix3fv(location_4, false, value);
                        break;
                    case 35676 /* FLOAT_MAT4 */:
                        webgl.uniformMatrix4fv(location_4, false, value);
                        break;
                    case 35678 /* SAMPLER_2D */:
                        if (glUniform.textureUnits && glUniform.textureUnits.length === 1) {
                            var unit = glUniform.textureUnits[0];
                            webgl.uniform1i(location_4, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, value._texture);
                        }
                        else {
                            console.error("Error texture unit");
                        }
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateAttributes = function (program, mesh, subMeshIndex, technique, forceUpdate) {
            var needUpdate = this._cacheSubMeshIndex !== subMeshIndex || this._cacheMesh !== mesh || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheSubMeshIndex = subMeshIndex;
            this._cacheMesh = mesh;
            if (0 <= subMeshIndex && subMeshIndex < mesh.glTFMesh.primitives.length) {
                var primitive = mesh.glTFMesh.primitives[subMeshIndex];
                var gl = egret3d.WebGLCapabilities.webgl;
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh._vbo);
                var glAttributes = program.attributes;
                var attributes = technique.attributes;
                for (var _i = 0, glAttributes_1 = glAttributes; _i < glAttributes_1.length; _i++) {
                    var glAttribute = glAttributes_1[_i];
                    var attribute = attributes[glAttribute.name];
                    var location_5 = glAttribute.location;
                    var accessorIndex = primitive.attributes[attribute.semantic];
                    if (accessorIndex !== undefined) {
                        var accessor = mesh.getAccessor(accessorIndex);
                        var bufferOffset = mesh.getBufferOffset(accessor);
                        var typeCount = mesh.getAccessorTypeCount(accessor.type);
                        gl.vertexAttribPointer(location_5, typeCount, accessor.componentType, accessor.normalized ? true : false, 0, bufferOffset); //TODO normalized应该来源于mesh，应该还没有
                        gl.enableVertexAttribArray(location_5);
                    }
                    else {
                        gl.disableVertexAttribArray(location_5);
                    }
                }
                var ibo = mesh._ibos[subMeshIndex];
                if (ibo) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        WebGLRenderSystem.prototype._drawCall = function (drawCall) {
            var webgl = egret3d.WebGLCapabilities.webgl;
            var mesh = drawCall.mesh;
            var primitive = mesh.glTFMesh.primitives[drawCall.subMeshIndex];
            var vertexAccessor = mesh.getAccessor(0);
            var bufferOffset = mesh.getBufferOffset(vertexAccessor);
            if (primitive.indices !== undefined) {
                var indexAccessor = mesh.getAccessor(primitive.indices);
                switch (primitive.mode) {
                    case 1 /* Lines */:
                        webgl.drawElements(webgl.LINES, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                        break;
                    case 4 /* Triangles */:
                    default:
                        webgl.drawElements(webgl.TRIANGLES, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                        break;
                }
            }
            else {
                switch (primitive.mode) {
                    case 1 /* Lines */:
                        webgl.drawArrays(webgl.LINES, bufferOffset, vertexAccessor.count);
                        break;
                    case 2 /* LineLoop */:
                        webgl.drawArrays(webgl.LINE_LOOP, bufferOffset, vertexAccessor.count);
                        break;
                    case 3 /* LineStrip */:
                        webgl.drawArrays(webgl.LINE_STRIP, bufferOffset, vertexAccessor.count);
                        break;
                    case 4 /* Triangles */:
                    default:
                        webgl.drawArrays(webgl.TRIANGLES, bufferOffset, vertexAccessor.count);
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._renderCall = function (context, drawCall, material) {
            context.update(drawCall);
            //
            var technique = material._glTFTechnique;
            var renderState = this._renderState;
            //Program
            var program = renderState.getProgram(material, technique, context.shaderContextDefine + material.shaderDefine);
            //Use Program
            var force = renderState.useProgram(program);
            //State
            renderState.updateState(technique.states);
            //Uniform
            this._updateContextUniforms(program, context, technique, force);
            this._updateUniforms(program, material, technique, force);
            //Attribute
            this._updateAttributes(program, drawCall.mesh, drawCall.subMeshIndex, technique, force);
            //Draw
            this._drawCall(drawCall);
        };
        /**
         * @internal
         * @param camera
         */
        WebGLRenderSystem.prototype._renderCamera = function (camera) {
            //在这里先剔除，然后排序，最后绘制
            var drawCalls = this._drawCalls;
            drawCalls.sortAfterFrustumCulling(camera);
            //
            var opaqueCalls = drawCalls.opaqueCalls;
            var transparentCalls = drawCalls.transparentCalls;
            //Step1 draw opaque
            for (var _i = 0, opaqueCalls_1 = opaqueCalls; _i < opaqueCalls_1.length; _i++) {
                var drawCall = opaqueCalls_1[_i];
                this._renderCall(camera.context, drawCall, drawCall.material);
            }
            //Step2 draw transparent
            for (var _a = 0, transparentCalls_1 = transparentCalls; _a < transparentCalls_1.length; _a++) {
                var drawCall = transparentCalls_1[_a];
                this._renderCall(camera.context, drawCall, drawCall.material);
            }
            // Egret2D渲染不加入DrawCallList的排序
            for (var _b = 0, _c = this._groups[1].gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                var egret2DRenderer = gameObject.getComponent(egret3d.Egret2DRenderer);
                if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                    egret2DRenderer.render(camera.context, camera);
                    //
                    this._renderState.clearState();
                }
            }
        };
        /**
         * @internal
         * @param light
         */
        WebGLRenderSystem.prototype._renderLightShadow = function (light) {
            var camera = this._lightCamera;
            var drawCalls = this._drawCalls;
            var faceCount = light.constructor === egret3d.PointLight ? 6 : 1;
            var renderState = this._renderState;
            for (var i = 0; i < faceCount; ++i) {
                var context = camera.context;
                light.update(camera, i);
                light.renderTarget.activeCubeFace = i; // TODO 创建接口。
                renderState.targetAndViewport(camera.viewport, light.renderTarget);
                renderState.cleanBuffer(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
                drawCalls.shadowFrustumCulling(camera);
                //
                var shadowCalls = drawCalls.shadowCalls;
                var shadowMaterial = light.constructor === egret3d.PointLight ? egret3d.DefaultMaterials.SHADOW_DISTANCE : egret3d.DefaultMaterials.SHADOW_DEPTH;
                for (var _i = 0, shadowCalls_1 = shadowCalls; _i < shadowCalls_1.length; _i++) {
                    var drawCall = shadowCalls_1[_i];
                    //TODO, 现在不支持蒙皮动画阴影     
                    this._renderCall(context, drawCall, shadowMaterial);
                }
            }
            var webgl = egret3d.WebGLCapabilities.webgl;
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        WebGLRenderSystem.prototype.onUpdate = function () {
            egret3d.Performance.startCounter("render");
            var lightsDirty = false;
            var renderState = this._renderState;
            var cameras = this._camerasAndLights.cameras;
            var lights = this._camerasAndLights.lights;
            var filteredLights = this._filteredLights;
            var camerasScene = paper.Application.sceneManager.camerasScene || paper.Application.sceneManager.activeScene;
            var lightsScene = paper.Application.sceneManager.lightsScene || paper.Application.sceneManager.activeScene;
            // Lights.
            if (filteredLights.length > 0) {
                lightsDirty = true;
                filteredLights.length = 0;
            }
            if (lights.length > 0) {
                for (var _i = 0, lights_3 = lights; _i < lights_3.length; _i++) {
                    var light = lights_3[_i];
                    if (light.gameObject.scene !== lightsScene) {
                        continue;
                    }
                    filteredLights.push(light);
                    if (!light.castShadows) {
                        continue;
                    }
                    this._renderLightShadow(light);
                }
            }
            // Cameras.
            if (cameras.length > 0) {
                for (var _a = 0, cameras_2 = cameras; _a < cameras_2.length; _a++) {
                    var camera = cameras_2[_a];
                    if (camera.gameObject.scene !== camerasScene) {
                        continue;
                    }
                    if (lightsDirty || filteredLights.length > 0) {
                        camera.context.updateLights(filteredLights, camera.gameObject.scene.ambientColor); // TODO 性能优化
                    }
                    if (camera.postQueues.length === 0) {
                        renderState.targetAndViewport(camera.viewport, camera.renderTarget);
                        renderState.cleanBuffer(camera.clearOption_Color, camera.clearOption_Depth, camera.backgroundColor);
                        this._renderCamera(camera);
                    }
                    else {
                        for (var _b = 0, _c = camera.postQueues; _b < _c.length; _b++) {
                            var item = _c[_b];
                            // TODO
                        }
                    }
                }
            }
            else {
                var webgl = egret3d.WebGLCapabilities.webgl;
                webgl.clearColor(0, 0, 0, 1);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            egret3d.Performance.endCounter("render");
        };
        return WebGLRenderSystem;
    }(paper.BaseSystem));
    egret3d.WebGLRenderSystem = WebGLRenderSystem;
    __reflect(WebGLRenderSystem.prototype, "egret3d.WebGLRenderSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = egret3d.Vector3.create();
    var helpVec3_2 = egret3d.Vector3.create();
    var helpInverseMatrix = egret3d.Matrix4.create();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
            combine.lightmapScaleOffset = meshRenderer.lightmapScaleOffset;
        }
        //适配最大格式
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += meshData.getAccessorTypeCount(meshData.getAccessor(primitive.attributes[attStr]).type);
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += meshData.getBufferLength(meshData.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
        meshFilter.mesh = combineMesh;
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        helpInverseMatrix.inverse(combineInstance.root.transform.getWorldMatrix());
        var meshAttribute = combineInstance.meshAttribute;
        var lightmapScaleOffset = combineInstance.lightmapScaleOffset;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.getWorldMatrix();
            var orginLightmapScaleOffset = meshRenderer.lightmapScaleOffset;
            var mesh = meshFilter.mesh;
            var primitives = mesh.glTFMesh.primitives;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = false;
                    var orginVertexCount = mesh.vertexCount;
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        worldMatrix.transformVector3(helpVec3_1, helpVec3_2);
                        helpInverseMatrix.transformVector3(helpVec3_2, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.MeshAttributeType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    if (meshAttribute["TANGENT" /* TANGENT */]) {
                        if (orginAttributes.TANGENT) {
                            var tangentBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TANGENT));
                            var target = tempVertexBuffers["TANGENT" /* TANGENT */];
                            var count = tangentBuffer.length;
                            var startIndex_2 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 4) {
                                helpVec3_1.x = tangentBuffer[j + 0];
                                helpVec3_1.y = tangentBuffer[j + 1];
                                helpVec3_1.z = tangentBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_2 + j] = helpVec3_1.x;
                                target[startIndex_2 + j + 1] = helpVec3_1.y;
                                target[startIndex_2 + j + 2] = helpVec3_1.z;
                                target[startIndex_2 + j + 3] = tangentBuffer[j + 3];
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.MeshAttributeType.TANGENT]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TANGENT" /* TANGENT */], orginVertexCount, [0, 0, 0, 1]);
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            // //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            // const uvBuffer = orginAttributes.TEXCOORD_1 ?
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_1)) as Float32Array :
                            //     mesh.createTypeArrayFromAccessor(mesh.getAccessor(orginAttributes.TEXCOORD_0!)) as Float32Array;
                            // //
                            // for (let j = 0; j < uvBuffer.length; j += 2) {
                            //     let u = uvBuffer[j + 0];
                            //     let v = uvBuffer[j + 1];
                            //     // u = ((u * orginLightmapScaleOffset[0] + orginLightmapScaleOffset[2]) - lightmapScaleOffset[2]) / lightmapScaleOffset[0];
                            //     // v = ((v * orginLightmapScaleOffset[1] - orginLightmapScaleOffset[1] - orginLightmapScaleOffset[3]) + lightmapScaleOffset[3] + lightmapScaleOffset[1]) / lightmapScaleOffset[1];
                            //     tempVertexBuffers[gltf.MeshAttributeType.TEXCOORD_1].push(u, v);
                            // }
                            if (orginAttributes.TEXCOORD_1) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1) {
                                _copyAccessorBufferArray(mesh, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(mesh, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(mesh, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = mesh.createTypeArrayFromAccessor(mesh.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var combineMesh = new egret3d.Mesh(combineInstance.vertexCount, combineInstance.indexBufferTotalSize, newAttribute, undefined, 35048 /* Dynamic */);
        var newVertexBuffers = combineMesh.buffers[0];
        var newIndexBuffers = combineMesh.buffers[1];
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var indicesCount = 0;
        for (var i = 0; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            //第一个submesh在构造函数中已经添加，需要手动添加后续的
            combineMesh.addSubMesh(indicesCount, subLen, i);
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(gltf, accessor, target) {
        var buffer = gltf.createTypeArrayFromAccessor(gltf.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.lightmapScaleOffset = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var PerformanceType;
    (function (PerformanceType) {
        PerformanceType["All"] = "all";
    })(PerformanceType = egret3d.PerformanceType || (egret3d.PerformanceType = {}));
    /**
     * Performance
     * 数据收集
     */
    var Performance = (function () {
        function Performance() {
        }
        Performance.getEntity = function (key) {
            return this._entities[key];
        };
        Performance.getFPS = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Performance.updateFPS = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Performance._getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Performance.startCounter = function (key, averageRange) {
            if (averageRange === void 0) { averageRange = 1; }
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this._getNow();
            entity.averageRange = averageRange;
        };
        Performance.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (entity) {
                entity.end = this._getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        Performance._entities = {};
        Performance.enable = false;
        return Performance;
    }());
    egret3d.Performance = Performance;
    __reflect(Performance.prototype, "egret3d.Performance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _a = 0, list_1 = list; _a < list_1.length; _a++) {
                var item = list_1[_a];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _b = 0, list_2 = list; _b < list_2.length; _b++) {
                var item = list_2[_b];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _a = 0, _b = this.profileList.values; _a < _b.length; _a++) {
                var item = _b[_a];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _a = 0, list0_1 = list0; _a < list0_1.length; _a++) {
                var _i = list0_1[_a];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var _i in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (options === void 0) { options = { antialias: false }; }
        // TODO WebAssembly load
        egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
        egret.Capabilities["renderMode" + ""] = "webgl";
        var requiredOptions = getOptions(options);
        var canvas = getMainCanvas(options);
        //TODO
        options.canvas = canvas;
        options.option = requiredOptions;
        options.webgl = canvas.getContext('webgl', options) || canvas.getContext("experimental-webgl", options);
        egret3d.WebGLCapabilities.canvas = options.canvas;
        egret3d.WebGLCapabilities.webgl = options.webgl;
        egret3d.InputManager.init(canvas);
        // DefaultTechnique.init();
        egret3d.stage.init(canvas, requiredOptions);
        if (!options.systems) {
            options.systems = [
                egret3d.BeginSystem,
                paper.EnableSystem,
                paper.StartSystem,
                //
                // oimo.PhysicsSystem,
                //
                paper.UpdateSystem,
                //
                egret3d.AnimationSystem,
                //
                paper.LateUpdateSystem,
                //
                egret3d.MeshRendererSystem,
                egret3d.SkinnedMeshRendererSystem,
                egret3d.particle.ParticleSystem,
                egret3d.Egret2DRendererSystem,
                //
                egret3d.CameraSystem,
                egret3d.WebGLRenderSystem,
                //
                paper.DisableSystem,
                egret3d.EndSystem,
            ];
        }
        paper.Application.init(options);
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas(options) {
        if (window.canvas) {
            return window.canvas;
        }
        else if (options.canvas) {
            return options.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
    function getOptions(options) {
        if (window.canvas) {
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: options.contentWidth || 640,
                contentHeight: options.contentHeight || 1136
            };
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: parseInt(div.getAttribute("data-content-width")),
                contentHeight: parseInt(div.getAttribute("data-content-height"))
            };
            ;
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 编辑器事件
         */
        var EditorEvent = (function (_super) {
            __extends(EditorEvent, _super);
            function EditorEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorEvent.CHANGE_SCENE = "changeScene";
            return EditorEvent;
        }(editor.BaseEvent));
        editor.EditorEvent = EditorEvent;
        __reflect(EditorEvent.prototype, "paper.editor.EditorEvent");
        /**
         * 编辑器
         **/
        var Editor = (function () {
            function Editor() {
            }
            /**初始化 */
            Editor.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                this.eventDispatcher = new editor.EventDispatcher();
                                //覆盖生成 uuid 的方式。
                                paper.createUUID = editor.generateUuid;
                                //初始化编辑环境
                                this.initEditEnvironment();
                                //允许重新加载
                                RES.FEATURE_FLAG.FIX_DUPLICATE_LOAD = 0;
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                //初始化编辑场景
                                this.editorSceneModel = new editor.EditorSceneModel();
                                this.editorSceneModel.init();
                                paper.Application.sceneManager.camerasScene = this.editorSceneModel.editorScene;
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Object.defineProperty(Editor, "activeEditorModel", {
                /**
                 * 当前激活的编辑模型
                 */
                get: function () {
                    return this._activeEditorModel;
                },
                enumerable: true,
                configurable: true
            });
            //设置激活模型
            Editor.setActiveModel = function (model) {
                this.activeScene(model.scene);
                this._activeEditorModel = model;
                this.editorSceneModel.editorModel = model;
                this.dispatchEvent(new EditorEvent(EditorEvent.CHANGE_SCENE));
            };
            Editor.activeScene = function (scene) {
                if (paper.Application.sceneManager.activeScene) {
                    var objs_1 = paper.Application.sceneManager.activeScene.getRootGameObjects();
                    objs_1.forEach(function (obj) {
                        obj.activeSelf = false;
                    });
                }
                paper.Application.sceneManager.activeScene = scene;
                var objs = paper.Application.sceneManager.activeScene.getRootGameObjects();
                objs.forEach(function (obj) {
                    obj.activeSelf = true;
                });
            };
            /**
             * 编辑场景
             * @param sceneUrl 场景资源URL
             */
            Editor.editScene = function (sceneUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var rawScene, scene, sceneEditorModel;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(sceneUrl)];
                            case 1:
                                rawScene = _a.sent();
                                if (rawScene) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = rawScene.createInstance(true);
                                    sceneEditorModel = new editor.EditorModel();
                                    sceneEditorModel.init(scene, 'scene', sceneUrl);
                                    this.setActiveModel(sceneEditorModel);
                                    this.currentEditInfo = { url: sceneUrl, type: 'scene' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 编辑预置体
             * @param prefabUrl 预置体资源URL
             */
            Editor.editPrefab = function (prefabUrl) {
                return __awaiter(this, void 0, void 0, function () {
                    var prefab, scene, prefabInstance, prefabEditorModel_1, clearPrefabInfo_1;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(prefabUrl)];
                            case 1:
                                prefab = _a.sent();
                                if (prefab) {
                                    if (this.activeEditorModel) {
                                        this.activeEditorModel.scene.destroy();
                                    }
                                    scene = paper.Scene.createEmpty('prefabEditScene', false);
                                    prefabInstance = prefab.createInstance(scene, true);
                                    prefabEditorModel_1 = new editor.EditorModel();
                                    prefabEditorModel_1.init(scene, 'prefab', prefabUrl);
                                    clearPrefabInfo_1 = function (obj) {
                                        obj.extras = {};
                                        for (var _i = 0, _a = obj.components; _i < _a.length; _i++) {
                                            var comp = _a[_i];
                                            comp.extras = {};
                                        }
                                        for (var i = 0; i < obj.transform.children.length; i++) {
                                            var child = obj.transform.children[i].gameObject;
                                            if (prefabEditorModel_1.isPrefabChild(child))
                                                clearPrefabInfo_1(child);
                                        }
                                    };
                                    clearPrefabInfo_1(prefabInstance);
                                    this.setActiveModel(prefabEditorModel_1);
                                    this.currentEditInfo = { url: prefabUrl, type: 'prefab' };
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 刷新
             */
            Editor.refresh = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.activeEditorModel) {
                                    this.activeEditorModel.scene.destroy();
                                }
                                //初始化资源
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                //初始化资源
                                _a.sent();
                                if (this.currentEditInfo) {
                                    switch (this.currentEditInfo.type) {
                                        case 'scene':
                                            this.editScene(this.currentEditInfo.url);
                                            break;
                                        case 'prefab':
                                            this.editPrefab(this.currentEditInfo.url);
                                            break;
                                    }
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             * 撤销
             */
            Editor.undo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.back();
            };
            /**
             * 重做
             */
            Editor.redo = function () {
                if (this.activeEditorModel)
                    this.activeEditorModel.history.forward();
            };
            Editor.deserializeHistory = function (data) {
                this.activeEditorModel.history.deserialize(data);
            };
            Editor.serializeHistory = function () {
                var historyData = this.activeEditorModel.history.serialize();
                return JSON.stringify(historyData);
            };
            Editor.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                this.eventDispatcher.addEventListener(type, fun, thisObj, level);
            };
            Editor.removeEventListener = function (type, fun, thisObj) {
                this.eventDispatcher.removeEventListener(type, fun, thisObj);
            };
            Editor.dispatchEvent = function (event) {
                this.eventDispatcher.dispatchEvent(event);
            };
            Editor.initEditEnvironment = function () {
                egret3d.runEgret({
                    antialias: false,
                    playerMode: 2 /* Editor */,
                    systems: [
                        egret3d.BeginSystem,
                        paper.EnableSystem,
                        paper.StartSystem,
                        //
                        paper.UpdateSystem,
                        //
                        egret3d.AnimationSystem,
                        //
                        paper.LateUpdateSystem,
                        //
                        egret3d.MeshRendererSystem,
                        egret3d.SkinnedMeshRendererSystem,
                        egret3d.particle.ParticleSystem,
                        egret3d.Egret2DRendererSystem,
                        //
                        egret3d.CameraSystem,
                        egret3d.WebGLRenderSystem,
                        egret3d.GizmoRenderSystem,
                        //
                        paper.DisableSystem,
                        egret3d.EndSystem
                    ]
                });
            };
            return Editor;
        }());
        editor.Editor = Editor;
        __reflect(Editor.prototype, "paper.editor.Editor");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.componentClass = null;
            _this._components = [];
            return _this;
        }
        /**
         * @internal
         */
        GroupComponent.prototype._addComponent = function (component) {
            this._components.push(component);
        };
        /**
         * @internal
         */
        GroupComponent.prototype._removeComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components.splice(1, 0);
            }
        };
        Object.defineProperty(GroupComponent.prototype, "components", {
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        return GroupComponent;
    }(paper.BaseComponent));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.context = new editor.EventDispatcher();
        var selectItemType;
        (function (selectItemType) {
            selectItemType[selectItemType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            selectItemType[selectItemType["ASSET"] = 1] = "ASSET";
        })(selectItemType = editor.selectItemType || (editor.selectItemType = {}));
        /**
         * 编辑模型事件
         */
        var EditorModelEvent = (function (_super) {
            __extends(EditorModelEvent, _super);
            function EditorModelEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorModelEvent.ADD_GAMEOBJECTS = "addGameObject";
            EditorModelEvent.DELETE_GAMEOBJECTS = "deleteGameObject";
            EditorModelEvent.SELECT_GAMEOBJECTS = "selectGame";
            EditorModelEvent.CHANGE_DIRTY = 'change_dirty';
            EditorModelEvent.CHANGE_PROPERTY = "changeProperty";
            EditorModelEvent.CHANGE_EDIT_MODE = "changeEditMode";
            EditorModelEvent.CHANGE_EDIT_TYPE = "changeEditType";
            EditorModelEvent.ADD_COMPONENT = "addComponent";
            EditorModelEvent.REMOVE_COMPONENT = "removeComponent";
            EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY = "updateGameObjectsHierarchy";
            EditorModelEvent.SAVE_ASSET = "saveAsset";
            return EditorModelEvent;
        }(editor.BaseEvent));
        editor.EditorModelEvent = EditorModelEvent;
        __reflect(EditorModelEvent.prototype, "paper.editor.EditorModelEvent");
        var ModifyObjectType;
        (function (ModifyObjectType) {
            ModifyObjectType[ModifyObjectType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            ModifyObjectType[ModifyObjectType["BASECOMPONENT"] = 1] = "BASECOMPONENT";
        })(ModifyObjectType = editor.ModifyObjectType || (editor.ModifyObjectType = {}));
        /**
         * 编辑模型
         */
        var EditorModel = (function (_super) {
            __extends(EditorModel, _super);
            function EditorModel() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._dirty = false;
                _this._cacheIds = [];
                return _this;
            }
            Object.defineProperty(EditorModel.prototype, "history", {
                get: function () {
                    return this._history;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "scene", {
                get: function () {
                    return this._scene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentType", {
                get: function () {
                    return this._contentType;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "contentUrl", {
                get: function () {
                    return this._contentUrl;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorModel.prototype, "dirty", {
                get: function () {
                    return this._dirty;
                },
                set: function (v) {
                    if (this._dirty !== v) {
                        this._dirty = v;
                        this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_DIRTY));
                    }
                },
                enumerable: true,
                configurable: true
            });
            /**
             * 初始化
             * @param history
             */
            EditorModel.prototype.init = function (scene, contentType, contentUrl) {
                this._history = new editor.History();
                this._scene = scene;
                this._contentType = contentType;
                this._contentUrl = contentUrl;
            };
            EditorModel.prototype.addState = function (state) {
                if (state) {
                    state.editorModel = this;
                    this.history.add(state);
                }
            };
            EditorModel.prototype.getEditType = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTransformProperty = function (propName, propValue, target) {
                var valueEditType = this.getEditType(propName, target);
                if (valueEditType != null) {
                    var newPropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    var prePropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(target[propName], valueEditType),
                        valueEditType: valueEditType
                    };
                    this.createModifyComponent(target.gameObject.uuid, target.uuid, [newPropertyData], [prePropertyData]);
                }
            };
            EditorModel.prototype.createModifyGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyGameObjectPropertyState.create(gameObjectUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyComponent = function (gameObjectUUid, componentUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyComponentPropertyState.create(gameObjectUUid, componentUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyAssetPropertyState = function (assetUrl, newValueList, preValueCopylist) {
                var state = editor.ModifyAssetPropertyState.create(assetUrl, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createPrefabState = function (prefab, parent) {
                var state = editor.CreatePrefabState.create(prefab, parent);
                this.addState(state);
            };
            EditorModel.prototype.serializeProperty = function (value, editType) {
                switch (editType) {
                    case editor.EditType.NUMBER:
                    case editor.EditType.TEXT:
                    case editor.EditType.CHECKBOX:
                        return value;
                    case editor.EditType.VECTOR2:
                    case editor.EditType.VECTOR3:
                    case editor.EditType.VECTOR4:
                    case editor.EditType.QUATERNION:
                    case editor.EditType.COLOR:
                    case editor.EditType.RECT:
                        var className = egret.getQualifiedClassName(value);
                        var serializeData = value.serialize(value);
                        return { className: className, serializeData: serializeData };
                    case editor.EditType.SHADER:
                        return value.name;
                    case editor.EditType.LIST:
                        return value;
                    case editor.EditType.MATERIAL_ARRAY:
                        var data = value.map(function (item) {
                            return { name: item.name, url: item.name };
                        });
                        return data;
                    case editor.EditType.MESH:
                        if (!value)
                            return '';
                        var url = value.name;
                        return url;
                    case editor.EditType.MATERIAL:
                    case editor.EditType.GAMEOBJECT:
                    case editor.EditType.TRANSFROM:
                    case editor.EditType.SOUND:
                    case editor.EditType.ARRAY:
                        //TODO
                        console.error("not supported!");
                        break;
                    default:
                        break;
                }
            };
            EditorModel.prototype.deserializeProperty = function (serializeData, editType) {
                switch (editType) {
                    case editor.EditType.NUMBER:
                    case editor.EditType.TEXT:
                    case editor.EditType.CHECKBOX:
                        return serializeData;
                    case editor.EditType.VECTOR2:
                    case editor.EditType.VECTOR3:
                    case editor.EditType.VECTOR4:
                    case editor.EditType.QUATERNION:
                    case editor.EditType.COLOR:
                    case editor.EditType.RECT:
                        var clazz = egret.getDefinitionByName(serializeData.className);
                        var target = null;
                        if (clazz) {
                            target = new clazz();
                            target.deserialize(serializeData.serializeData);
                        }
                        return target;
                    case editor.EditType.SHADER:
                        var url = serializeData;
                        var asset = RES.getRes(url);
                        return asset;
                    case editor.EditType.LIST:
                        return serializeData;
                    case editor.EditType.MATERIAL_ARRAY:
                        var materials = [];
                        for (var _i = 0, serializeData_1 = serializeData; _i < serializeData_1.length; _i++) {
                            var matrial = serializeData_1[_i];
                            var asset_1 = RES.getRes(matrial.url);
                            materials.push(asset_1);
                        }
                        return materials;
                    case editor.EditType.MESH:
                        var meshAsset = RES.getRes(serializeData);
                        return meshAsset;
                    case editor.EditType.MATERIAL:
                    case editor.EditType.GAMEOBJECT:
                    case editor.EditType.TRANSFROM:
                    case editor.EditType.SOUND:
                    case editor.EditType.ARRAY:
                        //TODO
                        console.error("not supported!");
                        return null;
                    default:
                        break;
                }
            };
            EditorModel.prototype.createGameObject = function (parentList, createType) {
                var state = editor.CreateGameObjectState.create(parentList, createType);
                this.addState(state);
            };
            EditorModel.prototype.addComponent = function (gameObjectUUid, compClzName) {
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    compClzName: compClzName
                };
                var state = editor.AddComponentState.create(gameObjectUUid, compClzName);
                this.addState(state);
            };
            EditorModel.prototype.removeComponent = function (gameObjectUUid, componentUUid) {
                var obj = this.getGameObjectByUUid(gameObjectUUid);
                if (!obj) {
                    return;
                }
                var removeComponent = this.getComponentById(obj, componentUUid);
                if (!removeComponent) {
                    return;
                }
                var serializeData = paper.serialize(removeComponent);
                var state = editor.RemoveComponentState.create(gameObjectUUid, componentUUid, serializeData);
                this.addState(state);
            };
            EditorModel.prototype.getComponentById = function (gameObject, componentId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.uuid === componentId) {
                        return comp;
                    }
                }
                return null;
            };
            EditorModel.prototype.getComponentByAssetId = function (gameObject, assetId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.extras.linkedID === assetId) {
                        return comp;
                    }
                }
                return null;
                ;
            };
            /**
             * 复制游戏对象
             * @param objs
             */
            EditorModel.prototype.copyGameObject = function (objs) {
                var clipboard = __global.runtimeModule.getClipborad();
                var content = [];
                //过滤
                this.filtTopHierarchyGameObjects(objs);
                //排序
                objs = this.sortGameObjectsForHierarchy(objs);
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    content.push({
                        type: "gameObject",
                        serializeData: paper.serialize(obj)
                    });
                }
                clipboard.writeText(JSON.stringify(content), "paper");
            };
            /**
             * 粘贴游戏对象
             * @param parent
             */
            EditorModel.prototype.pasteGameObject = function (parent) {
                var clipboard = __global.runtimeModule.getClipborad();
                var msg = clipboard.readText("paper");
                var content = JSON.parse(msg);
                if (content && content.length > 0) {
                    var objData = [];
                    for (var i = 0; i < content.length; i++) {
                        objData.push(content[i].serializeData);
                    }
                    var state = editor.PasteGameObjectsState.create(objData, parent);
                    this.addState(state);
                }
            };
            /**
             * 克隆游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.duplicateGameObjects = function (gameObjects) {
                var state = editor.DuplicateGameObjectsState.create(gameObjects, this);
                this.addState(state);
            };
            /**
             * 删除游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.deleteGameObject = function (gameObjects) {
                var _this = this;
                var deleteState = editor.DeleteGameObjectsState.create(gameObjects, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) && !_this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakState, deleteState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(deleteState);
                }
            };
            /**
             * 解除预置体联系
             * @param gameObjects
             */
            EditorModel.prototype.breakPrefab = function (gameObjects) {
                var _this = this;
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) || _this.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    this.addState(breakState);
                }
            };
            /**
             * 更改层级
             * */
            EditorModel.prototype.updateGameObjectsHierarchy = function (gameObjects, targetGameobjcet, dir) {
                var _this = this;
                var gameObjectHierarchyState = editor.GameObjectHierarchyState.create(gameObjects, targetGameobjcet, dir, this);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (_this.isPrefabChild(obj) &&
                        !_this.isPrefabRoot(obj) &&
                        (obj.transform.parent !== targetGameobjcet.transform.parent || dir === 'inner')) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakPrefabStructState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakPrefabStructState, gameObjectHierarchyState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(gameObjectHierarchyState);
                }
            };
            /**
             * 设置对象的层级
             */
            EditorModel.prototype.setGameObjectsHierarchy = function (objects, targetObject, dir) {
                objects = objects.concat();
                //剔除所有父级
                objects.forEach(function (obj) { obj.transform.parent = null; });
                objects.reverse();
                if (dir === 'inner') {
                    var index = targetObject.transform.children.length;
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];
                        obj.transform.parent = targetObject.transform;
                        var transform = targetObject.transform.children.pop();
                        targetObject.transform.children.splice(index, 0, transform);
                    }
                }
                else {
                    if (targetObject.transform.parent) {
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform);
                                break;
                            case 'bottom':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            obj.transform.parent = targetObject.transform.parent;
                            var transform = targetObject.transform.parent.children.pop();
                            targetObject.transform.parent.children.splice(index, 0, transform);
                        }
                    }
                    else {
                        var all = paper.Application.sceneManager.activeScene.gameObjects;
                        for (var i = 0; i < objects.length; i++) {
                            all.splice(all.indexOf(objects[i]), 1);
                        }
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = all.indexOf(targetObject);
                                break;
                            case 'bottom':
                                index = all.indexOf(targetObject) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            all.splice(index, 0, obj);
                        }
                    }
                }
            };
            /**
             * 筛选层级中的顶层游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.filtTopHierarchyGameObjects = function (gameObjects) {
                var findParent = false;
                var parent = null;
                for (var index = gameObjects.length - 1; index >= 0; index--) {
                    var element = gameObjects[index];
                    findParent = false;
                    parent = element.transform.parent;
                    while (parent) {
                        for (var i = 0; i < gameObjects.length; i++) {
                            var element_1 = gameObjects[i];
                            if (element_1.transform === parent) {
                                gameObjects.splice(index, 1);
                                findParent = true;
                                break;
                            }
                        }
                        if (findParent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                }
            };
            EditorModel.prototype.getGameObjectByUUid = function (uuid) {
                var objects = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                return null;
            };
            EditorModel.prototype.getAssetByAssetUrl = function (url) {
                return __awaiter(this, void 0, void 0, function () {
                    var asset;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                asset = RES.getRes(url);
                                if (!!asset) return [3 /*break*/, 2];
                                return [4 /*yield*/, RES.getResAsync(url)];
                            case 1:
                                asset = _a.sent();
                                _a.label = 2;
                            case 2: return [2 /*return*/, asset];
                        }
                    });
                });
            };
            EditorModel.prototype.getGameObjectsByUUids = function (uuids) {
                var objects = paper.Application.sceneManager.activeScene.gameObjects;
                var obj;
                var result = [];
                var idIndex;
                var cloneIds = uuids.concat();
                for (var i = 0; i < objects.length; i++) {
                    if (cloneIds.length == 0) {
                        return result;
                    }
                    obj = objects[i];
                    idIndex = cloneIds.indexOf(obj.uuid);
                    if (idIndex != -1) {
                        result.push(obj);
                        cloneIds.splice(idIndex, 1);
                    }
                }
                return result;
            };
            EditorModel.prototype.findOptionSetName = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTargetProperty = function (propName, target, value) {
                var setFunName = this.findOptionSetName(propName, target);
                if (setFunName !== null && target[setFunName]) {
                    target[setFunName].call(target, value);
                }
                else {
                    target[propName] = value;
                }
            };
            /**
             * 选择游戏对象
             *  */
            EditorModel.prototype.selectGameObject = function (objs) {
                this.currentSelected = objs;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.SELECT_GAMEOBJECTS, objs));
            };
            /**
             * 切换编辑模式
             */
            EditorModel.prototype.changeEditMode = function (mode) {
                this.currentEditMode = mode;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_MODE, mode));
            };
            /**
             * 切换编辑类型
             */
            EditorModel.prototype.changeEditType = function (type) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_TYPE, type));
            };
            EditorModel.prototype.isPrefabRoot = function (gameObj) {
                if (gameObj.extras.prefab) {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.isPrefabChild = function (gameObj) {
                if (gameObj.extras.rootID) {
                    return true;
                }
                return false;
            };
            /**将对象按照层级进行排序
             */
            EditorModel.prototype.sortGameObjectsForHierarchy = function (gameobjects) {
                gameobjects = gameobjects.concat();
                if (gameobjects.length < 2) {
                    return gameobjects;
                }
                //生成每个对象的显示索引路径列表
                var displayPathList = [];
                gameobjects.forEach(function (obj) {
                    var result = [];
                    var currentObj = obj;
                    while (currentObj.transform.parent) {
                        result.unshift(currentObj.transform.parent.children.indexOf(currentObj.transform));
                        currentObj = currentObj.transform.parent.gameObject;
                    }
                    //追加一个根部索引
                    result.unshift(paper.Application.sceneManager.activeScene.gameObjects.indexOf(currentObj));
                    displayPathList.push({ gameObject: obj, path: result });
                });
                function getPath(gameObject) {
                    for (var i_1 = 0; i_1 < displayPathList.length; i_1++) {
                        if (displayPathList[i_1].gameObject === gameObject) {
                            return displayPathList[i_1].path;
                        }
                    }
                }
                var length = gameobjects.length - 1;
                while (length > 0) {
                    for (var i = 0; i < length; i++) {
                        var A = getPath(gameobjects[i]);
                        var B = getPath(gameobjects[i + 1]);
                        var needChangeIndex = false;
                        var minLength = Math.min(A.length, B.length);
                        var k = 0;
                        b: for (k; k < minLength; k++) {
                            if (A[k] === B[k]) {
                                continue;
                            }
                            else if (A[k] > B[k]) {
                                needChangeIndex = true;
                                break b;
                            }
                            else if (A[k] < B[k]) {
                                needChangeIndex = false;
                                break b;
                            }
                        }
                        if (k === minLength && !needChangeIndex && A.length > B.length) {
                            needChangeIndex = true;
                        }
                        if (needChangeIndex) {
                            var tmpv = gameobjects[i];
                            gameobjects[i] = gameobjects[i + 1];
                            gameobjects[i + 1] = tmpv;
                        }
                    }
                    length--;
                }
                return gameobjects;
            };
            EditorModel.prototype.createApplyPrefabState = function (applyData, applyPrefabInstanceId, prefab) {
                var state = editor.ApplyPrefabInstanceState.create(applyData, applyPrefabInstanceId, prefab);
                this.addState(state);
            };
            EditorModel.prototype.createRevertPrefabState = function (revertData, revertPrefabInstanceId) {
                var state = editor.RevertPrefabInstanceState.create(revertData, revertPrefabInstanceId);
                this.addState(state);
            };
            EditorModel.prototype.deepClone = function (obj) {
                var _this = this;
                if (!obj || typeof obj !== 'object') {
                    return obj;
                }
                if (obj instanceof RegExp) {
                    return obj;
                }
                var result = Array.isArray(obj) ? [] : {};
                Object.keys(obj).forEach(function (key) {
                    if (obj[key] && typeof obj[key] === 'object') {
                        result[key] = _this.deepClone(obj[key]);
                    }
                    else {
                        result[key] = obj[key];
                    }
                });
                return result;
            };
            EditorModel.prototype.updateAsset = function (asset, prefabInstance) {
                if (prefabInstance === void 0) { prefabInstance = null; }
                var refs = this.findAssetRefs(paper.Application.sceneManager.activeScene, asset);
                var serializeData;
                if (asset instanceof paper.Prefab) {
                    serializeData = paper.serialize(prefabInstance);
                }
                else {
                }
                //save asset
                //destory asset,getRes
                //update refrence (paper.assets[])
                this._cacheIds.length = 0;
            };
            EditorModel.prototype.findAssetRefs = function (target, as, refs) {
                if (refs === void 0) { refs = null; }
                if (this._cacheIds.indexOf(target.uuid) >= 0) {
                    return;
                }
                this._cacheIds.push(target.uuid);
                refs = refs || [];
                for (var key in target) {
                    var source = target[key];
                    if ((typeof source) === "object") {
                        this.findFromChildren(source, as, refs, target, key);
                    }
                }
                return refs;
            };
            EditorModel.prototype.findFromChildren = function (source, as, refs, parent, key) {
                if ((typeof source) !== "object") {
                    return;
                }
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    for (var index = 0; index < source.length; index++) {
                        var element = source[index];
                        this.findFromChildren(element, as, refs, source, index);
                    }
                }
                if (source.constructor === Object) {
                    for (var key_1 in source) {
                        var element = source[key_1];
                        this.findFromChildren(element, as, refs, source, key_1);
                    }
                }
                if (source instanceof paper.BaseObject) {
                    if (source instanceof paper.Asset && source === as) {
                        refs.push({ p: parent, k: key });
                        return;
                    }
                    this.findAssetRefs(source, as, refs);
                }
            };
            EditorModel.prototype.getAllGameObjectsFromPrefabInstance = function (gameObj, objs) {
                if (objs === void 0) { objs = null; }
                if (gameObj) {
                    objs = objs || [];
                    if (gameObj.extras.linkedID) {
                        objs.push(gameObj);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllGameObjectsFromPrefabInstance(obj, objs);
                    }
                }
                return objs;
            };
            EditorModel.prototype.setMaterialTexture = function (target, url, propName) {
                return __awaiter(this, void 0, void 0, function () {
                    var asset;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                asset = paper.Asset.find(url);
                                if (!!asset) return [3 /*break*/, 2];
                                return [4 /*yield*/, this.getAssetByAssetUrl(url)];
                            case 1:
                                asset = _a.sent();
                                _a.label = 2;
                            case 2:
                                if (!asset) {
                                    console.error(url + " can't find");
                                    return [2 /*return*/];
                                }
                                target._glTFTechnique.uniforms[propName].value = asset;
                                return [2 /*return*/];
                        }
                    });
                });
            };
            EditorModel.prototype.modifyMaterialPropertyValues = function (target, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _i, valueList_1, propertyValue, propName, copyValue, uniformType, _a, _glTFMaterial, gltfUnifromMap, uniformMap, key, value;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _i = 0, valueList_1 = valueList;
                                _b.label = 1;
                            case 1:
                                if (!(_i < valueList_1.length)) return [3 /*break*/, 14];
                                propertyValue = valueList_1[_i];
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, uniformType = propertyValue.uniformType;
                                _a = uniformType;
                                switch (_a) {
                                    case 35670 /* BOOL */: return [3 /*break*/, 2];
                                    case 5124 /* INT */: return [3 /*break*/, 3];
                                    case 5126 /* FLOAT */: return [3 /*break*/, 4];
                                    case 35671 /* BOOL_VEC2 */: return [3 /*break*/, 5];
                                    case 35667 /* INT_VEC2 */: return [3 /*break*/, 5];
                                    case 35664 /* FLOAT_VEC2 */: return [3 /*break*/, 5];
                                    case 35672 /* BOOL_VEC3 */: return [3 /*break*/, 6];
                                    case 35668 /* INT_VEC3 */: return [3 /*break*/, 6];
                                    case 35665 /* FLOAT_VEC3 */: return [3 /*break*/, 6];
                                    case 35673 /* BOOL_VEC4 */: return [3 /*break*/, 7];
                                    case 35669 /* INT_VEC4 */: return [3 /*break*/, 7];
                                    case 35666 /* FLOAT_VEC4 */: return [3 /*break*/, 7];
                                    case 35678 /* SAMPLER_2D */: return [3 /*break*/, 8];
                                    case 35674 /* FLOAT_MAT2 */: return [3 /*break*/, 10];
                                    case 35675 /* FLOAT_MAT3 */: return [3 /*break*/, 10];
                                    case 35676 /* FLOAT_MAT4 */: return [3 /*break*/, 10];
                                }
                                return [3 /*break*/, 11];
                            case 2:
                                target.setBoolean(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 3:
                                target.setInt(propName, copyValue);
                                _b.label = 4;
                            case 4:
                                target.setFloat(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 5:
                                target.setVector2v(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 6:
                                target.setVector3v(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 7:
                                target.setVector4v(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 8: return [4 /*yield*/, this.setMaterialTexture(target, copyValue.url, propName)];
                            case 9:
                                _b.sent();
                                return [3 /*break*/, 12];
                            case 10:
                                target.setMatrixv(propName, copyValue);
                                return [3 /*break*/, 12];
                            case 11: return [3 /*break*/, 12];
                            case 12:
                                if (propName === "renderQueue") {
                                    target.config.materials[0].extensions.paper.renderQueue = copyValue;
                                }
                                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: copyValue }));
                                _b.label = 13;
                            case 13:
                                _i++;
                                return [3 /*break*/, 1];
                            case 14:
                                _glTFMaterial = target.config.materials[0];
                                gltfUnifromMap = _glTFMaterial.extensions.KHR_techniques_webgl.values;
                                uniformMap = target._glTFTechnique.uniforms;
                                for (key in uniformMap) {
                                    if (uniformMap[key].semantic === undefined) {
                                        value = uniformMap[key].value;
                                        if (Array.isArray(value)) {
                                            gltfUnifromMap[key] = value.concat();
                                        }
                                        else if (value instanceof egret3d.GLTexture2D) {
                                            gltfUnifromMap[key] = value.name;
                                        }
                                        else {
                                            gltfUnifromMap[key] = value;
                                        }
                                    }
                                }
                                return [2 /*return*/];
                        }
                    });
                });
            };
            return EditorModel;
        }(editor.EventDispatcher));
        editor.EditorModel = EditorModel;
        __reflect(EditorModel.prototype, "paper.editor.EditorModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var EditorSceneModel = (function () {
            function EditorSceneModel() {
                this.viewCache = {};
            }
            Object.defineProperty(EditorSceneModel.prototype, "editorScene", {
                get: function () {
                    return paper.Application.sceneManager.editorScene;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(EditorSceneModel.prototype, "editorModel", {
                set: function (v) {
                    if (this.currentModel) {
                        this.viewCache[this.currentModel.contentUrl] = {
                            position: this.cameraObject.transform.getPosition().clone(),
                            rotation: this.cameraObject.transform.getRotation().clone()
                        };
                    }
                    // this.pickGameScript.clearSelected();
                    // this.geoController.clearSelected();//TODO:应在controller里新增清空状态函数
                    this.editorCameraScript.editorModel = v;
                    this.pickGameScript.editorModel = v;
                    this.geoController.editorModel = v;
                    this.currentModel = v;
                    if (v && this.viewCache[v.contentUrl]) {
                        this.cameraObject.transform.setPosition(this.viewCache[v.contentUrl].position);
                        this.cameraObject.transform.setRotation(this.viewCache[v.contentUrl].rotation);
                    }
                    else {
                        this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                        this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                    }
                },
                enumerable: true,
                configurable: true
            });
            EditorSceneModel.prototype.init = function () {
                this.cameraObject = paper.GameObject.create("EditorCamera", "EditorOnly" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                var camera = this.cameraObject.addComponent(egret3d.Camera);
                camera.near = 0.1;
                camera.far = 500.0;
                camera.backgroundColor.set(0.13, 0.28, 0.51, 1.00);
                this.cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                this.cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                this.editorCameraScript = this.cameraObject.addComponent(editor.EditorCameraScript);
                this.editorCameraScript.moveSpeed = 10;
                this.editorCameraScript.rotateSpeed = 0.5;
                this.pickGameScript = this.cameraObject.addComponent(editor.PickGameObjectScript);
                this.geoController = this.cameraObject.addComponent(editor.Controller);
                editor.Gizmo.Enabled();
            };
            return EditorSceneModel;
        }());
        editor.EditorSceneModel = EditorSceneModel;
        __reflect(EditorSceneModel.prototype, "paper.editor.EditorSceneModel");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var helpVec3_1 = new egret3d.Vector3();
        var helpVec3_2 = new egret3d.Vector3();
        var helpVec3_3 = new egret3d.Vector3();
        var helpQuat_1 = new egret3d.Quaternion();
        var helpQuat_2 = new egret3d.Quaternion();
        var Controller = (function (_super) {
            __extends(Controller, _super);
            function Controller() {
                var _this = _super.call(this) || this;
                _this._modeCanChange = true;
                _this._isEditing = false;
                _this.selectedGameObjs = [];
                _this.geoCtrlMode = 'world';
                _this.mainGeo = new editor.GeoContainer();
                _this.coord = new paper.GameObject();
                _this.bindMouse = egret3d.InputManager.mouse;
                _this.bindKeyboard = egret3d.InputManager.keyboard;
                _this._cameraObject = paper.Application.sceneManager.editorScene.find("EditorCamera");
                _this._oldTransform = egret3d.Vector3.getDistance(_this.controller.transform.getLocalPosition(), _this.gameObject.transform.getLocalPosition());
                return _this;
            }
            Object.defineProperty(Controller.prototype, "onGeoControll", {
                get: function () {
                    return this.mainGeo.onGeoControll;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controller.prototype, "controller", {
                get: function () {
                    return this.mainGeo.geo;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controller.prototype, "editorModel", {
                get: function () {
                    return this._editorModel;
                },
                set: function (editorModel) {
                    this._editorModel = editorModel;
                    this.mainGeo.editorModel = editorModel;
                    this.selectGameObjects([]);
                    this.addEventListener();
                    this.changeEditType('position');
                },
                enumerable: true,
                configurable: true
            });
            Controller.prototype.onUpdate = function () {
                if (!this.editorModel) {
                    return;
                }
                this.drawCoord();
                this.geoChangeByCamera();
                this.inputUpdate();
                if (this._isEditing) {
                    (this.geoCtrlMode == "world" || this.selectedGameObjs.length > 1) ? this.updateInWorldMode() : this.updateInLocalMode();
                }
                if (this.bindMouse.wasReleased(0)) {
                    this.mainGeo.wasReleased(this.selectedGameObjs);
                }
            };
            Controller.prototype.updateInLocalMode = function () {
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var camera = this._cameraObject.getComponent(egret3d.Camera);
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ray = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    this.mainGeo.wasPressed_local(ray, this.selectedGameObjs);
                }
                else if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ray = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    this.mainGeo.isPressed_local(ray, this.selectedGameObjs);
                }
                else {
                    this.mouseRayCastUpdate();
                }
            };
            Controller.prototype.updateInWorldMode = function () {
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var camera = this._cameraObject.getComponent(egret3d.Camera);
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ray = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    this.mainGeo.wasPressed_world(ray, this.selectedGameObjs);
                }
                else if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ray = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    this.mainGeo.isPressed_world(ray, this.selectedGameObjs);
                }
                else {
                    this.mouseRayCastUpdate();
                }
            };
            Controller.prototype.mouseRayCastUpdate = function () {
                //变色逻辑
                var camera = this._cameraObject.getComponent(egret3d.Camera);
                var ray = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                var result = this.mainGeo.checkIntersect(ray);
                if (this._oldResult != result) {
                    if (this._oldResult) {
                        if (this._oldResult.geo) {
                            this._oldResult.changeColor("origin");
                        }
                    }
                    this._oldResult = result;
                    if (result) {
                        result.changeColor("yellow");
                    }
                }
            };
            Controller.prototype.geoChangeByCamera = function () {
                //控制杆大小随镜头远近变化
                var dis1;
                var delta;
                dis1 = egret3d.Vector3.getDistance(this.controller.transform.getLocalPosition(), this.gameObject.transform.getLocalPosition());
                delta = (dis1 - this._oldTransform) / 20;
                this._oldTransform = egret3d.Vector3.getDistance(this.controller.transform.getLocalPosition(), this.gameObject.transform.getLocalPosition());
                var scale = this.controller.transform.getLocalScale();
                this.controller.transform.setScale(new egret3d.Vector3(scale.x + delta, scale.y + delta, scale.z + delta));
            };
            Controller.prototype.inputUpdate = function () {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                if (keyboard.wasPressed("Q")) {
                    if (this.geoCtrlMode == "local") {
                        this.changeEditMode("world");
                        this.editorModel.changeEditMode("world");
                    }
                    else {
                        this.changeEditMode("local");
                        this.editorModel.changeEditMode("local");
                    }
                }
                if (keyboard.wasPressed("W")) {
                    this.changeEditType("position");
                    this.editorModel.changeEditType("position");
                }
                if (keyboard.wasPressed("E")) {
                    this.changeEditType("rotation");
                    this.editorModel.changeEditType("rotation");
                }
                if (keyboard.wasPressed("R")) {
                    this.changeEditType("scale");
                    this.editorModel.changeEditType("scale");
                }
            };
            Controller.prototype.changeEditMode = function (mode) {
                if (!this._modeCanChange) {
                    console.log("current mode: " + this.geoCtrlMode);
                    return;
                }
                this.geoCtrlMode = mode;
                var len = this.selectedGameObjs.length;
                if (len < 1)
                    return;
                if (this.geoCtrlType != "scale") {
                    switch (mode) {
                        case "local":
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                            break;
                        case "world":
                            this.controller.transform.setRotation(0, 0, 0, 1);
                            break;
                        default:
                            break;
                    }
                }
                console.log("current mode: " + this.geoCtrlMode);
            };
            Controller.prototype.changeEditType = function (type) {
                if (this.geoCtrlType == type)
                    return;
                this.geoCtrlType = type;
                this.editorModel.changeEditType(type);
                if (type == 'scale') {
                    this.mainGeo.geo.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                }
                if (this.geoCtrlMode == 'world') {
                    this.controller.transform.setRotation(0, 0, 0, 1);
                }
                this.mainGeo.changeType(type);
            };
            Controller.prototype.addEventListener = function () {
                var _this = this;
                this.editorModel.addEventListener(editor.EditorModelEvent.SELECT_GAMEOBJECTS, function (e) { return _this.selectGameObjects(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_MODE, function (e) { return _this.changeEditMode(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_TYPE, function (e) { return _this.changeEditType(e.data); }, this);
                // this.editorModel.addEventListener(EditorModelEvent.CHANGE_PROPERTY, e => this.changeProperty(e.data), this);
            };
            Controller.prototype.selectGameObjects = function (gameObjs) {
                if (!gameObjs) {
                    gameObjs = [];
                }
                this.selectedGameObjs = gameObjs;
                var len = this.selectedGameObjs.length;
                this._modeCanChange = true;
                if (len > 0) {
                    this._isEditing = true;
                    this.controller.activeSelf = true;
                    if (len == 1) {
                        // console.log("select: " + this.selectedGameObjs[0].name);
                        this.controller.transform.setPosition(this.selectedGameObjs[0].transform.getPosition());
                        if (this.geoCtrlMode == "local") {
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                        }
                        else if (this.geoCtrlMode == "world") {
                            this.controller.transform.setRotation(0, 0, 0, 1);
                        }
                    }
                    else {
                        var ctrlPos = egret3d.Vector3.set(0, 0, 0, helpVec3_3);
                        for (var i = 0; i < len; i++) {
                            // console.log("select: " + i + " " + this.selectedGameObjs[i].name);
                            var obj = this.selectedGameObjs[i];
                            egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                        }
                        ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                        this.controller.transform.setPosition(ctrlPos);
                        this.controller.transform.setRotation(0, 0, 0, 1);
                        this.geoCtrlMode = "world";
                        this._modeCanChange = false;
                    }
                }
                else {
                    this._isEditing = false;
                    this.controller.activeSelf = false;
                }
            };
            Controller.prototype.drawCoord = function () {
                var nrLine = 100;
                var bia = -0.05;
                var verticesCoord = [];
                var indices = [];
                var dis1;
                var delta;
                dis1 = egret3d.Vector3.getDistance(this.controller.transform.getLocalPosition(), this.gameObject.transform.getLocalPosition());
                delta = (dis1 - this._oldTransform) / 20;
                for (var i = 0, len = 2 * nrLine + 1; i < len; i++) {
                    verticesCoord[6 * i] = -nrLine + i;
                    verticesCoord[6 * i + 1] = bia;
                    verticesCoord[6 * i + 2] = -nrLine;
                    verticesCoord[6 * i + 3] = -nrLine + i;
                    verticesCoord[6 * i + 4] = bia;
                    verticesCoord[6 * i + 5] = nrLine;
                    verticesCoord[6 * len + 6 * i] = -nrLine;
                    verticesCoord[6 * len + 6 * i + 1] = bia;
                    verticesCoord[6 * len + 6 * i + 2] = -nrLine + i;
                    verticesCoord[6 * len + 6 * i + 3] = nrLine;
                    verticesCoord[6 * len + 6 * i + 4] = bia;
                    verticesCoord[6 * len + 6 * i + 5] = -nrLine + i;
                }
                for (var i = 0; i < 8 * nrLine + 1; i++) {
                    indices.push(i);
                }
                var mesh = new egret3d.Mesh(nrLine * 8, 8 * nrLine);
                var mat = new egret3d.Material(egret3d.DefaultShaders.LINEDASHED);
                var color1 = new Float32Array([0.3, 0.3, 0.5]);
                var funs = mat.glTFTechnique.states.functions;
                var enables = mat.glTFTechnique.states.enable;
                var index = enables.indexOf(2929 /* DEPTH_TEST */);
                if (index < 0) {
                    enables.push(2929 /* DEPTH_TEST */);
                }
                funs.depthMask = [true];
                funs.depthFunc = [515 /* LEQUAL */];
                mat.setVector3v("diffuse", color1);
                mesh.setAttributes("POSITION" /* POSITION */, verticesCoord);
                mesh.setIndices(indices);
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                this.coord.getOrAddComponent(egret3d.MeshFilter).mesh = mesh;
                this.coord.getOrAddComponent(egret3d.MeshRenderer).materials = [mat];
            };
            Controller = __decorate([
                paper.executeInEditMode
            ], Controller);
            return Controller;
        }(paper.Behaviour));
        editor.Controller = Controller;
        __reflect(Controller.prototype, "paper.editor.Controller");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.missingObject = null;
            return _this;
        }
        __decorate([
            paper.serializedField
        ], MissingComponent.prototype, "missingObject", void 0);
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var GeoContainer = (function (_super) {
            __extends(GeoContainer, _super);
            function GeoContainer() {
                var _this = _super.call(this) || this;
                _this.geos = [];
                _this.changeType("position");
                return _this;
            }
            Object.defineProperty(GeoContainer.prototype, "onGeoControll", {
                get: function () {
                    if (this.selectedGeo) {
                        return true;
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            GeoContainer.prototype.onSet = function () {
                var controller = new paper.GameObject("", "", paper.Application.sceneManager.editorScene);
                controller.activeSelf = false;
                controller.name = "GizmoController";
                controller.tag = "Editor";
                this.geo = controller;
            };
            GeoContainer.prototype.checkIntersect = function (ray) {
                for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                    var item = _a[_i];
                    var temp = item._checkIntersect(ray);
                    if (temp) {
                        return temp;
                    }
                }
            };
            GeoContainer.prototype.clear = function () {
                if (this.geos) {
                    for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.geo.destroy();
                        item.geo = null;
                    }
                }
                this.geos = [];
            };
            // public clearAll() {
            //     this.clear();
            //     this.selectedGeo = null;
            // }
            GeoContainer.prototype.changeType = function (type) {
                this.clear();
                switch (type) {
                    case "position":
                        {
                            var x = new editor.xAxis;
                            var y = new editor.yAxis;
                            var z = new editor.zAxis;
                            var xy = new editor.xyAxis;
                            var xz = new editor.xzAxis;
                            var yz = new editor.yzAxis;
                            this.geos.push(x, y, z, xy, xz, yz);
                        }
                        break;
                    case "rotation":
                        {
                            var ball = new editor.ballRot;
                            var x = new editor.xRot;
                            var y = new editor.yRot;
                            var z = new editor.zRot;
                            this.geos.push(x, y, z, ball);
                        }
                        break;
                    case "scale":
                        {
                            var x = new editor.xScl;
                            var y = new editor.yScl;
                            var z = new editor.zScl;
                            this.geos.push(x, y, z);
                        }
                        break;
                }
                for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                    var geo = _a[_i];
                    geo.editorModel = this.editorModel;
                    geo.geo.transform.setParent(this.geo.transform);
                }
            };
            GeoContainer.prototype.wasPressed_local = function (ray, selected) {
                var result = this.checkIntersect(ray);
                if (result) {
                    result.wasPressed_local(ray, selected);
                    this.selectedGeo = result;
                    for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.changeColor('grey');
                    }
                    this.selectedGeo.changeColor('yellow');
                    return;
                }
                this.selectedGeo = null;
                return null;
            };
            GeoContainer.prototype.isPressed_local = function (ray, selected) {
                if (this.selectedGeo) {
                    this.selectedGeo.isPressed_local(ray, selected);
                    this.geo.transform.setLocalPosition(selected[0].transform.getPosition());
                    this.geo.transform.setLocalRotation(selected[0].transform.getRotation());
                }
            };
            GeoContainer.prototype.wasPressed_world = function (ray, selected) {
                var ctrlRot = this.geo.transform.getRotation();
                var result = this.checkIntersect(ray);
                if (result) {
                    console.log(result.geo.name);
                    this._ctrlRot = ctrlRot;
                    result.wasPressed_world(ray, selected);
                    this.selectedGeo = result;
                    for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.changeColor('grey');
                    }
                    this.selectedGeo.changeColor('yellow');
                    return;
                }
                this.selectedGeo = null;
                return null;
            };
            GeoContainer.prototype.isPressed_world = function (ray, selected) {
                if (this.selectedGeo) {
                    this.selectedGeo.isPressed_world(ray, selected);
                    var len = selected.length;
                    var ctrlPos = egret3d.Vector3.set(0, 0, 0, this.helpVec3_3);
                    for (var i = 0; i < len; i++) {
                        // console.log("select: " + i + " " + this.selectedGameObjs[i].name);
                        var obj = selected[i];
                        egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                    }
                    ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                    if (this.selectedGeo._ctrlRot) {
                        this._ctrlRot.copy(this.selectedGeo._ctrlRot);
                        this.geo.transform.setRotation(this._ctrlRot);
                    }
                    this.geo.transform.setPosition(ctrlPos);
                }
            };
            GeoContainer.prototype.wasReleased = function (selectedGameObjs) {
                if (this.selectedGeo) {
                    this.selectedGeo.wasReleased(selectedGameObjs);
                    for (var _i = 0, _a = this.geos; _i < _a.length; _i++) {
                        var item = _a[_i];
                        item.changeColor('origin');
                    }
                    this.selectedGeo = null;
                }
            };
            return GeoContainer;
        }(editor.BaseGeo));
        editor.GeoContainer = GeoContainer;
        __reflect(GeoContainer.prototype, "paper.editor.GeoContainer");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var xAxis = (function (_super) {
            __extends(xAxis, _super);
            function xAxis() {
                return _super.call(this) || this;
            }
            xAxis.prototype.onSet = function () {
                var xAxis = this._createAxis(new egret3d.Vector4(1, 0.0, 0.0, 1), 0);
                xAxis.name = "GizmoController_X";
                xAxis.tag = "Editor";
                xAxis.transform.setLocalScale(0.1, 2, 0.1);
                xAxis.transform.setLocalEulerAngles(0, 0, 90);
                xAxis.transform.setLocalPosition(1, 0, 0);
                this.geo = xAxis;
            };
            xAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.applyQuaternion(worldRotation, this.right);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                // {
                //     let dragPlane = this._createAxis(new egret3d.Vector4(0, 0.2, 0.2), 3)
                //     dragPlane.transform.setPosition(worldPosition)
                //     this.helpVec3_1.set(0, 1, 0)
                //     this.helpQuat_1.w = Math.sqrt(normal.getDistance(new egret3d.Vector3(0, 0, 0)) ^ 2) + normal.dot(this.helpVec3_3)
                //     this.helpVec3_1.cross(normal)
                //     this.helpQuat_1.x = this.helpVec3_1.x
                //     this.helpQuat_1.y = this.helpVec3_1.y
                //     this.helpQuat_1.z = this.helpVec3_1.z
                //     this.helpQuat_1.normalize()
                //     dragPlane.transform.setRotation(this.helpQuat_1)
                //     // normal.fromPlaneProjection
                //     // dragPlane.transform.setRotation
                // }
            };
            xAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                console.log(hit);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset = new egret3d.Vector3;
                worldOffset.applyQuaternion(worldRotation, this.right);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset, this.helpVec3_2);
                egret3d.Vector3.copy(position, this._ctrlPos);
                // if (selectedGameObjs[0].transform.parent) {
                //     let parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix()
                //     parentMatrix = parentMatrix.inverse()
                //     parentMatrix.transformNormal(position)
                // }
                selectedGameObjs[0].transform.setPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            xAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.copy(this.right);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            xAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                worldOffset = egret3d.Vector3.copy(this.right, this.helpVec3_1);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                egret3d.Vector3.add(this._ctrlPos, worldOffset, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, worldOffset, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getWorldMatrix()
                    //     parentMatrix = parentMatrix.inverse()
                    //     parentMatrix.transformNormal(this._newPosition)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            xAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_1 = selectedGameObjs; _i < selectedGameObjs_1.length; _i++) {
                    var item = selectedGameObjs_1[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return xAxis;
        }(editor.BaseGeo));
        editor.xAxis = xAxis;
        __reflect(xAxis.prototype, "paper.editor.xAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var xyAxis = (function (_super) {
            __extends(xyAxis, _super);
            function xyAxis() {
                return _super.call(this) || this;
            }
            xyAxis.prototype.onSet = function () {
                var xyPlane = this._createAxis(new egret3d.Vector4(1, 0.0, 0.0, 0.5), 3);
                xyPlane.name = "GizmoController_XY";
                xyPlane.tag = "Editor";
                xyPlane.transform.setLocalScale(0.05, 0.05, 0.05);
                xyPlane.transform.setLocalEulerAngles(90, 0, 0);
                xyPlane.transform.setLocalPosition(0.2, 0.2, 0);
                this.geo = xyPlane;
            };
            xyAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                // let normal = new egret3d.Vector3(0, pos.y + pos.z, pos.z + pos.y)
                var normal = this.forward;
                this._dragPlaneNormal.applyQuaternion(worldRotation, normal);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                // let normal1 = new egret3d.Vector3(pos.x + pos.z, 0, pos.z + pos.x)
                // this._dragPlaneNormal1.applyQuaternion(worldRotation, normal1)
                // this._dragOffset1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(this._dragOffset1, worldPosition, this._dragOffset1);
            };
            xyAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset1 = new egret3d.Vector3();
                var worldOffset = new egret3d.Vector3();
                worldOffset.applyQuaternion(worldRotation, this.up);
                worldOffset1.applyQuaternion(worldRotation, this.right);
                var cosHit1 = egret3d.Vector3.dot(hit, worldOffset1);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset1, cosHit1);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset1, this.helpVec3_2);
                position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // let hit1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(hit1, this._dragOffset, hit1);
                // egret3d.Vector3.subtract(hit1, worldPosition, hit1);
                // let worldOffset = new egret3d.Vector3();
                // worldOffset.applyQuaternion(worldRotation, this.up);
                // let cosHit = egret3d.Vector3.dot(hit1, worldOffset);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // if (selectedGameObjs[0].transform.parent) {
                //     let parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix()
                //     parentMatrix = parentMatrix.inverse()
                //     parentMatrix.transformNormal(position)
                // }
                egret3d.Vector3.copy(position, this._ctrlPos);
                selectedGameObjs[0].transform.setPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            xyAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                var normal = this.forward;
                egret3d.Vector3.copy(normal, this._dragPlaneNormal);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            xyAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                // let worldOffset = new egret3d.Vector3;
                // let worldOffset1 = new egret3d.Vector3;
                // worldOffset = egret3d.Vector3.copy(this.right, this.helpVec3_1);
                // worldOffset1 = egret3d.Vector3.copy(this.up, this.helpVec3_1);
                // let cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                // let cosHit1 = egret3d.Vector3.dot(this._delta, worldOffset1);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // egret3d.Vector3.scale(worldOffset1, cosHit1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, this._delta, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getWorldMatrix()
                    //     parentMatrix = parentMatrix.inverse()
                    //     parentMatrix.transformNormal(this._newPosition)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            xyAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_2 = selectedGameObjs; _i < selectedGameObjs_2.length; _i++) {
                    var item = selectedGameObjs_2[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return xyAxis;
        }(editor.BaseGeo));
        editor.xyAxis = xyAxis;
        __reflect(xyAxis.prototype, "paper.editor.xyAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var xzAxis = (function (_super) {
            __extends(xzAxis, _super);
            function xzAxis() {
                return _super.call(this) || this;
            }
            xzAxis.prototype.onSet = function () {
                var xyPlane = this._createAxis(new egret3d.Vector4(0.0, 0.0, 1, 0.5), 3);
                xyPlane.name = "GizmoController_XZ";
                xyPlane.tag = "Editor";
                xyPlane.transform.setLocalScale(0.05, 0.05, 0.05);
                xyPlane.transform.setLocalEulerAngles(0, 90, 0);
                xyPlane.transform.setLocalPosition(0.2, 0, 0.2);
                this.geo = xyPlane;
            };
            xzAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                // let normal = new egret3d.Vector3(0, pos.y + pos.z, pos.z + pos.y)
                var normal = this.forward;
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.up);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                // let normal1 = new egret3d.Vector3(pos.x + pos.z, 0, pos.z + pos.x)
                // this._dragPlaneNormal1.applyQuaternion(worldRotation, normal1)
                // this._dragOffset1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(this._dragOffset1, worldPosition, this._dragOffset1);
            };
            xzAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset1 = new egret3d.Vector3();
                var worldOffset = new egret3d.Vector3();
                worldOffset.applyQuaternion(worldRotation, this.right);
                worldOffset1.applyQuaternion(worldRotation, this.forward);
                var cosHit1 = egret3d.Vector3.dot(hit, worldOffset1);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset1, cosHit1);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset1, this.helpVec3_2);
                position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // let hit1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(hit1, this._dragOffset, hit1);
                // egret3d.Vector3.subtract(hit1, worldPosition, hit1);
                // let worldOffset = new egret3d.Vector3();
                // worldOffset.applyQuaternion(worldRotation, this.up);
                // let cosHit = egret3d.Vector3.dot(hit1, worldOffset);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // if (selectedGameObjs[0].transform.parent) {
                //     let parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix()
                //     parentMatrix = parentMatrix.inverse()
                //     parentMatrix.transformNormal(position)
                // }
                egret3d.Vector3.copy(position, this._ctrlPos);
                selectedGameObjs[0].transform.setPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            xzAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                var normal = this.up;
                egret3d.Vector3.copy(normal, this._dragPlaneNormal);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            xzAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                // let worldOffset = new egret3d.Vector3;
                // let worldOffset1 = new egret3d.Vector3;
                // worldOffset = egret3d.Vector3.copy(this.right, this.helpVec3_1);
                // worldOffset1 = egret3d.Vector3.copy(this.up, this.helpVec3_1);
                // let cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                // let cosHit1 = egret3d.Vector3.dot(this._delta, worldOffset1);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // egret3d.Vector3.scale(worldOffset1, cosHit1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, this._delta, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getWorldMatrix()
                    //     parentMatrix = parentMatrix.inverse()
                    //     parentMatrix.transformNormal(this._newPosition)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            xzAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_3 = selectedGameObjs; _i < selectedGameObjs_3.length; _i++) {
                    var item = selectedGameObjs_3[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return xzAxis;
        }(editor.BaseGeo));
        editor.xzAxis = xzAxis;
        __reflect(xzAxis.prototype, "paper.editor.xzAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var yzAxis = (function (_super) {
            __extends(yzAxis, _super);
            function yzAxis() {
                return _super.call(this) || this;
            }
            yzAxis.prototype.onSet = function () {
                var xyPlane = this._createAxis(new egret3d.Vector4(0.0, 1, 0.0, 0.5), 3);
                xyPlane.name = "GizmoController_YZ";
                xyPlane.tag = "Editor";
                xyPlane.transform.setLocalScale(0.05, 0.05, 0.05);
                xyPlane.transform.setLocalEulerAngles(0, 0, 90);
                xyPlane.transform.setLocalPosition(0.0, 0.2, 0.2);
                this.geo = xyPlane;
            };
            yzAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                // let normal = new egret3d.Vector3(0, pos.y + pos.z, pos.z + pos.y)
                var normal = this.forward;
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.right);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                // let normal1 = new egret3d.Vector3(pos.x + pos.z, 0, pos.z + pos.x)
                // this._dragPlaneNormal1.applyQuaternion(worldRotation, normal1)
                // this._dragOffset1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(this._dragOffset1, worldPosition, this._dragOffset1);
            };
            yzAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset1 = new egret3d.Vector3();
                var worldOffset = new egret3d.Vector3();
                worldOffset.applyQuaternion(worldRotation, this.up);
                worldOffset1.applyQuaternion(worldRotation, this.forward);
                var cosHit1 = egret3d.Vector3.dot(hit, worldOffset1);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset1, cosHit1);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset1, this.helpVec3_2);
                position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // let hit1 = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal1);
                // egret3d.Vector3.subtract(hit1, this._dragOffset, hit1);
                // egret3d.Vector3.subtract(hit1, worldPosition, hit1);
                // let worldOffset = new egret3d.Vector3();
                // worldOffset.applyQuaternion(worldRotation, this.up);
                // let cosHit = egret3d.Vector3.dot(hit1, worldOffset);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // position = egret3d.Vector3.add(position, worldOffset, this.helpVec3_2);
                // if (selectedGameObjs[0].transform.parent) {
                //     let parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix()
                //     parentMatrix = parentMatrix.inverse()
                //     parentMatrix.transformNormal(position)
                // }
                egret3d.Vector3.copy(position, this._ctrlPos);
                selectedGameObjs[0].transform.setPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            yzAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var pos = paper.Application.sceneManager.editorScene.find("EditorCamera").transform.getPosition();
                var normal = this.right;
                egret3d.Vector3.copy(normal, this._dragPlaneNormal);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            yzAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                // let worldOffset = new egret3d.Vector3;
                // let worldOffset1 = new egret3d.Vector3;
                // worldOffset = egret3d.Vector3.copy(this.right, this.helpVec3_1);
                // worldOffset1 = egret3d.Vector3.copy(this.up, this.helpVec3_1);
                // let cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                // let cosHit1 = egret3d.Vector3.dot(this._delta, worldOffset1);
                // egret3d.Vector3.scale(worldOffset, cosHit);
                // egret3d.Vector3.scale(worldOffset1, cosHit1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, this._delta, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getWorldMatrix()
                    //     parentMatrix = parentMatrix.inverse()
                    //     parentMatrix.transformNormal(this._newPosition)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            yzAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_4 = selectedGameObjs; _i < selectedGameObjs_4.length; _i++) {
                    var item = selectedGameObjs_4[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return yzAxis;
        }(editor.BaseGeo));
        editor.yzAxis = yzAxis;
        __reflect(yzAxis.prototype, "paper.editor.yzAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var yAxis = (function (_super) {
            __extends(yAxis, _super);
            function yAxis() {
                return _super.call(this) || this;
            }
            yAxis.prototype.onSet = function () {
                var yAxis = this._createAxis(new egret3d.Vector4(0.0, 1, 0.0, 1), 0);
                yAxis.name = "GizmoController_Y";
                yAxis.tag = "Editor";
                yAxis.transform.setLocalScale(0.1, 2, 0.1);
                yAxis.transform.setLocalEulerAngles(0, 0, 0);
                yAxis.transform.setLocalPosition(0, 1, 0);
                this.geo = yAxis;
            };
            yAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.applyQuaternion(worldRotation, this.up);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
            };
            yAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset = new egret3d.Vector3;
                worldOffset.applyQuaternion(worldRotation, this.up);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset, this.helpVec3_2);
                egret3d.Vector3.copy(position, this._ctrlPos);
                // if (selectedGameObjs[0].transform.parent) {
                //     let parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix()
                //     parentMatrix = parentMatrix.inverse()
                //     parentMatrix.transformNormal(position)
                // }
                selectedGameObjs[0].transform.setPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            yAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.copy(this.up);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, normal);
            };
            yAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                worldOffset = egret3d.Vector3.copy(this.up, this.helpVec3_1);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                egret3d.Vector3.add(this._ctrlPos, worldOffset, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, worldOffset, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getWorldMatrix()
                    //     parentMatrix = parentMatrix.inverse()
                    //     parentMatrix.transformNormal(this._newPosition)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            yAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_5 = selectedGameObjs; _i < selectedGameObjs_5.length; _i++) {
                    var item = selectedGameObjs_5[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return yAxis;
        }(editor.BaseGeo));
        editor.yAxis = yAxis;
        __reflect(yAxis.prototype, "paper.editor.yAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var zAxis = (function (_super) {
            __extends(zAxis, _super);
            function zAxis() {
                return _super.call(this) || this;
            }
            zAxis.prototype.onSet = function () {
                var zAxis = this._createAxis(new egret3d.Vector4(0.0, 0.0, 1, 1), 0);
                zAxis.name = "GizmoController_Z";
                zAxis.tag = "Editor";
                zAxis.transform.setLocalScale(0.1, 2, 0.1);
                zAxis.transform.setLocalEulerAngles(90, 0, 0);
                zAxis.transform.setLocalPosition(0, 0, 1);
                this.geo = zAxis;
            };
            zAxis.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.applyQuaternion(worldRotation, this.forward);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
            };
            zAxis.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                egret3d.Vector3.subtract(hit, worldPosition, hit);
                var worldOffset = new egret3d.Vector3;
                worldOffset.applyQuaternion(worldRotation, this.forward);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                var position = egret3d.Vector3.add(worldPosition, worldOffset, this.helpVec3_2);
                egret3d.Vector3.copy(position, this._ctrlPos);
                if (selectedGameObjs[0].transform.parent) {
                    var parentMatrix = selectedGameObjs[0].transform.parent.getWorldMatrix();
                    parentMatrix = parentMatrix.inverse();
                    parentMatrix.transformNormal(position);
                }
                selectedGameObjs[0].transform.setLocalPosition(position);
                // this.editorModel.setTransformProperty("localPosition", position, selectedGameObjs[0].transform);
            };
            zAxis.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                egret3d.Vector3.set(0, 0, 0, this._dragOffset);
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                var normal = new egret3d.Vector3;
                var _normal = new egret3d.Vector3(ray.direction.x, ray.direction.y, ray.direction.z);
                normal.copy(this.forward);
                _normal.cross(normal);
                normal.cross(_normal);
                this._dragPlaneNormal = normal.normalize();
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, normal);
            };
            zAxis.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                worldOffset = egret3d.Vector3.copy(this.forward, this.helpVec3_1);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                egret3d.Vector3.scale(worldOffset, cosHit);
                egret3d.Vector3.add(this._ctrlPos, worldOffset, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var lastPos = obj.transform.getPosition();
                    egret3d.Vector3.add(lastPos, worldOffset, this._newPosition);
                    // if (obj.transform.parent) {
                    //     let parentMatrix = obj.transform.parent.getPosition();
                    //     this._newPosition.subtract(this._newPosition, parentMatrix)
                    // }
                    obj.transform.setPosition(this._newPosition);
                    // this.editorModel.setTransformProperty("localPosition", this._newPosition, obj.transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            zAxis.prototype.wasReleased = function (selectedGameObjs) {
                for (var _i = 0, selectedGameObjs_6 = selectedGameObjs; _i < selectedGameObjs_6.length; _i++) {
                    var item = selectedGameObjs_6[_i];
                    this.editorModel.setTransformProperty("localPosition", item.transform.getLocalPosition(), item.transform);
                }
            };
            return zAxis;
        }(editor.BaseGeo));
        editor.zAxis = zAxis;
        __reflect(zAxis.prototype, "paper.editor.zAxis");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var xRot = (function (_super) {
            __extends(xRot, _super);
            function xRot() {
                return _super.call(this) || this;
            }
            xRot.prototype.onSet = function () {
                var xRotate = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.8), 1);
                xRotate.name = "GizmoController_Rotate_X";
                xRotate.tag = "Editor";
                xRotate.transform.setLocalScale(2, 2, 2);
                xRotate.transform.setLocalEulerAngles(90, 0, 0);
                this.geo = xRotate;
                this.greyColor = this.geo.getComponent(egret3d.MeshRenderer).materials[0];
            };
            xRot.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var lastY = egret3d.InputManager.mouse.position.y;
                var lastX = egret3d.InputManager.mouse.position.x;
                this.helpVec3_1.set(lastX, lastY, 0);
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.up);
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            xRot.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var rot = selectedGameObjs[0].transform.getRotation();
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpQuat_2.multiply(this.helpQuat_1, rot);
                this.helpQuat_2.normalize();
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this.helpVec3_1.set(lastX, lastY, 0);
                selectedGameObjs[0].transform.setLocalRotation(this.helpQuat_2);
                // this.editorModel.setTransformProperty("rotation", this.helpQuat_2, selectedGameObjs[0].transform);
            };
            xRot.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.up);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                this.helpVec3_1.set(lastX, lastY, 0);
                this._ctrlRot = ctrlRot;
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            xRot.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this._ctrlRot.premultiply(this.helpQuat_1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var rot = obj.transform.getRotation();
                    this.helpQuat_2.multiply(this.helpQuat_1, rot);
                    this.helpQuat_2.normalize();
                    obj.transform.setLocalRotation(this.helpQuat_2);
                }
                this.helpVec3_1.set(lastX, lastY, 0);
            };
            xRot.prototype.wasReleased = function () {
                if (this.fan) {
                    this.fan.destroy();
                }
                return;
            };
            return xRot;
        }(editor.BaseGeo));
        editor.xRot = xRot;
        __reflect(xRot.prototype, "paper.editor.xRot");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var yRot = (function (_super) {
            __extends(yRot, _super);
            function yRot() {
                return _super.call(this) || this;
            }
            yRot.prototype.onSet = function () {
                var yRotate = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.8), 1);
                yRotate.name = "GizmoController_Rotate_Y";
                yRotate.tag = "Editor";
                yRotate.transform.setLocalScale(2, 2, 2);
                yRotate.transform.setLocalEulerAngles(90, 90, 0);
                this.geo = yRotate;
            };
            yRot.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                this.helpVec3_1.set(lastX, lastY, 0);
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.right);
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            yRot.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var rot = selectedGameObjs[0].transform.getRotation();
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpQuat_2.multiply(this.helpQuat_1, rot);
                this.helpQuat_2.normalize();
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this.helpVec3_1.set(lastX, lastY, 0);
                selectedGameObjs[0].transform.setLocalRotation(this.helpQuat_2);
                // this.editorModel.setTransformProperty("rotation", this.helpQuat_2, selectedGameObjs[0].transform);
            };
            yRot.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.right);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                this.helpVec3_1.set(lastX, lastY, 0);
                this._ctrlRot = ctrlRot;
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            yRot.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this._ctrlRot.premultiply(this.helpQuat_1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var rot = obj.transform.getRotation();
                    this.helpQuat_2.multiply(this.helpQuat_1, rot);
                    this.helpQuat_2.normalize();
                    obj.transform.setLocalRotation(this.helpQuat_2);
                }
                this.helpVec3_1.set(lastX, lastY, 0);
            };
            yRot.prototype.wasReleased = function () {
                if (this.fan) {
                    this.fan.destroy();
                }
                return;
            };
            return yRot;
        }(editor.BaseGeo));
        editor.yRot = yRot;
        __reflect(yRot.prototype, "paper.editor.yRot");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var zRot = (function (_super) {
            __extends(zRot, _super);
            function zRot() {
                return _super.call(this) || this;
            }
            zRot.prototype.onSet = function () {
                var zRotate = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.8), 1);
                zRotate.name = "GizmoController_Rotate_Z";
                zRotate.tag = "Editor";
                zRotate.transform.setLocalEulerAngles(0, 0, 0);
                zRotate.transform.setLocalScale(2, 2, 2);
                this.geo = zRotate;
            };
            zRot.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                this.helpVec3_1.set(lastX, lastY, 0);
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.forward);
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            zRot.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.x;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var rot = selectedGameObjs[0].transform.getRotation();
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpQuat_2.multiply(this.helpQuat_1, rot);
                this.helpQuat_2.normalize();
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this.helpVec3_1.set(lastX, lastY, 0);
                selectedGameObjs[0].transform.setLocalRotation(this.helpQuat_2);
                // this.editorModel.setTransformProperty("rotation", this.helpQuat_2, selectedGameObjs[0].transform);
            };
            zRot.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.forward);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                this.helpVec3_1.set(lastX, lastY, 0);
                this._ctrlRot = ctrlRot;
                this.fan = this._createAxis(new egret3d.Vector4(0.8, 0.8, 0.3, 0.6), 1);
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(0);
                this.fan.transform.setLocalPosition(this.geo.transform.getPosition());
                this.fan.transform.setLocalRotation(this.geo.transform.getRotation());
                this.fan.transform.setLocalScale(this.geo.parent.transform.getScale());
                this.helpVec3_3.x = 0;
            };
            zRot.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var delta = lastY - this.helpVec3_1.y + lastX - this.helpVec3_1.x;
                var cos = Math.cos(delta / 180 * Math.PI / 2), sin = Math.sin(delta / 180 * Math.PI / 2);
                this.helpQuat_1.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos);
                this.helpVec3_3.x = this.helpVec3_3.x + delta;
                this.fan.getComponent(egret3d.MeshFilter).mesh = this.createFan(this.helpVec3_3.x);
                this._ctrlRot.premultiply(this.helpQuat_1);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var rot = obj.transform.getRotation();
                    this.helpQuat_2.multiply(this.helpQuat_1, rot);
                    this.helpQuat_2.normalize();
                    obj.transform.setLocalRotation(this.helpQuat_2);
                }
                this.helpVec3_1.set(lastX, lastY, 0);
            };
            zRot.prototype.wasReleased = function () {
                if (this.fan) {
                    this.fan.destroy();
                }
                return;
            };
            return zRot;
        }(editor.BaseGeo));
        editor.zRot = zRot;
        __reflect(zRot.prototype, "paper.editor.zRot");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ballRot = (function (_super) {
            __extends(ballRot, _super);
            function ballRot() {
                return _super.call(this) || this;
            }
            ballRot.prototype.onSet = function () {
                var xRotate = this._createAxis(new egret3d.Vector4(0.3, 0.3, 0.2, 0.4), 1);
                xRotate.name = "GizmoController_Rotate_X";
                xRotate.tag = "Editor";
                xRotate.transform.setLocalScale(1.3, 1.3, 1.3);
                xRotate.getComponent(egret3d.MeshFilter).mesh = this.drawBall(32);
                this.geo = xRotate;
            };
            ballRot.prototype.drawBall = function (SPHERE_DIV) {
                var points = [];
                var indices = [];
                for (var j = 0; j <= SPHERE_DIV; j++) {
                    var aj = j * Math.PI / SPHERE_DIV;
                    var sj = Math.sin(aj);
                    var cj = Math.cos(aj);
                    for (var i = 0; i <= SPHERE_DIV; i++) {
                        var ai = i * 2 * Math.PI / SPHERE_DIV;
                        var si = Math.sin(ai);
                        var ci = Math.cos(ai);
                        points.push(si * sj); //point为顶点坐标
                        points.push(cj);
                        points.push(ci * sj);
                    }
                }
                for (var j = 0; j < SPHERE_DIV; j++) {
                    for (var i = 0; i < SPHERE_DIV; i++) {
                        var p1 = j * (SPHERE_DIV + 1) + i;
                        var p2 = p1 + (SPHERE_DIV + 1);
                        indices.push(p1); //indices为顶点的索引
                        indices.push(p2);
                        indices.push(p1 + 1);
                        indices.push(p1 + 1);
                        indices.push(p2);
                        indices.push(p2 + 1);
                    }
                }
                var mesh = new egret3d.Mesh(points.length, indices.length);
                mesh.setAttributes("POSITION" /* POSITION */, points);
                mesh.setIndices(indices);
                return mesh;
            };
            ballRot.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var lastY = egret3d.InputManager.mouse.position.y;
                var lastX = egret3d.InputManager.mouse.position.x;
                this.helpVec3_1.set(lastX, lastY, 0);
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.up);
            };
            ballRot.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var deltaX = -(lastX - this.helpVec3_1.x);
                var deltaY = -(lastY - this.helpVec3_1.y);
                var rot = selectedGameObjs[0].transform.getRotation();
                var cosX = Math.cos(deltaX / 180 * Math.PI / 2), sinX = Math.sin(deltaX / 180 * Math.PI / 2);
                var cosY = Math.cos(deltaY / 180 * Math.PI / 2), sinY = Math.sin(deltaY / 180 * Math.PI / 2);
                this._dragPlaneNormal.set(0, 1, 0);
                this.helpQuat_1.set(this._dragPlaneNormal.x * sinX, this._dragPlaneNormal.y * sinX, this._dragPlaneNormal.z * sinX, cosX);
                this.helpQuat_2.multiply(this.helpQuat_1, rot);
                this.helpQuat_2.normalize();
                var camera = paper.Application.sceneManager.editorScene.find("EditorCamera");
                camera.transform.getRight(this._dragPlaneNormal);
                this._dragPlaneNormal.normalize();
                this.helpQuat_1.set(this._dragPlaneNormal.x * sinY, this._dragPlaneNormal.y * sinY, this._dragPlaneNormal.z * sinY, cosY);
                this.helpQuat_2.multiply(this.helpQuat_1, this.helpQuat_2);
                this.helpQuat_2.normalize();
                this.helpVec3_1.set(lastX, lastY, 0);
                selectedGameObjs[0].transform.setLocalRotation(this.helpQuat_2);
                // this.editorModel.setTransformProperty("rotation", this.helpQuat_2, selectedGameObjs[0].transform);
            };
            ballRot.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                var ctrlRot = this.geo.transform.parent.getRotation();
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                this.helpVec3_1.set(lastX, lastY, 0);
                this._ctrlRot = ctrlRot;
            };
            ballRot.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var lastX = egret3d.InputManager.mouse.position.x;
                var lastY = egret3d.InputManager.mouse.position.y;
                var deltaX = -(lastX - this.helpVec3_1.x);
                var deltaY = -(lastY - this.helpVec3_1.y);
                var cosX = Math.cos(deltaX / 180 * Math.PI / 2), sinX = Math.sin(deltaX / 180 * Math.PI / 2);
                var cosY = Math.cos(deltaY / 180 * Math.PI / 2), sinY = Math.sin(deltaY / 180 * Math.PI / 2);
                var camera = paper.Application.sceneManager.editorScene.find("EditorCamera");
                this._dragPlaneNormal.set(0, 1, 0);
                this.helpQuat_1.set(this._dragPlaneNormal.x * sinX, this._dragPlaneNormal.y * sinX, this._dragPlaneNormal.z * sinX, cosX);
                camera.transform.getRight(this._dragPlaneNormal);
                this._dragPlaneNormal.normalize();
                this.helpQuat_2.set(this._dragPlaneNormal.x * sinY, this._dragPlaneNormal.y * sinY, this._dragPlaneNormal.z * sinY, cosY);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    var rot = obj.transform.getRotation();
                    rot.multiply(this.helpQuat_1, rot);
                    rot.normalize();
                    rot.multiply(this.helpQuat_2, rot);
                    rot.normalize();
                    obj.transform.setLocalRotation(rot);
                }
                this._ctrlRot.premultiply(this.helpQuat_1);
                this._ctrlRot.premultiply(this.helpQuat_2);
                this.helpVec3_1.set(lastX, lastY, 0);
            };
            ballRot.prototype.wasReleased = function () { return; };
            return ballRot;
        }(editor.BaseGeo));
        editor.ballRot = ballRot;
        __reflect(ballRot.prototype, "paper.editor.ballRot");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var xScl = (function (_super) {
            __extends(xScl, _super);
            function xScl() {
                return _super.call(this) || this;
            }
            xScl.prototype.onSet = function () {
                var xScale = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 1), 2);
                xScale.name = "GizmoController_Scale_X";
                xScale.tag = "Editor";
                xScale.transform.setLocalScale(0.2, 0.2, 0.2);
                xScale.transform.setLocalPosition(2, 0, 0);
                this.geo = xScale;
            };
            xScl.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.up);
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                this._initRotation.copy(worldRotation);
                egret3d.Vector3.copy(selectedGameObjs[0].transform.getLocalScale(), this._oldLocalScale);
            };
            xScl.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, worldPosition, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                worldOffset.applyQuaternion(worldRotation, this.right);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                var len = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                this.geo.transform.setLocalPosition(cosHit / len * 2, 0, 0);
                var oldScale = this._oldLocalScale;
                var sx = this.geo.transform.getLocalPosition().x / 2;
                var sy = 1;
                var sz = 1;
                scale = egret3d.Vector3.set(oldScale.x * sx, oldScale.y * sy, oldScale.z * sz, this.helpVec3_2);
                this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[0].transform);
            };
            xScl.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._ctrlRot = ctrlRot;
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.up);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            xScl.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                var len = selectedGameObjs.length;
                worldOffset.applyQuaternion(this._ctrlRot, this.right);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                var src = this.geo.transform.getLocalPosition().x;
                this.geo.transform.setLocalPosition(cosHit + src, 0, 0);
                var s = cosHit / src + 1;
                for (var i = 0; i < len; i++) {
                    var lastSca = selectedGameObjs[i].transform.getLocalScale();
                    scale = egret3d.Vector3.set(lastSca.x * s, lastSca.y, lastSca.z, this.helpVec3_2);
                    this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[i].transform);
                    var pos = selectedGameObjs[i].transform.getPosition();
                    var sub = this.helpVec3_2;
                    egret3d.Vector3.subtract(pos, this._ctrlPos, this.helpVec3_2);
                    this.helpVec3_3.applyQuaternion(this.geo.transform.parent.getRotation(), this.right);
                    var cos = egret3d.Vector3.dot(sub, this.helpVec3_3);
                    egret3d.Vector3.scale(this.helpVec3_3, cos * (s - 1));
                    egret3d.Vector3.add(pos, this.helpVec3_3, pos);
                    this.editorModel.setTransformProperty("position", pos, selectedGameObjs[i].transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            xScl.prototype.wasReleased = function () {
                this.geo.transform.setLocalPosition(2, 0, 0);
            };
            return xScl;
        }(editor.BaseGeo));
        editor.xScl = xScl;
        __reflect(xScl.prototype, "paper.editor.xScl");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var yScl = (function (_super) {
            __extends(yScl, _super);
            function yScl() {
                return _super.call(this) || this;
            }
            yScl.prototype.onSet = function () {
                var yScale = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 1), 2);
                yScale.name = "GizmoController_Scale_Y";
                yScale.tag = "Editor";
                yScale.transform.setLocalScale(0.2, 0.2, 0.2);
                yScale.transform.setLocalPosition(0, 2, 0);
                this.geo = yScale;
            };
            yScl.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.forward);
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                this._initRotation.copy(worldRotation);
                egret3d.Vector3.copy(selectedGameObjs[0].transform.getLocalScale(), this._oldLocalScale);
            };
            yScl.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, worldPosition, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                worldOffset.applyQuaternion(worldRotation, this.up);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                var len = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                this.geo.transform.setLocalPosition(0, cosHit / len * 2, 0);
                var oldScale = this._oldLocalScale;
                var sx = 1;
                var sy = this.geo.transform.getLocalPosition().y / 2;
                var sz = 1;
                scale = egret3d.Vector3.set(oldScale.x * sx, oldScale.y * sy, oldScale.z * sz, this.helpVec3_2);
                this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[0].transform);
            };
            yScl.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._ctrlRot = ctrlRot;
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.forward);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            yScl.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                var len = selectedGameObjs.length;
                worldOffset.applyQuaternion(this._ctrlRot, this.up);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                var src = this.geo.transform.getLocalPosition().y;
                this.geo.transform.setLocalPosition(0, cosHit + src, 0);
                var s = cosHit / src + 1;
                for (var i = 0; i < len; i++) {
                    var lastSca = selectedGameObjs[i].transform.getLocalScale();
                    scale = egret3d.Vector3.set(lastSca.x, lastSca.y * s, lastSca.z, this.helpVec3_2);
                    this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[i].transform);
                    var pos = selectedGameObjs[i].transform.getPosition();
                    var sub = this.helpVec3_2;
                    egret3d.Vector3.subtract(pos, this._ctrlPos, this.helpVec3_2);
                    this.helpVec3_3.applyQuaternion(this.geo.parent.transform.getRotation(), this.up);
                    var cos = egret3d.Vector3.dot(sub, this.helpVec3_3);
                    egret3d.Vector3.scale(this.helpVec3_3, cos * (s - 1));
                    egret3d.Vector3.add(pos, this.helpVec3_3, pos);
                    this.editorModel.setTransformProperty("position", pos, selectedGameObjs[i].transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            yScl.prototype.wasReleased = function () {
                this.geo.transform.setLocalPosition(0, 2, 0);
            };
            return yScl;
        }(editor.BaseGeo));
        editor.yScl = yScl;
        __reflect(yScl.prototype, "paper.editor.yScl");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var zScl = (function (_super) {
            __extends(zScl, _super);
            function zScl() {
                return _super.call(this) || this;
            }
            zScl.prototype.onSet = function () {
                var zScale = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 1), 2);
                zScale.name = "GizmoController_Scale_Z";
                zScale.tag = "Editor";
                zScale.transform.setLocalScale(0.2, 0.2, 0.2);
                zScale.transform.setLocalPosition(0, 0, 2);
                this.geo = zScale;
            };
            zScl.prototype.wasPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                this._dragPlaneNormal.applyQuaternion(worldRotation, this.up);
                egret3d.Vector3.copy(worldPosition, this._dragPlanePoint);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(this._dragOffset, worldPosition, this._dragOffset);
                this._initRotation.copy(worldRotation);
                egret3d.Vector3.copy(selectedGameObjs[0].transform.getLocalScale(), this._oldLocalScale);
            };
            zScl.prototype.isPressed_local = function (ray, selectedGameObjs) {
                var worldRotation = selectedGameObjs[0].transform.getRotation();
                var worldPosition = selectedGameObjs[0].transform.getPosition();
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, worldPosition, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                worldOffset.applyQuaternion(worldRotation, this.forward);
                var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                var len = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                this.geo.transform.setLocalPosition(0, 0, cosHit / len * 2);
                var oldScale = this._oldLocalScale;
                var sx = 1;
                var sy = 1;
                var sz = this.geo.transform.getLocalPosition().z / 2;
                scale = egret3d.Vector3.set(oldScale.x * sx, oldScale.y * sy, oldScale.z * sz, this.helpVec3_2);
                this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[0].transform);
            };
            zScl.prototype.wasPressed_world = function (ray, selectedGameObjs) {
                var len = selectedGameObjs.length;
                var ctrlPos = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                for (var i = 0; i < len; i++) {
                    var obj = selectedGameObjs[i];
                    egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                }
                ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                var ctrlRot = this.geo.transform.parent.getRotation();
                this._ctrlRot = ctrlRot;
                egret3d.Vector3.copy(ctrlPos, this._dragPlanePoint);
                this._dragPlaneNormal.applyQuaternion(ctrlRot, this.up);
                this._dragOffset = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
            };
            zScl.prototype.isPressed_world = function (ray, selectedGameObjs) {
                var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                var worldOffset = new egret3d.Vector3;
                var scale;
                var len = selectedGameObjs.length;
                worldOffset.applyQuaternion(this._ctrlRot, this.forward);
                var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                var src = this.geo.transform.getLocalPosition().z;
                this.geo.transform.setLocalPosition(0, 0, cosHit + src);
                var s = cosHit / src + 1;
                for (var i = 0; i < len; i++) {
                    var lastSca = selectedGameObjs[i].transform.getLocalScale();
                    scale = egret3d.Vector3.set(lastSca.x, lastSca.y, lastSca.z * s, this.helpVec3_2);
                    this.editorModel.setTransformProperty("localScale", scale, selectedGameObjs[i].transform);
                    var pos = selectedGameObjs[i].transform.getPosition();
                    var sub = this.helpVec3_2;
                    egret3d.Vector3.subtract(pos, this._ctrlPos, this.helpVec3_2);
                    this.helpVec3_3.applyQuaternion(this.geo.parent.transform.getRotation(), this.forward);
                    var cos = egret3d.Vector3.dot(sub, this.helpVec3_3);
                    egret3d.Vector3.scale(this.helpVec3_3, cos * (s - 1));
                    egret3d.Vector3.add(pos, this.helpVec3_3, pos);
                    this.editorModel.setTransformProperty("position", pos, selectedGameObjs[i].transform);
                }
                egret3d.Vector3.copy(hit, this._dragOffset);
            };
            zScl.prototype.wasReleased = function () {
                this.geo.transform.setLocalPosition(0, 0, 2);
            };
            return zScl;
        }(editor.BaseGeo));
        editor.zScl = zScl;
        __reflect(zScl.prototype, "paper.editor.zScl");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.EventType = {
            HistoryState: "HistoryState",
            HistoryAdd: "HistoryAdd",
            HistoryFree: "HistoryFree"
        };
        var History = (function () {
            function History() {
                this.dispatcher = null;
                this._locked = 0;
                this._index = -1;
                this._batchIndex = 0;
                this._states = [];
                this._batchStates = [];
                this._events = [];
            }
            History.prototype._free = function () {
                if (this._states.length > this._index + 1) {
                    this._states.length = this._index + 1; // TODO release.
                    if (this.dispatcher) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryFree, null));
                    }
                }
            };
            History.prototype._doState = function (state, isUndo) {
                if (isUndo) {
                    state.undo();
                }
                else {
                    state.redo();
                }
                var d = isUndo ? "undo" : "redo";
                if (this.dispatcher) {
                    var data = { isUndo: isUndo };
                    this._events.push(data);
                }
                return state.batchIndex > 0 && (isUndo ? this._index >= 0 : this._index < this._states.length - 1);
            };
            History.prototype.back = function () {
                if (this._index < 0 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[this._index--], true)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_1 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_1));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.forward = function () {
                if (this._index >= this._states.length - 1 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[++this._index], false)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_2 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_2));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.go = function (index) {
                if (this._batchIndex > 0) {
                    return false;
                }
                var result = false;
                if (this._index < index) {
                    while (this._index !== index && this.forward()) {
                        result = true;
                    }
                }
                else {
                    while (this._index !== index && this.back()) {
                        result = true;
                    }
                }
                return result;
            };
            History.prototype.add = function (state) {
                if (this._locked !== 0) {
                    return;
                }
                if (this._batchIndex > 0) {
                    state.batchIndex = this._batchIndex;
                    this._batchStates.push(state);
                }
                else {
                    this._states[this._index + 1] = state;
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this.forward();
                    this._free();
                }
            };
            History.prototype.beginBatch = function () {
                this._batchIndex++;
            };
            History.prototype.endBatch = function () {
                if (this._batchIndex === 0) {
                    return;
                }
                this._batchIndex--;
                if (this._batchIndex === 0) {
                    var index = this._index + 1;
                    for (var _i = 0, _a = this._batchStates; _i < _a.length; _i++) {
                        var state = _a[_i];
                        this._states[index++] = state;
                    }
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this._batchStates.length = 0;
                    this.go(this._states.length - 1);
                }
            };
            History.prototype.getState = function (index) {
                return this._states[index];
            };
            Object.defineProperty(History.prototype, "enabled", {
                get: function () {
                    return this._locked === 0;
                },
                set: function (value) {
                    if (value) {
                        this._locked &= 1;
                    }
                    else {
                        this._locked |= 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "count", {
                get: function () {
                    return this._states.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "batchIndex", {
                get: function () {
                    return this._batchIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "states", {
                get: function () {
                    return this._states;
                },
                enumerable: true,
                configurable: true
            });
            History.prototype.serialize = function () {
                var states = this.states;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element.hasOwnProperty('deserialize') ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                var serializeHistory = {
                    index: this.index,
                    batchIndex: this.batchIndex,
                    locked: this.locked,
                    statesData: statesData,
                };
                return serializeHistory;
            };
            History.prototype.deserialize = function (serializeHistory) {
                var states = [];
                var statesData = serializeHistory.statesData;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = void 0;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element.hasOwnProperty('deserialize') ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        states.push(state);
                    }
                }
                var initData = {
                    states: states,
                    index: serializeHistory.index,
                    batchIndex: serializeHistory.batchIndex,
                    locked: serializeHistory.locked,
                };
                this._index = initData ? initData.index : -1;
                this._locked = initData ? initData.locked : 0;
                this._batchIndex = initData ? initData.batchIndex : 0;
                this._states = initData ? initData.states : [];
            };
            return History;
        }());
        editor.History = History;
        __reflect(History.prototype, "paper.editor.History");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxFixedSubSteps = 3;
            _this.fixedDeltaTime = 1.0 / 50.0; // TODO same as fps.
            _this.timeScale = 1.0;
            _this._frameCount = 0;
            _this._beginTime = 0.0;
            _this._lastTime = 0.0;
            _this._delayTime = 0.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            /**
             * @internal
             */
            _this._fixedTime = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._beginTime = Date.now() * 0.001;
        };
        /**
         * @internal
         */
        Clock.prototype.update = function (time) {
            if (this._unscaledTime !== 0.0) {
                this._lastTime = this._unscaledTime;
                if (this._fixedTime < this.fixedDeltaTime) {
                }
                else if (this._fixedTime < this.fixedDeltaTime * this.maxFixedSubSteps) {
                    this._fixedTime %= this.fixedDeltaTime;
                }
                else {
                    this._fixedTime -= this.fixedDeltaTime * this.maxFixedSubSteps;
                }
            }
            var now = time || Date.now() * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - this._lastTime;
            this._fixedTime += this._unscaledDeltaTime;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "deltaTime", {
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        return Clock;
    }(paper.SingletonComponent));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 状态组
         * @author 杨宁
         */
        var StateGroup = (function (_super) {
            __extends(StateGroup, _super);
            function StateGroup() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            StateGroup.create = function (stateList) {
                var instance = new StateGroup();
                instance.stateList = stateList;
                return instance;
            };
            StateGroup.prototype.redo = function () {
                for (var i = 0; i < this.stateList.length; i++) {
                    this.stateList[i].redo();
                }
                return true;
            };
            StateGroup.prototype.undo = function () {
                for (var i = this.stateList.length - 1; i >= 0; i--) {
                    this.stateList[i].undo();
                }
                return true;
            };
            StateGroup.prototype.serialize = function () {
                var states = this.stateList;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element['serialize'] ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                return states;
            };
            StateGroup.prototype.deserialize = function (data) {
                this.stateList = [];
                var statesData = data;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element['deserialize'] ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        this.stateList.push(state);
                    }
                }
            };
            return StateGroup;
        }(editor.BaseState));
        editor.StateGroup = StateGroup;
        __reflect(StateGroup.prototype, "paper.editor.StateGroup");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ModifyGameObjectPropertyState = (function (_super) {
            __extends(ModifyGameObjectPropertyState, _super);
            function ModifyGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyGameObjectPropertyState.create = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = new ModifyGameObjectPropertyState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyGameObjectPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyGameObjectPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var uuid = this.stateData.gameObjectUUid;
                var modifyObj = this.editorModel.getGameObjectByUUid(uuid);
                if (modifyObj !== null) {
                    valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                        var propName, copyValue, valueEditType, newValue;
                        return __generator(this, function (_a) {
                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                            this.editorModel.setTargetProperty(propName, modifyObj, newValue);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                            return [2 /*return*/];
                        });
                    }); });
                }
            };
            ModifyGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyGameObjectPropertyState;
        }(editor.BaseState));
        editor.ModifyGameObjectPropertyState = ModifyGameObjectPropertyState;
        __reflect(ModifyGameObjectPropertyState.prototype, "paper.editor.ModifyGameObjectPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改组件属性属性
        var ModifyComponentPropertyState = (function (_super) {
            __extends(ModifyComponentPropertyState, _super);
            function ModifyComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyComponentPropertyState.toString = function () {
                return "[class common.ModifyComponentPropertyState]";
            };
            ModifyComponentPropertyState.create = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = new ModifyComponentPropertyState();
                var data = {
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyComponentPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyComponentPropertyState.prototype.modifyProperty = function (valueList) {
                var _this = this;
                var gameObjectUUid = this.stateData.gameObjUUid;
                var componentUUid = this.stateData.componentUUid;
                var gameObj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                var modifyObj;
                if (gameObj) {
                    modifyObj = this.editorModel.getComponentById(gameObj, componentUUid);
                    if (modifyObj) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, modifyObj, newValue);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                                return [2 /*return*/];
                            });
                        }); });
                    }
                }
            };
            ModifyComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyComponentPropertyState;
        }(editor.BaseState));
        editor.ModifyComponentPropertyState = ModifyComponentPropertyState;
        __reflect(ModifyComponentPropertyState.prototype, "paper.editor.ModifyComponentPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //创建游戏对象
        var CreateGameObjectState = (function (_super) {
            __extends(CreateGameObjectState, _super);
            function CreateGameObjectState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isFirst = true;
                return _this;
            }
            CreateGameObjectState.toString = function () {
                return "[class common.AddGameObjectState]";
            };
            CreateGameObjectState.create = function (parentList, createType) {
                var infos = parentList.map(function (obj) { return { parentUUID: obj.uuid, serializeData: null }; });
                var state = new CreateGameObjectState();
                state.infos = infos;
                state.createType = createType;
                return state;
            };
            CreateGameObjectState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    //一条信息都没有则添加到场景根
                    if (this.infos.length === 0) {
                        this.infos.push({ parentUUID: null, serializeData: null });
                    }
                    for (var i = 0; i < this.infos.length; i++) {
                        var obj = void 0;
                        if (this.isFirst) {
                            obj = this.createGameObjectByType(this.createType);
                            this.infos[i].serializeData = paper.serialize(obj);
                        }
                        else {
                            obj = new paper.Deserializer().deserialize(this.infos[i].serializeData, true);
                        }
                        var parent_3 = this.editorModel.getGameObjectByUUid(this.infos[i].parentUUID);
                        if (parent_3)
                            obj.transform.parent = parent_3.transform;
                        this.addList.push(obj.uuid);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.isFirst = false;
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.createGameObjectByType = function (createType) {
                var obj;
                switch (createType) {
                    case 'empty':
                        obj = new paper.GameObject();
                        obj.name = "NewGameObject";
                        break;
                    case 'cube':
                        obj = new paper.GameObject();
                        obj.name = "cube";
                        var mesh = obj.addComponent(egret3d.MeshFilter);
                        mesh.mesh = egret3d.DefaultMeshes.CUBE;
                        var renderer = obj.addComponent(egret3d.MeshRenderer);
                        break;
                }
                return obj;
            };
            return CreateGameObjectState;
        }(editor.BaseState));
        editor.CreateGameObjectState = CreateGameObjectState;
        __reflect(CreateGameObjectState.prototype, "paper.editor.CreateGameObjectState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //删除游戏对象
        var DeleteGameObjectsState = (function (_super) {
            __extends(DeleteGameObjectsState, _super);
            function DeleteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DeleteGameObjectsState.toString = function () {
                return "[class common.deleteGameObjectsState]";
            };
            DeleteGameObjectsState.create = function (gameObjects, editorModel) {
                gameObjects = gameObjects.concat();
                //筛选
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //排序
                gameObjects = editorModel.sortGameObjectsForHierarchy(gameObjects);
                var infos = [];
                for (var i = 0; i < gameObjects.length; i++) {
                    var obj = gameObjects[i];
                    var oldParentUUID = void 0;
                    var oldIndex = void 0;
                    var serializeData = paper.serialize(obj);
                    if (obj.transform.parent) {
                        oldParentUUID = obj.transform.parent.gameObject.uuid;
                        oldIndex = obj.transform.parent.children.indexOf(obj.transform);
                    }
                    else {
                        oldParentUUID = undefined;
                        oldIndex = paper.Application.sceneManager.activeScene.gameObjects.indexOf(obj);
                    }
                    infos.push({ UUID: obj.uuid, oldParentUUID: oldParentUUID, oldIndex: oldIndex, serializeData: serializeData });
                }
                var state = new DeleteGameObjectsState();
                state.deleteInfo = infos;
                return state;
            };
            DeleteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    for (var i = 0; i < this.deleteInfo.length; i++) {
                        var info = this.deleteInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, true);
                        var oldParentObj = this.editorModel.getGameObjectByUUid(info.oldParentUUID);
                        if (oldParentObj) {
                            var oldTargetTransform = oldParentObj.transform.children[info.oldIndex];
                            if (oldTargetTransform) {
                                this.editorModel.setGameObjectsHierarchy([obj], oldTargetTransform.gameObject, 'top');
                            }
                            else {
                                this.editorModel.setGameObjectsHierarchy([obj], oldParentObj, 'inner');
                            }
                        }
                        else {
                            obj.transform.parent = null;
                            var all = paper.Application.sceneManager.activeScene.gameObjects;
                            var currentIndex = all.indexOf(obj);
                            all.splice(currentIndex, 1);
                            all.splice(info.oldIndex, 0, obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.deleteInfo.map(function (info) { return info.UUID; }));
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var ids = this.deleteInfo.map(function (info) { return info.UUID; });
                    var objs = this.editorModel.getGameObjectsByUUids(ids);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, ids);
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.serialize = function () {
                return this.deleteInfo;
            };
            DeleteGameObjectsState.prototype.deserialize = function (data) {
                this.deleteInfo = data;
            };
            return DeleteGameObjectsState;
        }(editor.BaseState));
        editor.DeleteGameObjectsState = DeleteGameObjectsState;
        __reflect(DeleteGameObjectsState.prototype, "paper.editor.DeleteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //克隆游戏对象
        var DuplicateGameObjectsState = (function (_super) {
            __extends(DuplicateGameObjectsState, _super);
            function DuplicateGameObjectsState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstDo = true;
                return _this;
            }
            DuplicateGameObjectsState.toString = function () {
                return "[class common.DuplicateGameObjectsState]";
            };
            DuplicateGameObjectsState.create = function (objs, editorModel) {
                //过滤
                editorModel.filtTopHierarchyGameObjects(objs);
                //排序
                objs = editorModel.sortGameObjectsForHierarchy(objs);
                var duplicateInfo = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var UUID = obj.uuid;
                    var parentUUID = obj.transform.parent ? obj.transform.parent.gameObject.uuid : null;
                    var serializeData = paper.serialize(obj);
                    duplicateInfo.push({ UUID: UUID, parentUUID: parentUUID, serializeData: serializeData });
                }
                var state = new DuplicateGameObjectsState();
                state.duplicateInfo = duplicateInfo;
                return state;
            };
            DuplicateGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    for (var i = 0; i < this.duplicateInfo.length; i++) {
                        var info = this.duplicateInfo[i];
                        var obj = new paper.Deserializer().deserialize(info.serializeData, !this.firstDo);
                        var parent_4 = this.editorModel.getGameObjectByUUid(info.parentUUID);
                        if (parent_4) {
                            obj.transform.parent = parent_4.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (this.firstDo) {
                            info.serializeData = paper.serialize(obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.firstDo = false;
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            DuplicateGameObjectsState.prototype.serialize = function () {
                return { duplicateInfo: this.duplicateInfo, addList: this.addList };
            };
            DuplicateGameObjectsState.prototype.deserialize = function (data) {
                this.duplicateInfo = data.duplicateInfo;
                this.addList = data.addList;
            };
            return DuplicateGameObjectsState;
        }(editor.BaseState));
        editor.DuplicateGameObjectsState = DuplicateGameObjectsState;
        __reflect(DuplicateGameObjectsState.prototype, "paper.editor.DuplicateGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //粘贴游戏对象
        var PasteGameObjectsState = (function (_super) {
            __extends(PasteGameObjectsState, _super);
            function PasteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PasteGameObjectsState.toString = function () {
                return "[class common.PasteGameObjectsState]";
            };
            PasteGameObjectsState.create = function (serializeData, parent) {
                var state = new PasteGameObjectsState();
                var parentUUID = parent ? parent.uuid : null;
                state.pasteInfo = { parentUUID: parentUUID, serializeData: serializeData };
                return state;
            };
            PasteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = this.editorModel.getGameObjectsByUUids(this.addList);
                    for (var index = 0; index < objs.length; index++) {
                        var element = objs[index];
                        element.destroy();
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    var parent_5 = this.editorModel.getGameObjectByUUid(this.pasteInfo.parentUUID);
                    var serializeDataList = this.cacheSerializeData ? this.cacheSerializeData : this.pasteInfo.serializeData;
                    var keepUID = this.cacheSerializeData ? true : false;
                    for (var i = 0; i < serializeDataList.length; i++) {
                        var info = serializeDataList[i];
                        var obj = new paper.Deserializer().deserialize(info, keepUID);
                        if (obj && parent_5) {
                            obj.transform.parent = parent_5.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (serializeDataList === this.pasteInfo.serializeData) {
                            if (!this.cacheSerializeData)
                                this.cacheSerializeData = [];
                            this.cacheSerializeData.push(paper.serialize(obj));
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (this.editorModel.isPrefabChild(obj)) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            PasteGameObjectsState.prototype.serialize = function () {
                return { pasteInfo: this.pasteInfo, addList: this.addList };
            };
            PasteGameObjectsState.prototype.deserialize = function (data) {
                this.addList = data.addList;
                this.pasteInfo = data.pasteInfo;
            };
            return PasteGameObjectsState;
        }(editor.BaseState));
        editor.PasteGameObjectsState = PasteGameObjectsState;
        __reflect(PasteGameObjectsState.prototype, "paper.editor.PasteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var AddComponentState = (function (_super) {
            __extends(AddComponentState, _super);
            function AddComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddComponentState.toString = function () {
                return "[class common.AddComponentState]";
            };
            AddComponentState.create = function (gameObjectUUid, compClzName) {
                var state = new AddComponentState();
                var data = { gameObjectUUid: gameObjectUUid, compClzName: compClzName };
                state.data = data;
                return state;
            };
            Object.defineProperty(AddComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            AddComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentId = this.stateData.cacheComponentId;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        var component = this.editorModel.getComponentById(gameObject, componentId);
                        if (component) {
                            gameObject.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            AddComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var compClzName = this.stateData.compClzName;
                    var gameObject = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        if (this.stateData.serializeData) {
                            new paper.Deserializer().deserialize(this.data.serializeData, true, false, gameObject);
                        }
                        else {
                            var compClz = egret.getDefinitionByName(compClzName);
                            var addComponent = gameObject.addComponent(compClz);
                            this.stateData.serializeData = paper.serialize(addComponent);
                            this.stateData.cacheComponentId = addComponent.uuid;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            return AddComponentState;
        }(editor.BaseState));
        editor.AddComponentState = AddComponentState;
        __reflect(AddComponentState.prototype, "paper.editor.AddComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //移除组件
        var RemoveComponentState = (function (_super) {
            __extends(RemoveComponentState, _super);
            function RemoveComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemoveComponentState.toString = function () {
                return "[class common.RemoveComponentState]";
            };
            RemoveComponentState.create = function (gameObjectUUid, componentUUid, cacheSerializeData) {
                var state = new RemoveComponentState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    componentUUid: componentUUid,
                    cacheSerializeData: cacheSerializeData
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(RemoveComponentState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RemoveComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObject = this.editorModel.getGameObjectByUUid(this.stateData.gameObjectUUid);
                    if (gameObject) {
                        new paper.Deserializer().deserialize(this.stateData.cacheSerializeData, true, false, gameObject);
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            RemoveComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.stateData.gameObjectUUid;
                    var componentUUid = this.stateData.componentUUid;
                    var obj = this.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (obj) {
                        var component = this.editorModel.getComponentById(obj, componentUUid);
                        if (component) {
                            obj.removeComponent(component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            return RemoveComponentState;
        }(editor.BaseState));
        editor.RemoveComponentState = RemoveComponentState;
        __reflect(RemoveComponentState.prototype, "paper.editor.RemoveComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 游戏对象层级
         * @author 杨宁
         */
        var GameObjectHierarchyState = (function (_super) {
            __extends(GameObjectHierarchyState, _super);
            function GameObjectHierarchyState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.gameObjectsInfo = [];
                return _this;
            }
            GameObjectHierarchyState.create = function (gameObjects, targetGameObj, dir, editorModel) {
                //筛选
                gameObjects = gameObjects.concat();
                editorModel.filtTopHierarchyGameObjects(gameObjects);
                //必须进行层级排序
                var objs = editorModel.sortGameObjectsForHierarchy(gameObjects);
                //整理对象信息
                var objInfos = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var oldTargetUUID = void 0;
                    var oldDir = void 0;
                    if (obj.transform.parent) {
                        var index = obj.transform.parent.children.indexOf(obj.transform);
                        if (++index < obj.transform.parent.children.length) {
                            oldTargetUUID = obj.transform.parent.children[index].gameObject.uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = obj.transform.parent.gameObject.uuid;
                            oldDir = 'inner';
                        }
                    }
                    else {
                        var all = paper.Application.sceneManager.activeScene.gameObjects;
                        var index = all.indexOf(obj);
                        if (++index < all.length) {
                            oldTargetUUID = all[index].uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = 'scene'; //特殊标记，用来标记最外层最后一个
                            oldDir = 'inner';
                        }
                    }
                    objInfos.push({ UUID: obj.uuid, oldTargetUUID: oldTargetUUID, oldDir: oldDir });
                }
                var instance = new GameObjectHierarchyState();
                instance.gameObjectsInfo = objInfos;
                instance.targetDir = dir;
                instance.targetObject = targetGameObj.uuid;
                return instance;
            };
            GameObjectHierarchyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var tmpList = this.gameObjectsInfo.concat();
                    tmpList.reverse();
                    for (var index = 0; index < tmpList.length; index++) {
                        var info = tmpList[index];
                        var obj = this.editorModel.getGameObjectByUUid(info.UUID);
                        var oldTarget = this.editorModel.getGameObjectByUUid(info.oldTargetUUID);
                        ;
                        var oldDir = info.oldDir;
                        if (info.oldTargetUUID === 'scene') {
                            var all = paper.Application.sceneManager.activeScene.gameObjects;
                            oldTarget = all[all.length - 1];
                            oldDir = 'bottom';
                        }
                        this.editorModel.setGameObjectsHierarchy([obj], oldTarget, oldDir);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            GameObjectHierarchyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUids = this.gameObjectsInfo.map(function (v) { return v.UUID; });
                    var gameObjs = this.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var targetGameObj = this.editorModel.getGameObjectByUUid(this.targetObject);
                    gameObjs = this.editorModel.sortGameObjectsForHierarchy(gameObjs);
                    this.editorModel.setGameObjectsHierarchy(gameObjs, targetGameObj, this.targetDir);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            return GameObjectHierarchyState;
        }(editor.BaseState));
        editor.GameObjectHierarchyState = GameObjectHierarchyState;
        __reflect(GameObjectHierarchyState.prototype, "paper.editor.GameObjectHierarchyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改asset
        var ModifyAssetPropertyState = (function (_super) {
            __extends(ModifyAssetPropertyState, _super);
            function ModifyAssetPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyAssetPropertyState.toString = function () {
                return "[class common.ModifyAssetPropertyState]";
            };
            ModifyAssetPropertyState.create = function (assetUrl, newValueList, preValueCopylist) {
                var state = new ModifyAssetPropertyState();
                var data = {
                    assetUrl: assetUrl,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist
                };
                state.data = data;
                return state;
            };
            ModifyAssetPropertyState.prototype.modifyAssetPropertyValues = function (assetUrl, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var target;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.editorModel.getAssetByAssetUrl(assetUrl)];
                            case 1:
                                target = _a.sent();
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                        newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                        this.editorModel.setTargetProperty(propName, target, newValue);
                                        this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: newValue });
                                        return [2 /*return*/];
                                    });
                                }); });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            ModifyAssetPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, assetUrl = _a.assetUrl, preValueCopylist = _a.preValueCopylist;
                    this.modifyAssetPropertyValues(assetUrl, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyAssetPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, newValueList = _a.newValueList, assetUrl = _a.assetUrl;
                    this.modifyAssetPropertyValues(assetUrl, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyAssetPropertyState;
        }(editor.BaseState));
        editor.ModifyAssetPropertyState = ModifyAssetPropertyState;
        __reflect(ModifyAssetPropertyState.prototype, "paper.editor.ModifyAssetPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var CreatePrefabState = (function (_super) {
            __extends(CreatePrefabState, _super);
            function CreatePrefabState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            CreatePrefabState.toString = function () {
                return "[class common.CreatePrefabState]";
            };
            CreatePrefabState.create = function (prefab, parent) {
                var state = new CreatePrefabState();
                var parentUUID = parent ? parent.uuid : undefined;
                var data = {
                    prefab: prefab,
                    parentUUID: parentUUID
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(CreatePrefabState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            CreatePrefabState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var deleteUUid = this.stateData.cachePrefabUUid;
                    if (deleteUUid) {
                        var gameObj = this.editorModel.getGameObjectByUUid(deleteUUid);
                        if (gameObj) {
                            gameObj.destroy();
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS);
                        }
                    }
                    return true;
                }
                return false;
            };
            CreatePrefabState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var prefab = this.stateData.prefab;
                    if (prefab) {
                        var instance = this.stateData.prefab.createInstance();
                        this.stateData.cachePrefabUUid = instance.uuid;
                        var parent_6 = this.editorModel.getGameObjectByUUid(this.stateData.parentUUID);
                        if (parent_6) {
                            instance.transform.parent = parent_6.transform;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                    }
                    return true;
                }
                return false;
            };
            return CreatePrefabState;
        }(editor.BaseState));
        editor.CreatePrefabState = CreatePrefabState;
        __reflect(CreatePrefabState.prototype, "paper.editor.CreatePrefabState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 预置体结构状态
         * @author 杨宁
         */
        var BreakPrefabStructState = (function (_super) {
            __extends(BreakPrefabStructState, _super);
            function BreakPrefabStructState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.prefabInfos = [];
                return _this;
            }
            BreakPrefabStructState.create = function (prefabInstanceList) {
                var _this = this;
                var instance = new BreakPrefabStructState();
                instance.prefabInfos = [];
                prefabInstanceList.forEach(function (obj) {
                    for (var _i = 0, _a = instance.prefabInfos; _i < _a.length; _i++) {
                        var info = _a[_i];
                        if (info.uuid === obj.uuid)
                            return;
                    }
                    instance.prefabInfos = instance.prefabInfos.concat(_this.makePrefabInfo(obj));
                });
                return instance;
            };
            BreakPrefabStructState.makePrefabInfo = function (gameOjbect) {
                var isPrefabRoot = function (gameObj) {
                    if (gameObj.extras.prefab) {
                        return true;
                    }
                    return false;
                };
                var isPrefabChild = function (gameObj) {
                    if (gameObj.extras.rootID) {
                        return true;
                    }
                    return false;
                };
                var makeInfo = function (target, result) {
                    if (result === void 0) { result = []; }
                    result.push({ uuid: target.uuid, linkid: target.extras.linkedID, rootid: target.extras.rootID, prefab: target.extras.prefab.name });
                    target.transform.children.forEach(function (transform) {
                        var obj = transform.gameObject;
                        if (isPrefabChild(obj) && !isPrefabRoot(obj)) {
                            makeInfo(obj, result);
                        }
                    });
                };
                var target = gameOjbect;
                var infos = [];
                while (target) {
                    if (isPrefabRoot(target)) {
                        makeInfo(target, infos);
                        break;
                    }
                    if (target.transform.parent)
                        target = target.transform.parent.gameObject;
                    else
                        break;
                }
                return infos;
            };
            BreakPrefabStructState.prototype.redo = function () {
                var _this = this;
                var ids = this.prefabInfos.map(function (prefabInfos) { return prefabInfos.uuid; });
                var objs = this.editorModel.getGameObjectsByUUids(ids);
                objs.forEach(function (obj) {
                    obj.extras.linkedID = undefined;
                    obj.extras.prefab = undefined;
                    obj.extras.rootID = undefined;
                    _this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: null });
                });
                return true;
            };
            BreakPrefabStructState.prototype.undo = function () {
                var all = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < all.length; i++) {
                    var obj = all[i];
                    b: for (var k = 0; k < this.prefabInfos.length; k++) {
                        var info = this.prefabInfos[k];
                        if (obj.uuid === info.uuid) {
                            obj.extras.linkedID = info.linkid;
                            obj.extras.prefab = paper.Asset.find(info.prefab);
                            obj.extras.rootID = info.rootid;
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: obj, propName: 'prefab', propValue: obj.extras.prefab });
                            break b;
                        }
                    }
                }
                return true;
            };
            BreakPrefabStructState.prototype.serialize = function () {
                return this.prefabInfos;
            };
            BreakPrefabStructState.prototype.deserialize = function (data) {
                this.prefabInfos = data;
            };
            return BreakPrefabStructState;
        }(editor.BaseState));
        editor.BreakPrefabStructState = BreakPrefabStructState;
        __reflect(BreakPrefabStructState.prototype, "paper.editor.BreakPrefabStructState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var ApplyPrefabInstanceState = (function (_super) {
            __extends(ApplyPrefabInstanceState, _super);
            function ApplyPrefabInstanceState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstRedo = true;
                return _this;
            }
            ApplyPrefabInstanceState.toString = function () {
                return "[class common.ApplyPrefabInstanceState]";
            };
            ApplyPrefabInstanceState.create = function (applyData, applyPrefabRootId, prefab) {
                var state = new ApplyPrefabInstanceState();
                var cachePrefabSerializedData = editor.Editor.activeEditorModel.deepClone(prefab._raw);
                var data = {
                    applyPrefabRootId: applyPrefabRootId,
                    prefab: prefab,
                    applyData: applyData,
                    cachePrefabSerializedData: cachePrefabSerializedData
                };
                data.cacheGameObjetsIds = [];
                data.cacheComponentsIds = {};
                state.data = data;
                return state;
            };
            Object.defineProperty(ApplyPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ApplyPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    var objects = paper.Application.sceneManager.activeScene.gameObjects;
                    for (var index = objects.length - 1; index >= 0; index--) {
                        if (this.stateData.cacheGameObjetsIds.length === 0 && Object.keys(this.stateData.cacheComponentsIds).length === 0) {
                            break;
                        }
                        var gameObj = objects[index];
                        var gIndex = this.stateData.cacheGameObjetsIds.indexOf(gameObj.uuid);
                        if (gIndex >= 0) {
                            gameObj.destroy();
                            this.stateData.cacheGameObjetsIds.splice(gIndex, 1);
                        }
                        else if (this.stateData.cacheComponentsIds[gameObj.uuid] && this.stateData.cacheComponentsIds[gameObj.uuid].length > 0) {
                            var comIds = this.stateData.cacheComponentsIds[gameObj.uuid];
                            for (var comIndex = gameObj.components.length - 1; comIndex >= 0; comIndex--) {
                                var com = gameObj.components[comIndex];
                                var cIndex = comIds.indexOf(com.uuid);
                                if (cIndex >= 0) {
                                    gameObj.removeComponent(com);
                                    comIds.splice(cIndex, 1);
                                    if (comIds.length === 0) {
                                        delete this.stateData.cacheComponentsIds[gameObj.uuid];
                                    }
                                }
                            }
                        }
                    }
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    for (var linkedId in this.stateData.applyData) {
                        var applyData = this.stateData.applyData[linkedId];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var originalObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalObj) {
                                    this.clearLinkedId(originalObj);
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.addComponent && applyData.addComponents.length > 0) {
                            for (var index = 0; index < applyData.addComponents.length; index++) {
                                var element = applyData.addComponents[index];
                                var id = element.id, gameObjId = element.gameObjId;
                                var originalObj = this.getGameObjectByUUid(applyGameObject, gameObjId.id);
                                if (originalObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalObj, id);
                                    if (originalComponent) {
                                        originalComponent.extras = {};
                                    }
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = applyData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                this.modifyPrefabGameObjectPropertyValues(linkedId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = applyData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                this.modifyPrefabComponentPropertyValues(linkedId, obj.componentId, tempPrefabObject, obj.preValueCopylist);
                            }
                        }
                    }
                    //reset prefab serrializedata,save prefab
                    this.stateData.prefab._raw = this.stateData.cachePrefabSerializedData;
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, this.stateData.prefab.name);
                    tempPrefabObject.destroy();
                    tempPrefabObject = null;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.getAllUUidFromGameObject = function (gameObj, uuids) {
                if (uuids === void 0) { uuids = null; }
                if (gameObj) {
                    uuids = uuids || [];
                    uuids.push(gameObj.uuid);
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        uuids.push(com.uuid);
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.getAllUUidFromGameObject(obj, uuids);
                    }
                }
                return uuids;
            };
            ApplyPrefabInstanceState.prototype.setLinkedId = function (gameObj, ids) {
                if (gameObj) {
                    var linkedId = ids.shift();
                    if (linkedId === undefined) {
                        console.error("linkedId error");
                    }
                    gameObj.extras.linkedID = linkedId;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var com = _a[_i];
                        linkedId = ids.shift();
                        if (linkedId === undefined) {
                            console.error("linkedId error");
                        }
                        com.extras.linkedID = linkedId;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.setLinkedId(obj, ids);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearLinkedId = function (gameObj) {
                if (gameObj) {
                    gameObj.extras = {};
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearLinkedId(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (linkedId, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                valueList.forEach(function (propertyValue) {
                    var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                    var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                    objects.forEach(function (object) {
                        if (paper.equal(object[propName], prefabObj[propName])) {
                            _this.editorModel.setTargetProperty(propName, object, newValue);
                            _this.dispathPropertyEvent(object, propName, newValue);
                        }
                    });
                    _this.editorModel.setTargetProperty(propName, prefabObj, newValue);
                });
                this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
            };
            ApplyPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (linkedId, componentUUid, tempObj, valueList) {
                var _this = this;
                var prefabObj = this.getGameObjectByLinkedId(tempObj, linkedId);
                var objects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                var _loop_1 = function (k) {
                    var prefabComp = prefabObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) {
                            var propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                            var newValue = _this.editorModel.deserializeProperty(copyValue, valueEditType);
                            objects.forEach(function (object) {
                                var objectComp = _this.editorModel.getComponentByAssetId(object, prefabComp.extras.linkedID);
                                if (objectComp !== null) {
                                    if (paper.equal(objectComp[propName], prefabComp[propName])) {
                                        _this.editorModel.setTargetProperty(propName, objectComp, newValue);
                                        _this.dispathPropertyEvent(objectComp, propName, newValue);
                                    }
                                }
                            });
                            _this.editorModel.setTargetProperty(propName, prefabComp, newValue);
                        });
                    }
                };
                for (var k = 0; k < prefabObj.components.length; k++) {
                    _loop_1(k);
                }
            };
            ApplyPrefabInstanceState.prototype.setGameObjectPrefabRootId = function (gameObj, rootID) {
                if (gameObj.extras.prefab == undefined) {
                    gameObj.extras.rootID = rootID;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefabRootId(obj, rootID);
                }
            };
            ApplyPrefabInstanceState.prototype.getGameObjectsByLinkedId = function (linkedId, filterApplyRootId) {
                var objects = paper.Application.sceneManager.activeScene.gameObjects;
                var result = [];
                for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
                    var obj = objects_1[_i];
                    if ((obj.extras && obj.extras.linkedID && obj.extras.linkedID == linkedId) && (obj.extras.prefab || (obj.extras.rootID && obj.extras.rootID != filterApplyRootId)) && obj.uuid != filterApplyRootId) {
                        result.push(obj);
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByLinkedId = function (gameObj, linkedID) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.extras.linkedID === linkedID) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByLinkedId(obj, linkedID);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.getGameObjectByUUid = function (gameObj, uuid) {
                if (!gameObj) {
                    return null;
                }
                var result;
                if (gameObj.uuid === uuid) {
                    result = gameObj;
                    return gameObj;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    result = this.getGameObjectByUUid(obj, uuid);
                    if (result) {
                        break;
                    }
                }
                return result;
            };
            ApplyPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var tempPrefabObject = this.stateData.prefab.createInstance(paper.Application.sceneManager.globalScene, true);
                    var allGameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(tempPrefabObject);
                    var applyGameObject = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.applyPrefabRootId);
                    for (var _i = 0, _a = allGameObjects; _i < _a.length; _i++) {
                        var gameObj = _a[_i];
                        if (!(this.stateData.applyData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var applyData = this.stateData.applyData[gameObj.extras.linkedID];
                        if (applyData.addGameObjects && applyData.addGameObjects.length > 0) {
                            for (var index = 0; index < applyData.addGameObjects.length; index++) {
                                var obj = applyData.addGameObjects[index];
                                var ids = [];
                                var newObj = void 0;
                                if (this.firstRedo) {
                                    newObj = new paper.Deserializer().deserialize(obj.serializeData, false, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = [];
                                    obj.cacheSerializeData[gameObj.uuid][index] = paper.serialize(newObj);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid][index];
                                    newObj = new paper.Deserializer().deserialize(cacheData, true, false, paper.Application.sceneManager.globalScene);
                                    newObj.parent = gameObj;
                                    ids = this.getAllUUidFromGameObject(newObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _b = 0, instanceGameObjects_1 = instanceGameObjects; _b < instanceGameObjects_1.length; _b++) {
                                    var instanceGameObject = instanceGameObjects_1[_b];
                                    var addObj = void 0;
                                    if (this.firstRedo) {
                                        addObj = new paper.Deserializer().deserialize(obj.serializeData, false);
                                        addObj.parent = instanceGameObject;
                                        var rootId = instanceGameObject.extras.prefab ? instanceGameObject.uuid : instanceGameObject.extras.rootID;
                                        this.setGameObjectPrefabRootId(addObj, rootId);
                                        this.setLinkedId(addObj, ids.concat());
                                        obj.cacheSerializeData[instanceGameObject.uuid] = [];
                                        obj.cacheSerializeData[instanceGameObject.uuid][index] = paper.serialize(addObj);
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid][index];
                                        addObj = new paper.Deserializer().deserialize(cacheData, true);
                                        addObj.parent = instanceGameObject;
                                    }
                                    if (addObj) {
                                        this.stateData.cacheGameObjetsIds.push(addObj.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.id);
                                if (originalGameObj) {
                                    this.setGameObjectPrefabRootId(originalGameObj, this.stateData.applyPrefabRootId);
                                    this.setLinkedId(originalGameObj, ids.concat());
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (applyData.addComponents && applyData.addComponents.length > 0) {
                            for (var _c = 0, _d = applyData.addComponents; _c < _d.length; _c++) {
                                var obj = _d[_c];
                                var newComponent = void 0;
                                if (this.firstRedo) {
                                    newComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, gameObj);
                                    obj.cacheSerializeData = Object.create(null);
                                    obj.cacheSerializeData[gameObj.uuid] = paper.serialize(newComponent);
                                }
                                else {
                                    var cacheData = obj.cacheSerializeData[gameObj.uuid];
                                    newComponent = new paper.Deserializer().deserialize(cacheData, true, false, gameObj);
                                }
                                var linkedId = gameObj.extras.linkedID;
                                var instanceGameObjects = this.getGameObjectsByLinkedId(linkedId, this.stateData.applyPrefabRootId);
                                for (var _e = 0, instanceGameObjects_2 = instanceGameObjects; _e < instanceGameObjects_2.length; _e++) {
                                    var instanceGameObject = instanceGameObjects_2[_e];
                                    var addComponent = void 0;
                                    if (this.firstRedo) {
                                        addComponent = new paper.Deserializer().deserialize(obj.serializeData, false, false, instanceGameObject);
                                        addComponent.extras.linkedID = newComponent.uuid;
                                        obj.cacheSerializeData[instanceGameObject.uuid] = paper.serialize(addComponent);
                                    }
                                    else {
                                        var cacheData = obj.cacheSerializeData[instanceGameObject.uuid];
                                        addComponent = new paper.Deserializer().deserialize(cacheData, true, false, instanceGameObject);
                                    }
                                    this.stateData.cacheComponentsIds[instanceGameObject.uuid] = this.stateData.cacheComponentsIds[instanceGameObject.uuid] || [];
                                    if (addComponent) {
                                        this.stateData.cacheComponentsIds[instanceGameObject.uuid].push(addComponent.uuid);
                                    }
                                }
                                var originalGameObj = this.getGameObjectByUUid(applyGameObject, obj.gameObjId);
                                if (originalGameObj) {
                                    var originalComponent = editor.Editor.activeEditorModel.getComponentById(originalGameObj, obj.id);
                                    originalComponent.extras.linkedID = newComponent.uuid;
                                }
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (applyData.modifyGameObjectPropertyList && applyData.modifyGameObjectPropertyList.length > 0) {
                            for (var _f = 0, _g = applyData.modifyGameObjectPropertyList; _f < _g.length; _f++) {
                                var obj = _g[_f];
                                this.modifyPrefabGameObjectPropertyValues(gameObj.extras.linkedID, tempPrefabObject, obj.newValueList);
                            }
                        }
                        if (applyData.modifyComponentPropertyList && applyData.modifyComponentPropertyList.length > 0) {
                            for (var _h = 0, _j = applyData.modifyComponentPropertyList; _h < _j.length; _h++) {
                                var obj = _j[_h];
                                this.modifyPrefabComponentPropertyValues(gameObj.extras.linkedID, obj.componentId, tempPrefabObject, obj.newValueList);
                            }
                        }
                    }
                    this.clearGameObjectExtrasInfo(tempPrefabObject);
                    this.stateData.prefab._raw = this.clearExtrasFromSerilizeData(paper.serialize(tempPrefabObject));
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.SAVE_ASSET, this.stateData.prefab.name);
                    tempPrefabObject.destroy();
                    this.firstRedo = false;
                    return true;
                }
                return false;
            };
            ApplyPrefabInstanceState.prototype.clearGameObjectExtrasInfo = function (gameObj) {
                if (gameObj) {
                    delete gameObj.extras;
                    for (var _i = 0, _a = gameObj.components; _i < _a.length; _i++) {
                        var comp = _a[_i];
                        delete comp.extras;
                    }
                    for (var index = 0; index < gameObj.transform.children.length; index++) {
                        var element = gameObj.transform.children[index];
                        var obj = element.gameObject;
                        this.clearGameObjectExtrasInfo(obj);
                    }
                }
            };
            ApplyPrefabInstanceState.prototype.clearExtrasFromSerilizeData = function (data) {
                var objects = data.objects;
                var components = data.components;
                for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {
                    var obj = objects_2[_i];
                    delete obj["extras"];
                }
                for (var _a = 0, components_5 = components; _a < components_5.length; _a++) {
                    var comp = components_5[_a];
                    delete comp["extras"];
                }
                return data;
            };
            return ApplyPrefabInstanceState;
        }(editor.BaseState));
        editor.ApplyPrefabInstanceState = ApplyPrefabInstanceState;
        __reflect(ApplyPrefabInstanceState.prototype, "paper.editor.ApplyPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var RevertPrefabInstanceState = (function (_super) {
            __extends(RevertPrefabInstanceState, _super);
            function RevertPrefabInstanceState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RevertPrefabInstanceState.toString = function () {
                return "[class common.RevertPrefabInstanceState]";
            };
            RevertPrefabInstanceState.create = function (revertData, revertPrefabRootId) {
                var state = new RevertPrefabInstanceState();
                var data = { revertData: revertData, revertPrefabRootId: revertPrefabRootId };
                state.data = data;
                return state;
            };
            Object.defineProperty(RevertPrefabInstanceState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            RevertPrefabInstanceState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds = [];
                    for (var _i = 0, gameObjects_3 = gameObjects; _i < gameObjects_3.length; _i++) {
                        var gameObj = gameObjects_3[_i];
                        if (!(this.stateData.revertData[gameObj.extras.linkedID])) {
                            continue;
                        }
                        var revertData = this.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            for (var _a = 0, _b = revertData.revertGameObjects; _a < _b.length; _a++) {
                                var obj = _b[_a];
                                var serializeData = obj.serializeData;
                                var newObj = new paper.Deserializer().deserialize(serializeData, true);
                                newObj.parent = gameObj;
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS);
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            for (var _c = 0, _d = revertData.revertComponents; _c < _d.length; _c++) {
                                var com = _d[_c];
                                var serializeData = com.serializeData;
                                new paper.Deserializer().deserialize(serializeData, true, false, gameObj);
                            }
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _e = 0, _f = revertData.modifyGameObjectPropertyList; _e < _f.length; _e++) {
                                var obj = _f[_e];
                                var preValueCopylist = obj.newValueList;
                                this.modifyPrefabGameObjectPropertyValues(gameObj, preValueCopylist);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _g = 0, _h = revertData.modifyComponentPropertyList; _g < _h.length; _g++) {
                                var obj = _h[_g];
                                var componentId = obj.componentId, preValueCopylist = obj.preValueCopylist;
                                this.modifyPrefabComponentPropertyValues(gameObj, componentId, preValueCopylist);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            RevertPrefabInstanceState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabGameObjectPropertyValues = function (gameObj, valueList) {
                var _this = this;
                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                    var propName, copyValue, valueEditType, newValue;
                    return __generator(this, function (_a) {
                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                        newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                        this.editorModel.setTargetProperty(propName, gameObj, newValue);
                        this.dispathPropertyEvent(gameObj, propName, newValue);
                        return [2 /*return*/];
                    });
                }); });
            };
            RevertPrefabInstanceState.prototype.modifyPrefabComponentPropertyValues = function (gameObj, componentUUid, valueList) {
                var _this = this;
                var _loop_2 = function (k) {
                    var prefabComp = gameObj.components[k];
                    if (prefabComp.uuid === componentUUid) {
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                newValue = this.editorModel.deserializeProperty(copyValue, valueEditType);
                                this.editorModel.setTargetProperty(propName, prefabComp, newValue);
                                this.dispathPropertyEvent(prefabComp, propName, newValue);
                                return [2 /*return*/];
                            });
                        }); });
                    }
                };
                for (var k = 0; k < gameObj.components.length; k++) {
                    _loop_2(k);
                }
            };
            RevertPrefabInstanceState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var revertRoot = editor.Editor.activeEditorModel.getGameObjectByUUid(this.stateData.revertPrefabRootId);
                    var gameObjects = editor.Editor.activeEditorModel.getAllGameObjectsFromPrefabInstance(revertRoot);
                    var removeGameObjIds_1 = [];
                    var _loop_3 = function (gameObj) {
                        if (!(this_1.stateData.revertData[gameObj.extras.linkedID])) {
                            return "continue";
                        }
                        var revertData = this_1.stateData.revertData[gameObj.extras.linkedID];
                        if (revertData.revertGameObjects && revertData.revertGameObjects.length > 0) {
                            revertData.revertGameObjects.forEach(function (element) {
                                removeGameObjIds_1.push(element.id);
                            });
                        }
                        if (revertData.revertComponents && revertData.revertComponents.length > 0) {
                            var revertComponentIds_1 = [];
                            revertData.revertComponents.forEach(function (element) {
                                revertComponentIds_1.push(element.id);
                            });
                            var components = gameObj.components;
                            for (var index = components.length - 1; index >= 0; index--) {
                                var element = components[index];
                                if (revertComponentIds_1.indexOf(element.uuid) >= 0) {
                                    gameObj.removeComponent(element.constructor);
                                }
                            }
                            this_1.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                        }
                        if (revertData.modifyGameObjectPropertyList && revertData.modifyGameObjectPropertyList.length > 0) {
                            for (var _i = 0, _a = revertData.modifyGameObjectPropertyList; _i < _a.length; _i++) {
                                var obj = _a[_i];
                                var newValueList = obj.newValueList;
                                this_1.modifyPrefabGameObjectPropertyValues(gameObj, newValueList);
                            }
                        }
                        if (revertData.modifyComponentPropertyList && revertData.modifyComponentPropertyList.length > 0) {
                            for (var _b = 0, _c = revertData.modifyComponentPropertyList; _b < _c.length; _b++) {
                                var obj = _c[_b];
                                var componentId = obj.componentId, newValueList = obj.newValueList;
                                this_1.modifyPrefabComponentPropertyValues(gameObj, componentId, newValueList);
                            }
                        }
                    };
                    var this_1 = this;
                    for (var _i = 0, gameObjects_4 = gameObjects; _i < gameObjects_4.length; _i++) {
                        var gameObj = gameObjects_4[_i];
                        _loop_3(gameObj);
                    }
                    var gameObjs = editor.Editor.activeEditorModel.getGameObjectsByUUids(removeGameObjIds_1);
                    gameObjs.forEach(function (element) { return element.destroy(); });
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS);
                    return true;
                }
                return false;
            };
            return RevertPrefabInstanceState;
        }(editor.BaseState));
        editor.RevertPrefabInstanceState = RevertPrefabInstanceState;
        __reflect(RevertPrefabInstanceState.prototype, "paper.editor.RevertPrefabInstanceState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ValueUUID = (function () {
            function ValueUUID(_value) {
                this._value = _value;
                // empty
            }
            ValueUUID.prototype.asHex = function () {
                return this._value;
            };
            return ValueUUID;
        }());
        __reflect(ValueUUID.prototype, "ValueUUID", ["paper.editor.UUID"]);
        var V4UUID = (function (_super) {
            __extends(V4UUID, _super);
            function V4UUID() {
                return _super.call(this, [
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    '4',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._oneOf(V4UUID._timeHighBits),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                ].join('')) || this;
            }
            V4UUID._oneOf = function (array) {
                return array[Math.floor(array.length * Math.random())];
            };
            V4UUID._randomHex = function () {
                return V4UUID._oneOf(V4UUID._chars);
            };
            V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
            return V4UUID;
        }(ValueUUID));
        __reflect(V4UUID.prototype, "V4UUID");
        function v4() {
            return new V4UUID();
        }
        editor.v4 = v4;
        var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        function isUUID(value) {
            return _UUIDPattern.test(value);
        }
        editor.isUUID = isUUID;
        /**
         * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
         * @param value A uuid string.
         */
        function parse(value) {
            if (!isUUID(value)) {
                throw new Error('invalid uuid');
            }
            return new ValueUUID(value);
        }
        editor.parse = parse;
        function generateUuid() {
            return v4().asHex();
        }
        editor.generateUuid = generateUuid;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var forward = new egret3d.Vector3();
        var up = new egret3d.Vector3();
        var right = new egret3d.Vector3();
        var EditorCameraScript = (function (_super) {
            __extends(EditorCameraScript, _super);
            function EditorCameraScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.moveSpeed = 20;
                _this.wheelSpeed = 2;
                _this.rotateSpeed = 1;
                _this._lastMouseX = 0;
                _this._lastMouseY = 0;
                _this._mouseDown_r = false;
                _this._mouseDown_l = false;
                _this._mouseDown_m = false;
                _this._lookAtPiont = new egret3d.Vector3();
                _this._dragPlanePoint = new egret3d.Vector3(0, 0, 0);
                _this._dragPlaneNormal = new egret3d.Vector3(0, 1, 0);
                _this._helpQuat = new egret3d.Quaternion();
                _this._helpVec3 = new egret3d.Vector3();
                return _this;
            }
            EditorCameraScript.prototype.onStart = function () {
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.bindMouse = egret3d.InputManager.mouse;
            };
            ;
            EditorCameraScript.prototype.onUpdate = function (delta) {
                this.inputUpdate(delta);
                //this.mouseUpdate(delta);
                //Gizmo.DrawLine(new egret3d.Vector3(-5, 5, 0.5), new egret3d.Vector3(5, 5, 0.5), 100.0, [1.0, 0.0, 0.0, 1.0]);
                // Gizmo.DrawCoord();
                // Gizmo.DrawLights();
                // Gizmo.DrawCameras();
                //Gizmo.DrawArrowXYZ();
                // this.editorModel.geoController.update();
            };
            ;
            EditorCameraScript.prototype.OnEnable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.OnDisable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.inputUpdate = function (delta) {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                forward.x = 0;
                forward.y = 0;
                forward.z = 0;
                up.x = 0;
                up.y = this.moveSpeed * delta;
                up.z = 0;
                right.x = this.moveSpeed * delta;
                right.y = 0;
                right.z = 0;
                var rotation = this.gameObject.transform.getLocalRotation();
                up.applyQuaternion(rotation);
                right.applyQuaternion(rotation);
                var p = this.gameObject.transform.getLocalPosition();
                var result = new egret3d.Vector3();
                egret3d.Vector3.copy(p, result);
                //上下左右
                if (keyboard.isPressed("LEFT")) {
                    egret3d.Vector3.subtract(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("RIGHT")) {
                    egret3d.Vector3.add(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("UP")) {
                    egret3d.Vector3.add(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("DOWN")) {
                    egret3d.Vector3.subtract(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (mouse.isPressed(1)) {
                    if (!this._mouseDown_m) {
                        this._mouseDown_m = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var move = new egret3d.Vector3;
                        move.z = 0;
                        move.x = (mouse.position.x - this._lastMouseX) / 10;
                        move.y = -(mouse.position.y - this._lastMouseY) / 10;
                        move.applyQuaternion(rotation);
                        egret3d.Vector3.subtract(result, move, result);
                        this.gameObject.transform.setLocalPosition(result);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (mouse.wasReleased(1)) {
                    this._mouseDown_m = false;
                }
                //放大缩小
                if (mouse.wheel !== 0) {
                    forward.z = mouse.wheel * this.wheelSpeed;
                    forward.applyQuaternion(rotation);
                    result.add(forward);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (mouse.isPressed(2) && keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        forward.z = moveX * 0.1 + moveY * 0.1;
                        forward.applyQuaternion(rotation);
                        egret3d.Vector3.add(result, forward, result);
                        this.gameObject.transform.setLocalPosition(result);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_r = false;
                }
                //方向
                if (mouse.isPressed(2) && !keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                        console.log(this.gameObject.transform.getLocalEulerAngles());
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        var theta_x = moveY * this.rotateSpeed, theta_y = moveX * this.rotateSpeed;
                        var sinX = Math.sin(theta_x / 180 * Math.PI / 2), cosX = Math.cos(theta_x / 180 * Math.PI / 2);
                        var sinY = Math.sin(theta_y / 180 * Math.PI / 2), cosY = Math.cos(theta_y / 180 * Math.PI / 2);
                        var rot = this.gameObject.transform.getRotation();
                        this.gameObject.transform.getRight(this._helpVec3);
                        egret3d.Vector3.normalize(this._helpVec3);
                        this._helpQuat.set(sinX * this._helpVec3.x, sinX * this._helpVec3.y, sinX * this._helpVec3.z, cosX);
                        rot.multiply(this._helpQuat, rot);
                        rot.normalize();
                        egret3d.Vector3.set(0, 1, 0, this._helpVec3);
                        this._helpQuat.set(sinY * this._helpVec3.x, sinY * this._helpVec3.y, sinY * this._helpVec3.z, cosY);
                        rot.multiply(this._helpQuat, rot);
                        rot.normalize();
                        this.gameObject.transform.setRotation(rot);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (mouse.wasReleased(2) || keyboard.wasPressed('ALT')) {
                    this._mouseDown_r = false;
                }
                if (keyboard.isPressed('ALT') && mouse.isPressed(0)) {
                    if (!this._mouseDown_l) {
                        this._mouseDown_l = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                        var screenPosition = new egret3d.Vector2(egret3d.stage.screenViewport.w / 2, egret3d.stage.screenViewport.h / 2);
                        var camera = this.gameObject.getComponent(egret3d.Camera);
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        this._lookAtPiont = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        //let euler = this.gameObject.transform.getLocalEulerAngles();
                        var theta_x = moveY * this.rotateSpeed, theta_y = moveX * this.rotateSpeed;
                        var sinX = Math.sin(theta_x / 180 * Math.PI / 2), cosX = Math.cos(theta_x / 180 * Math.PI / 2);
                        var sinY = Math.sin(theta_y / 180 * Math.PI / 2), cosY = Math.cos(theta_y / 180 * Math.PI / 2);
                        //this.gameObject.transform.setLocalEulerAngles(Math.max(Math.min((euler.x + theta_x), 89.9), -89.9), euler.y + theta_y, euler.z);
                        var rot = this.gameObject.transform.getRotation();
                        var pos = this.gameObject.transform.getPosition();
                        egret3d.Vector3.subtract(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.getRight(this._helpVec3);
                        egret3d.Vector3.normalize(this._helpVec3);
                        this._helpQuat.set(sinX * this._helpVec3.x, sinX * this._helpVec3.y, sinX * this._helpVec3.z, cosX);
                        pos.applyQuaternion(this._helpQuat, pos);
                        rot.multiply(this._helpQuat, rot);
                        rot.normalize();
                        egret3d.Vector3.set(0, 1, 0, this._helpVec3);
                        this._helpQuat.set(sinY * this._helpVec3.x, sinY * this._helpVec3.y, sinY * this._helpVec3.z, cosY);
                        pos.applyQuaternion(this._helpQuat);
                        rot.multiply(this._helpQuat, rot);
                        rot.normalize();
                        egret3d.Vector3.add(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.setRotation(rot);
                        this.gameObject.transform.setPosition(pos);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_l = false;
                }
                // 复制粘贴
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('C')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     clipboard.writeText("zhrit", "paper");
                // }
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('V')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     let msg = clipboard.readText("paper");
                //     console.log(msg);
                // }
                //(keyboard.isPressed('ALT') && mouse.isPressed(0)) || 
            };
            ;
            EditorCameraScript.prototype.onDestroy = function () {
                var inputManager = egret3d.InputManager;
                if (inputManager.mouse.wasPressed(0)) {
                    // do something
                }
                if (inputManager.keyboard.isPressed("K")) {
                    // do something
                }
                if (inputManager.touch.touchCount > 0) {
                    var touch = inputManager.touch.getTouch(0);
                    // do something
                }
            };
            EditorCameraScript = __decorate([
                paper.executeInEditMode
            ], EditorCameraScript);
            return EditorCameraScript;
        }(paper.Behaviour));
        editor.EditorCameraScript = EditorCameraScript;
        __reflect(EditorCameraScript.prototype, "paper.editor.EditorCameraScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var PickGameObjectScript = (function (_super) {
            __extends(PickGameObjectScript, _super);
            function PickGameObjectScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._tapStart = 0;
                _this.selectedGameObjects = [];
                return _this;
            }
            Object.defineProperty(PickGameObjectScript.prototype, "onGeoControll", {
                get: function () {
                    return this.gameObject.getComponent(editor.Controller).onGeoControll;
                },
                enumerable: true,
                configurable: true
            });
            PickGameObjectScript.prototype.onStart = function () {
                this.bindMouse = egret3d.InputManager.mouse;
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.camera = this.gameObject.getComponent(egret3d.Camera);
                this.cameraScript = this.gameObject.getComponent(editor.EditorCameraScript);
                this.selectedGameObjects = [];
                this.initSelectBox();
            };
            PickGameObjectScript.prototype.clearSelected = function () {
                this.selectedGameObjects = [];
            };
            PickGameObjectScript.prototype.onUpdate = function (delta) {
                try {
                    // 点击 game object 激活
                    if (this.bindMouse.wasReleased(0)) {
                        var lastX = this.lastX;
                        var lastY = this.lastY;
                        var ray = this.camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                        var pickInfo = egret3d.Ray.raycast(ray, true);
                        var tapDelta = Date.now() - this._tapStart;
                        var pickCamera = this.intersectWithCameraAndLight(ray);
                        if (pickCamera) {
                            pickInfo = pickCamera;
                        }
                        if (this.bindKeyboard.isPressed('CONTROL')) {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                if (picked.name !== "GizmoController_YZ" && picked.name !== "GizmoController_XZ" && picked.name !== "GizmoController_XY" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        var index = -1;
                                        var l = this.selectedGameObjects.length;
                                        for (var i = 0; i < l; i++) {
                                            if (this.selectedGameObjects[i] == picked) {
                                                index = i;
                                                break;
                                            }
                                        }
                                        if (index < 0) {
                                            this.selectedGameObjects.push(picked);
                                        }
                                        else if (l > 1) {
                                            this.selectedGameObjects.splice(index, 1);
                                        }
                                    }
                                }
                            }
                            else if (tapDelta >= 200 && !this.onGeoControll) {
                                this.boxSelect();
                            }
                        }
                        else {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                this.setStroke(picked);
                                if (picked.name !== "GizmoController_YZ" && picked.name !== "GizmoController_XZ" && picked.name !== "GizmoController_XY" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        this.selectedGameObjects = [picked];
                                        // this.setStroke(picked)
                                    }
                                }
                            }
                            else if (tapDelta < 200) {
                                this.selectedGameObjects = [];
                            }
                            else if (tapDelta >= 200 && !this.onGeoControll) {
                                this.selectedGameObjects = [];
                                this.boxSelect();
                            }
                        }
                        this.excludingChild();
                        this.selectBox.activeSelf = false;
                        // if (this.selectedGameObjects[0]) {
                        //     Gizmo.setGameObj(this.selectedGameObjects[0])
                        // }
                        this.editorModel.selectGameObject(this.selectedGameObjects);
                    }
                    if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                        if (!this.onGeoControll) {
                            this.selectBox.activeSelf = true;
                        }
                        else {
                            this.selectBox.activeSelf = false;
                        }
                        var tapDelta = Date.now() - this._tapStart;
                        var MaxX = Math.max(this.lastX, this.bindMouse.position.x);
                        var MinX = Math.min(this.lastX, this.bindMouse.position.x);
                        var MaxY = Math.max(this.lastY, this.bindMouse.position.y);
                        var MinY = Math.min(this.lastY, this.bindMouse.position.y);
                        this.drawSelectBox(new egret3d.Vector2(MaxX, MaxY), new egret3d.Vector2(MinX, MinY));
                    }
                    // 点击控制杆，更新控制点
                    if (this.bindMouse.wasPressed(0)) {
                        this.lastX = this.bindMouse.position.x;
                        this.lastY = this.bindMouse.position.y;
                        this._tapStart = Date.now();
                    }
                }
                catch (e) {
                    console.log(e);
                }
            };
            //当父对象被选中时剔除子物体
            PickGameObjectScript.prototype.excludingChild = function () {
                var children = [];
                for (var _i = 0, _a = this.selectedGameObjects; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.transform.childCount > 0) {
                        children = children.concat(item.transform.getAllChildren());
                    }
                }
                for (var _b = 0, children_6 = children; _b < children_6.length; _b++) {
                    var child = children_6[_b];
                    for (var i = 0; i < this.selectedGameObjects.length; i++) {
                        if (this.selectedGameObjects[i].transform == child) {
                            this.selectedGameObjects.splice(i, 1);
                            break;
                        }
                    }
                }
            };
            //框选
            PickGameObjectScript.prototype.boxSelect = function () {
                var MaxX = Math.max(this.lastX, this.bindMouse.position.x);
                var MinX = Math.min(this.lastX, this.bindMouse.position.x);
                var MaxY = Math.max(this.lastY, this.bindMouse.position.y);
                var MinY = Math.min(this.lastY, this.bindMouse.position.y);
                for (var _i = 0, _a = paper.Application.sceneManager.activeScene.gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    var pos = new egret3d.Vector2;
                    this.camera.calcScreenPosFromWorldPos(gameObject.transform.getPosition(), pos);
                    if (pos.x < MaxX && pos.y < MaxY && pos.x > MinX && pos.y > MinY) {
                        var l = this.selectedGameObjects.length;
                        var js = 1;
                        for (var i = 0; i < l; i++) {
                            if (this.selectedGameObjects[i] == gameObject) {
                                js = 0;
                                break;
                            }
                        }
                        if (js) {
                            this.selectedGameObjects.push(gameObject);
                        }
                    }
                }
            };
            //TODO,描边
            PickGameObjectScript.prototype.setStroke = function (picked) {
                // let render = picked.getComponent(egret3d.MeshRenderer);
                // let mat = new egret3d.Material(egret3d.DefaultShaders.DIFFUSE_TINT_COLOR)
                // const strokeObj = new GameObject('stroke', '', Application.sceneManager.editorScene)
                // let mesh = strokeObj.addComponent(egret3d.MeshFilter)
                // let render = strokeObj.addComponent(egret3d.MeshRenderer)
                // let transform = strokeObj.getComponent(egret3d.Transform)
                // let _transform = picked.getComponent(egret3d.Transform)
                // mesh.mesh = picked.getComponent(egret3d.MeshFilter).mesh
                // render.materials = [egret3d.DefaultMaterials.MESH_BASIC.clone()];
                // transform.setPosition(_transform.getPosition())
                // transform.setRotation(_transform.getRotation())
                // transform.setScale(_transform.getScale())
                // transform.setLocalScale(new egret3d.Vector3(1.05, 1.05, 1.05))
                // transform.parent = _transform
                // console.log(render.materials)
            };
            //
            PickGameObjectScript.prototype.initSelectBox = function () {
                this.selectBox = new paper.GameObject('selectBox', '', paper.Application.sceneManager.editorScene);
                var selectBox = this.selectBox;
                var MeshFilter = selectBox.addComponent(egret3d.MeshFilter);
                var render = selectBox.addComponent(egret3d.MeshRenderer);
                var mesh = new egret3d.Mesh(4, 6);
                MeshFilter.mesh = mesh;
                mesh.setAttributes("POSITION" /* POSITION */, [
                    0, 1, 0,
                    1, 1, 0,
                    0, 0, 0,
                    1, 0, 0
                ]);
                mesh.setIndices([0, 1, 2, 2, 1, 3]);
                selectBox.activeSelf = false;
                var mat = new egret3d.Material(egret3d.DefaultShaders.LINEDASHED);
                mat.setVector3v("diffuse", new Float32Array([0.8, 0.8, 0.3]));
                mat.setFloatv("opacity", new Float32Array([0.3]));
                mat.setDepth(true, true);
                mat.renderQueue = 4000;
                mat.setCullFace(false);
                mat.setBlend(1 /* Blend */);
                render.materials = [mat];
            };
            //
            PickGameObjectScript.prototype.drawSelectBox = function (start, end) {
                var selectBox = this.selectBox;
                var MeshFilter = selectBox.getOrAddComponent(egret3d.MeshFilter);
                var mesh;
                mesh = MeshFilter.mesh;
                // mesh = egret3d.DefaultMeshes.QUAD
                var a = new egret3d.Vector3;
                var a1 = new egret3d.Vector3;
                var a2 = new egret3d.Vector3;
                var a3 = new egret3d.Vector3;
                this.camera.calcWorldPosFromScreenPos(new egret3d.Vector3(start.x, start.y, 0), a);
                this.camera.calcWorldPosFromScreenPos(new egret3d.Vector3(start.x, end.y, 0), a1);
                this.camera.calcWorldPosFromScreenPos(new egret3d.Vector3(end.x, start.y, 0), a2);
                this.camera.calcWorldPosFromScreenPos(new egret3d.Vector3(end.x, end.y, 0), a3);
                mesh.setAttributes("POSITION" /* POSITION */, [
                    a.x, a.y, a.z,
                    a1.x, a1.y, a1.z,
                    a2.x, a2.y, a2.z,
                    a3.x, a3.y, a3.z,
                ]);
                mesh.uploadVertexBuffer("POSITION" /* POSITION */);
                mesh.setIndices([0, 1, 2, 2, 1, 3]);
            };
            //点击选择相机和灯光
            PickGameObjectScript.prototype.intersectWithCameraAndLight = function (ray) {
                var camerasAndLights = paper.Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
                for (var _i = 0, _a = camerasAndLights.cameras; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.gameObject.name != "EditorCamera") {
                        var pos = item.transform.getPosition();
                        var rot = item.transform.getRotation();
                        var min = new egret3d.Vector3(pos.x - 0.5, pos.y - 0.5, pos.z - 0.5);
                        var max = new egret3d.Vector3(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5);
                        // min.applyQuaternion(rot)
                        // max.applyQuaternion(rot)
                        if (ray.intersectBoxMinMax(min, max)) {
                            return item.gameObject;
                        }
                    }
                }
                for (var _b = 0, _c = camerasAndLights.lights; _b < _c.length; _b++) {
                    var item = _c[_b];
                    var pos = item.transform.getPosition();
                    var rot = item.transform.getRotation();
                    var min = new egret3d.Vector3(pos.x - 0.5, pos.y - 0.5, pos.z - 0.5);
                    var max = new egret3d.Vector3(pos.x + 0.5, pos.y + 0.5, pos.z + 0.5);
                    // min.applyQuaternion(rot)
                    // max.applyQuaternion(rot)
                    if (ray.intersectBoxMinMax(min, max)) {
                        return item.gameObject;
                    }
                }
            };
            PickGameObjectScript = __decorate([
                paper.executeInEditMode
            ], PickGameObjectScript);
            return PickGameObjectScript;
        }(paper.Behaviour));
        editor.PickGameObjectScript = PickGameObjectScript;
        __reflect(PickGameObjectScript.prototype, "paper.editor.PickGameObjectScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var icons = {
            camera: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIcSURBVFhH7ZbPjtMwEMYj7vAACCFg28Rx4oQmtGnLQo/7Du1pK3Hk2BtSHwYkXoA34C34I7Fozxxoy+6yaocZx9M6u4WkFaA95JN+qu0Z21/riVOnVq1a/0oiaoMXPdlCBxpxG0xaNXlB+vHqIl7Utfo5Jl3LxU2uxpkmmjNp1RTEGfg4kZhOp/eRe8xwOHzqmnjSPXxnpjhBlIEIM5BRb40f96Ch2jCZTO6atGryVQeESjVmqCA/zGNy15/2xuv4xcuBK1N4KBNw445FZugauG/ndKr9GlJRYWBBxcn7LHveHAyOHtC4iJKLbQW0C0IlBRNemH6jTzpSQqouOFQ89iSdibLHcrKKbObYBqhGaC9qc/yaAdnKdMKjoLUe08QpvH7zFsp08fOyMI8N0DHRPqUGRJhXsWr112ME5SwWM73Jp5NTzecvFtg/+XqK0UsQ1vNvG+Ax6nN7bYBN8GPW0HVRZL44h+VqdW2cafcOYYUW9jZAAZb3uHiWxPcfZQae7Wdgmw7wYuEk5r8a8MPNBGa+OIMVGpBRfyu9rI/bL/+OAU/Sy2azOS06m81xgzItoRkmm3l7G2gGr7gwGR8LU+JbLAcvEQ29bIi8L4Li0bEBunR4TK9v2r81QCIDwiQSblwNzifYAMkNW+Dil6A2x/9ogGQvtg8HQn0wS2mxIY5LlV98pRqNRnfG4/HtXcD/CrfM9Fq1at1kOc4vVSG2+aaGzOwAAAAASUVORK5CYII=",
            light: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPcSURBVFhH3ZdLSNRRFMbn4fuZmtmYZpn0gCx6YbQokBZRq6hVL6xWUdCmICIoIYjaWBDRu3WShhUJLSKIIKISgqBWao9NlIsUwlKn33fnzDij/1HHsU0fHM693z333HPOffxnfNNBMBjcgRpCVjjiX6GwsHAJKhDpjYIAdqLCyEpHxKG8vLwgJyen2rrTR25uboPf7/+Ns31GxTBRAJmZmc2BQKC/rKys0qhpAz+Bt8inUCiUZ5xDsgAIeh5BDzCnzaj0kJ2d3YjDcFZW1imjHJIFkJGRcQf7waKiojqj0gdOH5DRz7y8vLlGeQZA6Vex+DBjLUalhtLS0iJrJoDsl+os4PiGUVqsHu48zVCEcYE+JdAfZF9qVAKS+XfgoM1nch+LnK2oqMg3OgYWvIhcsu44VFVV5RLAXYI9alQMBQUFsxm7prPk5dtBhwejdu03hr04Uonj4TftKy4ursVmP/bH0LvZmlgVQMwOBDlDh/D53bbmWklJSbGNeYMJW3D6kWaYBZ4Q/bLIiM+nM8BYG85G6Gr/ndD/owy5doWyE6joBmzf0Ayz8EsSXBsZmRqycHgCx/1MPieCyKtpdyNhgnTCluh2hHGuIFS519EgsGul/w27g3THPWRTAoemyg6OH2fPtLgWoz9OqI4CUNVu0Ve1QmxVidppgywaUUkXjwplVyWGsF9If+ZA5i3Knuw8F46KApCmEkfQKaEH+ewhWxG9xw+13zQnFJ0DBYl2DxHzDqO8/D5HRsGEVuTeWGFovcZx1D6VAKJVQl+gr8pt9/KLXNb4lIGjMzpgkwWhmyGN3V70zMHeguGJDqECtEP4k9M/Cy59cMe3ktUCtcnqKs7D+fn5bq+hEhYXrzZzjqN1DdcQcIPaKcOe2g6aKqfbr5qamhy4TnHKVA+QSh4V8ez/dbR7iml3Eugw+ibBzRE3KfRBYb+bmfhLwuLNY36IBFn4KGO6NfEVeI/tLhlEoS8ivq5gO8R4H4HoagYjox7AwXIMu5mgTDrIqtaGHOwTG31S/aoSduv0RBvnqhT/PRDYitX4fUFTt6NL35PIyBhoIkE8J8NtRiWAxR4x/tS642DV+4BcNCoefhJqYv5j2ql/F5i8GaV9PxlhXECbUM+QRY4AcLep4CC/pBcbNSMIUsIupFdZGuf5k4xTX0kAAwRy36j0QdkO6Fyg9xjl4BWAwOKnUSPcFFUoPegPBpl/RV7RTdi7ZAHoJxf2Xxh/TXd6vwOiIOt6HPWQzUajYkgWgMC8JsbfJT3xqaCuri7bmgmYKACgzDMizX+EuFswc39A/kfE/0RPAp/vL7M1A0/aWSCCAAAAAElFTkSuQmCC"
        };
        //只有编辑模式可以执行，编辑相机
        var Gizmo = (function (_super) {
            __extends(Gizmo, _super);
            function Gizmo() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Gizmo_1 = Gizmo;
            Gizmo.prototype.onStart = function () {
                this.nrLine = 100;
                this._oldTransform = egret3d.Vector3.getLength(this.gameObject.transform.getLocalPosition());
            };
            Gizmo.Enabled = function () {
                this.webgl = egret3d.WebGLCapabilities.webgl;
                this.camera = paper.Application.sceneManager.editorScene.find("EditorCamera").getComponent(egret3d.Camera);
                this.initPrg();
                this.lineVertexBuffer = this.webgl.createBuffer();
                this.setVertices();
                this.initIconTexture();
                this.camera.gameObject.addComponent(Gizmo_1);
            };
            Gizmo.setGameObj = function (obj) {
                this.gameObj = obj;
            };
            Gizmo.DrawStroke = function () {
                if (!this.enabled)
                    return;
                if (!this.gameObj)
                    return;
                var obj = this.gameObj;
                var gl = this.webgl;
                var prg = this.glProgram_stroke;
                var mesh = obj.getComponent(egret3d.MeshFilter).mesh;
                var position = mesh.getAttributes('POSITION');
                var normal = mesh.getAttributes('NORMAL');
                var indices = mesh.getIndices();
                var vertexCount = position.length / 3;
                var vertexBuffer = gl.createBuffer();
                var normalBuffer = gl.createBuffer();
                var indiceBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, position, gl.STATIC_DRAW);
                gl.vertexAttribPointer(gl.getAttribLocation(prg.prg, 'aPosition'), 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(gl.getAttribLocation(prg.prg, 'aPosition'));
                gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, normal, gl.STATIC_DRAW);
                gl.vertexAttribPointer(gl.getAttribLocation(prg.prg, 'aNormal'), 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(gl.getAttribLocation(prg.prg, 'aNormal'));
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [1, 1, 1, 1]);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indiceBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
                console.log(position, normal);
            };
            Gizmo.DrawIcon = function (path, pos, size, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_icon;
                this.verticesLine = [pos.x, pos.y, pos.z];
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesLine), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[path]);
                if (color) {
                    prg.setBool("hasColor", true);
                    prg.setColor("iconColor", [color.r, color.g, color.b, color.a]);
                }
                else {
                    prg.setBool("hasColor", false);
                    prg.setColor("iconColor", [1, 0, 0, 1]);
                }
                prg.setTexture("PointTexture", 0);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setFloat("pointSize", size);
                gl.drawArrays(gl.POINTS, 0, 1);
            };
            Gizmo.DrawCoord = function () {
                var gl = Gizmo_1.webgl;
                var prg = Gizmo_1.glProgram_line;
                var nrLine = this.nrLine;
                if (!this.enabled)
                    return;
                gl.enable(gl.DEPTH_TEST);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, Gizmo_1.coordVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                Gizmo_1.setMVPMatrix();
                prg.setMatrix("mvpMat", Gizmo_1.mvpMatrix);
                prg.setColor("lineColor", [0.7, 0.7, 0.7, 1]);
                gl.drawArrays(gl.LINES, 0, (2 * nrLine + 1) * 4 + 2);
            };
            Gizmo.setVertices = function () {
                var gl = this.webgl;
                var nrLine = this.nrLine = 100;
                this.verticesCoord = [];
                this.cameraVertexBuffer = gl.createBuffer();
                this.cameraIndexBuffer = gl.createBuffer();
                this.coordVertexBuffer = gl.createBuffer();
                this.cylinderVertexBuffer = gl.createBuffer();
                this.arrowVertexBuffer = gl.createBuffer();
                var bia = -0.05;
                for (var i = 0, len = 2 * nrLine + 1; i < len; i++) {
                    this.verticesCoord[6 * i] = -nrLine + i;
                    this.verticesCoord[6 * i + 1] = bia;
                    this.verticesCoord[6 * i + 2] = -nrLine;
                    this.verticesCoord[6 * i + 3] = -nrLine + i;
                    this.verticesCoord[6 * i + 4] = bia;
                    this.verticesCoord[6 * i + 5] = nrLine;
                    this.verticesCoord[6 * len + 6 * i] = -nrLine;
                    this.verticesCoord[6 * len + 6 * i + 1] = bia;
                    this.verticesCoord[6 * len + 6 * i + 2] = -nrLine + i;
                    this.verticesCoord[6 * len + 6 * i + 3] = nrLine;
                    this.verticesCoord[6 * len + 6 * i + 4] = bia;
                    this.verticesCoord[6 * len + 6 * i + 5] = -nrLine + i;
                }
                this.verticesCylinder = [
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, 0.25, 0, 0.433, 0.25, 2,
                    0.25, 0.433, 0, 0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, 0.25, 0, -0.433, 0.25, 2,
                    -0.25, 0.433, 0, -0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, -0.25, 0, -0.433, -0.25, 2,
                    -0.25, -0.433, 0, -0.25, -0.433, 2,
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, -0.25, 0, 0.433, -0.25, 2,
                    0.25, -0.433, 0, 0.25, -0.433, 2,
                ];
                for (var i = 0; i < this.verticesCylinder.length; i++) {
                    this.verticesCylinder[i] *= 0.5;
                }
                this.verticesArrow = [
                    0.7, 0.0, 0.0, 0.0, 0.0, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    0.7, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1
                ];
                this.verticesCoord = this.verticesCoord.concat([0, -this.nrLine, 0, 0, this.nrLine, 0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCoord), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCylinder), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesArrow), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            };
            Gizmo.setMVPMatrix = function (m) {
                var asp = this.camera.context.viewPortPixel.w / this.camera.context.viewPortPixel.h;
                this.vMatrix.inverse(this.camera.gameObject.transform.getWorldMatrix());
                this.camera.calcProjectMatrix(asp, this.pMatrix);
                this.mvpMatrix.multiply(this.pMatrix, this.vMatrix);
                m = m || new egret3d.Matrix4();
                this.mMatrix.copy(m);
                this.mvpMatrix.multiply(this.mMatrix);
            };
            Gizmo.initPrg = function () {
                this.glProgram_line = new editor.GizmoShader(this.webgl, editor.line_vert, editor.line_frag);
                this.glProgram_icon = new editor.GizmoShader(this.webgl, editor.icon_vert, editor.icon_frag);
                this.glProgram_stroke = new editor.GizmoShader(this.webgl, editor.stroke_vert, editor.line_frag);
            };
            // const cameras = Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            Gizmo.DrawLights = function () {
                if (!this.enabled)
                    return;
                var camerasAndLights = paper.Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
                for (var _i = 0, _a = camerasAndLights.lights; _i < _a.length; _i++) {
                    var light = _a[_i];
                    Gizmo_1.DrawIcon("light", light.gameObject.transform.getPosition(), 30, light.color);
                    Gizmo_1.DrawCylinder(light.gameObject.transform, light.color);
                }
            };
            Gizmo.DrawCylinder = function (transform, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                var m = this.helpMat;
                this.getWorldMatrixWithoutScale(transform, 15, m);
                this.setMVPMatrix(m);
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [color.r, color.g, color.b, color.a]);
                gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.DrawCameras = function () {
                if (!this.enabled)
                    return;
                var camerasAndLights = paper.Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
                for (var _i = 0, _a = camerasAndLights.cameras; _i < _a.length; _i++) {
                    var camera = _a[_i];
                    // if (!camera.gameObject.getComponent(egret3d.MeshFilter) && camera.gameObject.name != "EditorCamera") {
                    //     let obj = camera.gameObject
                    //     let mesh = obj.addComponent(egret3d.MeshFilter)
                    //     mesh.mesh = egret3d.DefaultMeshes.CUBE
                    //     // let renderer = obj.addComponent(egret3d.MeshRenderer);
                    //     // let mat = new egret3d.Material(egret3d.DefaultShaders.GIZMOS_COLOR);
                    //     // mat.setVector4v("_Color", [1, 0, 0, 1]);
                    //     // renderer.materials = [mat];
                    //     // obj.transform.setScale(0.6, 0.4, 0.4)
                    // }
                    Gizmo_1.DrawIcon("camera", camera.gameObject.transform.getPosition(), 30);
                    Gizmo_1.DrawCameraSquare(camera.gameObject, [1, 0, 0, 1]);
                    //Gizmo.DrawCameraSquare(this.cameraPool[i], [1.0, 0.0, 1.0, 1.0]);
                }
            };
            Gizmo.DrawCameraSquare = function (obj, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                this.getCameraSquare(obj);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cameraVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCameraSquare), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                var indices = [1, 0, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7];
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cameraIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT, 0);
                //sconsole.log(this.verticesCameraSquare);
                //gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.getCameraSquare = function (obj) {
                this.verticesCameraSquare = [];
                var t = obj.transform;
                var camera = obj.getComponent(egret3d.Camera);
                var forward = this.helpVec31;
                var up = this.helpVec32;
                var right = this.helpVec33;
                var nearCenter = this.helpVec34;
                var farCenter = this.helpVec35;
                t.getForward(forward);
                t.getUp(up);
                t.getRight(right);
                var cameraPos = t.getPosition();
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.near), cameraPos, nearCenter);
                t.getForward(forward);
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.far), cameraPos, farCenter);
                var asp = this.camera.context.viewPortPixel.w / this.camera.context.viewPortPixel.h;
                var nearH = camera.opvalue > 0 ? camera.near * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var nearW = nearH * asp;
                var farH = camera.opvalue > 0 ? camera.far * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var farW = farH * asp;
                var point = this.helpVec36;
                //0
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //1
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //2
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //3
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //4
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //5
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //6
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //7
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
            };
            // public static DrawArrowXYZ(transform: egret3d.Transform) {
            //     console.log("now drawXYZ", transform)
            //     let worldMat = Gizmo.helpMat;
            //     Gizmo.getWorldMatrixWithoutScale(transform, 10, worldMat);
            //     worldMat.multiply(this.xArrowMMatrix);
            //     Gizmo.DrawArrow(worldMat, [1.0, 0.0, 0.0, 1.0], true);
            //     worldMat.multiply(this.yArrowMMatrix);
            //     Gizmo.DrawArrow(worldMat, [0.0, 1.0, 0.0, 1.0], true);
            //     worldMat.multiply(this.zArrowMMatrix);
            //     Gizmo.DrawArrow(worldMat, [0.0, 0.0, 1.0, 1.0], true);
            // }
            Gizmo.getWorldMatrixWithoutScale = function (transform, fixScale, out) {
                out.identity();
                var p = transform.getPosition();
                var r = transform.getRotation();
                var p_c = this.camera.gameObject.transform.getPosition();
                egret3d.Vector3.subtract(p, p_c, p_c);
                var sca = egret3d.Vector3.getLength(p_c) / fixScale;
                var matS = this.helpMat1;
                // egret3d.Quaternion.toMatrix(r, out);
                out.fromRotation(r);
                matS.fromScale(sca, sca, sca);
                out.multiply(matS);
                out.rawData[12] = p.x;
                out.rawData[13] = p.y;
                out.rawData[14] = p.z;
            };
            Gizmo.initIconTexture = function () {
                for (var key in icons) {
                    var image = new Image();
                    this._imageLoadCount++;
                    image.setAttribute('src', icons[key]);
                    image.onload = this.loadIconTexture.bind(this, image, key);
                }
            };
            Gizmo.loadIconTexture = function (image, key) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var texture = webgl.createTexture();
                webgl.bindTexture(webgl.TEXTURE_2D, texture);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, webgl.RGBA, webgl.UNSIGNED_BYTE, image);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                this._imageLoadCount--;
                this.textures[key] = texture;
                if (this._imageLoadCount === 0) {
                    this.enabled = true;
                }
            };
            Gizmo.enabled = false;
            Gizmo.mvpMatrix = new egret3d.Matrix4();
            Gizmo.mMatrix = new egret3d.Matrix4();
            Gizmo.vMatrix = new egret3d.Matrix4();
            Gizmo.pMatrix = new egret3d.Matrix4();
            Gizmo.helpVec31 = new egret3d.Vector3();
            Gizmo.helpVec32 = new egret3d.Vector3();
            Gizmo.helpVec33 = new egret3d.Vector3();
            Gizmo.helpVec34 = new egret3d.Vector3();
            Gizmo.helpVec35 = new egret3d.Vector3();
            Gizmo.helpVec36 = new egret3d.Vector3();
            // public static DrawArrow(m: egret3d.Matrix4, color: number[], fixSize?: boolean) {
            //     if (!this.enabled) return;
            //     let gl = this.webgl;
            //     let prg = this.glProgram_line;
            //     gl.disable(gl.DEPTH_TEST);
            //     prg.use();
            //     let prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
            //     gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
            //     gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
            //     gl.enableVertexAttribArray(prgVertexPosition);
            //     this.setMVPMatrix(m);
            //     prg.setMatrix("mvpMat", this.mvpMatrix);
            //     prg.setColor("lineColor", color);
            //     gl.drawArrays(gl.LINES, 0, 2);
            //     gl.drawArrays(gl.TRIANGLES, 2, 24);
            // }
            // private static xArrowMMatrix = new egret3d.Matrix4();
            // private static yArrowMMatrix = egret3d.Matrix4.create([
            //     0, 1, 0, 0,
            //     -1, 0, 0, 0,
            //     0, 0, 1, 0,
            //     0, 0, 0, 1
            // ]);
            // private static zArrowMMatrix = egret3d.Matrix4.create([
            //     0, 0, 1, 0,
            //     0, 1, 0, 0,
            //     -1, 0, 0, 0,
            //     0, 0, 0, 1
            // ]);
            Gizmo.helpMat = new egret3d.Matrix4();
            Gizmo.helpMat1 = new egret3d.Matrix4();
            Gizmo._imageLoadCount = 0;
            Gizmo.textures = {};
            Gizmo = Gizmo_1 = __decorate([
                paper.executeInEditMode
            ], Gizmo);
            return Gizmo;
            var Gizmo_1;
        }(paper.Behaviour));
        editor.Gizmo = Gizmo;
        __reflect(Gizmo.prototype, "paper.editor.Gizmo");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var GizmoShader = (function () {
            function GizmoShader(gl, vshader, fshader) {
                this.gl = gl;
                this.prg = this.createProgram(vshader, fshader);
            }
            GizmoShader.prototype.createProgram = function (vshader, fshader) {
                var gl = this.gl;
                var prg = gl.createProgram();
                var vertexShader = this.createShader(gl.VERTEX_SHADER, vshader);
                var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fshader);
                gl.attachShader(prg, vertexShader);
                gl.attachShader(prg, fragmentShader);
                gl.linkProgram(prg);
                if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }
                return prg;
            };
            GizmoShader.prototype.createShader = function (type, str) {
                var gl = this.gl;
                var shader = gl.createShader(type);
                gl.shaderSource(shader, str);
                gl.compileShader(shader);
                var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!parameter) {
                    if (confirm("shader compile:" + gl.getShaderInfoLog(shader) + "\n")) {
                        gl.deleteShader(shader);
                    }
                    return null;
                }
                return shader;
            };
            GizmoShader.prototype.use = function () {
                this.gl.useProgram(this.prg);
            };
            GizmoShader.prototype.setFloat = function (name, value) {
                var gl = this.gl;
                gl.uniform1f(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setInt = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setBool = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value ? 1 : 0);
            };
            GizmoShader.prototype.setVec3 = function (name, value) {
                var gl = this.gl;
                gl.uniform3f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z);
            };
            GizmoShader.prototype.setVec4 = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z, value.w);
            };
            GizmoShader.prototype.setColor = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value[0], value[1], value[2], value[3]);
            };
            // public setColor(name: string, value: egret3d.Color) {
            //     let gl = this.gl;
            //     gl.uniform4f(gl.getUniformLocation(this.prg, name), value.r, value.g, value.b, value.a);
            // }
            GizmoShader.prototype.setMatrix = function (name, value) {
                var gl = this.gl;
                gl.uniformMatrix4fv(gl.getUniformLocation(this.prg, name), false, value.rawData);
            };
            GizmoShader.prototype.setTexture = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            return GizmoShader;
        }());
        editor.GizmoShader = GizmoShader;
        __reflect(GizmoShader.prototype, "paper.editor.GizmoShader");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.icon_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform sampler2D PointTexture;\n        uniform bool hasColor;\n        uniform vec4 iconColor;\n        void main(void) {\n            vec4 tex = texture2D(PointTexture, gl_PointCoord);\n            gl_FragColor = tex;\n            if (hasColor) {\n                if (gl_FragColor.a >= 0.1) {\n                    gl_FragColor = iconColor;\n                } else {\n                    gl_FragColor.a = 0.0;\n                }\n            }\n        }";
        editor.icon_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        uniform float pointSize;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n            gl_PointSize = pointSize; \n        }";
        editor.line_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform vec4 lineColor;\n        void main(void) {\n            gl_FragColor = lineColor;\n        }";
        editor.line_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n        }";
        editor.stroke_vert = "\n        uniform mat4 uMVPMatrix;                            //\u603B\u53D8\u6362\u77E9\u9635\n        attribute  vec3 aPosition;                                   //\u9876\u70B9\u4F4D\u7F6E\n        attribute vec3 aNormal;                                   //\u9876\u70B9\u6CD5\u5411\u91CF\n        void main(){\n            vec3 position=aPosition;                     //\u83B7\u53D6\u6B64\u9876\u70B9\u4F4D\u7F6E\n            position.xyz+=aNormal*0.4;                //\u5C06\u9876\u70B9\u4F4D\u7F6E\u6CBF\u6CD5\u7EBF\u65B9\u5411\u6324\u51FA\n            gl_Position = uMVPMatrix * vec4(position.xyz,1);//\u6839\u636E\u603B\u53D8\u6362\u77E9\u9635\u8BA1\u7B97\u6B64\u6B21\u7ED8\u5236\u6B64\u9876\u70B9\u4F4D\u7F6E\n        }";
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var GizmoRenderSystem = (function (_super) {
        __extends(GizmoRenderSystem, _super);
        function GizmoRenderSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._renderState = egret3d.WebGLRenderState.getInstance(egret3d.WebGLRenderState);
            return _this;
        }
        GizmoRenderSystem.prototype.onUpdate = function () {
            this._renderState.clearState(); //编辑器走自己的渲染流程，状态需要清除一下
            // paper.editor.Gizmo.DrawCoord();
            paper.editor.Gizmo.DrawLights();
            paper.editor.Gizmo.DrawCameras();
            // paper.editor.Gizmo.DrawStroke()
        };
        return GizmoRenderSystem;
    }(paper.BaseSystem));
    egret3d.GizmoRenderSystem = GizmoRenderSystem;
    __reflect(GizmoRenderSystem.prototype, "egret3d.GizmoRenderSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.Matrix = egret3d.Matrix4;
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = egret3d.Color.create();
        var startRotationHelper = new egret3d.Vector3();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        totalEmitCount += egret3d.numberLerp(burst.minCount, burst.maxCount, Math.random());
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule._mode === 3 /* TwoConstants */ || velocityModule._mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule._color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule._size.mode === 3 /* TwoConstants */ || sizeModule._size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule._x.mode === 3 /* TwoConstants */ || rotationModule._x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule._startFrame.mode === 3 /* TwoConstants */ || textureSheetModule._startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main._simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var age = Math.min(this._emittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    //发射粒子要根据粒子发射器的形状发射
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    startSizeHelper.x = main.startSizeX.evaluate(age);
                    startSizeHelper.y = main.startSizeY.evaluate(age);
                    startSizeHelper.z = main.startSizeZ.evaluate(age);
                    startRotationHelper.x = main.startRotationX.evaluate(age);
                    startRotationHelper.y = main.startRotationY.evaluate(age);
                    startRotationHelper.z = main.startRotationZ.evaluate(age);
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    ;
                    startCursor++;
                    if (startCursor >= main._maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function (time) {
                var maxParticles = this._comp.main._maxParticles;
                var nextCursor = this._firstAliveCursor + 1 > maxParticles ? 0 : this._firstAliveCursor + 1;
                if (nextCursor >= maxParticles) {
                    nextCursor = 0;
                }
                if (!this._isParticleExpired(nextCursor)) {
                    return false;
                }
                //
                this._firstAliveCursor = nextCursor;
                this._dirty = true;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main._maxParticles);
                this._vertexStride = renderer._renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("_START_POSITION" /* _START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("_START_VELOCITY" /* _START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("_START_COLOR" /* _START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("_START_SIZE" /* _START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("_START_ROTATION" /* _START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("_TIME" /* _TIME */);
                this._random0Buffer = mesh.getAttributes("_RANDOM0" /* _RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("_RANDOM1" /* _RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("_WORLD_POSITION" /* _WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("_WORLD_ROTATION" /* _WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                //粒子系统不能用共享材质
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor != this._firstAliveCursor) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule._maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.getPosition();
                this._worldRotationCache = transform.getRotation();
                //检测是否已经过了Delay时间，否则不能发射
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                //根据时间判断
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                if (!isOver) {
                    //由爆发触发的粒子发射
                    var totalEmitCount = 0;
                    if (comp.emission.bursts.length > 0) {
                        var readyEmitCount = 0;
                        readyEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        readyEmitCount = Math.min(mainModule._maxParticles - this.aliveParticleCount, readyEmitCount);
                        //
                        for (var i = 0; i < readyEmitCount; i++) {
                            if (this._tryEmit(this._time)) {
                                totalEmitCount++;
                            }
                        }
                    }
                    //由时间触发的粒子发射,不支持曲线
                    var rateOverTime = comp.emission.rateOverTime.constant;
                    if (rateOverTime > 0) {
                        var minEmissionTime = 1 / rateOverTime;
                        this._frameRateTime += elapsedTime;
                        while (this._frameRateTime > minEmissionTime) {
                            if (!this._tryEmit(this._time)) {
                                break;
                            }
                            totalEmitCount++;
                            this._frameRateTime -= minEmissionTime;
                        }
                    }
                    if (totalEmitCount > 0) {
                        this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount);
                    }
                }
                else {
                    //一个生命周期结束
                    if (mainModule.loop) {
                        //直接置零，对时间敏感的可能有问题
                        this._emittsionTime = 0;
                        this._burstIndex = 0;
                    }
                    else {
                        //自己停止，不要影响子粒子播放状态
                        comp.stop(false);
                    }
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    //为了性能，不能提交整个buffer，只提交改变的buffer
                    var bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, bufferCount);
                        // uploadVertexSubData(this._vertexAttributes, bufferOffset, bufferCount);
                    }
                    else {
                        var addCount = mainModule._maxParticles - this._lastFrameFirstCursor;
                        //先更新尾部的，再更新头部的
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        renderer.batchMesh.uploadVertexBuffer(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                        // renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        // renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                var material = renderer.batchMaterial;
                if (mainModule._simulationSpace === 0 /* Local */) {
                    material.setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    material.setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule._scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.getLocalScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.getScale();
                            material.setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            material.setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                material.setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                material.setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main._maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
