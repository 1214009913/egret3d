"use strict";
var __reflect = (this && this.__reflect) || function (p, c, t) {
    p.__class__ = c, t ? t.push(c) : t = [c], p.__types__ = p.__types__ ? t.concat(p.__types__) : t;
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __extends = this && this.__extends || function __extends(t, e) { 
 function r() { 
 this.constructor = t;
}
for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i]);
r.prototype = e.prototype, t.prototype = new r();
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var paper;
(function (paper) {
    /**
     * 标记序列化属性
     * 通过装饰器标记需要序列化的属性
     */
    function serializedField(classPrototype, type) {
        var types = (classPrototype["__serialized" /* Serialized */] = classPrototype["__serialized" /* Serialized */] || [type]);
        if (types.indexOf(type) < 0) {
            types.push(type);
        }
    }
    paper.serializedField = serializedField;
    /**
     * 标记反序列化时需要忽略的属性
     * 通过装饰器标记反序列化时需要被忽略的属性（但属性中引用的对象依然会被实例化）
     */
    function deserializedIgnore(classPrototype, type) {
        var types = (classPrototype["__deserializedIgnore" /* DeserializedIgnore */] = classPrototype["__deserializedIgnore" /* DeserializedIgnore */] || [type]);
        if (types.indexOf(type) < 0) {
            types.push(type);
        }
    }
    paper.deserializedIgnore = deserializedIgnore;
    /**
     * 标记组件是否在编辑模式拥有生命周期。
     */
    function executeInEditMode(target) {
        paper.BaseComponent.register(target);
        target.executeInEditMode = true;
    }
    paper.executeInEditMode = executeInEditMode;
    /**
     * 标记组件是否禁止在同一实体上添加多个实例。
     */
    function disallowMultiple(target) {
        paper.BaseComponent.register(target);
        target.disallowMultiple = true;
    }
    paper.disallowMultiple = disallowMultiple;
    /**
     * 标记组件依赖的其他组件。
     */
    function requireComponent(requireTarget) {
        return function (target) {
            var parentRequireComponents = target.prototype.__proto__.constructor.requireComponents;
            if (!target.requireComponents ||
                target.requireComponents === parentRequireComponents) {
                target.requireComponents = !parentRequireComponents ? [] : parentRequireComponents.concat();
            }
            if (target.requireComponents.indexOf(requireTarget) < 0) {
                target.requireComponents.push(requireTarget);
            }
        };
    }
    paper.requireComponent = requireComponent;
})(paper || (paper = {}));
var paper;
(function (paper) {
    var _hashCount = 1;
    /**
     * 生成 uuid 的方式。
     */
    paper.createUUID = function () {
        return (_hashCount++).toString();
    };
    paper.createAssetID = function () {
        return undefined;
    };
    /**
     * 可序列化对象。
     */
    var SerializableObject = (function () {
        function SerializableObject() {
            /**
             *
             */
            this.uuid = paper.createUUID();
        }
        SerializableObject.prototype.serialize = function () {
            console.warn("Unimplemented serialize method.");
        };
        /**
         *
         */
        SerializableObject.prototype.deserialize = function (element) {
            console.warn("Unimplemented deserialize method.");
        };
        __decorate([
            paper.serializedField
        ], SerializableObject.prototype, "uuid", void 0);
        return SerializableObject;
    }());
    paper.SerializableObject = SerializableObject;
    __reflect(SerializableObject.prototype, "paper.SerializableObject", ["paper.IUUID", "paper.ISerializable"]);
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * Base Class for Asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 资源基类，扩展资源类型需要继承此抽象类
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Asset = (function (_super) {
        __extends(Asset, _super);
        /**
         *
         */
        function Asset(name) {
            if (name === void 0) { name = ""; }
            var _this = _super.call(this) || this;
            /**
             *
             */
            _this.name = "";
            /**
             * @internal
             */
            _this._isBuiltin = false;
            _this.name = name;
            return _this;
        }
        /**
         * @deprecated
         */
        Asset.register = function (asset) {
            this._assets[asset.name] = asset;
        };
        /**
         * @deprecated
         */
        Asset.find = function (name) {
            var result = this._assets[name];
            if (!result) {
                return RES.getRes(name);
            }
            return result;
        };
        /**
         * @deprecated
         */
        Asset._assets = {};
        return Asset;
    }(paper.SerializableObject));
    paper.Asset = Asset;
    __reflect(Asset.prototype, "paper.Asset");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var Vector3 = (function () {
        function Vector3(x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
        }
        Vector3.create = function (x, y, z) {
            if (this._instances.length > 0) {
                return this._instances.pop().set(x, y, z);
            }
            return new Vector3(x, y, z);
        };
        Vector3.release = function (value) {
            if (this._instances.indexOf(value) >= 0) {
                return;
            }
            this._instances.push(value);
        };
        Vector3.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            out.z = v1.z - v2.z;
            return out;
        };
        Vector3.getSqrLength = function (v) {
            return v.x * v.x + v.y * v.y + v.z * v.z;
        };
        Vector3.getLength = function (v) {
            return Math.sqrt(this.getSqrLength(v));
        };
        Vector3.getDistance = function (a, b) {
            return this.getLength(this.subtract(a, b, helpVector));
        };
        Vector3.prototype.serialize = function () {
            return [this.x, this.y, this.z];
        };
        Vector3.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
        };
        Vector3.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            return this;
        };
        Vector3.prototype.clone = function () {
            var value = new Vector3();
            value.copy(this);
            return value;
        };
        Vector3.prototype.set = function (x, y, z) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            return this;
        };
        Vector3.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
                this.z = 0.0;
            }
            return this;
        };
        Vector3.prototype.scale = function (scale) {
            this.x *= scale;
            this.y *= scale;
            this.z *= scale;
            return this;
        };
        Vector3.prototype.add = function (value) {
            this.x += value.x;
            this.y += value.y;
            this.z += value.z;
            return this;
        };
        Vector3.prototype.subtract = function (value) {
            this.x -= value.x;
            this.y -= value.y;
            this.z -= value.z;
            return this;
        };
        Vector3.prototype.multiply = function (value) {
            this.x *= value.x;
            this.y *= value.y;
            this.z *= value.z;
            return this;
        };
        Vector3.prototype.cross = function (rhs) {
            var x = this.x;
            var y = this.y;
            var z = this.z;
            this.x = y * rhs.z - z * rhs.y;
            this.y = z * rhs.x - x * rhs.z;
            this.z = x * rhs.y - y * rhs.x;
            return this;
        };
        Vector3.prototype.dot = function (value) {
            return this.x * value.x + this.y * value.y + this.z * value.z;
        };
        Vector3.prototype.min = function (v1, v2) {
            this.x = Math.min(v1.x, v2.x);
            this.y = Math.min(v1.y, v2.y);
            this.z = Math.min(v1.z, v2.z);
            return this;
        };
        Vector3.prototype.max = function (v1, v2) {
            this.x = Math.max(v1.x, v2.x);
            this.y = Math.max(v1.y, v2.y);
            this.z = Math.max(v1.z, v2.z);
            return this;
        };
        Vector3.prototype.lerp = function (v1, v2, v) {
            this.x = v1.x * (1 - v) + v2.x * v;
            this.y = v1.y * (1 - v) + v2.y * v;
            this.z = v1.z * (1 - v) + v2.z * v;
            return this;
        };
        Vector3.prototype.equal = function (value, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(this.x - value.x) > threshold) {
                return false;
            }
            if (Math.abs(this.y - value.y) > threshold) {
                return false;
            }
            if (Math.abs(this.z - value.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.prototype.getDistance = function (value) {
            return helpVector.copy(this).subtract(value).length;
        };
        Object.defineProperty(Vector3.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector3.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y + this.z * this.z;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Vector3.set = function (x, y, z, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.normalize = function (v) {
            var num = Vector3.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
                v.z = v.z / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
                v.z = 0.0;
            }
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            out.z = v.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            out.z = v1.z + v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            out.z = v1.z * v2.z;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.scale = function (v, scale) {
            v.x = v.x * scale;
            v.y = v.y * scale;
            v.z = v.z * scale;
            return v;
        };
        /**
         * @deprecated
         */
        Vector3.cross = function (lhs, rhs, out) {
            out.x = lhs.y * rhs.z - lhs.z * rhs.y;
            out.y = lhs.z * rhs.x - lhs.x * rhs.z;
            out.z = lhs.x * rhs.y - lhs.y * rhs.x;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
        };
        /**
         * @deprecated
         */
        Vector3.min = function (v1, v2, out) {
            out.x = Math.min(v1.x, v2.x);
            out.y = Math.min(v1.y, v2.y);
            out.z = Math.min(v1.z, v2.z);
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.max = function (v1, v2, out) {
            out.x = Math.max(v1.x, v2.x);
            out.y = Math.max(v1.y, v2.y);
            out.z = Math.max(v1.z, v2.z);
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.lerp = function (v1, v2, v, out) {
            out.x = v1.x * (1 - v) + v2.x * v;
            out.y = v1.y * (1 - v) + v2.y * v;
            out.z = v1.z * (1 - v) + v2.z * v;
            return out;
        };
        /**
         * @deprecated
         */
        Vector3.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            if (Math.abs(v1.z - v2.z) > threshold) {
                return false;
            }
            return true;
        };
        Vector3.ZERO = new Vector3(0.0, 0.0, 0.0);
        Vector3.ONE = new Vector3(1.0, 1.0, 1.0);
        Vector3.UP = new Vector3(0.0, 1.0, 0.0);
        Vector3.DOWN = new Vector3(0.0, -1.0, 0.0);
        Vector3.LEFT = new Vector3(-1.0, 0.0, 0.0);
        Vector3.RIGHT = new Vector3(1.0, 0.0, 0.0);
        Vector3.FORWARD = new Vector3(0.0, 0.0, 1.0);
        Vector3.BACK = new Vector3(0.0, 0.0, -1.0);
        Vector3._instances = [];
        return Vector3;
    }());
    egret3d.Vector3 = Vector3;
    __reflect(Vector3.prototype, "egret3d.Vector3", ["egret3d.IVector3", "paper.ISerializable"]);
    var helpVector = new Vector3();
    egret3d.helpVector3A = new Vector3();
    egret3d.helpVector3B = new Vector3();
    egret3d.helpVector3C = new Vector3();
    egret3d.helpVector3D = new Vector3();
    egret3d.helpVector3E = new Vector3();
    egret3d.helpVector3F = new Vector3();
    egret3d.helpVector3G = new Vector3();
    egret3d.helpVector3H = new Vector3();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var BaseObjectAsset = (function (_super) {
        __extends(BaseObjectAsset, _super);
        function BaseObjectAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._raw = null;
            return _this;
        }
        /**
         * @internal
         */
        BaseObjectAsset.prototype.$parse = function (json) {
            this._raw = json;
        };
        BaseObjectAsset.prototype.dispose = function () {
            if (this._isBuiltin) {
                return;
            }
            this._raw = null;
        };
        BaseObjectAsset.prototype.caclByteLength = function () {
            return 0;
        };
        return BaseObjectAsset;
    }(paper.Asset));
    paper.BaseObjectAsset = BaseObjectAsset;
    __reflect(BaseObjectAsset.prototype, "paper.BaseObjectAsset");
    /**
     * 预制体资源。
     */
    var Prefab = (function (_super) {
        __extends(Prefab, _super);
        function Prefab() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * 从当前预制体生成一个实例。
         */
        Prefab.prototype.createInstance = function () {
            if (!this._raw) {
                return null;
            }
            var gameObject = paper.deserialize(this._raw);
            if (gameObject) {
                gameObject.prefab = this;
            }
            return gameObject;
        };
        return Prefab;
    }(BaseObjectAsset));
    paper.Prefab = Prefab;
    __reflect(Prefab.prototype, "paper.Prefab");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 组件基类
     */
    var BaseComponent = (function (_super) {
        __extends(BaseComponent, _super);
        /**
         * 禁止实例化组件。
         * @protected
         */
        function BaseComponent() {
            var _this = _super.call(this) || this;
            _this.assetID = paper.createAssetID();
            /**
             * 组件挂载的 GameObject
             */
            _this.gameObject = null;
            _this._enabled = true;
            if (BaseComponent._createEnabled) {
                _this.gameObject = BaseComponent._createEnabled;
                BaseComponent._createEnabled = null;
            }
            else {
                throw new Error("Create an instance of a component is not allowed.");
            }
            return _this;
        }
        /**
         * @internal
         */
        BaseComponent.register = function (target) {
            if (target === BaseComponent) {
                return;
            }
            if (target.level < 0) {
                target.level = target.prototype.__proto__.constructor.level + 1;
                target.componentIndex = this._componentCount++;
            }
            if (target.index < 0) {
                target.index = this._componentClasses.length;
                this._componentClasses.push(target);
            }
        };
        /**
         * @internal
         */
        BaseComponent.create = function (componentClass, gameObject) {
            this.register(componentClass);
            BaseComponent._createEnabled = gameObject;
            return new componentClass();
        };
        /**
         * 添加组件后，组件内部初始化。
         * - 重载此方法时，必须调用 `super.initialize()`。
         */
        BaseComponent.prototype.initialize = function (config) {
        };
        /**
         * 移除组件后，组件内部卸载。
         * - 重载此方法时，必须调用 `super.uninitialize()`。
         */
        BaseComponent.prototype.uninitialize = function () {
        };
        BaseComponent.prototype.serialize = function () {
            var target = paper.createReference(this, false);
            target._enabled = this._enabled;
            if (this.assetID) {
                target.assetID = this.assetID;
            }
            if (this.extras) {
                target.extras = {};
                for (var k in this.extras) {
                    target.extras[k] = this.extras[k];
                }
            }
            return target;
        };
        BaseComponent.prototype.deserialize = function (element) {
            this._enabled = element._enabled === false ? false : true;
            if (element.uuid) {
                this.uuid = element.uuid;
            }
            if (element.assetID) {
                this.assetID = element.assetID;
            }
            if (element.extras) {
                this.extras = {};
                for (var k in element.extras) {
                    this.extras[k] = element.extras[k];
                }
            }
        };
        Object.defineProperty(BaseComponent.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this.gameObject;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "enabled", {
            /**
             * 组件的激活状态。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._enabled === value) {
                    return;
                }
                var prevEnabled = this.isActiveAndEnabled;
                this._enabled = value;
                var currentEnabled = this.isActiveAndEnabled;
                if (currentEnabled !== prevEnabled) {
                    paper.EventPool.dispatchEvent(currentEnabled ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, this);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseComponent.prototype, "isActiveAndEnabled", {
            /**
             * 组件在场景的激活状态。
             */
            get: function () {
                // return this._enabled && this.gameObject.activeInHierarchy;
                return this._enabled && (this.gameObject._activeDirty ? this.gameObject.activeInHierarchy : this.gameObject._activeInHierarchy);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 是否在编辑模式拥有生命周期。
         */
        BaseComponent.executeInEditMode = false;
        /**
         * 是否禁止在同一实体上添加多个实例。
         */
        BaseComponent.disallowMultiple = false;
        /**
         * @internal
         */
        BaseComponent.level = -1;
        /**
         * @internal
         */
        BaseComponent.componentIndex = -1;
        /**
         * @internal
         */
        BaseComponent.index = -1;
        /**
         * 依赖的其他组件。
         */
        BaseComponent.requireComponents = null;
        BaseComponent._createEnabled = null;
        BaseComponent._componentCount = 0;
        BaseComponent._componentClasses = [];
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "assetID", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], BaseComponent.prototype, "_enabled", void 0);
        return BaseComponent;
    }(paper.SerializableObject));
    paper.BaseComponent = BaseComponent;
    __reflect(BaseComponent.prototype, "paper.BaseComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var Vector2 = (function () {
        function Vector2(x, y) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            this.x = x;
            this.y = y;
        }
        Vector2.prototype.serialize = function () {
            return [this.x, this.y];
        };
        Vector2.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
        };
        Vector2.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            return this;
        };
        Vector2.prototype.clone = function () {
            var value = new Vector2();
            value.copy(this);
            return value;
        };
        Vector2.prototype.set = function (x, y) {
            this.x = x;
            this.y = y;
            return this;
        };
        Vector2.prototype.normalize = function () {
            var l = this.length;
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
            }
            else {
                this.x = 1.0;
                this.y = 0.0;
            }
            return this;
        };
        Object.defineProperty(Vector2.prototype, "length", {
            get: function () {
                return Math.sqrt(this.sqrtLength);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Vector2.prototype, "sqrtLength", {
            get: function () {
                return this.x * this.x + this.y * this.y;
            },
            enumerable: true,
            configurable: true
        });
        Vector2.set = function (x, y, out) {
            out.x = x;
            out.y = y;
            return out;
        };
        Vector2.normalize = function (v) {
            var num = this.getLength(v);
            if (num > Number.MIN_VALUE) {
                v.x = v.x / num;
                v.y = v.y / num;
            }
            else {
                v.x = 1.0;
                v.y = 0.0;
            }
            return v;
        };
        Vector2.add = function (v1, v2, out) {
            out.x = v1.x + v2.x;
            out.y = v1.y + v2.y;
            return out;
        };
        Vector2.subtract = function (v1, v2, out) {
            out.x = v1.x - v2.x;
            out.y = v1.y - v2.y;
            return out;
        };
        Vector2.multiply = function (v1, v2, out) {
            out.x = v1.x * v2.x;
            out.y = v1.y * v2.y;
            return out;
        };
        Vector2.dot = function (v1, v2) {
            return v1.x * v2.x + v1.y * v2.y;
        };
        Vector2.scale = function (v, scaler) {
            v.x = v.x * scaler;
            v.y = v.y * scaler;
            return v;
        };
        Vector2.getLength = function (v) {
            return Math.sqrt(v.x * v.x + v.y * v.y);
        };
        Vector2.getDistance = function (v1, v2) {
            this.subtract(v1, v2, _helpVector2A);
            return this.getLength(_helpVector2A);
        };
        Vector2.copy = function (v, out) {
            out.x = v.x;
            out.y = v.y;
            return out;
        };
        Vector2.equal = function (v1, v2, threshold) {
            if (threshold === void 0) { threshold = 0.00001; }
            if (Math.abs(v1.x - v2.x) > threshold) {
                return false;
            }
            if (Math.abs(v1.y - v2.y) > threshold) {
                return false;
            }
            return true;
        };
        Vector2.lerp = function (v1, v2, value, out) {
            out.x = v1.x * (1 - value) + v2.x * value;
            out.y = v1.y * (1 - value) + v2.y * value;
            return out;
        };
        Vector2.ZERO = new Vector2(0.0, 0.0);
        Vector2.ONE = new Vector2(1.0, 1.0);
        return Vector2;
    }());
    egret3d.Vector2 = Vector2;
    __reflect(Vector2.prototype, "egret3d.Vector2", ["egret3d.IVector2", "paper.ISerializable"]);
    var _helpVector2A = new Vector2();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVectorA = new egret3d.Vector3();
    var Matrix = (function () {
        function Matrix(rawData) {
            if (rawData === void 0) { rawData = null; }
            if (rawData) {
                this.rawData = rawData;
            }
            else {
                this.rawData = new Float32Array([
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    0.0, 0.0, 0.0, 1.0
                ]);
            }
        }
        Matrix.create = function () {
            if (this._instances.length > 0) {
                return this._instances.pop();
            }
            return new Matrix();
        };
        Matrix.release = function (value) {
            if (this._instances.indexOf(value) >= 0) {
                return;
            }
            this._instances.push(value);
        };
        Matrix.prototype.copy = function (value) {
            var fromRawData = value.rawData;
            var toRawData = this.rawData;
            toRawData[0] = fromRawData[0];
            toRawData[1] = fromRawData[1];
            toRawData[2] = fromRawData[2];
            toRawData[3] = fromRawData[3];
            toRawData[4] = fromRawData[4];
            toRawData[5] = fromRawData[5];
            toRawData[6] = fromRawData[6];
            toRawData[7] = fromRawData[7];
            toRawData[8] = fromRawData[8];
            toRawData[9] = fromRawData[9];
            toRawData[10] = fromRawData[10];
            toRawData[11] = fromRawData[11];
            toRawData[12] = fromRawData[12];
            toRawData[13] = fromRawData[13];
            toRawData[14] = fromRawData[14];
            toRawData[15] = fromRawData[15];
            return this;
        };
        Matrix.prototype.clone = function () {
            var value = new Matrix();
            value.copy(this);
            return value;
        };
        Matrix.prototype.set = function (n11, n21, n31, n41, n12, n22, n32, n42, n13, n23, n33, n43, n14, n24, n34, n44) {
            this.rawData[0] = n11;
            this.rawData[1] = n12;
            this.rawData[2] = n13;
            this.rawData[3] = n14;
            this.rawData[4] = n21;
            this.rawData[5] = n22;
            this.rawData[6] = n23;
            this.rawData[7] = n24;
            this.rawData[8] = n31;
            this.rawData[9] = n32;
            this.rawData[10] = n33;
            this.rawData[11] = n34;
            this.rawData[12] = n41;
            this.rawData[13] = n42;
            this.rawData[14] = n43;
            this.rawData[15] = n44;
            return this;
        };
        Matrix.prototype.set3x3 = function (n11, n21, n31, n12, n22, n32, n13, n23, n33) {
            this.rawData[0] = n11;
            this.rawData[1] = n12;
            this.rawData[2] = n13;
            this.rawData[4] = n21;
            this.rawData[5] = n22;
            this.rawData[6] = n23;
            this.rawData[8] = n31;
            this.rawData[9] = n32;
            this.rawData[10] = n33;
            return this;
        };
        Matrix.prototype.setTranslation = function (translation) {
            this.rawData[12] = translation.x;
            this.rawData[13] = translation.y;
            this.rawData[14] = translation.z;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix.prototype.identity = function () {
            this.rawData[0] = 1.0;
            this.rawData[1] = 0.0;
            this.rawData[2] = 0.0;
            this.rawData[3] = 0.0;
            this.rawData[4] = 0.0;
            this.rawData[5] = 1.0;
            this.rawData[6] = 0.0;
            this.rawData[7] = 0.0;
            this.rawData[8] = 0.0;
            this.rawData[9] = 0.0;
            this.rawData[10] = 1.0;
            this.rawData[11] = 0.0;
            this.rawData[12] = 0.0;
            this.rawData[13] = 0.0;
            this.rawData[14] = 0.0;
            this.rawData[15] = 1.0;
            return this;
        };
        Matrix.prototype.inverse = function () {
            var l1 = this.rawData[0];
            var l2 = this.rawData[1];
            var l3 = this.rawData[2];
            var l4 = this.rawData[3];
            var l5 = this.rawData[4];
            var l6 = this.rawData[5];
            var l7 = this.rawData[6];
            var l8 = this.rawData[7];
            var l9 = this.rawData[8];
            var l10 = this.rawData[9];
            var l11 = this.rawData[10];
            var l12 = this.rawData[11];
            var l13 = this.rawData[12];
            var l14 = this.rawData[13];
            var l15 = this.rawData[14];
            var l16 = this.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            var rawData = this.rawData;
            rawData[0] = l23 * l27;
            rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            rawData[4] = l24 * l27;
            rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            rawData[8] = l25 * l27;
            rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            rawData[12] = l26 * l27;
            rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
            return this;
        };
        Matrix.prototype.transformVector3 = function (value) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]) + this.rawData[12];
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]) + this.rawData[13];
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]) + this.rawData[14];
            var w = (value.x * this.rawData[3]) + (value.y * this.rawData[7]) + (value.z * this.rawData[11]) + this.rawData[15];
            value.x = x / w;
            value.y = y / w;
            value.z = z / w;
            return value;
        };
        Matrix.prototype.transformNormal = function (value) {
            var x = (value.x * this.rawData[0]) + (value.y * this.rawData[4]) + (value.z * this.rawData[8]);
            var y = (value.x * this.rawData[1]) + (value.y * this.rawData[5]) + (value.z * this.rawData[9]);
            var z = (value.x * this.rawData[2]) + (value.y * this.rawData[6]) + (value.z * this.rawData[10]);
            value.x = x;
            value.y = y;
            value.z = z;
            return value;
        };
        Matrix.set = function (n11, n21, n31, n41, n12, n22, n32, n42, n13, n23, n33, n43, n14, n24, n34, n44, result) {
            var rawData = result.rawData;
            rawData[0] = n11;
            rawData[1] = n12;
            rawData[2] = n13;
            rawData[3] = n14;
            rawData[4] = n21;
            rawData[5] = n22;
            rawData[6] = n23;
            rawData[7] = n24;
            rawData[8] = n31;
            rawData[9] = n32;
            rawData[10] = n33;
            rawData[11] = n34;
            rawData[12] = n41;
            rawData[13] = n42;
            rawData[14] = n43;
            rawData[15] = n44;
            return result;
        };
        Matrix.getScale = function (m, out) {
            out.x = m.rawData[0];
            out.y = m.rawData[5];
            out.z = m.rawData[10];
            return out;
        };
        Matrix.getTranslation = function (m, out) {
            out.x = m.rawData[12];
            out.y = m.rawData[13];
            out.z = m.rawData[14];
            return out;
        };
        Matrix.getQuaternion = function (m, out) {
            var data = m.rawData;
            var m11 = data[0], m12 = data[4], m13 = data[8];
            var m21 = data[1], m22 = data[5], m23 = data[9];
            var m31 = data[2], m32 = data[6], m33 = data[10];
            var trace = m11 + m22 + m33;
            var s;
            if (trace > 0) {
                s = 0.5 / Math.sqrt(trace + 1.0);
                out.w = 0.25 / s;
                out.x = (m32 - m23) * s;
                out.y = (m13 - m31) * s;
                out.z = (m21 - m12) * s;
            }
            else if (m11 > m22 && m11 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
                out.w = (m32 - m23) / s;
                out.x = 0.25 * s;
                out.y = (m12 + m21) / s;
                out.z = (m13 + m31) / s;
            }
            else if (m22 > m33) {
                s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
                out.w = (m13 - m31) / s;
                out.x = (m12 + m21) / s;
                out.y = 0.25 * s;
                out.z = (m23 + m32) / s;
            }
            else {
                s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
                out.w = (m21 - m12) / s;
                out.x = (m13 + m31) / s;
                out.y = (m23 + m32) / s;
                out.z = 0.25 * s;
            }
            return out;
        };
        Matrix.add = function (left, right, out) {
            out.rawData[0] = left.rawData[0] + right.rawData[0];
            out.rawData[1] = left.rawData[1] + right.rawData[1];
            out.rawData[2] = left.rawData[2] + right.rawData[2];
            out.rawData[3] = left.rawData[3] + right.rawData[3];
            out.rawData[4] = left.rawData[4] + right.rawData[4];
            out.rawData[5] = left.rawData[5] + right.rawData[5];
            out.rawData[6] = left.rawData[6] + right.rawData[6];
            out.rawData[7] = left.rawData[7] + right.rawData[7];
            out.rawData[8] = left.rawData[8] + right.rawData[8];
            out.rawData[9] = left.rawData[9] + right.rawData[9];
            out.rawData[10] = left.rawData[10] + right.rawData[10];
            out.rawData[11] = left.rawData[11] + right.rawData[11];
            out.rawData[12] = left.rawData[12] + right.rawData[12];
            out.rawData[13] = left.rawData[13] + right.rawData[13];
            out.rawData[14] = left.rawData[14] + right.rawData[14];
            out.rawData[15] = left.rawData[15] + right.rawData[15];
            return out;
        };
        Matrix.multiply = function (lhs, rhs, out) {
            var a00 = lhs.rawData[0], a01 = lhs.rawData[1], a02 = lhs.rawData[2], a03 = lhs.rawData[3];
            var a10 = lhs.rawData[4], a11 = lhs.rawData[5], a12 = lhs.rawData[6], a13 = lhs.rawData[7];
            var a20 = lhs.rawData[8], a21 = lhs.rawData[9], a22 = lhs.rawData[10], a23 = lhs.rawData[11];
            var a30 = lhs.rawData[12], a31 = lhs.rawData[13], a32 = lhs.rawData[14], a33 = lhs.rawData[15];
            var b0 = rhs.rawData[0], b1 = rhs.rawData[1], b2 = rhs.rawData[2], b3 = rhs.rawData[3];
            out.rawData[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[4];
            b1 = rhs.rawData[5];
            b2 = rhs.rawData[6];
            b3 = rhs.rawData[7];
            out.rawData[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[8];
            b1 = rhs.rawData[9];
            b2 = rhs.rawData[10];
            b3 = rhs.rawData[11];
            out.rawData[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            b0 = rhs.rawData[12];
            b1 = rhs.rawData[13];
            b2 = rhs.rawData[14];
            b3 = rhs.rawData[15];
            out.rawData[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
            out.rawData[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
            out.rawData[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
            out.rawData[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
            return out;
        };
        Matrix.scale = function (scaler, m) {
            m.rawData[0] *= scaler;
            m.rawData[1] *= scaler;
            m.rawData[2] *= scaler;
            m.rawData[3] *= scaler;
            m.rawData[4] *= scaler;
            m.rawData[5] *= scaler;
            m.rawData[6] *= scaler;
            m.rawData[7] *= scaler;
            m.rawData[8] *= scaler;
            m.rawData[9] *= scaler;
            m.rawData[10] *= scaler;
            m.rawData[11] *= scaler;
            m.rawData[12] *= scaler;
            m.rawData[13] *= scaler;
            m.rawData[14] *= scaler;
            m.rawData[15] *= scaler;
            return m;
        };
        Matrix.transpose = function (m, out) {
            out.rawData[1] = m.rawData[4];
            out.rawData[2] = m.rawData[8];
            out.rawData[3] = m.rawData[12];
            out.rawData[4] = m.rawData[1];
            out.rawData[6] = m.rawData[9];
            out.rawData[7] = m.rawData[13];
            out.rawData[8] = m.rawData[2];
            out.rawData[9] = m.rawData[6];
            out.rawData[11] = m.rawData[14];
            out.rawData[12] = m.rawData[3];
            out.rawData[13] = m.rawData[7];
            out.rawData[14] = m.rawData[11];
            return out;
        };
        Matrix.inverse = function (src, out) {
            var l1 = src.rawData[0];
            var l2 = src.rawData[1];
            var l3 = src.rawData[2];
            var l4 = src.rawData[3];
            var l5 = src.rawData[4];
            var l6 = src.rawData[5];
            var l7 = src.rawData[6];
            var l8 = src.rawData[7];
            var l9 = src.rawData[8];
            var l10 = src.rawData[9];
            var l11 = src.rawData[10];
            var l12 = src.rawData[11];
            var l13 = src.rawData[12];
            var l14 = src.rawData[13];
            var l15 = src.rawData[14];
            var l16 = src.rawData[15];
            var l17 = (l11 * l16) - (l12 * l15);
            var l18 = (l10 * l16) - (l12 * l14);
            var l19 = (l10 * l15) - (l11 * l14);
            var l20 = (l9 * l16) - (l12 * l13);
            var l21 = (l9 * l15) - (l11 * l13);
            var l22 = (l9 * l14) - (l10 * l13);
            var l23 = ((l6 * l17) - (l7 * l18)) + (l8 * l19);
            var l24 = -(((l5 * l17) - (l7 * l20)) + (l8 * l21));
            var l25 = ((l5 * l18) - (l6 * l20)) + (l8 * l22);
            var l26 = -(((l5 * l19) - (l6 * l21)) + (l7 * l22));
            var l27 = 1.0 / ((((l1 * l23) + (l2 * l24)) + (l3 * l25)) + (l4 * l26));
            var l28 = (l7 * l16) - (l8 * l15);
            var l29 = (l6 * l16) - (l8 * l14);
            var l30 = (l6 * l15) - (l7 * l14);
            var l31 = (l5 * l16) - (l8 * l13);
            var l32 = (l5 * l15) - (l7 * l13);
            var l33 = (l5 * l14) - (l6 * l13);
            var l34 = (l7 * l12) - (l8 * l11);
            var l35 = (l6 * l12) - (l8 * l10);
            var l36 = (l6 * l11) - (l7 * l10);
            var l37 = (l5 * l12) - (l8 * l9);
            var l38 = (l5 * l11) - (l7 * l9);
            var l39 = (l5 * l10) - (l6 * l9);
            var rawData = out.rawData;
            rawData[0] = l23 * l27;
            rawData[1] = -(((l2 * l17) - (l3 * l18)) + (l4 * l19)) * l27;
            rawData[2] = (((l2 * l28) - (l3 * l29)) + (l4 * l30)) * l27;
            rawData[3] = -(((l2 * l34) - (l3 * l35)) + (l4 * l36)) * l27;
            rawData[4] = l24 * l27;
            rawData[5] = (((l1 * l17) - (l3 * l20)) + (l4 * l21)) * l27;
            rawData[6] = -(((l1 * l28) - (l3 * l31)) + (l4 * l32)) * l27;
            rawData[7] = (((l1 * l34) - (l3 * l37)) + (l4 * l38)) * l27;
            rawData[8] = l25 * l27;
            rawData[9] = -(((l1 * l18) - (l2 * l20)) + (l4 * l22)) * l27;
            rawData[10] = (((l1 * l29) - (l2 * l31)) + (l4 * l33)) * l27;
            rawData[11] = -(((l1 * l35) - (l2 * l37)) + (l4 * l39)) * l27;
            rawData[12] = l26 * l27;
            rawData[13] = (((l1 * l19) - (l2 * l21)) + (l3 * l22)) * l27;
            rawData[14] = -(((l1 * l30) - (l2 * l32)) + (l3 * l33)) * l27;
            rawData[15] = (((l1 * l36) - (l2 * l38)) + (l3 * l39)) * l27;
            return out;
        };
        Matrix.decompose = function (m, scale, rotation, translation) {
            translation.x = m.rawData[12];
            translation.y = m.rawData[13];
            translation.z = m.rawData[14];
            var xs = egret3d.sign(m.rawData[0] * m.rawData[1] * m.rawData[2] * m.rawData[3]) < 0 ? -1 : 1;
            var ys = egret3d.sign(m.rawData[4] * m.rawData[5] * m.rawData[6] * m.rawData[7]) < 0 ? -1 : 1;
            var zs = egret3d.sign(m.rawData[8] * m.rawData[9] * m.rawData[10] * m.rawData[11]) < 0 ? -1 : 1;
            scale.x = xs * Math.sqrt(m.rawData[0] * m.rawData[0] + m.rawData[1] * m.rawData[1] + m.rawData[2] * m.rawData[2]);
            scale.y = ys * Math.sqrt(m.rawData[4] * m.rawData[4] + m.rawData[5] * m.rawData[5] + m.rawData[6] * m.rawData[6]);
            scale.z = zs * Math.sqrt(m.rawData[8] * m.rawData[8] + m.rawData[9] * m.rawData[9] + m.rawData[10] * m.rawData[10]);
            if (scale.x === 0 || scale.y === 0 || scale.z === 0) {
                rotation.x = 0;
                rotation.y = 0;
                rotation.z = 0;
                rotation.w = 1;
                return false;
            }
            var mat = helpMat_1;
            mat.rawData[0] = m.rawData[0] / scale.x;
            mat.rawData[1] = m.rawData[1] / scale.x;
            mat.rawData[2] = m.rawData[2] / scale.x;
            mat.rawData[3] = 0;
            mat.rawData[4] = m.rawData[4] / scale.y;
            mat.rawData[5] = m.rawData[5] / scale.y;
            mat.rawData[6] = m.rawData[6] / scale.y;
            mat.rawData[7] = 0;
            mat.rawData[8] = m.rawData[8] / scale.z;
            mat.rawData[9] = m.rawData[9] / scale.z;
            mat.rawData[10] = m.rawData[10] / scale.z;
            mat.rawData[11] = 0;
            this.getQuaternion(mat, rotation);
            return true;
        };
        Matrix.copy = function (m, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = m.rawData[i];
            }
            return out;
        };
        Matrix.identify = function (m) {
            m.rawData[0] = 1;
            m.rawData[1] = 0;
            m.rawData[2] = 0;
            m.rawData[3] = 0;
            m.rawData[4] = 0;
            m.rawData[5] = 1;
            m.rawData[6] = 0;
            m.rawData[7] = 0;
            m.rawData[8] = 0;
            m.rawData[9] = 0;
            m.rawData[10] = 1;
            m.rawData[11] = 0;
            m.rawData[12] = 0;
            m.rawData[13] = 0;
            m.rawData[14] = 0;
            m.rawData[15] = 1;
            return m;
        };
        Matrix.zero = function (m) {
            m.rawData[0] = 0;
            m.rawData[1] = 0;
            m.rawData[2] = 0;
            m.rawData[3] = 0;
            m.rawData[4] = 0;
            m.rawData[5] = 0;
            m.rawData[6] = 0;
            m.rawData[7] = 0;
            m.rawData[8] = 0;
            m.rawData[9] = 0;
            m.rawData[10] = 0;
            m.rawData[11] = 0;
            m.rawData[12] = 0;
            m.rawData[13] = 0;
            m.rawData[14] = 0;
            m.rawData[15] = 1;
            return m;
        };
        Matrix.formScale = function (xScale, yScale, zScale, out) {
            out.rawData[0] = xScale;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0.0;
            out.rawData[4] = 0.0;
            out.rawData[5] = yScale;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = zScale;
            out.rawData[11] = 0.0;
            out.rawData[12] = 0.0;
            out.rawData[13] = 0.0;
            out.rawData[14] = 0.0;
            out.rawData[15] = 1.0;
            return out;
        };
        Matrix.fromTranslate = function (x, y, z, out) {
            out.rawData[0] = 1.0;
            out.rawData[1] = 0.0;
            out.rawData[2] = 0.0;
            out.rawData[3] = 0;
            out.rawData[4] = 0.0;
            out.rawData[5] = 1.0;
            out.rawData[6] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[8] = 0.0;
            out.rawData[9] = 0.0;
            out.rawData[10] = 1.0;
            out.rawData[11] = 0.0;
            out.rawData[12] = x;
            out.rawData[13] = y;
            out.rawData[14] = z;
            out.rawData[15] = 1.0;
            return out;
        };
        Matrix.fromRTS = function (p, s, q, out) {
            var matS = helpMat_1;
            this.formScale(s.x, s.y, s.z, matS);
            var matR = helpMat_2;
            egret3d.Quaternion.toMatrix(q, matR);
            this.multiply(matR, matS, out);
            out.rawData[12] = p.x;
            out.rawData[13] = p.y;
            out.rawData[14] = p.z;
            out.rawData[15] = 1;
            return out;
        };
        Matrix.getVector3ByOffset = function (src, offset, result) {
            result.x = src.rawData[offset];
            result.y = src.rawData[offset + 1];
            result.z = src.rawData[offset + 2];
            return result;
        };
        Matrix.transformVector3 = function (vector, transformMatrix, result) {
            var transformMatrixRawdata = transformMatrix.rawData;
            var x = (vector.x * transformMatrixRawdata[0]) + (vector.y * transformMatrixRawdata[4]) + (vector.z * transformMatrixRawdata[8]) + transformMatrixRawdata[12];
            var y = (vector.x * transformMatrixRawdata[1]) + (vector.y * transformMatrixRawdata[5]) + (vector.z * transformMatrixRawdata[9]) + transformMatrixRawdata[13];
            var z = (vector.x * transformMatrixRawdata[2]) + (vector.y * transformMatrixRawdata[6]) + (vector.z * transformMatrixRawdata[10]) + transformMatrixRawdata[14];
            var w = (vector.x * transformMatrixRawdata[3]) + (vector.y * transformMatrixRawdata[7]) + (vector.z * transformMatrixRawdata[11]) + transformMatrixRawdata[15];
            result.x = x / w;
            result.y = y / w;
            result.z = z / w;
            return result;
        };
        Matrix.transformNormal = function (vector, transformMatrix, result) {
            var transformMatrixRawdata = transformMatrix.rawData;
            var x = (vector.x * transformMatrixRawdata[0]) + (vector.y * transformMatrixRawdata[4]) + (vector.z * transformMatrixRawdata[8]);
            var y = (vector.x * transformMatrixRawdata[1]) + (vector.y * transformMatrixRawdata[5]) + (vector.z * transformMatrixRawdata[9]);
            var z = (vector.x * transformMatrixRawdata[2]) + (vector.y * transformMatrixRawdata[6]) + (vector.z * transformMatrixRawdata[10]);
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        };
        Matrix.lerp = function (left, right, v, out) {
            for (var i = 0; i < 16; i++) {
                out.rawData[i] = left.rawData[i] * (1 - v) + right.rawData[i] * v;
            }
            return out;
        };
        Matrix.perspectiveProjectLH = function (fov, aspect, znear, zfar, out) {
            var tan = 1.0 / (Math.tan(fov * 0.5));
            out.rawData[0] = tan / aspect;
            out.rawData[1] = out.rawData[2] = out.rawData[3] = 0.0;
            out.rawData[4] = out.rawData[6] = out.rawData[7] = 0.0;
            out.rawData[5] = tan;
            out.rawData[8] = out.rawData[9] = 0.0;
            out.rawData[10] = (zfar + znear) / (zfar - znear);
            out.rawData[11] = 1.0;
            out.rawData[12] = out.rawData[13] = out.rawData[15] = 0.0;
            out.rawData[14] = -2 * (znear * zfar) / (zfar - znear);
            return out;
        };
        Matrix.orthoProjectLH = function (width, height, znear, zfar, out) {
            var hw = 2.0 / width;
            var hh = 2.0 / height;
            var id = 2.0 / (zfar - znear);
            var nid = (znear + zfar) / (znear - zfar);
            out.rawData[0] = hw;
            out.rawData[1] = 0;
            out.rawData[2] = 0;
            out.rawData[3] = 0;
            out.rawData[4] = 0;
            out.rawData[5] = hh;
            out.rawData[6] = 0;
            out.rawData[7] = 0;
            out.rawData[8] = 0;
            out.rawData[9] = 0;
            out.rawData[10] = id;
            out.rawData[11] = 0;
            out.rawData[12] = 0;
            out.rawData[13] = 0;
            out.rawData[14] = nid;
            out.rawData[15] = 1;
            return out;
        };
        Matrix.toEulerAngles = function (matrix, out) {
            var x, y, z, sx, sy, sz, m, halfPi;
            var scale = _helpVectorA;
            Matrix.getScale(matrix, scale);
            sx = scale.x;
            sy = scale.y;
            sz = scale.z;
            m = matrix.rawData;
            y = Math.asin(-m[2] / sx);
            halfPi = Math.PI * 0.5;
            if (y < halfPi) {
                if (y > -halfPi) {
                    x = Math.atan2(m[6] / sy, m[10] / sz);
                    z = Math.atan2(m[1] / sx, m[0] / sx);
                }
                else {
                    // Not a unique solution
                    z = 0;
                    x = -Math.atan2(m[4] / sy, m[5] / sy);
                }
            }
            else {
                // Not a unique solution
                z = 0;
                x = Math.atan2(m[4] / sy, m[5] / sy);
            }
            out.x = x * 180 / Math.PI;
            out.y = y * 180 / Math.PI;
            out.z = z * 180 / Math.PI;
            return out;
        };
        Matrix.determinant = function (matrix) {
            var te = matrix.rawData;
            var n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];
            var n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];
            var n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];
            var n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];
            //TODO: make this more efficient
            //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
            return (n41 * (+n14 * n23 * n32 -
                n13 * n24 * n32 -
                n14 * n22 * n33 +
                n12 * n24 * n33 +
                n13 * n22 * n34 -
                n12 * n23 * n34) +
                n42 * (+n11 * n23 * n34 -
                    n11 * n24 * n33 +
                    n14 * n21 * n33 -
                    n13 * n21 * n34 +
                    n13 * n24 * n31 -
                    n14 * n23 * n31) +
                n43 * (+n11 * n24 * n32 -
                    n11 * n22 * n34 -
                    n14 * n21 * n32 +
                    n12 * n21 * n34 +
                    n14 * n22 * n31 -
                    n12 * n24 * n31) +
                n44 * (-n13 * n22 * n31 -
                    n11 * n23 * n32 +
                    n11 * n22 * n33 +
                    n13 * n21 * n32 -
                    n12 * n21 * n33 +
                    n12 * n23 * n31));
        };
        Matrix._instances = [];
        return Matrix;
    }());
    egret3d.Matrix = Matrix;
    __reflect(Matrix.prototype, "egret3d.Matrix");
    var helpMat_1 = new Matrix();
    var helpMat_2 = new Matrix();
    egret3d.helpMatrixA = new Matrix();
    egret3d.helpMatrixB = new Matrix();
    egret3d.helpMatrixC = new Matrix();
    egret3d.helpMatrixD = new Matrix();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**属性信息 */
        var PropertyInfo = (function () {
            function PropertyInfo(name, editType, option) {
                this.name = name;
                this.editType = editType;
                this.option = option;
            }
            return PropertyInfo;
        }());
        editor.PropertyInfo = PropertyInfo;
        __reflect(PropertyInfo.prototype, "paper.editor.PropertyInfo");
        /**编辑类型 */
        var EditType;
        (function (EditType) {
            /**数字输入 */
            EditType[EditType["NUMBER"] = 0] = "NUMBER";
            /**文本输入 */
            EditType[EditType["TEXT"] = 1] = "TEXT";
            /**选中框 */
            EditType[EditType["CHECKBOX"] = 2] = "CHECKBOX";
            /**vertor2 */
            EditType[EditType["VECTOR2"] = 3] = "VECTOR2";
            /**vertor3 */
            EditType[EditType["VECTOR3"] = 4] = "VECTOR3";
            /**vertor4 */
            EditType[EditType["VECTOR4"] = 5] = "VECTOR4";
            /**Quaternion */
            EditType[EditType["QUATERNION"] = 6] = "QUATERNION";
            /**颜色选择器 */
            EditType[EditType["COLOR"] = 7] = "COLOR";
            /**下拉 */
            EditType[EditType["LIST"] = 8] = "LIST";
            /**Rect */
            EditType[EditType["RECT"] = 9] = "RECT";
            /**材质 */
            EditType[EditType["MATERIAL"] = 10] = "MATERIAL";
            /**材质数组 */
            EditType[EditType["MATERIAL_ARRAY"] = 11] = "MATERIAL_ARRAY";
            /**游戏对象 */
            EditType[EditType["GAMEOBJECT"] = 12] = "GAMEOBJECT";
            /**变换 */
            EditType[EditType["TRANSFROM"] = 13] = "TRANSFROM";
            /**声音 */
            EditType[EditType["SOUND"] = 14] = "SOUND";
            /**Mesh */
            EditType[EditType["MESH"] = 15] = "MESH";
            /**shader */
            EditType[EditType["SHADER"] = 16] = "SHADER";
            /**数组 */
            EditType[EditType["ARRAY"] = 17] = "ARRAY";
        })(EditType = editor.EditType || (editor.EditType = {}));
        var customMap = {};
        /**
         * 装饰器:自定义
         */
        function custom() {
            return function (target) {
                customMap[target.name] = true;
            };
        }
        editor.custom = custom;
        var propertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function property(editType, option) {
            return function (target, property) {
                if (!propertyMap[target.constructor.name]) {
                    propertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    propertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.property = property;
        /**
         * 检测一个实例对象是否为已被自定义
         * @param classInstance 实例对象
         */
        function isCustom(classInstance) {
            return customMap[classInstance.constructor.name] ? true : false;
        }
        editor.isCustom = isCustom;
        /**
         * 获取一个实例对象的编辑信息
         * @param classInstance 实例对象
         */
        function getEditInfo(classInstance) {
            var className = classInstance.constructor.name;
            function _getEditInfo(className) {
                var classInfo = propertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getEditInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getEditInfo(className);
        }
        editor.getEditInfo = getEditInfo;
        function getEditInfoByPrototype(classInstance) {
            function _getEditInfo(proto) {
                var classInfo;
                var extendsInfo;
                if (proto && Object.getPrototypeOf(proto)) {
                    classInfo = propertyMap[Object.getPrototypeOf(proto).constructor.name];
                }
                if (classInfo) {
                    extendsInfo = _getEditInfo(Object.getPrototypeOf(proto));
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                else {
                    if (proto) {
                        extendsInfo = _getEditInfo(Object.getPrototypeOf(proto));
                        return extendsInfo;
                    }
                }
                return [];
            }
            return _getEditInfo(classInstance);
        }
        editor.getEditInfoByPrototype = getEditInfoByPrototype;
        var extraPropertyMap = {};
        /**
         * 装饰器:属性
         * @param editType 编辑类型
         */
        function extraProperty(editType, option) {
            return function (target, property) {
                if (!extraPropertyMap[target.constructor.name]) {
                    extraPropertyMap[target.constructor.name] = {
                        extends: target.__proto__.constructor.name,
                        propertyList: [],
                    };
                }
                if (editType !== undefined) {
                    extraPropertyMap[target.constructor.name].propertyList.push(new PropertyInfo(property, editType, option));
                }
                else {
                    //TODO:自动分析编辑类型
                }
            };
        }
        editor.extraProperty = extraProperty;
        /**
         * 额外信息
         * @param classInstance 实例对象
         */
        function getExtraInfo(classInstance) {
            var className = classInstance.constructor.name;
            function _getExtraInfo(className) {
                var classInfo = extraPropertyMap[className];
                if (classInfo) {
                    var extendsInfo = _getExtraInfo(classInfo.extends);
                    extendsInfo = extendsInfo.concat(classInfo.propertyList);
                    return extendsInfo;
                }
                return [];
            }
            return _getExtraInfo(className);
        }
        editor.getExtraInfo = getExtraInfo;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * renderer component interface
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 渲染器组件接口
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var BaseRenderer = (function (_super) {
        __extends(BaseRenderer, _super);
        function BaseRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._receiveShadows = false;
            _this._castShadows = false;
            _this._lightmapIndex = -1;
            _this._lightmapScaleOffset = new Float32Array([1.0, 1.0, 0.0, 0.0]);
            return _this;
        }
        Object.defineProperty(BaseRenderer.prototype, "receiveShadows", {
            // TODO materials
            get: function () {
                return this._receiveShadows;
            },
            set: function (value) {
                if (value === this._receiveShadows) {
                    return;
                }
                this._receiveShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "castShadows", {
            get: function () {
                return this._castShadows;
            },
            set: function (value) {
                if (value === this._castShadows) {
                    return;
                }
                this._castShadows = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapIndex", {
            get: function () {
                return this._lightmapIndex;
            },
            set: function (value) {
                if (value === this._lightmapIndex) {
                    return;
                }
                this._lightmapIndex = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseRenderer.prototype, "lightmapScaleOffset", {
            // @editor.property(editor.EditType.VECTOR4) TODO
            get: function () {
                return this._lightmapScaleOffset;
            },
            enumerable: true,
            configurable: true
        });
        BaseRenderer.prototype.setLightmapScaleOffset = function (scaleX, scaleY, offsetX, offsetY) {
            this._lightmapScaleOffset[0] = scaleX;
            this._lightmapScaleOffset[1] = scaleY;
            this._lightmapScaleOffset[2] = offsetX;
            this._lightmapScaleOffset[3] = offsetY;
        };
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_receiveShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_castShadows", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapIndex", void 0);
        __decorate([
            paper.serializedField
        ], BaseRenderer.prototype, "_lightmapScaleOffset", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "receiveShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseRenderer.prototype, "castShadows", null);
        __decorate([
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseRenderer.prototype, "lightmapIndex", null);
        return BaseRenderer;
    }(paper.BaseComponent));
    paper.BaseRenderer = BaseRenderer;
    __reflect(BaseRenderer.prototype, "paper.BaseRenderer");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 脚本组件。
     * 生命周期的顺序。
     * - onAwake();
     * - onReset();
     * - onEnable();
     * - onStart();
     * - onFixedUpdate();
     * - onUpdate();
     * - onLateUpdate();
     * - onDisable();
     * - onDestroy();
     */
    var Behaviour = (function (_super) {
        __extends(Behaviour, _super);
        function Behaviour() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @internal
             */
            _this._isReseted = false;
            /**
             * @internal
             */
            _this._isStarted = false;
            return _this;
        }
        Behaviour.prototype.initialize = function (config) {
            _super.prototype.initialize.call(this, config);
            if (!paper.Application.isEditor || this.constructor.executeInEditMode) {
                this.onAwake && this.onAwake(config);
            }
        };
        Behaviour.prototype.uninitialize = function () {
            if (!paper.Application.isEditor || this.constructor.executeInEditMode) {
                this.onDestroy && this.onDestroy(); // TODO onDestroy 如果不是 enabled 就不派发
            }
            _super.prototype.uninitialize.call(this);
        };
        /**
         * @deprecated
         */
        Behaviour.prototype.onCollide = function (collider) { };
        return Behaviour;
    }(paper.BaseComponent));
    paper.Behaviour = Behaviour;
    __reflect(Behaviour.prototype, "paper.Behaviour");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 系统基类。
     */
    var BaseSystem = (function () {
        /**
         * 禁止实例化系统。
         * @protected
         */
        function BaseSystem() {
            /**
             * @internal
             */
            this._started = true;
            this._locked = false;
            this._enabled = true;
            /**
             *
             */
            this._interests = [];
            /**
             *
             */
            this._groups = [];
            /**
             *
             */
            this._globalGameObject = paper.Application.sceneManager.globalGameObject;
            /**
             *
             */
            this._clock = this._globalGameObject.getOrAddComponent(paper.Clock);
            if (!BaseSystem._createEnabled) {
                throw new Error("Create an instance of a system is not allowed.");
            }
            BaseSystem._createEnabled = false;
        }
        /**
         * @internal
         */
        BaseSystem.create = function (systemClass) {
            this._createEnabled = true;
            return new systemClass();
        };
        /**
         * TODO 宏定义。
         * @internal
         */
        BaseSystem.prototype._isEditorUpdate = function () {
            return paper.Application.isEditor && !paper.Application.isPlaying;
        };
        /**
         * 系统内部初始化。
         * @internal
         */
        BaseSystem.prototype.initialize = function () {
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_1 = interests; _i < interests_1.length; _i++) {
                    var interest = interests_1[_i];
                    for (var _a = 0, interest_1 = interest; _a < interest_1.length; _a++) {
                        var config = interest_1[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.addEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.addEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                    this._groups.push(paper.Group.create(interest));
                }
            }
            this.onAwake && this.onAwake();
            this.onEnable && this.onEnable();
        };
        /**
         * 系统内部卸载。
         * @internal
         */
        BaseSystem.prototype.uninitialize = function () {
            this.onDestroy && this.onDestroy();
            if (this._interests.length > 0) {
                var interests = void 0;
                if (Array.isArray(this._interests[0])) {
                    interests = this._interests;
                }
                else {
                    interests = [this._interests];
                }
                for (var _i = 0, interests_2 = interests; _i < interests_2.length; _i++) {
                    var interest = interests_2[_i];
                    for (var _a = 0, interest_2 = interest; _a < interest_2.length; _a++) {
                        var config = interest_2[_a];
                        if (!config.listeners) {
                            continue;
                        }
                        for (var _b = 0, _c = config.listeners; _b < _c.length; _b++) {
                            var listenerConfig = _c[_b];
                            if (Array.isArray(config.componentClass)) {
                                for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                                    var componentClass = _e[_d];
                                    paper.EventPool.removeEventListener(listenerConfig.type, componentClass, listenerConfig.listener);
                                }
                            }
                            else {
                                paper.EventPool.removeEventListener(listenerConfig.type, config.componentClass, listenerConfig.listener);
                            }
                        }
                    }
                }
            }
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.update = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                if (this.onAddGameObject) {
                    for (var _b = 0, _c = group._addedGameObjects; _b < _c.length; _b++) {
                        var gameObject = _c[_b];
                        if (gameObject) {
                            this.onAddGameObject(gameObject, group);
                        }
                    }
                }
                if (this.onAddComponent) {
                    for (var _d = 0, _e = group._addedComponents; _d < _e.length; _d++) {
                        var component = _e[_d];
                        if (component) {
                            this.onAddComponent(component, group);
                        }
                    }
                }
            }
            this.onUpdate && this.onUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        /**
         * 系统内部更新。
         * @internal
         */
        BaseSystem.prototype.lateUpdate = function () {
            if (!this._enabled) {
                return;
            }
            this._locked = true;
            this.onLateUpdate && this.onLateUpdate(this._clock.deltaTime);
            this._locked = false;
        };
        Object.defineProperty(BaseSystem.prototype, "enabled", {
            /**
             * 该系统是否被激活。
             */
            get: function () {
                return this._enabled;
            },
            set: function (value) {
                if (this._locked) {
                    console.warn("Cannot change the enabled value when the system is updating.", egret.getQualifiedClassName(this));
                    return;
                }
                if (this._enabled === value) {
                    return;
                }
                this._enabled = value;
                if (this._enabled) {
                    this.onEnable && this.onEnable();
                }
                else {
                    this.onDisable && this.onDisable();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BaseSystem.prototype, "groups", {
            /**
             *
             */
            get: function () {
                return this._groups;
            },
            enumerable: true,
            configurable: true
        });
        BaseSystem._createEnabled = false;
        return BaseSystem;
    }());
    paper.BaseSystem = BaseSystem;
    __reflect(BaseSystem.prototype, "paper.BaseSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * scene asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 场景数据资源
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var RawScene = (function (_super) {
        __extends(RawScene, _super);
        function RawScene() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * @internal
         */
        RawScene.prototype.createInstance = function (isKeepUUID) {
            if (isKeepUUID === void 0) { isKeepUUID = false; }
            if (!this._raw) {
                return null;
            }
            var scene = paper.deserialize(this._raw, isKeepUUID);
            if (scene) {
                scene.rawScene = this;
            }
            return scene;
        };
        return RawScene;
    }(paper.BaseObjectAsset));
    paper.RawScene = RawScene;
    __reflect(RawScene.prototype, "paper.RawScene");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * SystemManager 是ecs内部的系统管理者，负责每帧循环时轮询每个系统。
     */
    var SystemManager = (function () {
        function SystemManager() {
            this._systems = [];
            this._currentSystem = null;
        }
        SystemManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SystemManager();
            }
            return this._instance;
        };
        SystemManager.prototype._preRegister = function (systemClass) {
            if (this.getSystem(systemClass)) {
                console.warn("The system has been registered.", egret.getQualifiedClassName(systemClass));
                return true;
            }
            return false;
        };
        /**
         * 注册一个系统到管理器中。
         */
        SystemManager.prototype.register = function (systemClass, after) {
            if (after === void 0) { after = null; }
            if (this._preRegister(systemClass)) {
                return;
            }
            var index = -1;
            var system = paper.BaseSystem.create(systemClass);
            if (after) {
                for (var i = 0, l = this._systems.length; i < l; ++i) {
                    var eachSystem = this._systems[i];
                    if (eachSystem && eachSystem.constructor === after) {
                        index = i + 1;
                        this._systems.splice(index, 0, system);
                        break;
                    }
                }
            }
            if (index < 0) {
                this._systems.push(system);
            }
            system.initialize();
        };
        /**
         * 注册一个系统到管理器中。
         */
        SystemManager.prototype.registerBefore = function (systemClass, before) {
            if (before === void 0) { before = null; }
            if (this._preRegister(systemClass)) {
                return;
            }
            var index = -1;
            var system = paper.BaseSystem.create(systemClass);
            if (before) {
                for (var i = 0, l = this._systems.length; i < l; ++i) {
                    var eachSystem = this._systems[i];
                    if (eachSystem && eachSystem.constructor === before) {
                        index = i;
                        this._systems.splice(index, 0, system);
                        break;
                    }
                }
            }
            if (index < 0) {
                this._systems.unshift(system);
            }
            system.initialize();
        };
        /**
         *
         */
        SystemManager.prototype.enableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = true;
            }
            else {
                console.warn("Enable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         *
         */
        SystemManager.prototype.disableSystem = function (systemClass) {
            var system = this.getSystem(systemClass);
            if (system) {
                system.enabled = false;
            }
            else {
                console.warn("Disable system error.", egret.getQualifiedClassName(systemClass));
            }
        };
        /**
         * 获取一个管理器中指定的系统实例。
         */
        SystemManager.prototype.getSystem = function (systemClass) {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.constructor === systemClass) {
                    return system;
                }
            }
            return null;
        };
        /**
         * @internal
         */
        SystemManager.prototype.update = function () {
            for (var _i = 0, _a = this._systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (system && system.enabled && !system._started) {
                    this._currentSystem = system;
                    system._started = true;
                    system.onStart && system.onStart();
                }
            }
            for (var _b = 0, _c = this._systems; _b < _c.length; _b++) {
                var system = _c[_b];
                if (system) {
                    this._currentSystem = system;
                    system.update();
                }
            }
            for (var _d = 0, _e = this._systems; _d < _e.length; _d++) {
                var system = _e[_d];
                if (system) {
                    this._currentSystem = system;
                    system.lateUpdate();
                }
            }
        };
        Object.defineProperty(SystemManager.prototype, "systems", {
            /**
             *
             */
            get: function () {
                return this._systems;
            },
            enumerable: true,
            configurable: true
        });
        SystemManager._instance = null;
        return SystemManager;
    }());
    paper.SystemManager = SystemManager;
    __reflect(SystemManager.prototype, "paper.SystemManager");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 场景管理器
     */
    var SceneManager = (function () {
        function SceneManager() {
            /**
             *
             */
            this.camerasScene = null;
            /**
             *
             */
            this.lightsScene = null;
            this._scenes = [];
            this._globalScene = null;
            this._editorScene = null;
            this._globalGameObject = null;
        }
        SceneManager.getInstance = function () {
            if (!this._instance) {
                this._instance = new SceneManager();
            }
            return this._instance;
        };
        /**
         * @internal
         */
        SceneManager.prototype._addScene = function (scene, isActive) {
            if (this._scenes.indexOf(scene) < 0) {
                if (isActive) {
                    this._scenes.unshift(scene);
                }
                else {
                    this._scenes.push(scene);
                }
            }
            else {
                console.debug("Add the scene again.", scene.name);
            }
        };
        /**
         * 创建一个空场景并激活
         */
        SceneManager.prototype.createScene = function (name, isActive) {
            if (isActive === void 0) { isActive = true; }
            var scene = new paper.Scene(isActive);
            scene.name = name;
            return scene;
        };
        /**
         * 加载场景
         * @param resourceName 资源名称
         */
        SceneManager.prototype.loadScene = function (resourceName, combineStaticObjects) {
            if (combineStaticObjects === void 0) { combineStaticObjects = true; }
            var rawScene = RES.getRes(resourceName);
            if (rawScene) {
                var scene = rawScene.createInstance();
                if (scene) {
                    if (combineStaticObjects && paper.Application.isPlaying) {
                        egret3d.combine(scene.gameObjects);
                    }
                    return scene;
                }
            }
            return null;
        };
        /**
         * 卸载指定场景。
         */
        SceneManager.prototype.unloadScene = function (scene) {
            if (scene === this._globalScene ||
                scene === this._editorScene) {
                console.warn("Cannot unload global scene.");
                return;
            }
            var index = this._scenes.indexOf(scene);
            if (index >= 0) {
                scene._destroy();
                this._scenes.splice(index, 1);
            }
        };
        /**
         * 卸载所有场景。
         */
        SceneManager.prototype.unloadAllScene = function (excludes) {
            var i = this._scenes.length;
            while (i--) {
                var scene = this._scenes[i];
                if (excludes && excludes.indexOf(scene) >= 0) {
                    continue;
                }
                this.unloadScene(scene);
            }
        };
        /**
         *
         */
        SceneManager.prototype.getSceneByName = function (name) {
            for (var _i = 0, _a = this._scenes; _i < _a.length; _i++) {
                var scene = _a[_i];
                if (scene.name === name) {
                    return scene;
                }
            }
            return null;
        };
        Object.defineProperty(SceneManager.prototype, "scenes", {
            /**
             *
             */
            get: function () {
                return this._scenes;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalScene", {
            /**
             *
             */
            get: function () {
                if (!this._globalScene) {
                    this._globalScene = this.createScene("global" /* Global */, false);
                    this._scenes.pop(); // Remove global scene from scenes.
                }
                return this._globalScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "activeScene", {
            /**
             * 当前激活的场景。
             */
            get: function () {
                if (this._scenes.length === 0) {
                    this.createScene("default");
                }
                return this._scenes[0];
            },
            set: function (value) {
                if (this._scenes.length <= 1 ||
                    this._scenes[0] === value ||
                    this._globalScene === value ||
                    this._editorScene === value // Cannot active editor scene.
                ) {
                    return;
                }
                var index = this._scenes.indexOf(value);
                if (index >= 0) {
                    this._scenes.splice(index, 1);
                    this._scenes.unshift(value);
                }
                else {
                    console.debug("Active scene error.", value.name);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "editorScene", {
            /**
             *
             */
            get: function () {
                if (!this._editorScene) {
                    this._editorScene = this.createScene("EditorOnly" /* EditorOnly */, false);
                    this._scenes.pop(); // Remove editor scene from scenes.
                }
                return this._editorScene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SceneManager.prototype, "globalGameObject", {
            /**
             *
             */
            get: function () {
                if (!this._globalGameObject) {
                    this._globalGameObject = paper.GameObject.create("global" /* Global */, "global" /* Global */, this.globalScene);
                    this._globalGameObject.dontDestroy = true;
                }
                return this._globalGameObject;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        SceneManager.prototype.getActiveScene = function () {
            return this.activeScene;
        };
        SceneManager._instance = null;
        return SceneManager;
    }());
    paper.SceneManager = SceneManager;
    __reflect(SceneManager.prototype, "paper.SceneManager");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpMat4_1 = new egret3d.Matrix();
    var Quaternion = (function () {
        function Quaternion(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Quaternion.create = function (x, y, z, w) {
            if (this._instances.length > 0) {
                return this._instances.pop().set(x, y, z, w);
            }
            return new Quaternion(x, y, z, w);
        };
        Quaternion.release = function (value) {
            if (this._instances.indexOf(value) >= 0) {
                return;
            }
            this._instances.push(value);
        };
        Quaternion.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Quaternion.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
            this.w = element[3];
        };
        Quaternion.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            this.w = value.w;
            return this;
        };
        Quaternion.prototype.clone = function () {
            var value = new Quaternion();
            value.copy(this);
            return value;
        };
        Quaternion.prototype.set = function (x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 1.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Quaternion.prototype.normalize = function () {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
                this.w /= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        Quaternion.prototype.inverse = function () {
            var ll = this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z;
            if (ll > 0.0) {
                var ill = 1.0 / ll;
                this.x = -this.x * ill;
                this.y = -this.y * ill;
                this.z = -this.z * ill;
                this.w = this.w * ill;
            }
            return this;
        };
        Quaternion.prototype.multiply = function (value) {
            var w1 = this.w, x1 = this.x, y1 = this.y, z1 = this.z;
            var w2 = value.w, x2 = value.x, y2 = value.y, z2 = value.z;
            this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            this.normalize();
            return this;
        };
        Quaternion.prototype.transformVector3 = function (value) {
            var x2 = value.x, y2 = value.y, z2 = value.z;
            var x1 = this.w * x2 + this.y * z2 - this.z * y2;
            var y1 = this.w * y2 - this.x * z2 + this.z * x2;
            var z1 = this.w * z2 + this.x * y2 - this.y * x2;
            var w1 = -this.x * x2 - this.y * y2 - this.z * z2;
            value.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
            value.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
            value.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
            return value;
        };
        /**
         * @deprecated
         */
        Quaternion.set = function (x, y, z, w, out) {
            out.x = x;
            out.y = y;
            out.z = z;
            out.w = w;
            return out;
        };
        Quaternion.getMagnitude = function (src) {
            return Math.sqrt(src.w * src.w + src.x * src.x + src.y * src.y + src.z * src.z);
        };
        Quaternion.fromYawPitchRoll = function (yaw, pitch, roll, out) {
            // Produces a quaternion from Euler angles in the z-y-x orientation (Tait-Bryan angles)
            var halfRoll = roll * 0.5;
            var halfPitch = pitch * 0.5;
            var halfYaw = yaw * 0.5;
            var sinRoll = Math.sin(halfRoll);
            var cosRoll = Math.cos(halfRoll);
            var sinPitch = Math.sin(halfPitch);
            var cosPitch = Math.cos(halfPitch);
            var sinYaw = Math.sin(halfYaw);
            var cosYaw = Math.cos(halfYaw);
            out.x = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);
            out.y = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);
            out.z = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);
            out.w = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);
            return out;
        };
        Quaternion.fromEulerAngles = function (ax, ay, az, out) {
            ax *= Math.PI / 180;
            ay *= Math.PI / 180;
            az *= Math.PI / 180;
            var halfX = ax * 0.5, halfY = ay * 0.5, halfZ = az * 0.5;
            var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
            var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
            var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
            out.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
            out.x = sinX * cosY * cosZ + cosX * sinY * sinZ;
            out.y = cosX * sinY * cosZ - sinX * cosY * sinZ;
            out.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
            return this.normalize(out);
        };
        Quaternion.fromAxisAngle = function (axis, angle, out) {
            angle *= Math.PI / 180.0;
            var halfAngle = angle * 0.5;
            var sin_a = Math.sin(halfAngle);
            out.w = Math.cos(halfAngle);
            out.x = axis.x * sin_a;
            out.y = axis.y * sin_a;
            out.z = axis.z * sin_a;
            this.normalize(out);
            return out;
        };
        Quaternion.fromMatrix = function (matrix, out) {
            var m00, m01, m02, m10, m11, m12, m20, m21, m22, tr, s, rs, lx, ly, lz;
            var m = matrix.rawData;
            // Cache matrix values for super-speed
            m00 = m[0];
            m01 = m[1];
            m02 = m[2];
            m10 = m[4];
            m11 = m[5];
            m12 = m[6];
            m20 = m[8];
            m21 = m[9];
            m22 = m[10];
            // Remove the scale from the matrix
            lx = 1 / Math.sqrt(m00 * m00 + m01 * m01 + m02 * m02);
            ly = 1 / Math.sqrt(m10 * m10 + m11 * m11 + m12 * m12);
            lz = 1 / Math.sqrt(m20 * m20 + m21 * m21 + m22 * m22);
            m00 *= lx;
            m01 *= lx;
            m02 *= lx;
            m10 *= ly;
            m11 *= ly;
            m12 *= ly;
            m20 *= lz;
            m21 *= lz;
            m22 *= lz;
            // http://www.cs.ucr.edu/~vbz/resources/quatut.pdf
            tr = m00 + m11 + m22;
            if (tr >= 0) {
                s = Math.sqrt(tr + 1);
                out.w = s * 0.5;
                s = 0.5 / s;
                out.x = (m12 - m21) * s;
                out.y = (m20 - m02) * s;
                out.z = (m01 - m10) * s;
            }
            else {
                if (m00 > m11) {
                    if (m00 > m22) {
                        // XDiagDomMatrix
                        rs = (m00 - (m11 + m22)) + 1;
                        rs = Math.sqrt(rs);
                        out.x = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m12 - m21) * rs;
                        out.y = (m01 + m10) * rs;
                        out.z = (m02 + m20) * rs;
                    }
                    else {
                        // ZDiagDomMatrix
                        rs = (m22 - (m00 + m11)) + 1;
                        rs = Math.sqrt(rs);
                        out.z = rs * 0.5;
                        rs = 0.5 / rs;
                        out.w = (m01 - m10) * rs;
                        out.x = (m20 + m02) * rs;
                        out.y = (m21 + m12) * rs;
                    }
                }
                else if (m11 > m22) {
                    // YDiagDomMatrix
                    rs = (m11 - (m22 + m00)) + 1;
                    rs = Math.sqrt(rs);
                    out.y = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m20 - m02) * rs;
                    out.z = (m12 + m21) * rs;
                    out.x = (m10 + m01) * rs;
                }
                else {
                    // ZDiagDomMatrix
                    rs = (m22 - (m00 + m11)) + 1;
                    rs = Math.sqrt(rs);
                    out.z = rs * 0.5;
                    rs = 0.5 / rs;
                    out.w = (m01 - m10) * rs;
                    out.x = (m20 + m02) * rs;
                    out.y = (m21 + m12) * rs;
                }
            }
            return out;
        };
        Quaternion.lookAt = function (pos, target, out) {
            var dir = helpVec3_1;
            egret3d.Vector3.subtract(target, pos, dir);
            egret3d.Vector3.normalize(dir);
            var dirxz = helpVec3_2;
            helpVec3_2.x = dir.x;
            helpVec3_2.y = 0;
            helpVec3_2.z = dir.z;
            egret3d.Vector3.normalize(dirxz);
            var yaw = Math.acos(dirxz.z);
            if (dirxz.x < 0) {
                yaw = -yaw;
            }
            var dirxz1 = helpVec3_3;
            helpVec3_3.x = dir.x;
            helpVec3_3.y = 0;
            helpVec3_3.z = dir.z;
            var v3length = egret3d.Vector3.getLength(dirxz1);
            if (v3length > 0.9999999999) {
                v3length = 1;
            }
            if (v3length < -0.999999999) {
                v3length = -1;
            }
            var pitch = Math.acos(v3length);
            if (dir.y > 0) {
                pitch = -pitch;
            }
            this.fromYawPitchRoll(yaw, pitch, 0, out);
            return this.normalize(out);
        };
        Quaternion.lookAtWithUp = function (pos, target, up, out) {
            var eye = pos;
            var zaxis = egret3d.Vector3.subtract(target, eye, helpVec3_1); // right-hand coordinates system
            egret3d.Vector3.normalize(zaxis);
            var xaxis = egret3d.Vector3.cross(up, zaxis, helpVec3_2);
            egret3d.Vector3.normalize(xaxis);
            var yaxis = egret3d.Vector3.cross(zaxis, xaxis, helpVec3_3);
            return Quaternion.fromMatrix(egret3d.Matrix.set(xaxis.x, yaxis.x, zaxis.x, 0, xaxis.y, yaxis.y, zaxis.y, 0, xaxis.z, yaxis.z, zaxis.z, 0, 0, 0, 0, 1, helpMat4_1), out);
        };
        Quaternion.multiply = function (q1, q2, out) {
            var w1 = q1.w, x1 = q1.x, y1 = q1.y, z1 = q1.z;
            var w2 = q2.w, x2 = q2.x, y2 = q2.y, z2 = q2.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.normalize(out);
            return out;
        };
        Quaternion.normalize = function (out) {
            var mag = 1 / Math.sqrt(out.x * out.x + out.y * out.y + out.z * out.z + out.w * out.w);
            out.x *= mag;
            out.y *= mag;
            out.z *= mag;
            out.w *= mag;
            return out;
        };
        Quaternion.copy = function (q, out) {
            out.x = q.x;
            out.y = q.y;
            out.z = q.z;
            out.w = q.w;
            return out;
        };
        Quaternion.inverse = function (q, out) {
            var norm = q.w * q.w + q.x * q.x + q.y * q.y + q.z * q.z;
            if (norm > 0.0) {
                var invNorm = 1.0 / norm;
                out.w = q.w * invNorm;
                out.x = -q.x * invNorm;
                out.y = -q.y * invNorm;
                out.z = -q.z * invNorm;
            }
            return out;
        };
        Quaternion.toEulerAngles = function (q, out) {
            var temp = 2.0 * (q.w * q.x - q.y * q.z);
            temp = egret3d.floatClamp(temp, -1.0, 1.0);
            out.x = Math.asin(temp);
            out.y = Math.atan2(2.0 * (q.w * q.y + q.z * q.x), 1.0 - 2.0 * (q.y * q.y + q.x * q.x));
            out.z = Math.atan2(2.0 * (q.w * q.z + q.y * q.x), 1.0 - 2.0 * (q.x * q.x + q.z * q.z));
            out.x /= Math.PI / 180;
            out.y /= Math.PI / 180;
            out.z /= Math.PI / 180;
            return out;
        };
        Quaternion.toMatrix = function (q, out) {
            var xy2 = 2.0 * q.x * q.y, xz2 = 2.0 * q.x * q.z, xw2 = 2.0 * q.x * q.w;
            var yz2 = 2.0 * q.y * q.z, yw2 = 2.0 * q.y * q.w, zw2 = 2.0 * q.z * q.w;
            var xx = q.x * q.x, yy = q.y * q.y, zz = q.z * q.z, ww = q.w * q.w;
            out.rawData[0] = xx - yy - zz + ww;
            out.rawData[4] = xy2 - zw2;
            out.rawData[8] = xz2 + yw2;
            out.rawData[12] = 0;
            out.rawData[1] = xy2 + zw2;
            out.rawData[5] = -xx + yy - zz + ww;
            out.rawData[9] = yz2 - xw2;
            out.rawData[13] = 0;
            out.rawData[2] = xz2 - yw2;
            out.rawData[6] = yz2 + xw2;
            out.rawData[10] = -xx - yy + zz + ww;
            out.rawData[14] = 0;
            out.rawData[3] = 0.0;
            out.rawData[7] = 0.0;
            out.rawData[11] = 0;
            out.rawData[15] = 1;
            return out;
        };
        Quaternion.toAxisAngle = function (q, axis) {
            var sqrLength = q.x * q.x + q.y * q.y + q.z * q.z;
            var angle = 0;
            if (sqrLength > 0.0) {
                angle = 2.0 * Math.acos(q.w);
                sqrLength = 1.0 / Math.sqrt(sqrLength);
                axis.x = q.x * sqrLength;
                axis.y = q.y * sqrLength;
                axis.z = q.z * sqrLength;
            }
            else {
                angle = 0;
                axis.x = 1.0;
                axis.y = 0;
                axis.z = 0;
            }
            angle /= Math.PI / 180.0;
            return angle;
        };
        Quaternion.transformVector3 = function (src, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            w1 = -src.x * x2 - src.y * y2 - src.z * z2;
            x1 = src.w * x2 + src.y * z2 - src.z * y2;
            y1 = src.w * y2 - src.x * z2 + src.z * x2;
            z1 = src.w * z2 + src.x * y2 - src.y * x2;
            out.x = -w1 * src.x + x1 * src.w - y1 * src.z + z1 * src.y;
            out.y = -w1 * src.y + x1 * src.z + y1 * src.w - z1 * src.x;
            out.z = -w1 * src.z - x1 * src.y + y1 * src.x + z1 * src.w;
            return out;
        };
        Quaternion.transformVector3ByQuaternionData = function (src, srcseek, vector, out) {
            var x1, y1, z1, w1;
            var x2 = vector.x, y2 = vector.y, z2 = vector.z;
            var srcx = src[srcseek];
            var srcy = src[srcseek + 1];
            var srcz = src[srcseek + 2];
            var srcw = src[srcseek + 3];
            w1 = -srcx * x2 - srcy * y2 - srcz * z2;
            x1 = srcw * x2 + srcy * z2 - srcz * y2;
            y1 = srcw * y2 - srcx * z2 + srcz * x2;
            z1 = srcw * z2 + srcx * y2 - srcy * x2;
            out.x = -w1 * srcx + x1 * srcw - y1 * srcz + z1 * srcy;
            out.y = -w1 * srcy + x1 * srcz + y1 * srcw - z1 * srcx;
            out.z = -w1 * srcz - x1 * srcy + y1 * srcx + z1 * srcw;
            return out;
        };
        Quaternion.multiplyByQuaternionData = function (srca, srcaseek, srcb, out) {
            var w1 = srca[srcaseek + 3], x1 = srca[srcaseek + 0], y1 = srca[srcaseek + 1], z1 = srca[srcaseek + 2];
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            out.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
            out.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
            out.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
            out.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            this.normalize(out);
            return out;
        };
        Quaternion.lerp = function (srca, srcb, out, t) {
            var w1 = srca.w, x1 = srca.x, y1 = srca.y, z1 = srca.z;
            var w2 = srcb.w, x2 = srcb.x, y2 = srcb.y, z2 = srcb.z;
            if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
                w2 = -w2;
                x2 = -x2;
                y2 = -y2;
                z2 = -z2;
            }
            out.w = w1 + t * (w2 - w1);
            out.x = x1 + t * (x2 - x1);
            out.y = y1 + t * (y2 - y1);
            out.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(out.w * out.w + out.x * out.x + out.y * out.y + out.z * out.z);
            out.w *= len;
            out.x *= len;
            out.y *= len;
            out.z *= len;
            return out;
        };
        Quaternion._instances = [];
        return Quaternion;
    }());
    egret3d.Quaternion = Quaternion;
    __reflect(Quaternion.prototype, "egret3d.Quaternion", ["egret3d.IVector4", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 矩形可序列化对象
     */
    var Rectangle = (function () {
        /**
         *
         */
        function Rectangle(x, y, w, h) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (w === void 0) { w = 0.0; }
            if (h === void 0) { h = 0.0; }
            this.x = x;
            this.y = y;
            this.w = w;
            this.h = h;
        }
        Rectangle.prototype.serialize = function () {
            return [this.x, this.y, this.w, this.h];
        };
        Rectangle.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.w = element[2];
            this.h = element[3];
        };
        return Rectangle;
    }());
    egret3d.Rectangle = Rectangle;
    __reflect(Rectangle.prototype, "egret3d.Rectangle", ["egret3d.IRectangle", "paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Color = (function () {
        function Color(r, g, b, a) {
            if (r === void 0) { r = 1.0; }
            if (g === void 0) { g = 1.0; }
            if (b === void 0) { b = 1.0; }
            if (a === void 0) { a = 1.0; }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
        }
        Color.prototype.serialize = function () {
            return [this.r, this.g, this.b, this.a];
        };
        Color.prototype.deserialize = function (element) {
            this.r = element[0];
            this.g = element[1];
            this.b = element[2];
            this.a = element[3];
        };
        Color.prototype.set = function (r, g, b, a) {
            if (r === void 0) { r = 1; }
            if (g === void 0) { g = 1; }
            if (b === void 0) { b = 1; }
            if (a === void 0) { a = 1; }
            this.r = r;
            this.g = g;
            this.b = b;
            this.a = a;
            return this;
        };
        Color.multiply = function (c1, c2, out) {
            out.r = c1.r * c2.r;
            out.g = c1.g * c2.g;
            out.b = c1.b * c2.b;
            out.a = c1.a * c2.a;
            return out;
        };
        Color.scale = function (c, scaler) {
            c.r = c.r * scaler;
            c.g = c.g * scaler;
            c.b = c.b * scaler;
            c.a = c.a * scaler;
            return c;
        };
        Color.copy = function (c, out) {
            out.r = c.r;
            out.g = c.g;
            out.b = c.b;
            out.a = c.a;
            return out;
        };
        Color.lerp = function (c1, c2, value, out) {
            out.a = value * (c2.a - c1.a) + c1.a;
            out.r = value * (c2.r - c1.r) + c1.r;
            out.g = value * (c2.g - c1.g) + c1.g;
            out.b = value * (c2.b - c1.b) + c1.b;
            return out;
        };
        return Color;
    }());
    egret3d.Color = Color;
    __reflect(Color.prototype, "egret3d.Color", ["paper.ISerializable"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var JointType;
        (function (JointType) {
            JointType[JointType["Spherical"] = OIMO.JointType.SPHERICAL] = "Spherical";
            JointType[JointType["Prismatic"] = OIMO.JointType.PRISMATIC] = "Prismatic";
            JointType[JointType["Hinge"] = OIMO.JointType.REVOLUTE] = "Hinge";
            JointType[JointType["Cylindrical"] = OIMO.JointType.CYLINDRICAL] = "Cylindrical";
            JointType[JointType["ConeTwist"] = OIMO.JointType.RAGDOLL] = "ConeTwist";
            JointType[JointType["Universal"] = OIMO.JointType.UNIVERSAL] = "Universal";
        })(JointType = oimo.JointType || (oimo.JointType = {}));
        /**
         *
         */
        var Joint = (function (_super) {
            __extends(Joint, _super);
            function Joint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._anchor = egret3d.Vector3.ZERO.clone();
                _this._values = new Float32Array([
                    0, 0,
                ]);
                _this._connectedBody = null;
                _this._rigidbody = null;
                _this._oimoJoint = null;
                return _this;
            }
            /**
             *
             */
            Joint.prototype.getAppliedForce = function (out) {
                out = out || new egret3d.Vector3();
                this._oimoJoint.getAppliedForceTo(out); // TODO
                return out;
            };
            /**
             *
             */
            Joint.prototype.getAppliedTorque = function (out) {
                out = out || new egret3d.Vector3();
                this._oimoJoint.getAppliedTorqueTo(out); // TODO
                return out;
            };
            Object.defineProperty(Joint.prototype, "collisionEnabled", {
                /**
                 *
                 */
                get: function () {
                    return this._values[0 /* CollisionEnabled */] > 0;
                },
                set: function (value) {
                    if (this.collisionEnabled === value) {
                        return;
                    }
                    this._values[0 /* CollisionEnabled */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        this._oimoJoint.setAllowCollision(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Joint.prototype, "useGlobalAnchor", {
                /**
                 *
                 */
                get: function () {
                    return this._values[1 /* UseGlobalAnchor */] > 0;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the isGlobalAnchor after the joint has been created.");
                    }
                    else {
                        this._values[1 /* UseGlobalAnchor */] = value ? 1 : 0;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Joint.prototype, "anchor", {
                /**
                 *
                 */
                get: function () {
                    return this._anchor;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the anchor after the joint has been created.");
                    }
                    else {
                        this._anchor.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Joint.prototype, "connectedRigidbody", {
                /**
                 *
                 */
                get: function () {
                    return this._connectedBody;
                },
                set: function (value) {
                    if (this._connectedBody === value) {
                        return;
                    }
                    if (this._oimoJoint) {
                        console.warn("Cannot change the connected rigidbody after the joint has been created.");
                    }
                    else {
                        this._connectedBody = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Joint.prototype, "rigidbody", {
                /**
                 *
                 */
                get: function () {
                    return this._rigidbody;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Joint.prototype, "oimoJoint", {
                /**
                 *
                 */
                get: function () {
                    if (!this._oimoJoint) {
                        this._oimoJoint = this._createJoint();
                    }
                    return this._oimoJoint;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Joint.prototype, "_anchor", void 0);
            __decorate([
                paper.serializedField
            ], Joint.prototype, "_values", void 0);
            __decorate([
                paper.serializedField
            ], Joint.prototype, "_connectedBody", void 0);
            return Joint;
        }(paper.BaseComponent));
        oimo.Joint = Joint;
        __reflect(Joint.prototype, "egret3d.oimo.Joint");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var EventDispatcher = (function () {
        function EventDispatcher() {
            this._eventMap = {};
        }
        EventDispatcher.prototype.addEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                list = this._eventMap[type] = [];
            }
            list.push({ listener: listener, thisObject: thisObject || this });
        };
        EventDispatcher.prototype.removeEventListener = function (type, listener, thisObject) {
            var list = this._eventMap[type];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                if (bin.listener == listener && bin.thisObject == (thisObject || this)) {
                    list.splice(i, 1);
                    break;
                }
            }
        };
        EventDispatcher.prototype.dispatchEvent = function (event) {
            event.target = this;
            this.notifyListener(event);
        };
        EventDispatcher.prototype.notifyListener = function (event) {
            var list = this._eventMap[event.type || event];
            if (!list) {
                return;
            }
            for (var i = 0, len = list.length; i < len; i++) {
                var bin = list[i];
                bin.listener.call(bin.thisObject, event);
            }
        };
        return EventDispatcher;
    }());
    egret3d.EventDispatcher = EventDispatcher;
    __reflect(EventDispatcher.prototype, "egret3d.EventDispatcher");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * light component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 灯光组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var BaseLight = (function (_super) {
        __extends(BaseLight, _super);
        function BaseLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.castShadows = false;
            /**
             *
             */
            _this.intensity = 2;
            /**
             *
             */
            _this.distance = 50;
            /**
             *
             */
            _this.decay = 2;
            /**
             *
             */
            _this.angle = Math.PI / 6;
            /**
             *
             */
            _this.penumbra = 0;
            /**
             * spot angel cos
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 聚光灯的开合角度cos值
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.spotAngelCos = 0.9;
            /**
             *
             */
            _this.shadowBias = 0.0003;
            /**
             *
             */
            _this.shadowRadius = 2;
            /**
             *
             */
            _this.shadowSize = 16;
            /**
             *
             */
            _this.shadowCameraNear = 0.1;
            /**
             *
             */
            _this.shadowCameraFar = 200;
            /**
             *
             */
            _this.color = new egret3d.Color(1.0, 1.0, 1.0, 1.0);
            _this.matrix = new egret3d.Matrix();
            return _this;
        }
        BaseLight.prototype._updateMatrix = function (camera) {
            // matrix * 0.5 + 0.5, after identity, range is 0 ~ 1 instead of -1 ~ 1
            var matrix = this.matrix;
            matrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
            camera.calcProjectMatrix(512 / 512, egret3d.helpMatrixA);
            egret3d.helpMatrixB.copy(this.gameObject.transform.getWorldMatrix()).inverse();
            egret3d.Matrix.multiply(matrix, egret3d.helpMatrixA, matrix);
            egret3d.Matrix.multiply(matrix, egret3d.helpMatrixB, matrix);
        };
        /**
         * @internal
         */
        BaseLight.prototype.update = function (camera, faceIndex) {
            camera.opvalue = 1.0;
            camera.backgroundColor.set(1.0, 1.0, 1.0, 1.0);
            camera.clearOption_Color = true;
            camera.clearOption_Depth = true;
            this._updateMatrix(camera);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], BaseLight.prototype, "castShadows", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "intensity", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "distance", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "decay", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "angle", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "penumbra", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "spotAngelCos", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowBias", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowRadius", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowSize", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraNear", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.NUMBER)
        ], BaseLight.prototype, "shadowCameraFar", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.COLOR)
        ], BaseLight.prototype, "color", void 0);
        return BaseLight;
    }(paper.BaseComponent));
    egret3d.BaseLight = BaseLight;
    __reflect(BaseLight.prototype, "egret3d.BaseLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 引擎启动入口
     */
    function runEgret(options) {
        if (options === void 0) { options = { antialias: false }; }
        // TODO WebAssembly load
        egret.Sound = egret.web ? egret.web.HtmlSound : egret['wxgame']['HtmlSound']; //TODO:Sound
        var requiredOptions = getOptions(options);
        var canvas = getMainCanvas();
        //TODO
        options.canvas = canvas;
        options.option = requiredOptions;
        options.webgl = canvas.getContext('webgl', options) || canvas.getContext("experimental-webgl", options);
        egret3d.WebGLCapabilities.webgl = options.webgl;
        egret3d.InputManager.init(canvas);
        egret3d.DefaultMeshes.init();
        egret3d.DefaultTextures.init();
        egret3d.DefaultShaders.init();
        // DefaultTechnique.init();
        egret3d.stage.init(canvas, requiredOptions);
        if (!options.systems) {
            options.systems = [
                egret3d.BeginSystem,
                paper.EnableSystem,
                paper.StartSystem,
                //
                egret3d.oimo.PhysicsSystem,
                //
                paper.UpdateSystem,
                //
                egret3d.AnimationSystem,
                //
                paper.LateUpdateSystem,
                //
                egret3d.MeshRendererSystem,
                egret3d.SkinnedMeshRendererSystem,
                egret3d.particle.ParticleSystem,
                egret3d.Egret2DRendererSystem,
                //
                egret3d.CameraSystem,
                egret3d.WebGLRenderSystem,
                //
                paper.DisableSystem,
                egret3d.EndSystem,
            ];
        }
        paper.Application.init(options);
    }
    egret3d.runEgret = runEgret;
    function getMainCanvas() {
        if (window.canvas) {
            return window.canvas;
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            var canvas = document.createElement("canvas");
            div.appendChild(canvas);
            return canvas;
        }
    }
    function getOptions(options) {
        if (window.canvas) {
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: options.contentWidth || 640,
                contentHeight: options.contentHeight || 1136
            };
        }
        else {
            var div = document.getElementsByClassName("egret-player")[0];
            return {
                antialias: options.antialias,
                antialiasSamples: 4,
                contentWidth: parseInt(div.getAttribute("data-content-width")),
                contentHeight: parseInt(div.getAttribute("data-content-height"))
            };
            ;
        }
    }
})(egret3d || (egret3d = {}));
window.paper = paper;
window.egret3d = egret3d;
var paper;
(function (paper) {
    /**
     * 单例组件基类。
     */
    var SingletonComponent = (function (_super) {
        __extends(SingletonComponent, _super);
        function SingletonComponent() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        SingletonComponent.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            if (!this.constructor.instance) {
                this.constructor.instance = this;
            }
            else {
                console.error("Cannot add singleton component again.", egret.getQualifiedClassName(this));
            }
        };
        SingletonComponent.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this.constructor.instance === this) {
                this.constructor.instance = null;
            }
        };
        /**
         *
         */
        SingletonComponent.instance = null;
        return SingletonComponent;
    }(paper.BaseComponent));
    paper.SingletonComponent = SingletonComponent;
    __reflect(SingletonComponent.prototype, "paper.SingletonComponent");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 事件派发器
         */
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.__z_e_listeners = {};
            }
            EventDispatcher.prototype.addEventListener = function (type, fun, thisObj, level) {
                if (level === void 0) { level = 0; }
                var list = this.__z_e_listeners[type];
                if (list === undefined) {
                    list = [];
                    this.__z_e_listeners[type] = list;
                }
                var item = {
                    func: fun,
                    context: thisObj,
                    level: level
                };
                list.push(item);
                list.sort(function (a, b) {
                    return b.level - a.level;
                });
            };
            EventDispatcher.prototype.removeEventListener = function (type, fun, thisObj) {
                var list = this.__z_e_listeners[type];
                if (list !== undefined) {
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var obj = list[i];
                        if (obj.func === fun && obj.context === thisObj) {
                            list.splice(i, 1);
                            return;
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatchEvent = function (event) {
                var list = this.__z_e_listeners[event.type];
                if (list !== undefined) {
                    list.forEach(function (ef) {
                        ef['___dirty___'] = true;
                    });
                    var size = list.length;
                    for (var i = 0; i < size; i++) {
                        var ef = list[i];
                        if (ef['___dirty___']) {
                            var fun = ef.func;
                            var context = ef.context;
                            if (context) {
                                fun.call(context, event);
                            }
                            else {
                                fun(event);
                            }
                            ef['___dirty___'] = false;
                        }
                        if (size != list.length) {
                            size = list.length;
                            i = 0;
                        }
                    }
                }
            };
            return EventDispatcher;
        }());
        editor.EventDispatcher = EventDispatcher;
        __reflect(EventDispatcher.prototype, "paper.editor.EventDispatcher", ["paper.editor.IEventDispatcher"]);
        /**
         * 事件
         */
        var BaseEvent = (function () {
            function BaseEvent(type, data) {
                this.type = type;
                this.data = data;
            }
            return BaseEvent;
        }());
        editor.BaseEvent = BaseEvent;
        __reflect(BaseEvent.prototype, "paper.editor.BaseEvent");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var BaseState = (function () {
            function BaseState() {
                this.autoClear = false;
                this.batchIndex = 0;
                this._isDone = false;
            }
            BaseState.prototype.undo = function () {
                if (this._isDone) {
                    this._isDone = false;
                    return true;
                }
                return false;
            };
            BaseState.prototype.redo = function () {
                if (this._isDone) {
                    return false;
                }
                this._isDone = true;
                return true;
            };
            Object.defineProperty(BaseState.prototype, "isDone", {
                get: function () {
                    return this._isDone;
                },
                set: function (value) {
                    this._isDone = value;
                },
                enumerable: true,
                configurable: true
            });
            BaseState.prototype.dispatchEditorModelEvent = function (type, data) {
                editor.Editor.editorModel.dispatchEvent(new editor.EditorModelEvent(type, data));
            };
            BaseState.prototype.serialize = function () {
                return null;
            };
            BaseState.prototype.deserialize = function (data) {
            };
            return BaseState;
        }());
        editor.BaseState = BaseState;
        __reflect(BaseState.prototype, "paper.editor.BaseState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        var RaycastInfo = (function () {
            function RaycastInfo() {
                this.position = new egret3d.Vector3();
                this.normal = new egret3d.Vector3();
            }
            /**
             * @internal
             */
            RaycastInfo.prototype.clean = function () {
                this.distance = 0.0;
                this.position.x = 0.0;
                this.position.y = 0.0;
                this.position.z = 0.0;
                this.normal.x = 0.0;
                this.normal.y = 0.0;
                this.normal.z = 0.0;
                this.rigidbody = null;
                this.collider = null;
            };
            return RaycastInfo;
        }());
        oimo.RaycastInfo = RaycastInfo;
        __reflect(RaycastInfo.prototype, "egret3d.oimo.RaycastInfo");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        OIMO.RigidBodyType.STATIC;
        /**
         *
         */
        var Rigidbody = (function (_super) {
            __extends(Rigidbody, _super);
            function Rigidbody() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._linearVelocity = egret3d.Vector3.ZERO.clone();
                _this._angularVelocity = egret3d.Vector3.ZERO.clone();
                /**
                 * [Type, Mass, LinearDamping, AngularDamping];
                 */
                _this._values = new Float32Array([
                    0 /* DYNAMIC */, 1.0, 1.0, 0.0, 0.0,
                ]);
                _this._oimoRigidbody = null;
                return _this;
            }
            Rigidbody_1 = Rigidbody;
            Rigidbody.prototype._createRigidbody = function () {
                var config = Rigidbody_1._config;
                config.type = this.type;
                config.linearDamping = this.linearDamping;
                config.angularDamping = this.angularDamping;
                config.linearVelocity = this._linearVelocity; // 
                config.angularVelocity = this._angularVelocity; // 
                var rigidbody = new OIMO.RigidBody(config);
                var position = this.gameObject.transform.getPosition();
                var quaternion = this.gameObject.transform.getRotation();
                var oimoTransform = oimo.PhysicsSystem._helpTransform;
                oimoTransform.setPosition(position);
                oimoTransform.setOrientation(quaternion);
                rigidbody.setTransform(oimoTransform);
                rigidbody.userData = this;
                // this._updateMass(rigidbody); // TODO update mesh and type.
                rigidbody.setGravityScale(this.gravityScale);
                return rigidbody;
            };
            /**
             * @internal
             */
            Rigidbody.prototype._updateMass = function (rigidbody) {
                var massData = Rigidbody_1._massData;
                rigidbody.getMassDataTo(massData); // Copy mass data from rigibody.
                massData.mass = this._values[1 /* Mass */]; // Update mass.
                rigidbody.setMassData(massData); // Set mass data to rigibody.
            };
            Rigidbody.prototype._addShapes = function () {
                for (var _i = 0, _a = this.gameObject.getComponents(oimo.Collider, true); _i < _a.length; _i++) {
                    var shape = _a[_i];
                    this.oimoRigidbody.addShape(shape.oimoShape);
                    // rigidbody._updateMass(rigidbody.oimoRigidbody);
                }
                // 子物体的transform？ TODO
            };
            /**
             *
             */
            Rigidbody.prototype.wakeUp = function () {
                if (this._oimoRigidbody) {
                    this._oimoRigidbody.wakeUp();
                }
            };
            /**
             *
             */
            Rigidbody.prototype.sleep = function () {
                if (this._oimoRigidbody) {
                    this._oimoRigidbody.sleep();
                }
            };
            /**
             *
             */
            Rigidbody.prototype.applyForce = function (force, positionInWorld) {
                if (!this._oimoRigidbody && this.oimoRigidbody.getNumShapes() === 0) {
                    this._addShapes();
                }
                if (this._oimoRigidbody.getNumShapes() === 0) {
                    console.warn("Can not add force to an empty rigidbody.");
                    return;
                }
                this.oimoRigidbody.applyForce(force, positionInWorld);
            };
            /**
             *
             */
            Rigidbody.prototype.applyForceToCenter = function (force) {
                if (!this._oimoRigidbody && this.oimoRigidbody.getNumShapes() === 0) {
                    this._addShapes();
                }
                if (this._oimoRigidbody.getNumShapes() === 0) {
                    console.warn("Can not add force to an empty rigidbody.");
                    return;
                }
                this.oimoRigidbody.applyForceToCenter(force);
            };
            /**
             *
             */
            Rigidbody.prototype.applyImpulse = function (impulse, position) {
                if (!this._oimoRigidbody && this.oimoRigidbody.getNumShapes() === 0) {
                    this._addShapes();
                }
                if (this._oimoRigidbody.getNumShapes() === 0) {
                    console.warn("Can not add impulse to an empty rigidbody.");
                    return;
                }
                this.oimoRigidbody.applyImpulse(impulse, position);
            };
            /**
             *
             */
            Rigidbody.prototype.applyTorque = function (torque) {
                if (!this._oimoRigidbody && this.oimoRigidbody.getNumShapes() === 0) {
                    this._addShapes();
                }
                if (this._oimoRigidbody.getNumShapes() === 0) {
                    console.warn("Can not add torque to an empty rigidbody.");
                    return;
                }
                this.oimoRigidbody.applyTorque(torque);
            };
            Object.defineProperty(Rigidbody.prototype, "isSleeping", {
                /**
                 *
                 */
                get: function () {
                    if (this._oimoRigidbody) {
                        return this._oimoRigidbody.isSleeping();
                    }
                    return false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "type", {
                /**
                 *
                 */
                get: function () {
                    return this._values[0 /* Type */];
                },
                set: function (value) {
                    if (this._values[0 /* Type */] === value) {
                        return;
                    }
                    this._values[0 /* Type */] = value;
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setType(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "mass", {
                /**
                 *
                 */
                get: function () {
                    return this._values[1 /* Mass */];
                },
                set: function (value) {
                    if (value <= 0.0) {
                        value = 0.01;
                    }
                    if (this._values[1 /* Mass */] === value) {
                        return;
                    }
                    this._values[1 /* Mass */] = value;
                    if (this._oimoRigidbody) {
                        this._updateMass(this._oimoRigidbody);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "gravityScale", {
                /**
                 *
                 */
                get: function () {
                    return this._values[2 /* GravityScale */];
                },
                set: function (value) {
                    if (this._values[2 /* GravityScale */] === value) {
                        return;
                    }
                    this._values[2 /* GravityScale */] = value;
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setGravityScale(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "linearDamping", {
                /**
                 *
                 */
                get: function () {
                    return this._values[3 /* LinearDamping */];
                },
                set: function (value) {
                    if (this._values[3 /* LinearDamping */] === value) {
                        return;
                    }
                    this._values[3 /* LinearDamping */] = value;
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setLinearDamping(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "angularDamping", {
                /**
                 *
                 */
                get: function () {
                    return this._values[4 /* AngularDamping */];
                },
                set: function (value) {
                    if (this._values[4 /* AngularDamping */] === value) {
                        return;
                    }
                    this._values[4 /* AngularDamping */] = value;
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setAngularDamping(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "linearVelocity", {
                /**
                 *
                 */
                get: function () {
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.getLinearVelocityTo(this._linearVelocity); //
                    }
                    return this._linearVelocity;
                },
                set: function (value) {
                    this._linearVelocity.copy(value);
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setLinearVelocity(this._linearVelocity); //
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "angularVelocity", {
                /**
                 *
                 */
                get: function () {
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.getAngularVelocityTo(this._angularVelocity); //
                    }
                    return this._angularVelocity;
                },
                set: function (value) {
                    this._angularVelocity.copy(value);
                    if (this._oimoRigidbody) {
                        this._oimoRigidbody.setAngularVelocity(this._angularVelocity); //
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Rigidbody.prototype, "oimoRigidbody", {
                /**
                 *
                 */
                get: function () {
                    if (!this._oimoRigidbody) {
                        this._oimoRigidbody = this._createRigidbody();
                    }
                    return this._oimoRigidbody;
                },
                enumerable: true,
                configurable: true
            });
            Rigidbody._config = new OIMO.RigidBodyConfig();
            Rigidbody._massData = new OIMO.MassData();
            __decorate([
                paper.serializedField
            ], Rigidbody.prototype, "_values", void 0);
            Rigidbody = Rigidbody_1 = __decorate([
                paper.disallowMultiple
            ], Rigidbody);
            return Rigidbody;
            var Rigidbody_1;
        }(paper.BaseComponent));
        oimo.Rigidbody = Rigidbody;
        __reflect(Rigidbody.prototype, "egret3d.oimo.Rigidbody");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var GeometryType;
        (function (GeometryType) {
            GeometryType[GeometryType["Box"] = OIMO.GeometryType.BOX] = "Box";
            GeometryType[GeometryType["Sphere"] = OIMO.GeometryType.SPHERE] = "Sphere";
            GeometryType[GeometryType["Cylinder"] = OIMO.GeometryType.CYLINDER] = "Cylinder";
            GeometryType[GeometryType["Cone"] = OIMO.GeometryType.CONE] = "Cone";
            GeometryType[GeometryType["Capsule"] = OIMO.GeometryType.CAPSULE] = "Capsule";
            GeometryType[GeometryType["ConvexHull"] = OIMO.GeometryType.CONVEX_HULL] = "ConvexHull";
        })(GeometryType = oimo.GeometryType || (oimo.GeometryType = {}));
        /**
         *
         */
        var Collider = (function (_super) {
            __extends(Collider, _super);
            function Collider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * [Type, Mass, LinearDamping, AngularDamping];
                 */
                _this._values = new Float32Array([
                    16777215 /* Everything */, 16777215 /* Everything */, OIMO.Setting.defaultFriction, OIMO.Setting.defaultRestitution, OIMO.Setting.defaultDensity,
                ]);
                _this._oimoShape = null;
                return _this;
            }
            Collider.prototype._updateConfig = function () {
                var config = Collider._config;
                config.collisionGroup = this.collisionGroup;
                config.collisionMask = this.collisionMask;
                config.friction = this.friction;
                config.restitution = this.restitution;
                config.density = this.density;
                return config;
            };
            Object.defineProperty(Collider.prototype, "collisionGroup", {
                /**
                 *
                 */
                get: function () {
                    return this._values[0 /* CollisionGroup */];
                },
                set: function (value) {
                    if (this._values[0 /* CollisionGroup */] === value) {
                        return;
                    }
                    this._values[0 /* CollisionGroup */] = value;
                    if (this._oimoShape) {
                        this._oimoShape.setCollisionGroup(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Collider.prototype, "collisionMask", {
                /**
                 *
                 */
                get: function () {
                    return this._values[1 /* CollisionMask */];
                },
                set: function (value) {
                    if (this._values[1 /* CollisionMask */] === value) {
                        return;
                    }
                    this._values[1 /* CollisionMask */] = value;
                    if (this._oimoShape) {
                        this._oimoShape.setCollisionMask(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Collider.prototype, "friction", {
                /**
                 *
                 */
                get: function () {
                    return this._values[2 /* Friction */];
                },
                set: function (value) {
                    if (this._values[2 /* Friction */] === value) {
                        return;
                    }
                    this._values[2 /* Friction */] = value;
                    if (this._oimoShape) {
                        this._oimoShape.setFriction(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Collider.prototype, "restitution", {
                /**
                 *
                 */
                get: function () {
                    return this._values[3 /* Restitution */];
                },
                set: function (value) {
                    if (this._values[3 /* Restitution */] === value) {
                        return;
                    }
                    this._values[3 /* Restitution */] = value;
                    if (this._oimoShape) {
                        this._oimoShape.setRestitution(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Collider.prototype, "density", {
                /**
                 *
                 */
                get: function () {
                    return this._values[4 /* Density */];
                },
                set: function (value) {
                    if (this._values[4 /* Density */] === value) {
                        return;
                    }
                    this._values[4 /* Density */] = value;
                    if (this._oimoShape) {
                        this._oimoShape.setDensity(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Collider.prototype, "oimoShape", {
                /**
                 *
                 */
                get: function () {
                    if (!this._oimoShape) {
                        this._oimoShape = this._createShape();
                    }
                    return this._oimoShape;
                },
                enumerable: true,
                configurable: true
            });
            Collider._config = new OIMO.ShapeConfig();
            __decorate([
                paper.serializedField
            ], Collider.prototype, "_values", void 0);
            return Collider;
        }(paper.BaseComponent));
        oimo.Collider = Collider;
        __reflect(Collider.prototype, "egret3d.oimo.Collider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Vector4 = (function () {
        function Vector4(x, y, z, w) {
            if (x === void 0) { x = 0.0; }
            if (y === void 0) { y = 0.0; }
            if (z === void 0) { z = 0.0; }
            if (w === void 0) { w = 0.0; }
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
        }
        Vector4.prototype.serialize = function () {
            return [this.x, this.y, this.z, this.w];
        };
        Vector4.prototype.deserialize = function (element) {
            this.x = element[0];
            this.y = element[1];
            this.z = element[2];
            this.w = element[3];
        };
        Vector4.prototype.copy = function (value) {
            this.x = value.x;
            this.y = value.y;
            this.z = value.z;
            this.w = value.w;
            return this;
        };
        Vector4.prototype.clone = function () {
            var value = new Vector4();
            value.copy(this);
            return value;
        };
        Vector4.prototype.set = function (x, y, z, w) {
            this.x = x;
            this.y = y;
            this.z = z;
            this.w = w;
            return this;
        };
        Vector4.prototype.normalize = function () {
            var l = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
            if (l > Number.MIN_VALUE) {
                this.x /= l;
                this.y /= l;
                this.z /= l;
                this.w /= l;
            }
            else {
                this.x = 0.0;
                this.y = 0.0;
                this.z = 0.0;
                this.w = 1.0;
            }
            return this;
        };
        return Vector4;
    }());
    egret3d.Vector4 = Vector4;
    __reflect(Vector4.prototype, "egret3d.Vector4", ["egret3d.IVector4", "paper.ISerializable"]);
    egret3d.helpVector4A = new Vector4();
    egret3d.helpVector4B = new Vector4();
    egret3d.helpVector4C = new Vector4();
    egret3d.helpVector4D = new Vector4();
    egret3d.helpVector4E = new Vector4();
    egret3d.helpVector4F = new Vector4();
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var UpdateSystem = (function (_super) {
        __extends(UpdateSystem, _super);
        function UpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        UpdateSystem.prototype.onUpdate = function (deltaTime) {
            var components = this._groups[0].components;
            if (this._isEditorUpdate()) {
                for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
                    var component = components_1[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_2 = components; _a < components_2.length; _a++) {
                    var component = components_2[_a];
                    if (component) {
                        component.onUpdate && component.onUpdate(deltaTime);
                    }
                }
            }
        };
        return UpdateSystem;
    }(paper.BaseSystem));
    paper.UpdateSystem = UpdateSystem;
    __reflect(UpdateSystem.prototype, "paper.UpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var LateUpdateSystem = (function (_super) {
        __extends(LateUpdateSystem, _super);
        function LateUpdateSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._laterCalls = [];
            return _this;
        }
        LateUpdateSystem.prototype.onUpdate = function (deltaTime) {
            // Update behaviours.
            var components = this._groups[0].components;
            if (this._isEditorUpdate()) {
                for (var _i = 0, components_3 = components; _i < components_3.length; _i++) {
                    var component = components_3[_i];
                    if (component && component.constructor.executeInEditMode) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            else {
                for (var _a = 0, components_4 = components; _a < components_4.length; _a++) {
                    var component = components_4[_a];
                    if (component) {
                        component.onLateUpdate && component.onLateUpdate(deltaTime);
                    }
                }
            }
            //
            egret.ticker.update(); // TODO 帧频
            //
            if (this._laterCalls.length > 0) {
                for (var _b = 0, _c = this._laterCalls; _b < _c.length; _b++) {
                    var callback = _c[_b];
                    callback();
                }
                this._laterCalls.length = 0;
            }
        };
        /**
         *
         */
        LateUpdateSystem.prototype.callLater = function (callback) {
            this._laterCalls.push(callback);
        };
        return LateUpdateSystem;
    }(paper.BaseSystem));
    paper.LateUpdateSystem = LateUpdateSystem;
    __reflect(LateUpdateSystem.prototype, "paper.LateUpdateSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var DisableSystem = (function (_super) {
        __extends(DisableSystem, _super);
        function DisableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            _this._bufferedComponents = [];
            _this._bufferedGameObjects = [];
            _this._contactColliders = _this._globalGameObject.getOrAddComponent(paper.ContactColliders);
            return _this;
        }
        DisableSystem.prototype.onRemoveComponent = function (component) {
            if (!component) {
                return;
            }
            if (this._isEditorUpdate() &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component.onDisable && component.onDisable();
        };
        DisableSystem.prototype.onUpdate = function () {
            //
            for (var _i = 0, _a = this._bufferedComponents; _i < _a.length; _i++) {
                var component = _a[_i];
                component.uninitialize();
            }
            this._bufferedComponents.length = 0;
            this._bufferedGameObjects.length = 0;
            //
            var begin = this._contactColliders.begin;
            var stay = this._contactColliders.stay;
            var end = this._contactColliders.end;
            if (begin.length > 0) {
                for (var _b = 0, begin_1 = begin; _b < begin_1.length; _b++) {
                    var contact = begin_1[_b];
                    stay.push(contact);
                }
                begin.length = 0;
            }
            if (end.length > 0) {
                for (var _c = 0, end_1 = end; _c < end_1.length; _c++) {
                    var contact = end_1[_c];
                    var index = stay.indexOf(contact);
                    if (index >= 0) {
                        stay.splice(index, 1);
                    }
                }
                end.length = 0;
            }
            if (stay.length > 0) {
            }
        };
        /**
         * @internal
         */
        DisableSystem.prototype.bufferComponent = function (component) {
            if (this._bufferedComponents.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        /**
         * @internal
         */
        DisableSystem.prototype.bufferGameObject = function (gameObject) {
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            this._bufferedGameObjects.push(gameObject);
        };
        return DisableSystem;
    }(paper.BaseSystem));
    paper.DisableSystem = DisableSystem;
    __reflect(DisableSystem.prototype, "paper.DisableSystem");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 可以挂载Component的实体类。
     */
    var GameObject = (function (_super) {
        __extends(GameObject, _super);
        /**
         * @deprecated
         */
        function GameObject(name, tag, scene) {
            if (name === void 0) { name = "NoName"; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var _this = _super.call(this) || this;
            /**
             * 是否是静态，启用这个属性可以提升性能
             */
            _this.isStatic = false;
            /**
             *
             */
            _this.hideFlags = 0 /* None */;
            /**
             * 层级
             */
            _this.layer = 2 /* Default */;
            /**
             * 名称
             */
            _this.name = "";
            /**
             * 标签
             */
            _this.tag = "";
            _this.assetID = paper.createAssetID();
            /**
             * 预制体
             */
            _this.prefab = null;
            /**
             * 变换组件
             */
            _this.transform = null;
            /**
             *
             */
            _this.renderer = null;
            /**
             * 额外数据，仅保存在编辑器环境，项目发布该数据将被移除。
             */
            _this.extras = {};
            _this._activeSelf = true;
            /**
             * @internal
             */
            _this._activeInHierarchy = true;
            /**
             * @internal
             */
            _this._activeDirty = true;
            _this._components = [];
            _this._scene = null;
            _this.name = name;
            _this.tag = tag;
            //
            _this._addToScene(scene || paper.Application.sceneManager.activeScene);
            //
            _this.addComponent(egret3d.Transform);
            return _this;
        }
        /**
         * 创建 GameObject，并添加到当前场景中。
         */
        GameObject.create = function (name, tag, scene) {
            if (name === void 0) { name = "NoName"; }
            if (tag === void 0) { tag = "" /* Untagged */; }
            if (scene === void 0) { scene = null; }
            var gameObect = new GameObject(name, tag, scene);
            // gameObect.addComponent(egret3d.Transform);
            // gameObect._addToScene(Application.sceneManager.activeScene);
            return gameObect;
        };
        GameObject.prototype._destroy = function () {
            var destroySystem = paper.Application.systemManager.getSystem(paper.DisableSystem);
            if (destroySystem) {
                destroySystem.bufferGameObject(this);
            }
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                child.gameObject._destroy();
            }
            for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                var component = _c[_b];
                if (!component) {
                    continue;
                }
                this._removeComponent(component, null);
            }
            this.transform = null;
            this.renderer = null;
            this._components.length = 0;
            this._scene._removeGameObject(this);
            this._scene = null;
        };
        GameObject.prototype._addToScene = function (value) {
            if (this._scene) {
                this._scene._removeGameObject(this);
            }
            this._scene = value;
            this._scene._addGameObject(this);
        };
        GameObject.prototype._canRemoveComponent = function (value) {
            if (value === this.transform) {
                console.warn("Cannot remove the transform component from a game object.");
                return false;
            }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    component = component.components[0]; // 只检查第一个。
                }
                var requireComponents = component.constructor.requireComponents;
                if (requireComponents && requireComponents.indexOf(value.constructor) >= 0) {
                    console.warn("Cannot remove the " + egret.getQualifiedClassName(value) + " component from the game object (" + this.path + "), because it is required from the " + egret.getQualifiedClassName(component) + " component.");
                    return false;
                }
            }
            return true;
        };
        GameObject.prototype._removeComponent = function (value, groupComponent) {
            value.enabled = false;
            value.gameObject = null;
            if (value === this.renderer) {
                this.renderer = null;
            }
            var destroySystem = paper.Application.systemManager.getSystem(paper.DisableSystem);
            if (destroySystem) {
                destroySystem.bufferComponent(value);
            }
            if (groupComponent) {
                groupComponent._removeComponent(value);
                if (groupComponent.components.length === 0) {
                    this._removeComponent(groupComponent, null);
                }
            }
            else if (value.constructor === paper.GroupComponent) {
                groupComponent = value;
                delete this._components[groupComponent.componentIndex];
                for (var _i = 0, _a = groupComponent.components; _i < _a.length; _i++) {
                    var componentInGroup = _a[_i];
                    this._removeComponent(componentInGroup, groupComponent);
                }
            }
            else {
                delete this._components[value.constructor.index];
            }
        };
        GameObject.prototype._getComponentsInChildren = function (componentClass, child, components, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            for (var _i = 0, _a = child._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (!component) {
                    continue;
                }
                if (component.constructor === paper.GroupComponent) {
                    var groupComponent = component;
                    if (isExtends ? groupComponent.components[0] instanceof componentClass : groupComponent.componentClass === componentClass) {
                        for (var _b = 0, _c = groupComponent.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                }
                else if (isExtends ? component instanceof componentClass : component.constructor === componentClass) {
                    components.push(component);
                }
            }
            for (var _d = 0, _e = child.transform.children; _d < _e.length; _d++) {
                var childOfChild = _e[_d];
                this._getComponentsInChildren(componentClass, childOfChild.gameObject, components, isExtends);
            }
        };
        GameObject.prototype._getComponent = function (componentClass) {
            var componentIndex = componentClass.index;
            return componentIndex < 0 ? null : this._components[componentIndex];
        };
        /**
         * @internal
         */
        GameObject.prototype._activeInHierarchyDirty = function (prevActive) {
            this._activeDirty = true;
            var currentActive = this.activeInHierarchy;
            if (currentActive !== prevActive) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.enabled) {
                        paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, component);
                    }
                    if (component.constructor === paper.GroupComponent) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            if (componentInGroup.enabled) {
                                paper.EventPool.dispatchEvent(currentActive ? "__enabled__" /* Enabled */ : "__disabled__" /* Disabled */, componentInGroup);
                            }
                        }
                    }
                }
            }
            for (var _d = 0, _e = this.transform.children; _d < _e.length; _d++) {
                var child = _e[_d];
                child.gameObject._activeInHierarchyDirty(prevActive);
            }
        };
        /**
         *
         */
        GameObject.prototype.destroy = function () {
            if (this.isDestroyed) {
                console.warn("The game object (" + this.path + ") has been destroyed.");
                return;
            }
            if (this === paper.Application.sceneManager.globalGameObject) {
                console.warn("Cannot destroy global game object.");
                return;
            }
            var parent = this.transform.parent;
            if (parent) {
                parent._children.splice(parent._children.indexOf(this.transform), 1);
            }
            this._destroy();
        };
        /**
         * 添加组件。
         */
        GameObject.prototype.addComponent = function (componentClass, config) {
            paper.BaseComponent.register(componentClass);
            var componentIndex = componentClass.index;
            var existedComponent = this._components[componentIndex];
            // disallowMultipleComponents.
            if (componentClass.disallowMultiple && existedComponent) {
                console.warn("Cannot add the " + egret.getQualifiedClassName(componentClass) + " component to the game object (" + this.path + ") again.");
                return existedComponent;
            }
            // requireComponents.
            if (componentClass.requireComponents) {
                for (var _i = 0, _a = componentClass.requireComponents; _i < _a.length; _i++) {
                    var requireComponentClass = _a[_i];
                    this.getOrAddComponent(requireComponentClass);
                }
            }
            // Linked reference.
            var component = paper.BaseComponent.create(componentClass, this);
            if (componentClass === egret3d.Transform) {
                this.transform = component;
            }
            else if (component instanceof paper.BaseRenderer) {
                this.renderer = component;
            }
            // Add component.
            if (existedComponent) {
                if (existedComponent.constructor === paper.GroupComponent) {
                    existedComponent._addComponent(component);
                }
                else {
                    var groupComponent = paper.BaseComponent.create(paper.GroupComponent, this);
                    groupComponent.initialize();
                    groupComponent.componentIndex = componentIndex;
                    groupComponent.componentClass = componentClass;
                    groupComponent._addComponent(existedComponent);
                    groupComponent._addComponent(component);
                    this._components[componentIndex] = groupComponent;
                }
            }
            else {
                this._components[componentIndex] = component;
            }
            if (config) {
                component.initialize(config);
            }
            else {
                component.initialize();
            }
            if (component.isActiveAndEnabled) {
                paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
            }
            return component;
        };
        /**
         * 移除组件。
         */
        GameObject.prototype.removeComponent = function (componentInstanceOrClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentInstanceOrClass instanceof paper.BaseComponent) {
                if (!this._canRemoveComponent(componentInstanceOrClass)) {
                    return;
                }
                this._removeComponent(componentInstanceOrClass, null);
            }
            else if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    var groupComponent = null;
                    if (component.constructor === paper.GroupComponent) {
                        groupComponent = component;
                        component = groupComponent.components[0];
                    }
                    if (groupComponent) {
                        if (!(groupComponent.components[0] instanceof componentInstanceOrClass) ||
                            (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0]))) {
                            continue;
                        }
                    }
                    else if (!(component instanceof componentInstanceOrClass) ||
                        !this._canRemoveComponent(component)) {
                        continue;
                    }
                    this._removeComponent(component, groupComponent);
                }
            }
            else {
                var component = this._getComponent(componentInstanceOrClass);
                if (!component) {
                    return;
                }
                var groupComponent = null;
                if (component.constructor === paper.GroupComponent) {
                    groupComponent = component;
                    component = groupComponent.components[0];
                }
                if (groupComponent) {
                    if (groupComponent.components.length === 1 && !this._canRemoveComponent(groupComponent.components[0])) {
                        return;
                    }
                }
                else if (!this._canRemoveComponent(component)) {
                    return;
                }
                this._removeComponent(component, groupComponent);
            }
        };
        /**
         * 移除所有组件。
         */
        GameObject.prototype.removeAllComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (componentClass) {
                if (isExtends) {
                    for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                        var component = _a[_i];
                        if (!component) {
                            continue;
                        }
                        if (component.constructor === paper.GroupComponent) {
                            var groupComponent = component;
                            if (!(groupComponent.components[0] instanceof componentClass) ||
                                !this._canRemoveComponent(groupComponent.components[0])) {
                                continue;
                            }
                        }
                        else if (!this._canRemoveComponent(component)) {
                            continue;
                        }
                        this._removeComponent(component, null);
                    }
                }
                else {
                    var component = this._getComponent(componentClass);
                    if (!component) {
                        return;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (!this._canRemoveComponent(groupComponent.components[0])) {
                            return;
                        }
                    }
                    else if (!this._canRemoveComponent(component)) {
                        return;
                    }
                    this._removeComponent(component, null);
                }
            }
            else {
                for (var _b = 0, _c = this._components; _b < _c.length; _b++) {
                    var component = _c[_b];
                    if (!component || component.constructor === egret3d.Transform) {
                        continue;
                    }
                    this._removeComponent(component, null);
                }
            }
        };
        /**
         * 获取组件。
         */
        GameObject.prototype.getComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent) {
                        var groupComponent = component;
                        if (groupComponent.components[0] instanceof componentClass) {
                            return groupComponent.components[0];
                        }
                    }
                    else if (component instanceof componentClass) {
                        return component;
                    }
                }
                return null;
            }
            var componentIndex = componentClass.index;
            return componentIndex < 0 ? null : this._components[componentIndex] || null;
        };
        /**
         *
         */
        GameObject.prototype.getComponents = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            if (isExtends) {
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (!component) {
                        continue;
                    }
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _b = 0, _c = component.components; _b < _c.length; _b++) {
                            var componentInGroup = _c[_b];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            else {
                var component = this._getComponent(componentClass);
                if (component) {
                    if (component.constructor === paper.GroupComponent && component.components[0] instanceof componentClass) {
                        for (var _d = 0, _e = component.components; _d < _e.length; _d++) {
                            var componentInGroup = _e[_d];
                            components.push(componentInGroup);
                        }
                    }
                    else if (component instanceof componentClass) {
                        components.push(component);
                    }
                }
            }
            return components;
        };
        /**
         * 搜索自己和父节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentInParent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var result = null;
            var parent = this.transform.parent;
            while (!result && parent) {
                result = parent.gameObject.getComponent(componentClass, isExtends); // 
                parent = parent.parent;
            }
            return result;
        };
        /**
         * 搜索自己和子节点中所有特定类型的组件
         */
        GameObject.prototype.getComponentsInChildren = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            var components = [];
            this._getComponentsInChildren(componentClass, this, components, isExtends);
            return components;
        };
        /**
         * 获取组件，如果未添加该组件，则添加该组件。
         */
        GameObject.prototype.getOrAddComponent = function (componentClass, isExtends) {
            if (isExtends === void 0) { isExtends = false; }
            return this.getComponent(componentClass, isExtends) || this.addComponent(componentClass, isExtends);
        };
        /**
         * 针对同级的组件发送消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                var component = _a[_i];
                if (component && component.isActiveAndEnabled && component.constructor instanceof paper.Behaviour) {
                    if (methodName in component) {
                        component[methodName](parameter);
                    }
                    else if (requireReceiver) {
                        console.warn(this.name, egret.getQualifiedClassName(component), methodName); // TODO
                    }
                }
            }
        };
        /**
         * 针对直接父级发送消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.sendMessageUpwards = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            //
            var parent = this.transform.parent;
            if (parent && parent.gameObject.activeInHierarchy) {
                parent.gameObject.sendMessage(methodName, parameter, requireReceiver);
            }
        };
        /**
         * 群发消息
         * @param methodName
         * @param parameter
         */
        GameObject.prototype.broadcastMessage = function (methodName, parameter, requireReceiver) {
            if (requireReceiver === void 0) { requireReceiver = true; }
            this.sendMessage(methodName, parameter, requireReceiver);
            for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child.gameObject.activeInHierarchy) {
                    child.gameObject.broadcastMessage(methodName, parameter, requireReceiver);
                }
            }
        };
        Object.defineProperty(GameObject.prototype, "isDestroyed", {
            /**
             *
             */
            get: function () {
                return !this._scene;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "dontDestroy", {
            /**
             *
             */
            get: function () {
                return this._scene === paper.Application.sceneManager.globalScene;
            },
            set: function (value) {
                if (this.dontDestroy === value) {
                    return;
                }
                for (var _i = 0, _a = this.transform.children; _i < _a.length; _i++) {
                    var child = _a[_i];
                    child.gameObject.dontDestroy = value;
                }
                if (value) {
                    this._addToScene(paper.Application.sceneManager.globalScene);
                }
                else {
                    if (this === paper.Application.sceneManager.globalGameObject) {
                        console.warn("Cannot change the `dontDestroy` value of the global game object.", this.name, this.uuid);
                        return;
                    }
                    this._addToScene(paper.Application.sceneManager.activeScene);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeSelf", {
            /**
             * 当前GameObject对象自身激活状态
             */
            get: function () {
                return this._activeSelf;
            },
            set: function (value) {
                if (this._activeSelf === value) {
                    return;
                }
                var parent = this.transform.parent;
                if (!parent || parent.gameObject.activeInHierarchy) {
                    var prevActive = this._activeSelf;
                    this._activeSelf = value;
                    this._activeInHierarchyDirty(prevActive);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "activeInHierarchy", {
            /**
             * 获取当前GameObject对象在场景中激活状态。
             * 如果当前对象父级的activeSelf为false，那么当前GameObject对象在场景中为禁用状态。
             */
            get: function () {
                if (this._activeDirty) {
                    var parent_1 = this.transform.parent;
                    if (!parent_1 || parent_1.gameObject.activeInHierarchy) {
                        this._activeInHierarchy = this._activeSelf;
                    }
                    else {
                        this._activeInHierarchy = false;
                    }
                    this._activeDirty = false;
                }
                return this._activeInHierarchy;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "path", {
            get: function () {
                var path = this.name;
                if (this.transform) {
                    var parent_2 = this.transform.parent;
                    while (parent_2) {
                        path = parent_2.gameObject.name + "/" + path;
                        parent_2 = parent_2.parent;
                    }
                    return this._scene.name + "/" + path;
                }
                return path;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "components", {
            /**
             * 组件列表
             */
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(GameObject.prototype, "scene", {
            /**
             * 获取物体所在场景实例。
             */
            get: function () {
                return this._scene;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         * @see paper.Scene#find()
         */
        GameObject.find = function (name, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).find(name);
        };
        /**
         * @deprecated
         * @see paper.Scene#findWithTag()
         */
        GameObject.findWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findWithTag(tag);
        };
        /**
         * @deprecated
         * @see paper.Scene#findGameObjectsWithTag()
         */
        GameObject.findGameObjectsWithTag = function (tag, scene) {
            if (scene === void 0) { scene = null; }
            return (scene || paper.Application.sceneManager.activeScene).findGameObjectsWithTag(tag);
        };
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.CHECKBOX)
        ], GameObject.prototype, "isStatic", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "hideFlags", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore // TODO remove
        ], GameObject.prototype, "layer", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.TEXT)
        ], GameObject.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "tag", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "assetID", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "prefab", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "extras", void 0);
        __decorate([
            paper.serializedField
        ], GameObject.prototype, "_activeSelf", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], GameObject.prototype, "components", null);
        return GameObject;
    }(paper.SerializableObject));
    paper.GameObject = GameObject;
    __reflect(GameObject.prototype, "paper.GameObject");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var VERSION = 2;
    var VERSIONS = [VERSION];
    var KEY_GAMEOBJECTS = "gameObjects";
    var KEY_COMPONENTS = "components";
    var KEY_CHILDREN = "children";
    var KEY_SERIALIZE = "serialize";
    var _serializeds = [];
    var _serializeData = null;
    /**
     * 序列化场景，实体或组件。
     */
    function serialize(source) {
        if (_serializeData) {
            console.debug("The deserialization is not complete.");
        }
        _serializeData = { version: VERSION, assets: [], objects: [], components: [] };
        _serializeObject(source);
        _serializeds.length = 0;
        var serializeData = _serializeData;
        _serializeData = null;
        return serializeData;
    }
    paper.serialize = serialize;
    /**
     * 创建指定资源的引用。
     */
    function createAssetReference(source) {
        if (!source.name) {
            return { asset: -1 };
        }
        if (_serializeData.assets) {
            var index = _serializeData.assets.indexOf(source.name);
            if (index < 0) {
                index = _serializeData.assets.length;
                _serializeData.assets.push(source.name);
            }
            return { asset: index };
        }
        return { asset: -1 };
    }
    paper.createAssetReference = createAssetReference;
    /**
     * 创建指定对象的引用。
     */
    function createReference(source, isOnlyUUID) {
        if (isOnlyUUID) {
            return { uuid: source.uuid };
        }
        var className = egret.getQualifiedClassName(source);
        return { uuid: source.uuid, class: _findClassCode(className) || className };
    }
    paper.createReference = createReference;
    /**
     * 创建指定对象的结构体。
     */
    function createStruct(source) {
        var className = egret.getQualifiedClassName(source);
        return { class: _findClassCode(className) || className };
    }
    paper.createStruct = createStruct;
    function _getTypesFromPrototype(classPrototype, typeKey, types) {
        if (types === void 0) { types = null; }
        if (typeKey in classPrototype) {
            types = types || [];
            for (var _i = 0, _a = classPrototype[typeKey]; _i < _a.length; _i++) {
                var type = _a[_i];
                types.push(type);
            }
        }
        if (classPrototype.__proto__) {
            _getTypesFromPrototype(classPrototype.__proto__, typeKey, types);
        }
        return types;
    }
    function _findClassCode(name) {
        for (var key in paper.serializeClassMap) {
            if (paper.serializeClassMap[key] === name) {
                return key;
            }
        }
        return "";
    }
    function _serializeObject(source, isStruct) {
        if (isStruct === void 0) { isStruct = false; }
        if (_serializeds.indexOf(source.uuid) >= 0) {
            return createReference(source, true);
        }
        var classPrototype = source.constructor.prototype;
        var hasCustomSerialize = classPrototype.hasOwnProperty(KEY_SERIALIZE);
        var target = hasCustomSerialize ?
            classPrototype[KEY_SERIALIZE].apply(source) :
            (isStruct ? createStruct(source) : createReference(source, false));
        if (!isStruct) {
            _serializeds.push(source.uuid);
            if (source instanceof paper.BaseComponent) {
                if (_serializeData.components) {
                    _serializeData.components.push(target);
                }
            }
            else {
                if (_serializeData.objects) {
                    _serializeData.objects.push(target);
                }
            }
        }
        if (!hasCustomSerialize) {
            var serializedKeys = _getTypesFromPrototype(classPrototype, "__serialized" /* Serialized */);
            if (serializedKeys && serializedKeys.length > 0) {
                for (var _i = 0, serializedKeys_1 = serializedKeys; _i < serializedKeys_1.length; _i++) {
                    var key = serializedKeys_1[_i];
                    target[key] = _serializeChild(source[key], source, key);
                }
            }
        }
        return target;
    }
    function _serializeChild(source, parent, key) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (Array.isArray(source) || ArrayBuffer.isView(source)) {
                    var target = [];
                    for (var _i = 0, _a = source; _i < _a.length; _i++) {
                        var element = _a[_i];
                        target.push(_serializeChild(element, parent, key));
                    }
                    return target;
                }
                if (source.constructor === Object) {
                    var target = {};
                    for (var k in source) {
                        target[k] = _serializeChild(source[k], parent, key);
                    }
                    return target;
                }
                // TODO es6
                if (source instanceof paper.Asset) {
                    return createAssetReference(source);
                }
                if (source.constructor === paper.Scene || source.constructor === paper.GameObject || source instanceof paper.BaseComponent) {
                    if (parent) {
                        if (source.constructor === paper.Scene) {
                            return null;
                        }
                        if (parent.constructor === paper.Scene) {
                            if (key === KEY_GAMEOBJECTS) {
                                _serializeObject(source);
                                return createReference(source, true);
                            }
                        }
                        else if (parent.constructor === paper.GameObject) {
                            if (key === KEY_COMPONENTS) {
                                _serializeObject(source);
                                return createReference(source, true);
                            }
                        }
                        else if (parent.constructor === egret3d.Transform) {
                            if (key === KEY_CHILDREN) {
                                _serializeObject(source.gameObject);
                                return createReference(source, true);
                            }
                        }
                    }
                    return createReference(source, false);
                }
                return _serializeObject(source, true); // Other class.
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        var _attributes = [
            "POSITION" /* POSITION */,
            "COLOR_0" /* COLOR_0 */,
        ];
        var _raycastInfo = new oimo.RaycastInfo();
        /**
         *
         */
        var RayTester = (function (_super) {
            __extends(RayTester, _super);
            function RayTester() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.distance = 10.0;
                _this.collisionMask = 16777215 /* Everything */;
                _this._hitted = false;
                return _this;
            }
            RayTester.prototype.onStart = function () {
                this._meshFilter = this.gameObject.getComponent(egret3d.MeshFilter) || this.gameObject.addComponent(egret3d.MeshFilter);
                this._meshRender = this.gameObject.getComponent(egret3d.MeshRenderer) || this.gameObject.addComponent(egret3d.MeshRenderer);
                var mesh = new egret3d.Mesh(4, null, _attributes);
                var vertices = mesh.getVertices();
                var colors = mesh.getColors();
                vertices[0] = 0.0;
                vertices[1] = 0.0;
                vertices[2] = 0.0;
                vertices[3] = this.distance;
                vertices[4] = 0.0;
                vertices[5] = 0.0;
                vertices[6] = this.distance;
                vertices[7] = 0.0;
                vertices[8] = 0.0;
                vertices[9] = this.distance;
                vertices[10] = 0.0;
                vertices[11] = 0.0;
                for (var i = 0, l = colors.length; i < l; i += 4) {
                    colors[i + 0] = 0.0;
                    colors[i + 1] = 1.0;
                    colors[i + 2] = 0.0;
                    colors[i + 3] = 0.7;
                }
                mesh.glTFMesh.primitives[0].mode = 1 /* Lines */;
                mesh.uploadSubVertexBuffer(_attributes);
                RayTester._material = new egret3d.Material(egret3d.DefaultShaders.LINE);
                this._meshRender.materials = [RayTester._material];
                this._meshFilter.mesh = mesh;
            };
            RayTester.prototype.onUpdate = function () {
                var transform = this.gameObject.transform;
                var matrix = transform.getWorldMatrix();
                var from = transform.getPosition();
                var to = matrix.transformVector3(egret3d.helpVector3A.set(this.distance, 0.0, 0.0));
                var raycastInfo = oimo.PhysicsSystem.instance.rayCast(from, to, this.collisionMask, _raycastInfo);
                if (raycastInfo) {
                    this._hitted = true;
                    var mesh = this._meshFilter.mesh;
                    if (mesh) {
                        var v = egret3d.helpMatrixA.copy(matrix).inverse().transformNormal(raycastInfo.normal).scale(1.0);
                        var vertices = mesh.getVertices();
                        var colors = mesh.getColors();
                        vertices[3] = raycastInfo.distance;
                        vertices[4] = 0.0;
                        vertices[5] = 0.0;
                        vertices[6] = raycastInfo.distance;
                        vertices[7] = 0.0;
                        vertices[8] = 0.0;
                        vertices[9] = v.x + raycastInfo.distance;
                        vertices[10] = v.y;
                        vertices[11] = v.z;
                        for (var i = 2 * 4, l = colors.length; i < l; i += 4) {
                            colors[i + 0] = 1.0;
                            colors[i + 1] = 0.0;
                            colors[i + 2] = 0.0;
                            colors[i + 3] = 0.7;
                        }
                        mesh.uploadSubVertexBuffer(_attributes);
                    }
                }
                else if (this._hitted) {
                    this._hitted = false;
                    var mesh = this._meshFilter.mesh;
                    if (mesh) {
                        var vertices = mesh.getVertices();
                        var colors = mesh.getColors();
                        vertices[3] = this.distance;
                        vertices[4] = 0.0;
                        vertices[5] = 0.0;
                        vertices[6] = this.distance;
                        vertices[7] = 0.0;
                        vertices[8] = 0.0;
                        vertices[9] = this.distance;
                        vertices[10] = 0.0;
                        vertices[11] = 0.0;
                        for (var i = 2 * 4, l = colors.length; i < l; i += 4) {
                            colors[i + 0] = 0.0;
                            colors[i + 1] = 1.0;
                            colors[i + 2] = 0.0;
                            colors[i + 3] = 0.7;
                        }
                        mesh.uploadSubVertexBuffer(_attributes);
                    }
                }
            };
            __decorate([
                paper.serializedField
            ], RayTester.prototype, "distance", void 0);
            __decorate([
                paper.serializedField
            ], RayTester.prototype, "collisionMask", void 0);
            return RayTester;
        }(paper.Behaviour));
        oimo.RayTester = RayTester;
        __reflect(RayTester.prototype, "egret3d.oimo.RayTester");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * 组件事件。
     */
    var EventPool;
    (function (EventPool) {
        var _behaviourComponentType = egret.getQualifiedClassName(paper.Behaviour);
        var _componentListeners = {};
        function _dispatchEvent(type, componentType, component, extend) {
            var componentListeners = _componentListeners[componentType];
            if (type in componentListeners) {
                var eventListeners = componentListeners[type];
                for (var _i = 0, eventListeners_1 = eventListeners; _i < eventListeners_1.length; _i++) {
                    var listener = eventListeners_1[_i];
                    // 监听直接派发，所以监听都应注意 bind 问题。
                    if (extend) {
                        listener(component, extend);
                    }
                    else {
                        listener(component);
                    }
                }
            }
        }
        /**
         * 添加事件监听
         */
        function addEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            var componentListeners = componentType in _componentListeners ? _componentListeners[componentType] : _componentListeners[componentType] = {};
            var eventListeners = eventType in componentListeners ? componentListeners[eventType] : componentListeners[eventType] = [];
            eventListeners.push(callback);
        }
        EventPool.addEventListener = addEventListener;
        /**
         * 移除事件监听
         */
        function removeEventListener(eventType, componentClass, callback) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType in componentListeners) {
                    var eventListeners = componentListeners[eventType];
                    for (var i = 0, l = eventListeners.length; i < l; i++) {
                        if (eventListeners[i] === callback) {
                            eventListeners.splice(i, 1);
                            break;
                        }
                    }
                }
            }
        }
        EventPool.removeEventListener = removeEventListener;
        /**
         * 移除所有该类型的事件监听
         */
        function removeAllEventListener(eventType, componentClass) {
            var componentType = egret.getQualifiedClassName(componentClass);
            if (componentType in _componentListeners) {
                var componentListeners = _componentListeners[componentType];
                if (eventType) {
                    if (eventType in componentListeners) {
                        componentListeners[eventType].length = 0;
                    }
                }
                else {
                    delete _componentListeners[componentType];
                }
            }
        }
        EventPool.removeAllEventListener = removeAllEventListener;
        /**
         * 发送组件事件:
         * @param type event type:
         * @param component component
         */
        function dispatchEvent(type, component, extend) {
            // 如果是组件的添加或删除事件，并且该组件派生自 Behaviour 组件，则需要使用基类的组件类型，这些组件发出的添加或删除事件都能被生命周期系统收到。 
            if (type === "__enabled__" /* Enabled */ || type === "__disabled__" /* Disabled */) {
                if (egret.is(component, _behaviourComponentType)) {
                    _dispatchEvent(type, _behaviourComponentType, component);
                }
            }
            var componentType = egret.getQualifiedClassName(component);
            if (componentType in _componentListeners) {
                _dispatchEvent(type, componentType, component, extend);
            }
        }
        EventPool.dispatchEvent = dispatchEvent;
    })(EventPool = paper.EventPool || (paper.EventPool = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var ECS = (function () {
        function ECS() {
            /**
             * 系统管理器。
             */
            this.systemManager = paper.SystemManager.getInstance();
            /**
             * 场景管理器。
             */
            this.sceneManager = paper.SceneManager.getInstance();
            this._isEditor = false;
            this._isFocused = false;
            this._isPlaying = false;
            this._isRunning = false;
            this._bindUpdate = null;
        }
        /**
         *
         */
        ECS.getInstance = function () {
            if (!this._instance) {
                this._instance = new ECS();
            }
            return this._instance;
        };
        ECS.prototype._update = function () {
            if (this._isRunning) {
                requestAnimationFrame(this._bindUpdate);
            }
            paper.Time && paper.Time.update();
            paper.Group.update();
            this.systemManager.update();
        };
        ECS.prototype.init = function (_a) {
            var _b = _a === void 0 ? {} : _a, _c = _b.isEditor, isEditor = _c === void 0 ? false : _c, _d = _b.isPlaying, isPlaying = _d === void 0 ? true : _d, _e = _b.systems, systems = _e === void 0 ? [] : _e, _f = _b.option, option = _f === void 0 ? {} : _f, _g = _b.canvas, canvas = _g === void 0 ? {} : _g, _h = _b.webgl, webgl = _h === void 0 ? {} : _h;
            for (var _i = 0, systems_1 = systems; _i < systems_1.length; _i++) {
                var systemClass = systems_1[_i];
                this.systemManager.register(systemClass);
            }
            this._isEditor = isEditor;
            this._isPlaying = isPlaying;
            this._option = option;
            this._canvas = canvas;
            this._webgl = webgl;
            this.resume();
        };
        /**
         *
         */
        ECS.prototype.pause = function () {
            this._isRunning = false;
        };
        ECS.prototype.resume = function () {
            if (this._isRunning) {
                return;
            }
            this._isRunning = true;
            if (!this._bindUpdate) {
                this._bindUpdate = this._update.bind(this);
            }
            this._update();
        };
        ECS.prototype.callLater = function (callback) {
            this.systemManager.getSystem(paper.LateUpdateSystem).callLater(callback);
        };
        Object.defineProperty(ECS.prototype, "isEditor", {
            get: function () {
                return this._isEditor;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isFocused", {
            get: function () {
                return this._isFocused;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isPlaying", {
            get: function () {
                return this._isPlaying;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(ECS.prototype, "isRunning", {
            get: function () {
                return this._isRunning;
            },
            enumerable: true,
            configurable: true
        });
        ECS._instance = null;
        return ECS;
    }());
    paper.ECS = ECS;
    __reflect(ECS.prototype, "paper.ECS");
    paper.Application = ECS.getInstance();
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var tmpVecA = new egret3d.Vector3();
    var tmpVecB = new egret3d.Vector3();
    var tmpVecC = new egret3d.Vector3();
    var tmpVecD = new egret3d.Vector3();
    var tmpVecE = new egret3d.Vector3();
    /**
     * aabb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 轴对称包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var AABB = (function () {
        /**
         * build a aabb
         * @param minimum min point
         * @param maximum max point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 构建轴对称包围盒
         * @param minimum 最小点
         * @param maximum 最大点
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        function AABB(minimum, maximum) {
            /**
             * min point
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 最小点
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.minimum = new egret3d.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            /**
             * max point
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 最大点
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            this.maximum = new egret3d.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            // TODO local bounding box 与 world bounding box 分离
            this.srcmin = new egret3d.Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
            this.srcmax = new egret3d.Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
            this._center = new egret3d.Vector3();
            if (minimum) {
                egret3d.Vector3.copy(minimum, this.srcmin);
                egret3d.Vector3.copy(minimum, this.minimum);
            }
            if (maximum) {
                egret3d.Vector3.copy(maximum, this.srcmax);
                egret3d.Vector3.copy(maximum, this.maximum);
            }
        }
        /**
         * update
         * @param worldmatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 刷新轴对称包围盒
         * @param worldmatrix 物体的世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.update = function (worldmatrix) {
            egret3d.Matrix.getTranslation(worldmatrix, tmpVecA);
            egret3d.Matrix.getTranslation(worldmatrix, tmpVecB);
            if (worldmatrix.rawData[0] > 0) {
                tmpVecA.x += worldmatrix.rawData[0] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[0] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[0] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[0] * this.srcmin.x;
            }
            if (worldmatrix.rawData[1] > 0) {
                tmpVecA.y += worldmatrix.rawData[1] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[1] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[1] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[1] * this.srcmin.y;
            }
            if (worldmatrix.rawData[2] > 0) {
                tmpVecA.z += worldmatrix.rawData[2] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[2] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[2] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[2] * this.srcmin.z;
            }
            if (worldmatrix.rawData[4] > 0) {
                tmpVecA.x += worldmatrix.rawData[4] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[4] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[4] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[4] * this.srcmin.x;
            }
            if (worldmatrix.rawData[5] > 0) {
                tmpVecA.y += worldmatrix.rawData[5] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[5] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[5] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[5] * this.srcmin.y;
            }
            if (worldmatrix.rawData[6] > 0) {
                tmpVecA.z += worldmatrix.rawData[6] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[6] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[6] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[6] * this.srcmin.z;
            }
            if (worldmatrix.rawData[8] > 0) {
                tmpVecA.x += worldmatrix.rawData[8] * this.srcmin.x;
                tmpVecB.x += worldmatrix.rawData[8] * this.srcmax.x;
            }
            else {
                tmpVecA.x += worldmatrix.rawData[8] * this.srcmax.x;
                tmpVecB.x += worldmatrix.rawData[8] * this.srcmin.x;
            }
            if (worldmatrix.rawData[9] > 0) {
                tmpVecA.y += worldmatrix.rawData[9] * this.srcmin.y;
                tmpVecB.y += worldmatrix.rawData[9] * this.srcmax.y;
            }
            else {
                tmpVecA.y += worldmatrix.rawData[9] * this.srcmax.y;
                tmpVecB.y += worldmatrix.rawData[9] * this.srcmin.y;
            }
            if (worldmatrix.rawData[10] > 0) {
                tmpVecA.z += worldmatrix.rawData[10] * this.srcmin.z;
                tmpVecB.z += worldmatrix.rawData[10] * this.srcmax.z;
            }
            else {
                tmpVecA.z += worldmatrix.rawData[10] * this.srcmax.z;
                tmpVecB.z += worldmatrix.rawData[10] * this.srcmin.z;
            }
            egret3d.Vector3.copy(tmpVecA, this.minimum);
            egret3d.Vector3.copy(tmpVecB, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * extend by a point
         * @param vec a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 包含一个点
         * @param vec 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.addVector3 = function (vec) {
            egret3d.Vector3.max(this.maximum, vec, this.maximum);
            egret3d.Vector3.min(this.minimum, vec, this.minimum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * check contains vector
         * @param vec a world point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否包含点
         * @param vec 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.containsVector3 = function (vec) {
            return (vec.x > this.minimum.x) && (vec.x < this.maximum.x) &&
                (vec.y > this.minimum.y) && (vec.x < this.maximum.y) &&
                (vec.z > this.minimum.z) && (vec.z < this.maximum.z);
        };
        /**
         * intersect with aabb
         * @param aabb aabb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 检查是否与aabb相交
         * @param aabb 轴对称包围盒
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.intersectAABB = function (aabb) {
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            if (this.minimum.x > aabb.maximum.x)
                return false;
            if (this.maximum.x < aabb.minimum.x)
                return false;
            return true;
        };
        /**
         *
         * 用于视锥检测的计算，引擎内部使用
         * 这里采用包围球式计算以提高性能
         */
        AABB.prototype.intersectPlane = function (v0, v1, v2) {
            var subV0 = tmpVecA;
            var subV1 = tmpVecB;
            var cross = tmpVecC;
            var hitPoint = tmpVecD;
            var distVec = tmpVecE;
            var center = this.center;
            egret3d.Vector3.subtract(v1, v0, subV0);
            egret3d.Vector3.subtract(v2, v1, subV1);
            egret3d.Vector3.cross(subV0, subV1, cross);
            egret3d.calPlaneLineIntersectPoint(cross, v0, cross, center, hitPoint);
            egret3d.Vector3.subtract(hitPoint, center, distVec);
            var val = egret3d.Vector3.dot(cross, distVec);
            if (val <= 0) {
                return true;
            }
            var dist = egret3d.Vector3.getDistance(center, hitPoint);
            if (dist < this.radius) {
                return true;
            }
            return false;
        };
        /**
         * extend by aabb
         * @param aabb aabb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 包含一个aabb
         * @param aabb 轴对称包围盒
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.addAABB = function (aabb) {
            egret3d.Vector3.max(this.maximum, aabb.maximum, this.maximum);
            egret3d.Vector3.min(this.minimum, aabb.minimum, this.minimum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        Object.defineProperty(AABB.prototype, "center", {
            /**
             * get center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取中心点位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyCenter) {
                    egret3d.Vector3.add(this.maximum, this.minimum, this._center);
                    egret3d.Vector3.scale(this._center, 0.5);
                    this._dirtyCenter = false;
                }
                return this._center;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AABB.prototype, "radius", {
            /**
             * get bounding sphere radius
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 获取包围球的半径
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                if (this._dirtyRadius) {
                    egret3d.Vector3.subtract(this.maximum, this.minimum, tmpVecA);
                    egret3d.Vector3.scale(tmpVecA, 0.5);
                    this._dirtyRadius = false;
                }
                return egret3d.Vector3.getLength(tmpVecA);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * clear
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 清空
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.clear = function () {
            egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, this.minimum);
            egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
        };
        /**
         * clone
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 克隆
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.clone = function () {
            var aabb = new egret3d.AABB(this.minimum, this.maximum);
            return aabb;
        };
        /**
         * copy
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 复制
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.copy = function (aabb) {
            egret3d.Vector3.copy(aabb.minimum, this.minimum);
            egret3d.Vector3.copy(aabb.maximum, this.maximum);
            this._dirtyCenter = true;
            this._dirtyRadius = true;
            return this;
        };
        /**
         * get vectors
         * @param vecs output vectors
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取包围盒顶点数据
         * @param vecs 引用数组
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        AABB.prototype.getVec3 = function (vecs) {
            vecs[0] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[1] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[1].z = this.maximum.z;
            vecs[2] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[2].x = this.maximum.x;
            vecs[3] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[3].y = this.minimum.y;
            vecs[4] = egret3d.Vector3.copy(this.minimum, new egret3d.Vector3());
            vecs[4].y = this.maximum.y;
            vecs[5] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[5].x = this.minimum.x;
            vecs[6] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
            vecs[6].z = this.minimum.z;
            vecs[7] = egret3d.Vector3.copy(this.maximum, new egret3d.Vector3());
        };
        return AABB;
    }());
    egret3d.AABB = AABB;
    __reflect(AABB.prototype, "egret3d.AABB");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = new egret3d.Vector3();
    var _helpVector3B = new egret3d.Vector3();
    /**
     * obb box
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 定向包围盒
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var OBB = (function (_super) {
        __extends(OBB, _super);
        function OBB() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * center
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒中心
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.center = new egret3d.Vector3();
            /**
             * size
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒各轴向长
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.size = new egret3d.Vector3();
            /**
             * vectors
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 包围盒世界空间下各个点坐标
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.vectors = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
            _this._directions = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
            ];
            return _this;
        }
        OBB.prototype._computeBoxExtents = function (axis, box, out) {
            var p = egret3d.Vector3.dot(box.center, axis);
            //
            var r0 = Math.abs(egret3d.Vector3.dot(box._directions[0], axis)) * box.size.x * 0.5;
            var r1 = Math.abs(egret3d.Vector3.dot(box._directions[1], axis)) * box.size.y * 0.5;
            var r2 = Math.abs(egret3d.Vector3.dot(box._directions[2], axis)) * box.size.z * 0.5;
            //
            var r = r0 + r1 + r2;
            out.x = p - r;
            out.y = p + r;
            return out;
        };
        OBB.prototype._axisOverlap = function (axis, a, b) {
            var resultA = this._computeBoxExtents(axis, a, _helpVector3A);
            var resultB = this._computeBoxExtents(axis, b, _helpVector3B);
            return !(resultA.x > resultA.y || resultB.x > resultB.y);
        };
        /**
         * clone a obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 克隆一个obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.clone = function () {
            var value = new OBB();
            egret3d.Vector3.copy(this.center, value.center);
            egret3d.Vector3.copy(this.center, value.size);
            for (var key in this._directions) {
                egret3d.Vector3.copy(this._directions[key], value._directions[key]);
            }
            return value;
        };
        /**
         * build by min point and max point
         * @param minimum min point
         * @param maximum max point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由最大最小点构建定向包围盒
         * @param minimum 最小点坐标
         * @param maximum 最大点坐标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByMaxMin = function (minimum, maximum) {
            egret3d.Vector3.copy(minimum, this.vectors[0]);
            egret3d.Vector3.copy(minimum, this.vectors[1]);
            egret3d.Vector3.copy(minimum, this.vectors[2]);
            egret3d.Vector3.copy(maximum, this.vectors[3]);
            egret3d.Vector3.copy(minimum, this.vectors[4]);
            egret3d.Vector3.copy(maximum, this.vectors[5]);
            egret3d.Vector3.copy(maximum, this.vectors[6]);
            egret3d.Vector3.copy(maximum, this.vectors[7]);
            //
            this.vectors[1].z = maximum.z;
            this.vectors[2].x = maximum.x;
            this.vectors[3].y = minimum.y;
            this.vectors[4].y = maximum.y;
            this.vectors[5].x = minimum.x;
            this.vectors[6].z = minimum.z;
            //
            egret3d.Vector3.add(maximum, minimum, this.center);
            egret3d.Vector3.scale(this.center, 0.5);
            egret3d.Vector3.subtract(maximum, minimum, this.size);
        };
        /**
         * build by center and size
         * @param center center
         * @param size size
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由中心点和各轴向长度构建定向包围盒
         * @param center 中心点坐标
         * @param size 各轴向长度
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.setByCenterSize = function (center, size) {
            egret3d.Vector3.copy(center, this.center);
            egret3d.Vector3.copy(size, this.size);
            //
            var hsx = this.size.x * 0.5;
            var hsy = this.size.y * 0.5;
            var hsz = this.size.z * 0.5;
            var cenx = this.center.x;
            var ceny = this.center.y;
            var cenz = this.center.z;
            //
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz - hsz, this.vectors[0]);
            egret3d.Vector3.set(cenx - hsx, ceny - hsy, cenz + hsz, this.vectors[1]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz - hsz, this.vectors[2]);
            egret3d.Vector3.set(cenx + hsx, ceny - hsy, cenz + hsz, this.vectors[3]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz - hsz, this.vectors[4]);
            egret3d.Vector3.set(cenx - hsx, ceny + hsy, cenz + hsz, this.vectors[5]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz - hsz, this.vectors[6]);
            egret3d.Vector3.set(cenx + hsx, ceny + hsy, cenz + hsz, this.vectors[7]);
        };
        /**
         * update by world matrix
         * @param worldmatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 刷新定向包围盒
         * @param worldmatrix 世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.update = function (worldMatrix) {
            egret3d.Matrix.getTranslation(worldMatrix, this.center);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 0, this._directions[0]);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 4, this._directions[1]);
            egret3d.Matrix.getVector3ByOffset(worldMatrix, 8, this._directions[2]);
        };
        /**
         * intersect width obb
         * @param value obb
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * obb的碰撞检测
         * @param value 待检测obb
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.intersects = function (value) {
            var a = this;
            var b = value;
            //
            if (!this._axisOverlap(a._directions[0], a, b))
                return false;
            if (!this._axisOverlap(a._directions[1], a, b))
                return false;
            if (!this._axisOverlap(a._directions[2], a, b))
                return false;
            if (!this._axisOverlap(b._directions[0], a, b))
                return false;
            if (!this._axisOverlap(b._directions[1], a, b))
                return false;
            if (!this._axisOverlap(b._directions[2], a, b))
                return false;
            var result = _helpVector3A;
            egret3d.Vector3.cross(a._directions[0], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[0], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[1], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[0], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[1], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            egret3d.Vector3.cross(a._directions[2], b._directions[2], result);
            if (!this._axisOverlap(result, a, b))
                return false;
            return true;
        };
        /**
         * update vectors by world matrix
         * @param vectors vectors
         * @param worldMatrix world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 计算世界空间下各点坐标
         * @param vectors 结果数组
         * @param worldMatrix 物体的世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        OBB.prototype.caclWorldVectors = function (vectors, worldMatrix) {
            for (var i = 0; i < 8; ++i) {
                egret3d.Matrix.transformVector3(this.vectors[i], worldMatrix, vectors[i]);
            }
        };
        OBB.prototype.deserialize = function (element) {
            this.center.deserialize(element.center);
            this.size.deserialize(element.size);
        };
        __decorate([
            paper.serializedField
        ], OBB.prototype, "center", void 0);
        __decorate([
            paper.serializedField
        ], OBB.prototype, "size", void 0);
        return OBB;
    }(paper.SerializableObject));
    egret3d.OBB = OBB;
    __reflect(OBB.prototype, "egret3d.OBB");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 贝塞尔曲线，目前定义了三种：线性贝塞尔曲线(两个点形成),二次方贝塞尔曲线（三个点形成），三次方贝塞尔曲线（四个点形成）
     */
    var Curve3 = (function () {
        function Curve3(points, nbPoints) {
            this._beizerPoints = points;
            this._bezierPointNum = nbPoints;
        }
        Object.defineProperty(Curve3.prototype, "beizerPoints", {
            get: function () {
                return this._beizerPoints;
            },
            set: function (value) {
                this._beizerPoints = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Curve3.prototype, "bezierPointNum", {
            get: function () {
                return this._bezierPointNum;
            },
            set: function (value) {
                this._bezierPointNum = value;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 线性贝塞尔曲线
         */
        Curve3.CreateLinearBezier = function (start, end, indices) {
            indices = indices > 2 ? indices : 3;
            var bez = new Array();
            var equation = function (t, va10, va11) {
                var res = (1.0 - t) * va10 + t * va11;
                return res;
            };
            bez.push(start);
            for (var i = 1; i <= indices; i++) {
                bez.push(new egret3d.Vector3(equation(i / indices, start.x, end.x), equation(i / indices, start.y, start.y), equation(i / indices, start.z, start.z)));
            }
            return new Curve3(bez, indices);
        };
        /**
         * 二次方贝塞尔曲线路径
         * @param v0 起始点
         * @param v1 选中的节点
         * @param v2 结尾点
         * @param nbPoints 将贝塞尔曲线拆分nbPoints段，一共有nbPoints + 1个点
         */
        Curve3.CreateQuadraticBezier = function (v0, v1, v2, bezierPointNum) {
            bezierPointNum = bezierPointNum > 2 ? bezierPointNum : 3;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2) {
                var res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 三次方贝塞尔曲线路径
         * @param v0
         * @param v1
         * @param v2
         * @param v3
         * @param nbPoints
         */
        Curve3.CreateCubicBezier = function (v0, v1, v2, v3, bezierPointNum) {
            bezierPointNum = bezierPointNum > 3 ? bezierPointNum : 4;
            var beizerPoint = new Array();
            var equation = function (t, val0, val1, val2, val3) {
                var res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 + 3.0 * t * (1.0 - t) * (1.0 - t) * val1 + 3.0 * t * t * (1.0 - t) * val2 + t * t * t * val3;
                return res;
            };
            for (var i = 1; i <= bezierPointNum; i++) {
                beizerPoint.push(new egret3d.Vector3(equation(i / bezierPointNum, v0.x, v1.x, v2.x, v3.x), equation(i / bezierPointNum, v0.y, v1.y, v2.y, v3.y), equation(i / bezierPointNum, v0.z, v1.z, v2.z, v3.z)));
            }
            return new Curve3(beizerPoint, bezierPointNum);
        };
        /**
         * 贝塞尔曲线上的点
         */
        Curve3.prototype.getPoints = function () {
            return this._beizerPoints;
        };
        return Curve3;
    }());
    egret3d.Curve3 = Curve3;
    __reflect(Curve3.prototype, "egret3d.Curve3");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    function layerTest(cullingMask, layer) {
        return (cullingMask & layer) !== 0;
    }
    paper.layerTest = layerTest;
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 克隆
     */
    function clone(object) {
        var data = paper.serialize(object);
        return paper.deserialize(data);
    }
    paper.clone = clone;
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    egret3d.RAD_DEG = 180.0 / Math.PI;
    /**
     *
     */
    egret3d.DEG_RAD = Math.PI / 180.0;
    function floatClamp(v, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        if (v < min)
            return min;
        else if (v > max)
            return max;
        else
            return v;
    }
    egret3d.floatClamp = floatClamp;
    function sign(value) {
        value = +value; // convert to a number
        if (value === 0 || isNaN(value))
            return value;
        return value > 0 ? 1 : -1;
    }
    egret3d.sign = sign;
    function numberLerp(fromV, toV, v) {
        return fromV * (1 - v) + toV * v;
    }
    egret3d.numberLerp = numberLerp;
    function calPlaneLineIntersectPoint(planeVector, planePoint, lineVector, linePoint, out) {
        var vp1 = planeVector.x;
        var vp2 = planeVector.y;
        var vp3 = planeVector.z;
        var n1 = planePoint.x;
        var n2 = planePoint.y;
        var n3 = planePoint.z;
        var v1 = lineVector.x;
        var v2 = lineVector.y;
        var v3 = lineVector.z;
        var m1 = linePoint.x;
        var m2 = linePoint.y;
        var m3 = linePoint.z;
        var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
        if (vpt === 0) {
            out = null;
        }
        else {
            var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
            out.x = m1 + v1 * t;
            out.y = m2 + v2 * t;
            out.z = m3 + v3 * t;
        }
        return out;
    }
    egret3d.calPlaneLineIntersectPoint = calPlaneLineIntersectPoint;
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    function getPointAlongCurve(curveStart, curveStartHandle, curveEnd, curveEndHandle, t, out, crease) {
        if (crease === void 0) { crease = 0.3; }
        var oneMinT = 1 - t;
        var oneMinTPow3 = Math.pow(oneMinT, 3);
        var oneMinTPow2 = Math.pow(oneMinT, 2);
        var oneMinCrease = 1 - crease;
        var tempt1 = helpVec3_1;
        egret3d.Vector3.copy(curveStart, tempt1);
        egret3d.Vector3.scale(tempt1, oneMinTPow3 * oneMinCrease);
        var tempt2 = helpVec3_2;
        egret3d.Vector3.copy(curveStartHandle, tempt2);
        egret3d.Vector3.scale(tempt2, 3 * oneMinTPow2 * t * crease);
        var tempt3 = helpVec3_3;
        egret3d.Vector3.copy(curveEndHandle, tempt3);
        egret3d.Vector3.scale(tempt3, 3 * oneMinT * Math.pow(t, 2) * crease);
        var tempt4 = helpVec3_4;
        egret3d.Vector3.copy(curveEnd, tempt4);
        egret3d.Vector3.scale(tempt4, Math.pow(t, 3) * oneMinCrease);
        var tempt5 = helpVec3_5;
        egret3d.Vector3.add(tempt1, tempt2, tempt5);
        egret3d.Vector3.add(tempt5, tempt3, tempt5);
        egret3d.Vector3.add(tempt5, tempt4, tempt5);
        egret3d.Vector3.copy(tempt5, out);
        egret3d.Vector3.scale(out, 1 / (oneMinTPow3 * oneMinCrease + 3 * oneMinTPow2 * t * crease + 3 * oneMinT * Math.pow(t, 2) * crease + Math.pow(t, 3) * oneMinCrease));
    }
    egret3d.getPointAlongCurve = getPointAlongCurve;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var GroupComponent = (function (_super) {
        __extends(GroupComponent, _super);
        function GroupComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.componentIndex = -1;
            _this.componentClass = null;
            _this._components = [];
            return _this;
        }
        /**
         * @internal
         */
        GroupComponent.prototype._addComponent = function (component) {
            this._components.push(component);
        };
        /**
         * @internal
         */
        GroupComponent.prototype._removeComponent = function (component) {
            var index = this._components.indexOf(component);
            if (index >= 0) {
                this._components.splice(1, 0);
            }
        };
        Object.defineProperty(GroupComponent.prototype, "components", {
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        return GroupComponent;
    }(paper.BaseComponent));
    paper.GroupComponent = GroupComponent;
    __reflect(GroupComponent.prototype, "paper.GroupComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * textrue asset
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 纹理资源。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Texture = (function (_super) {
        __extends(Texture, _super);
        function Texture() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._realName = "";
            return _this;
        }
        Texture.prototype.dispose = function () {
            if (this._isBuiltin) {
                return;
            }
            this.glTexture.dispose(egret3d.WebGLCapabilities.webgl);
        };
        /**
         * @inheritDoc
         */
        Texture.prototype.caclByteLength = function () {
            if (this.glTexture) {
                return this.glTexture.caclByteLength();
            }
            return 0;
        };
        Object.defineProperty(Texture.prototype, "realName", {
            /**
             * real image name
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 如果是imgdesc加载来的图片，通过这个可以获取到真实的图片名字。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._realName;
            },
            set: function (name) {
                this._realName = name;
            },
            enumerable: true,
            configurable: true
        });
        return Texture;
    }(paper.Asset));
    egret3d.Texture = Texture;
    __reflect(Texture.prototype, "egret3d.Texture");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * glTF 资源。
     */
    var GLTFAsset = (function (_super) {
        __extends(GLTFAsset, _super);
        function GLTFAsset() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * Buffer 列表。
             */
            _this.buffers = [];
            /**
             * 配置。
             */
            _this.config = null;
            return _this;
        }
        /**
         *
         */
        GLTFAsset.getComponentTypeCount = function (type) {
            switch (type) {
                case 5120 /* Byte */:
                case 5121 /* UnsignedByte */:
                    return 1;
                case 5122 /* Short */:
                case 5123 /* UnsignedShort */:
                    return 2;
                case 5124 /* Int */:
                case 5125 /* UnsignedInt */:
                    return 4;
                case 5126 /* Float */:
                    return 4;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.getAccessorTypeCount = function (type) {
            switch (type) {
                case "SCALAR" /* SCALAR */:
                    return 1;
                case "VEC2" /* VEC2 */:
                    return 2;
                case "VEC3" /* VEC3 */:
                    return 3;
                case "VEC4" /* VEC4 */:
                case "MAT2" /* MAT2 */:
                    return 4;
                case "MAT3" /* MAT3 */:
                    return 9;
                case "MAT4" /* MAT4 */:
                    return 16;
                default:
                    throw new Error();
            }
        };
        /**
         * 自定义 Mesh 的属性枚举。
         */
        GLTFAsset.getMeshAttributeType = function (type) {
            switch (type) {
                case "POSITION" /* POSITION */:
                case "NORMAL" /* NORMAL */:
                    return "VEC3" /* VEC3 */;
                case "TEXCOORD_0" /* TEXCOORD_0 */:
                case "TEXCOORD_1" /* TEXCOORD_1 */:
                    return "VEC2" /* VEC2 */;
                case "TANGENT" /* TANGENT */:
                case "COLOR_0" /* COLOR_0 */:
                case "COLOR_1" /* COLOR_1 */:
                case "JOINTS_0" /* JOINTS_0 */:
                case "WEIGHTS_0" /* WEIGHTS_0 */:
                    return "VEC4" /* VEC4 */;
                default:
                    throw new Error();
            }
        };
        /**
         *
         */
        GLTFAsset.createGLTFAsset = function () {
            var glftAsset = new GLTFAsset("");
            glftAsset.config = {
                asset: {
                    version: "2.0"
                },
                extensionsRequired: ["paper"],
                extensionsUsed: ["paper"],
            };
            return glftAsset;
        };
        GLTFAsset.createGLTFExtensionsAsset = function (url) {
            if (url === void 0) { url = ""; }
            var glftAsset = new GLTFAsset(url);
            glftAsset.config = {
                asset: {
                    version: "2.0"
                },
                extensions: { KHR_techniques_webgl: {} },
                extensionsRequired: ["egret"],
                extensionsUsed: ["egret"],
            };
            return glftAsset;
        };
        GLTFAsset.createTechnique = function (source) {
            var target = { name: source.name, attributes: {}, uniforms: {}, states: { enable: [], functions: {} } };
            for (var key in source.attributes) {
                var attribute = source.attributes[key];
                target.attributes[key] = { semantic: attribute.semantic, extensions: { paper: { enable: true, location: -1 } } };
            }
            for (var key in source.uniforms) {
                var uniform = source.uniforms[key];
                var value = Array.isArray(uniform.value) ? uniform.value.concat() : uniform.value;
                target.uniforms[key] = { type: uniform.type, semantic: uniform.semantic, value: value, extensions: { paper: { enable: false, location: -1 } } };
            }
            var states = source.states;
            var targetStates = target.states;
            if (states.enable) {
                targetStates.enable = states.enable.concat();
            }
            for (var fun in states.functions) {
                if (Array.isArray(states.functions[fun])) {
                    targetStates.functions[fun] = states.functions[fun].concat();
                }
                else {
                    targetStates.functions[fun] = states.functions[fun];
                }
            }
            return target;
        };
        /**
         * @internal
         */
        GLTFAsset.prototype.parse = function (config, buffers) {
            this.config = config;
            for (var _i = 0, buffers_1 = buffers; _i < buffers_1.length; _i++) {
                var buffer = buffers_1[_i];
                this.buffers.push(buffer);
            }
        };
        /**
         * @internal
         */
        GLTFAsset.prototype.parseFromBinary = function (array) {
            var index = 0;
            if (array[index++] !== 0x46546C67 ||
                array[index++] !== 2) {
                console.assert(false, "Nonsupport glTF data.");
                return;
            }
            if (array[index++] !== array.byteLength) {
                console.assert(false, "Error glTF data.");
                return;
            }
            var chunkLength = 0;
            var chunkType = 0;
            while (index < array.length) {
                chunkLength = array[index++];
                chunkType = array[index++];
                if (chunkLength % 4) {
                    console.assert(false, "Error glTF data.");
                }
                if (chunkType === 0x4E4F534A) {
                    var jsonArray = new Uint8Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint8Array.BYTES_PER_ELEMENT);
                    var jsonString = egret3d.io.BinReader.utf8ArrayToString(jsonArray);
                    this.config = JSON.parse(jsonString);
                }
                else if (chunkType === 0x004E4942) {
                    var buffer = new Uint32Array(array.buffer, index * 4 + array.byteOffset, chunkLength / Uint32Array.BYTES_PER_ELEMENT);
                    this.buffers.push(buffer);
                }
                else {
                    console.assert(false, "Nonsupport glTF data.");
                    return;
                }
                index += chunkLength / 4;
            }
        };
        /**
         * 根据指定 BufferView 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromBufferView = function (bufferView, componentType) {
            var buffer = this.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0);
            // assert.config.buffers[bufferView.buffer];
            switch (componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int8Array.BYTES_PER_ELEMENT);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint8Array.BYTES_PER_ELEMENT);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int16Array.BYTES_PER_ELEMENT);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Int32Array.BYTES_PER_ELEMENT);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Uint32Array.BYTES_PER_ELEMENT);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferView.byteLength / Float32Array.BYTES_PER_ELEMENT);
            }
            throw new Error();
        };
        /**
         * 根据指定 Accessor 创建二进制数组。
         */
        GLTFAsset.prototype.createTypeArrayFromAccessor = function (accessor) {
            var bufferCount = GLTFAsset.getAccessorTypeCount(accessor.type) * accessor.count;
            var bufferView = this.getBufferView(accessor);
            var buffer = this.buffers[bufferView.buffer];
            // assert.config.buffers[bufferView.buffer];
            var bufferOffset = buffer.byteOffset + (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
            switch (accessor.componentType) {
                case 5120 /* Byte */:
                    return new Int8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5121 /* UnsignedByte */:
                    return new Uint8Array(buffer.buffer, bufferOffset, bufferCount);
                case 5122 /* Short */:
                    return new Int16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(buffer.buffer, bufferOffset, bufferCount);
                case 5124 /* Int */:
                    return new Int32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5125 /* UnsignedInt */:
                    return new Uint32Array(buffer.buffer, bufferOffset, bufferCount);
                case 5126 /* Float */:
                    return new Float32Array(buffer.buffer, bufferOffset, bufferCount);
            }
            throw new Error();
        };
        /**
         * 通过 Accessor 获取指定 BufferLength。
         */
        GLTFAsset.prototype.getBufferLength = function (accessor) {
            return GLTFAsset.getAccessorTypeCount(accessor.type) * GLTFAsset.getComponentTypeCount(accessor.componentType) * accessor.count;
        };
        /**
         * 通过 Accessor 获取指定 BufferOffset。
         */
        GLTFAsset.prototype.getBufferOffset = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // const buffer = this.buffers[bufferView.buffer];
            return (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
        };
        /**
         * 通过 Accessor 获取指定 Buffer。
         */
        GLTFAsset.prototype.getBuffer = function (accessor) {
            var bufferView = this.getBufferView(accessor);
            // this.config.buffers[bufferView.buffer];
            return this.buffers[bufferView.buffer];
        };
        /**
         * 通过 Accessor 获取指定 BufferView。
         */
        GLTFAsset.prototype.getBufferView = function (accessor) {
            if (!this.config.bufferViews) {
                throw new Error();
            }
            return this.config.bufferViews[accessor.bufferView || 0];
        };
        /**
         * 通过 Accessor 索引，获取指定 Accessor。
         */
        GLTFAsset.prototype.getAccessor = function (index) {
            if (!this.config.accessors) {
                throw new Error();
            }
            return this.config.accessors[index];
        };
        /**
         * 获取节点。
         */
        GLTFAsset.prototype.getNode = function (index) {
            if (!this.config.nodes) {
                throw new Error();
            }
            return this.config.nodes[index];
        };
        /*
         * 获取动画剪辑。
         */
        GLTFAsset.prototype.getAnimationClip = function (name) {
            if (!this.config.animations ||
                this.config.animations.length === 0) {
                return null;
            }
            var animation = this.config.animations[0];
            if (animation.extensions.paper.clips.length === 0) {
                return null;
            }
            if (!name) {
                return animation.extensions.paper.clips[0];
            }
            for (var _i = 0, _a = this.config.animations; _i < _a.length; _i++) {
                var animation_1 = _a[_i];
                for (var _b = 0, _c = animation_1.extensions.paper.clips; _b < _c.length; _b++) {
                    var animationClip = _c[_b];
                    if (animationClip.name === name) {
                        return animationClip;
                    }
                }
            }
            return null;
        };
        GLTFAsset.prototype.caclByteLength = function () {
            return 0; // TODO
        };
        GLTFAsset.prototype.dispose = function () {
            if (this._isBuiltin) {
                return;
            }
            this.buffers.length = 0;
        };
        return GLTFAsset;
    }(paper.Asset));
    egret3d.GLTFAsset = GLTFAsset;
    __reflect(GLTFAsset.prototype, "egret3d.GLTFAsset");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var helpVec3_6 = new egret3d.Vector3();
    var helpVec3_7 = new egret3d.Vector3();
    // const helpVec3_8: Vector3 = new Vector3();
    /**
     * Mesh.
     * @version egret3D 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 网格模型。
     * @version egret3D 1.0
     * @platform Web
     * @language zh_CN
     */
    var Mesh = (function (_super) {
        __extends(Mesh, _super);
        function Mesh() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            /**
             * @internal
             */
            _this.vertexCount = 0;
            /**
             * true :所有subMesh公用一个buffer; false :每个subMesh使用单独的buffer
             * @internal
             */
            _this.isSharedBuffer = true;
            _this._drawMode = 1 /* Static */; // TODO
            /**
             * @internal
             */
            _this._version = 0;
            _this._glTFMeshIndex = 0;
            _this._glTFAsset = null;
            _this._glTFMesh = null;
            _this._vertexBuffer = null;
            /**
             * 暂时实现在这里，应实现到 gltf material。
             */
            _this._attributeType = {};
            /**
             * 暂时实现在这里，应该下放到 web，并将此方法抽象。
             */
            _this.ibos = [];
            _this.vbo = null;
            if (args.length === 0) {
                return _this;
            }
            if ((args[0] instanceof egret3d.GLTFAsset)) {
                _this._drawMode = args[2] || 1 /* Static */;
                _this._glTFMeshIndex = args[1];
                _this._glTFAsset = args[0];
            }
            else {
                var isSubIndexCountParameter = typeof args[2] === "number";
                var isAttributeTypeParameter = Array.isArray(args[4]);
                if (isAttributeTypeParameter) {
                    _this._drawMode = args[5] || 1 /* Static */;
                    _this._cacheMeshAttributeType(args[3], args[4]);
                }
                else {
                    _this._drawMode = (isSubIndexCountParameter ? args[4] : args[3]) || 1 /* Static */;
                }
                // Create gltf asset.
                _this._glTFAsset = egret3d.GLTFAsset.createGLTFAsset();
                _this._glTFAsset.config.buffers = [{ byteLength: 0 }];
                _this._glTFAsset.config.bufferViews = [{ buffer: 0, byteOffset: 0, byteLength: 0, target: 34962 /* ArrayBuffer */ }];
                _this._glTFAsset.config.accessors = [];
                _this._glTFMesh = { primitives: [{ attributes: { POSITION: 0 } }] };
                _this._glTFAsset.config.meshes = [_this._glTFMesh];
                //
                var attributeNames = (isSubIndexCountParameter ? args[3] : args[2]);
                var buffer = _this._glTFAsset.config.buffers[0];
                var vertexBufferView = _this._glTFAsset.config.bufferViews[0];
                var accessors = _this._glTFAsset.config.accessors;
                var primitive = _this._glTFMesh.primitives[0];
                var attributes = primitive.attributes;
                {
                    var isVertexCountParameter = typeof args[0] === "number";
                    var vertexBuffer = isVertexCountParameter ? null : args[0];
                    var count = isVertexCountParameter ? args[0] : _this._getVertexCountFromBuffer(vertexBuffer, attributeNames);
                    for (var _a = 0, attributeNames_1 = attributeNames; _a < attributeNames_1.length; _a++) {
                        var attributeName = attributeNames_1[_a];
                        // const type = GLTFAsset.getMeshAttributeType(attributeName);
                        var type = _this._getMeshAttributeType(attributeName);
                        var byteOffset = vertexBufferView.byteLength;
                        vertexBufferView.byteLength += count * egret3d.GLTFAsset.getAccessorTypeCount(type) * Float32Array.BYTES_PER_ELEMENT;
                        attributes[attributeName] = accessors.length;
                        accessors.push({
                            bufferView: 0,
                            byteOffset: byteOffset,
                            count: count,
                            componentType: 5126 /* Float */,
                            type: type,
                        });
                    }
                    buffer.byteLength = vertexBufferView.byteLength;
                    if (isVertexCountParameter) {
                        _this._glTFAsset.buffers[0] = new Float32Array(vertexBufferView.byteLength);
                    }
                    else {
                        _this._glTFAsset.buffers[0] = vertexBuffer;
                    }
                }
                if (args[1]) {
                    var isIndexCountParameter = typeof args[1] === "number";
                    var indexBuffer = isIndexCountParameter ? null : args[1];
                    var totalCount = isIndexCountParameter ? args[1] : indexBuffer.length;
                    var count = isSubIndexCountParameter ? args[2] : totalCount;
                    var indexBufferView = _this._glTFAsset.config.bufferViews[1] = {
                        buffer: 1,
                        byteOffset: 0,
                        byteLength: totalCount * egret3d.GLTFAsset.getAccessorTypeCount("SCALAR" /* SCALAR */) * Uint16Array.BYTES_PER_ELEMENT,
                        target: 34963 /* ElementArrayBuffer */,
                    };
                    primitive.indices = accessors.length;
                    accessors.push({
                        bufferView: 1, byteOffset: 0, count: count,
                        componentType: 5123 /* UnsignedShort */, type: "SCALAR" /* SCALAR */,
                    });
                    _this._glTFAsset.config.buffers[1] = { byteLength: indexBufferView.byteLength };
                    if (isIndexCountParameter) {
                        _this._glTFAsset.buffers[1] = new Uint16Array(indexBufferView.byteLength / Uint16Array.BYTES_PER_ELEMENT);
                    }
                    else {
                        _this._glTFAsset.buffers[1] = indexBuffer;
                    }
                }
            }
            _this.initialize();
            return _this;
        }
        Mesh.prototype._getDrawMode = function (mode) {
            var webgl = egret3d.WebGLCapabilities.webgl;
            switch (mode) {
                case 1 /* Static */:
                    return webgl.STATIC_DRAW;
                case 2 /* Dynamic */:
                    return webgl.DYNAMIC_DRAW;
                case 3 /* Stream */:
                    return webgl.STREAM_DRAW;
            }
            throw new Error();
        };
        Mesh.prototype._cacheVertexCount = function () {
            var primitives = this._glTFMesh.primitives;
            var isSameAccessor = true;
            var firstPosAccessor = primitives[0].attributes.POSITION;
            for (var i = 1; i < primitives.length; i++) {
                var posAccessor = primitives[i].attributes.POSITION;
                if (posAccessor !== firstPosAccessor) {
                    isSameAccessor = false;
                    break;
                }
            }
            this.vertexCount = 0;
            //
            if (isSameAccessor) {
                this.vertexCount = this.getVertexCount();
            }
            else {
                for (var i = 0; i < primitives.length; i++) {
                    this.vertexCount += this.getVertexCount(i);
                }
            }
        };
        Mesh.prototype._cacheMeshAttributeType = function (attributeNames, attributeTypes) {
            //
            if (attributeNames.length !== attributeTypes.length) {
                throw "_cacheMeshAttributeType: attributeNames.length is not equal attributeType.length";
            }
            for (var i = 0, l = attributeNames.length; i < l; i++) {
                this._attributeType[attributeNames[i]] = attributeTypes[i];
            }
        };
        Mesh.prototype._getMeshAttributeType = function (attributeName) {
            if (attributeName in this._attributeType) {
                return this._attributeType[attributeName];
            }
            return egret3d.GLTFAsset.getMeshAttributeType(attributeName);
        };
        Mesh.prototype._getVertexCountFromBuffer = function (vertexBuffer, attributeNames) {
            var vertexPerCount = 0;
            for (var _i = 0, attributeNames_2 = attributeNames; _i < attributeNames_2.length; _i++) {
                var attributeName = attributeNames_2[_i];
                // vertexPerCount += GLTFAsset.getAccessorTypeCount(GLTFAsset.getMeshAttributeType(attributeName));
                vertexPerCount += egret3d.GLTFAsset.getAccessorTypeCount(this._getMeshAttributeType(attributeName));
            }
            return vertexBuffer.length / vertexPerCount;
        };
        Mesh.prototype.serialize = function () {
            if (!this._glTFAsset.name) {
                return null;
            }
            var target = paper.createStruct(this);
            target._glTFMeshIndex = this._glTFMeshIndex;
            target._glTFAsset = paper.createAssetReference(this._glTFAsset);
            return target;
        };
        Mesh.prototype.deserialize = function (element) {
            this._glTFMeshIndex = element._glTFMeshIndex;
            this._glTFAsset = paper.getDeserializedAssetOrComponent(element._glTFAsset);
            this.initialize();
        };
        Mesh.prototype.dispose = function () {
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (this.vbo) {
                webgl.deleteBuffer(this.vbo);
            }
            for (var _i = 0, _a = this.ibos; _i < _a.length; _i++) {
                var ibo = _a[_i];
                webgl.deleteBuffer(ibo);
            }
            this.ibos.length = 0;
            this.vbo = null;
            this._glTFAsset = null;
            this._glTFMesh = null;
            this._vertexBuffer = null;
        };
        Mesh.prototype.caclByteLength = function () {
            return 0;
        };
        /**
         *
         */
        Mesh.prototype.clone = function () {
            return new Mesh(this._glTFAsset, this._glTFMeshIndex, this._drawMode);
        };
        /**
         *
         */
        Mesh.prototype.initialize = function (drawMode) {
            if (this._vertexBuffer) {
                // console.warn("The mesh instance bas been initialized.");
                // return;
            }
            var config = this._glTFAsset.config;
            if (!config.buffers ||
                !config.bufferViews ||
                !config.accessors ||
                !config.meshes ||
                config.meshes.length <= this._glTFMeshIndex) {
                console.error("Error glTF asset.");
                return;
            }
            this._glTFMesh = config.meshes[this._glTFMeshIndex];
            if (drawMode) {
                this._drawMode = drawMode;
            }
            //
            var vertexBufferViewAccessor = this._glTFAsset.getAccessor(this._glTFMesh.primitives[0].attributes.POSITION);
            this._vertexBuffer = this._glTFAsset.createTypeArrayFromBufferView(this._glTFAsset.getBufferView(vertexBufferViewAccessor), 5126 /* Float */);
            this._cacheVertexCount();
            // 暂时实现在这里，应该下放到 web，并将此类抽象。
            var webgl = egret3d.WebGLCapabilities.webgl;
            var vbo = webgl.createBuffer();
            if (vbo) {
                this.vbo = vbo;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                webgl.bufferData(webgl.ARRAY_BUFFER, this._vertexBuffer.byteLength, this._getDrawMode(this._drawMode));
                var subMeshIndex = 0;
                for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                    var primitive = _a[_i];
                    var attributeNames = [];
                    for (var k in primitive.attributes) {
                        attributeNames.push(k);
                    }
                    this.uploadSubVertexBuffer(attributeNames, subMeshIndex);
                    if (primitive.indices !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(primitive.indices);
                        var ibo = webgl.createBuffer();
                        if (ibo) {
                            this.ibos.push(ibo);
                            webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                            webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this._glTFAsset.getBufferLength(accessor), this._getDrawMode(this._drawMode));
                            this.uploadSubIndexBuffer(subMeshIndex);
                        }
                        else {
                            this.ibos.push(null);
                            console.log("Create webgl element buffer error.");
                        }
                    }
                    else {
                        this.ibos.push(null);
                    }
                    subMeshIndex++;
                }
            }
            else {
                console.log("Create webgl buffer error.");
            }
        };
        /**
         * @internal
         */
        Mesh.prototype.addSubMesh = function (indexOffset, indexCount, materialIndex, sourceSubMeshIndex) {
            if (materialIndex === void 0) { materialIndex = 0; }
            if (sourceSubMeshIndex === void 0) { sourceSubMeshIndex = 0; }
            if (0 <= sourceSubMeshIndex && sourceSubMeshIndex < this._glTFMesh.primitives.length) {
                this._glTFAsset.config.accessors = this._glTFAsset.config.accessors || [];
                //
                var sourcePrimitive = this._glTFMesh.primitives[sourceSubMeshIndex];
                var sourceIndiceAccessor = this._glTFAsset.getAccessor(sourcePrimitive.indices || 0);
                var primitive = {
                    attributes: sourcePrimitive.attributes,
                    indices: this._glTFAsset.config.accessors.length,
                    material: materialIndex,
                };
                this._glTFMesh.primitives.push(primitive);
                this._glTFAsset.config.accessors.push({
                    bufferView: sourceIndiceAccessor.bufferView,
                    byteOffset: indexOffset * egret3d.GLTFAsset.getComponentTypeCount(5123 /* UnsignedShort */) * egret3d.GLTFAsset.getAccessorTypeCount("SCALAR" /* SCALAR */),
                    count: indexCount,
                    componentType: 5123 /* UnsignedShort */,
                    type: "SCALAR" /* SCALAR */,
                });
                var accessor = this._glTFAsset.getAccessor(primitive.indices);
                var webgl = egret3d.WebGLCapabilities.webgl;
                var ibo = webgl.createBuffer();
                if (ibo) {
                    this.ibos.push(ibo);
                    webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                    webgl.bufferData(webgl.ELEMENT_ARRAY_BUFFER, this._glTFAsset.getBufferLength(accessor), this._getDrawMode(this._drawMode));
                }
                else {
                    this.ibos.push(null);
                    console.log("Create webgl element buffer error.");
                }
                return this._glTFMesh.primitives.length - 1;
            }
            console.warn("Error arguments.");
            return -1;
        };
        Mesh.prototype.getVertexCount = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessor = this._glTFAsset.getAccessor(this._glTFMesh.primitives[subMeshIndex].attributes.POSITION);
                return accessor.count;
            }
            console.warn("Error arguments.");
            return 0;
        };
        Mesh.prototype.getVertices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("POSITION" /* POSITION */, subMeshIndex);
        };
        Mesh.prototype.getUVs = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */, subMeshIndex);
        };
        Mesh.prototype.getColors = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("COLOR_0" /* COLOR_0 */, subMeshIndex);
        };
        Mesh.prototype.getNormals = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("NORMAL" /* NORMAL */, subMeshIndex);
        };
        Mesh.prototype.getTangents = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            return this.getAttributes("TANGENT" /* TANGENT */, subMeshIndex);
        };
        Mesh.prototype.getAttributes = function (attributeType, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (accessorIndex === undefined) {
                    return null;
                }
                var accessor = this._glTFAsset.getAccessor(accessorIndex);
                return this._glTFAsset.createTypeArrayFromAccessor(accessor);
            }
            console.warn("Error arguments.");
            return null;
        };
        Mesh.prototype.getIndices = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var accessorIndex = this._glTFMesh.primitives[subMeshIndex].indices;
                if (accessorIndex === undefined) {
                    return null;
                }
                var accessor = this._glTFAsset.getAccessor(accessorIndex);
                return this._glTFAsset.createTypeArrayFromAccessor(accessor);
            }
            console.warn("Error arguments.");
            return null;
        };
        Mesh.prototype.uploadVertexSubData = function (uploadAttributes, startVertexIndex, vertexCount, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                var attributes = primitive.attributes;
                for (var _i = 0, uploadAttributes_1 = uploadAttributes; _i < uploadAttributes_1.length; _i++) {
                    var attributeName = uploadAttributes_1[_i];
                    var accessorIndex = attributes[attributeName];
                    if (accessorIndex !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(accessorIndex);
                        var compType = egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType);
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        var startOffset = this._glTFAsset.getBufferOffset(accessor);
                        var bufferOffset = startOffset + startVertexIndex * typeCount * compType;
                        var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        var letray = new Float32Array(subVertexBuffer.buffer, bufferOffset, typeCount * vertexCount);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, letray);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                this._version++;
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 暂时实现在这里，应该下放到 web，并将此方法抽象。
         */
        Mesh.prototype.uploadSubVertexBuffer = function (uploadAttributes, subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                var attributes = primitive.attributes;
                webgl.bindBuffer(webgl.ARRAY_BUFFER, this.vbo);
                if (typeof uploadAttributes === "string") {
                    var accessorIndex = attributes[uploadAttributes];
                    if (accessorIndex !== undefined) {
                        var accessor = this._glTFAsset.getAccessor(accessorIndex);
                        var bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                        var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                    }
                    else {
                        console.warn("Error arguments.");
                    }
                }
                else {
                    for (var _i = 0, uploadAttributes_2 = uploadAttributes; _i < uploadAttributes_2.length; _i++) {
                        var attributeName = uploadAttributes_2[_i];
                        var accessorIndex = attributes[attributeName];
                        if (accessorIndex !== undefined) {
                            var accessor = this._glTFAsset.getAccessor(accessorIndex);
                            var bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                            var subVertexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                            webgl.bufferSubData(webgl.ARRAY_BUFFER, bufferOffset, subVertexBuffer);
                        }
                        else {
                            console.warn("Error arguments.");
                        }
                    }
                }
                this._version++;
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 暂时实现在这里，应该下放到 web，并将此方法抽象。
         */
        Mesh.prototype.uploadSubIndexBuffer = function (subMeshIndex) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var primitive = this._glTFMesh.primitives[subMeshIndex];
                if (primitive.indices !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(primitive.indices);
                    // const bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                    var subIndexBuffer = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                    var ibo = this.ibos[subMeshIndex];
                    if (ibo) {
                        webgl.bindBuffer(webgl.ELEMENT_ARRAY_BUFFER, ibo);
                        //ibo每个单独上传，偏移一直是0
                        webgl.bufferSubData(webgl.ELEMENT_ARRAY_BUFFER, 0, subIndexBuffer);
                        this._version++;
                    }
                    else {
                        console.error("Error webgl element buffer.");
                    }
                }
                else {
                    console.warn("Error arguments.");
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        /**
         * 检测射线碰撞
         * @param ray 射线
         * @param matrix 所在transform的矩阵
         *
         */
        Mesh.prototype.intersects = function (ray, matrix) {
            var pickInfo = null; // TODO
            var subMeshIndex = 0;
            for (var _i = 0, _a = this._glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                if (primitive.mode === 1 /* Lines */ ||
                    primitive.mode === 2 /* LineLoop */ ||
                    primitive.mode === 3 /* LineStrip */) {
                }
                else {
                    if (primitive.indices === undefined) {
                        // 不使用index TODO
                    }
                    else {
                        var indices = this.getIndices(subMeshIndex);
                        if (indices) {
                            var t0 = helpVec3_1;
                            var t1 = helpVec3_2;
                            var t2 = helpVec3_3;
                            var vertices = this.getVertices(subMeshIndex);
                            for (var i = 0; i < indices.length; i += 3) {
                                var p0 = helpVec3_4;
                                var p1 = helpVec3_5;
                                var p2 = helpVec3_6;
                                var index = indices[i] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p0);
                                index = indices[i + 1] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p1);
                                index = indices[i + 2] * 3;
                                egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p2);
                                egret3d.Matrix.transformVector3(p0, matrix, t0);
                                egret3d.Matrix.transformVector3(p1, matrix, t1);
                                egret3d.Matrix.transformVector3(p2, matrix, t2);
                                var result = ray.intersectsTriangle(t0, t1, t2);
                                if (result) {
                                    if (result.distance < 0) {
                                        continue;
                                    }
                                    if (!pickInfo || pickInfo.distance > result.distance) {
                                        pickInfo = result;
                                        pickInfo.triangleIndex = i / 3;
                                        pickInfo.subMeshIndex = i;
                                        var tdir = helpVec3_7;
                                        egret3d.Vector3.copy(ray.direction, tdir);
                                        egret3d.Vector3.scale(tdir, result.distance);
                                        egret3d.Vector3.add(ray.origin, tdir, pickInfo.position);
                                    }
                                }
                            }
                        }
                    }
                }
                subMeshIndex++;
            }
            return pickInfo;
        };
        Object.defineProperty(Mesh.prototype, "subMeshCount", {
            /**
             * 获取子网格数量。
             */
            get: function () {
                return this._glTFMesh.primitives.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFAsset", {
            /**
             * 获取 mesh 数据所属的 glTF 资源。
             */
            get: function () {
                return this._glTFAsset;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Mesh.prototype, "glTFMesh", {
            /**
             * 获取 glTFMesh 数据。
             */
            get: function () {
                return this._glTFMesh;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @deprecated
         */
        Mesh.prototype.getAttribute = function (vertexIndex, attributeType, subMeshIndex, result) {
            if (subMeshIndex === void 0) { subMeshIndex = 0; }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var attributeIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (attributeIndex !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(attributeIndex);
                    if (0 <= vertexIndex && vertexIndex < accessor.count) {
                        // const bufferOffset = this._glTFAsset.getBufferOffset(accessor);
                        // const typeCount= GLTFAsset.getComponentTypeCount(accessor.componentType);
                        // const offset = bufferOffset / typeCount + vertexIndex * typeCount;
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        var offset = vertexIndex * typeCount;
                        var buffers = this._glTFAsset.createTypeArrayFromAccessor(accessor);
                        switch (accessor.type) {
                            case "VEC2" /* VEC2 */: {
                                if (!result) {
                                    result = new egret3d.Vector2();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                break;
                            }
                            case "VEC3" /* VEC3 */: {
                                if (!result) {
                                    result = new egret3d.Vector3();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                result.z = buffers[offset + 2];
                                break;
                            }
                            case "VEC4" /* VEC4 */: {
                                if (!result) {
                                    result = new egret3d.Vector4();
                                }
                                result.x = buffers[offset];
                                result.y = buffers[offset + 1];
                                result.z = buffers[offset + 2];
                                result.w = buffers[offset + 3];
                                break;
                            }
                        }
                        return result;
                    }
                }
            }
            console.warn("Error arguments.");
            return result;
        };
        /**
         * @deprecated
         */
        Mesh.prototype.setAttribute = function (vertexIndex, attributeType, subMeshIndex) {
            var args = [];
            for (var _i = 3; _i < arguments.length; _i++) {
                args[_i - 3] = arguments[_i];
            }
            if (0 <= subMeshIndex && subMeshIndex < this._glTFMesh.primitives.length) {
                var attributeIndex = this._glTFMesh.primitives[subMeshIndex].attributes[attributeType];
                if (attributeIndex !== undefined) {
                    var accessor = this._glTFAsset.getAccessor(attributeIndex);
                    if (0 <= vertexIndex && vertexIndex < accessor.count) {
                        var offset = this._glTFAsset.getBufferOffset(accessor) / egret3d.GLTFAsset.getComponentTypeCount(accessor.componentType) + vertexIndex * egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        switch (accessor.type) {
                            case "SCALAR" /* SCALAR */: {
                                this._vertexBuffer[offset] = args[0];
                                break;
                            }
                            case "VEC2" /* VEC2 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                break;
                            }
                            case "VEC3" /* VEC3 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                this._vertexBuffer[offset + 2] = args[2];
                                break;
                            }
                            case "VEC4" /* VEC4 */: {
                                this._vertexBuffer[offset] = args[0];
                                this._vertexBuffer[offset + 1] = args[1];
                                this._vertexBuffer[offset + 2] = args[2];
                                this._vertexBuffer[offset + 3] = args[3];
                                break;
                            }
                        }
                    }
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_drawMode", void 0);
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_glTFMeshIndex", void 0);
        __decorate([
            paper.serializedField
        ], Mesh.prototype, "_glTFAsset", void 0);
        return Mesh;
    }(paper.SerializableObject));
    egret3d.Mesh = Mesh;
    __reflect(Mesh.prototype, "egret3d.Mesh");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var BeginSystem = (function (_super) {
        __extends(BeginSystem, _super);
        function BeginSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        BeginSystem.prototype.onAwake = function () {
            this._globalGameObject.getOrAddComponent(egret3d.DefaultMaterials);
            this._globalGameObject.getOrAddComponent(egret3d.WebGLCapabilities);
            paper.Time = this._globalGameObject.getOrAddComponent(paper.Clock);
        };
        BeginSystem.prototype.onUpdate = function () {
            //
            egret3d.Performance.startCounter("all" /* All */);
            //
            egret3d.stage.update();
        };
        return BeginSystem;
    }(paper.BaseSystem));
    egret3d.BeginSystem = BeginSystem;
    __reflect(BeginSystem.prototype, "egret3d.BeginSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var EndSystem = (function (_super) {
        __extends(EndSystem, _super);
        function EndSystem() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        EndSystem.prototype.onUpdate = function (deltaTime) {
            //
            egret3d.InputManager.update(deltaTime);
            //
            egret3d.Performance.updateFPS();
            egret3d.Performance.endCounter("all" /* All */);
        };
        return EndSystem;
    }(paper.BaseSystem));
    egret3d.EndSystem = EndSystem;
    __reflect(EndSystem.prototype, "egret3d.EndSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Pool = (function () {
        function Pool() {
            this._instances = [];
        }
        Pool.prototype.clear = function () {
            this._instances.length = 0;
        };
        Pool.prototype.add = function (instanceOrInstances) {
            if (Array.isArray(instanceOrInstances)) {
                for (var _i = 0, instanceOrInstances_1 = instanceOrInstances; _i < instanceOrInstances_1.length; _i++) {
                    var instance = instanceOrInstances_1[_i];
                    if (this._instances.indexOf(instance) < 0) {
                        this._instances.push(instance);
                    }
                }
            }
            else {
                if (this._instances.indexOf(instanceOrInstances) < 0) {
                    this._instances.push(instanceOrInstances);
                }
            }
        };
        Pool.prototype.remove = function (instanceOrInstances) {
            if (Array.isArray(instanceOrInstances)) {
                for (var _i = 0, instanceOrInstances_2 = instanceOrInstances; _i < instanceOrInstances_2.length; _i++) {
                    var instance = instanceOrInstances_2[_i];
                    var index = this._instances.indexOf(instance);
                    if (index >= 0) {
                        this._instances.splice(index, 1);
                    }
                }
            }
            else {
                var index = this._instances.indexOf(instanceOrInstances);
                if (index >= 0) {
                    this._instances.splice(index, 1);
                }
            }
        };
        Pool.prototype.get = function () {
            return this._instances.pop() || null;
        };
        Object.defineProperty(Pool.prototype, "instances", {
            get: function () {
                return this._instances;
            },
            enumerable: true,
            configurable: true
        });
        return Pool;
    }());
    egret3d.Pool = Pool;
    __reflect(Pool.prototype, "egret3d.Pool");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpMat4 = new egret3d.Matrix();
    var helpQuat4 = new egret3d.Quaternion();
    var helpQuat4_2 = new egret3d.Quaternion();
    var helpVector = new egret3d.Vector3();
    var helpRotation = new egret3d.Quaternion();
    var helpUp = new egret3d.Vector3(0, 1, 0);
    var helpRight = new egret3d.Vector3(1, 0, 0);
    var helpFoward = new egret3d.Vector3(0, 0, 1);
    /**
     * Transform Class
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * Transform实例可以被添加到3D场景中，并持有一个GameObejct实例
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Transform = (function (_super) {
        __extends(Transform, _super);
        function Transform() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._dirtyAABB = true;
            _this._dirtyLocal = true;
            _this._dirtyWorld = true;
            /**
             * 世界矩阵的行列式，如果小于0，说明进行了反转
             * @internal
             */
            _this._worldMatrixDeterminant = 0.0;
            _this.localMatrix = new egret3d.Matrix();
            _this.worldMatrix = new egret3d.Matrix();
            _this.localPosition = new egret3d.Vector3();
            _this.position = new egret3d.Vector3();
            _this.localRotation = new egret3d.Quaternion();
            _this.rotation = new egret3d.Quaternion();
            _this.localEulerAngles = new egret3d.Vector3();
            _this.eulerAngles = new egret3d.Vector3();
            _this.localScale = new egret3d.Vector3(1.0, 1.0, 1.0);
            _this.scale = new egret3d.Vector3(1.0, 1.0, 1.0);
            /**
             * @internal
             */
            _this._children = [];
            _this._aabb = null;
            /**
             * @internal
             */
            _this._parent = null;
            return _this;
        }
        Transform_1 = Transform;
        Transform.prototype._removeFromChildren = function (value) {
            var index = 0;
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                if (child === value) {
                    this._children.splice(index, 1);
                    break;
                }
                index++;
            }
        };
        Transform.prototype._buildAABB = function () {
            var vertexPosition = new egret3d.Vector3();
            var minimum = new egret3d.Vector3();
            var maximum = new egret3d.Vector3();
            var filter = this.gameObject.getComponent(egret3d.MeshFilter);
            if (filter && filter.mesh) {
                egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                var subMeshIndex = 0;
                for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                    var _primitive = _a[_i];
                    var vertices = filter.mesh.getVertices(subMeshIndex);
                    for (var i = 0, l = vertices.length; i < l; i += 3) {
                        egret3d.Vector3.set(vertices[i], vertices[i + 1], vertices[i + 2], vertexPosition);
                        egret3d.Vector3.max(vertexPosition, maximum, maximum);
                        egret3d.Vector3.min(vertexPosition, minimum, minimum);
                    }
                    subMeshIndex++;
                }
            }
            else {
                var skinmesh = this.gameObject.getComponent(egret3d.SkinnedMeshRenderer);
                if (skinmesh && skinmesh.mesh) {
                    egret3d.Vector3.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, minimum);
                    egret3d.Vector3.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE, maximum);
                    var subMeshIndex = 0;
                    for (var _b = 0, _c = skinmesh.mesh.glTFMesh.primitives; _b < _c.length; _b++) {
                        var _primitive = _c[_b];
                        var vertices = skinmesh.mesh.getVertices(subMeshIndex);
                        for (var i = 0, l = vertices.length; i < l; i += 3) {
                            egret3d.Vector3.set(vertices[i], vertices[i + 1], vertices[i + 2], vertexPosition);
                            egret3d.Vector3.max(vertexPosition, maximum, maximum);
                            egret3d.Vector3.min(vertexPosition, minimum, minimum);
                        }
                        subMeshIndex++;
                    }
                }
                else {
                    minimum.x = -1;
                    minimum.y = -1;
                    minimum.z = -1;
                    maximum.x = 1;
                    maximum.y = 1;
                    maximum.z = 1;
                }
            }
            var aabb = new egret3d.AABB(minimum, maximum);
            return aabb;
        };
        Transform.prototype._sync = function () {
            if (this._dirtyLocal) {
                egret3d.Matrix.fromRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                this._dirtyLocal = false;
            }
            if (this._dirtyWorld) {
                if (!this._parent) {
                    egret3d.Matrix.copy(this.localMatrix, this.worldMatrix);
                }
                else {
                    egret3d.Matrix.multiply(this._parent.worldMatrix, this.localMatrix, this.worldMatrix);
                }
                this._worldMatrixDeterminant = egret3d.Matrix.determinant(this.worldMatrix);
                this._dirtyWorld = false;
            }
        };
        Transform.prototype._dirtify = function (local) {
            if (local === void 0) { local = false; }
            if ((!local || (local && this._dirtyLocal)) && this._dirtyWorld) {
                return;
            }
            if (local) {
                this._dirtyLocal = true;
            }
            if (!this._dirtyWorld) {
                this._dirtyWorld = true;
                var i = this._children.length;
                while (i--) {
                    if (this._children[i]._dirtyWorld) {
                        continue;
                    }
                    this._children[i]._dirtify();
                }
            }
            // transform dirty
            this._dirtyAABB = true;
        };
        /**
         * 父节点发生改变的回调方法
         * 子类可通过重载此方法进行标脏状态传递
         */
        Transform.prototype._onParentChange = function (newParent, oldParent) {
            var prevActive = oldParent ? oldParent.gameObject.activeInHierarchy : this.gameObject.activeSelf;
            if ((newParent ? newParent.gameObject.activeInHierarchy : this.gameObject.activeSelf) !== prevActive) {
                this.gameObject._activeInHierarchyDirty(prevActive);
            }
            this._dirtify();
        };
        Transform.prototype._getAllChildren = function (children) {
            for (var _i = 0, _a = this._children; _i < _a.length; _i++) {
                var child = _a[_i];
                children.push(child);
                child._getAllChildren(children);
            }
        };
        /**
         * @internal
         */
        Transform.prototype.getAllChildren = function () {
            var children = [];
            this._getAllChildren(children);
            return children;
        };
        /**
         * 设置父节点
         */
        Transform.prototype.setParent = function (newParent, worldPositionStays) {
            if (worldPositionStays === void 0) { worldPositionStays = false; }
            var oldParent = this._parent;
            if (oldParent === newParent) {
                return;
            }
            if (worldPositionStays) {
                egret3d.Vector3.copy(this.getPosition(), egret3d.helpVector3A);
            }
            if (oldParent) {
                oldParent._removeFromChildren(this);
            }
            if (newParent) {
                newParent._children.push(this);
            }
            this._parent = newParent;
            this._onParentChange(newParent, oldParent);
            if (worldPositionStays) {
                this.setPosition(egret3d.helpVector3A);
            }
        };
        Transform.prototype.getChildIndex = function (value) {
            if (value.parent !== this) {
                return -1;
            }
            return this._children.indexOf(value);
        };
        Transform.prototype.setChildIndex = function (value, index) {
            if (value.parent !== this) {
                return;
            }
            var prevIndex = this._children.indexOf(value);
            if (prevIndex === index) {
                return;
            }
            this._children.splice(prevIndex, 1);
            this._children.splice(index, 0, value);
        };
        /**
         * 获取对象下标的子集对象
         * @param index
         */
        Transform.prototype.getChildAt = function (index) {
            return 0 <= index && index < this._children.length ? this._children[index] : null;
        };
        /**
         * get local matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalMatrix = function () {
            if (this._dirtyLocal) {
                egret3d.Matrix.fromRTS(this.localPosition, this.localScale, this.localRotation, this.localMatrix);
                this._dirtyLocal = false;
            }
            return this.localMatrix;
        };
        /**
         * get world matrix
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得世界矩阵
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getWorldMatrix = function () {
            if (!this._dirtyLocal && !this._dirtyWorld) {
                return this.worldMatrix;
            }
            if (this._parent) {
                this._parent.getWorldMatrix();
            }
            this._sync();
            return this.worldMatrix;
        };
        /**
         * get local position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalPosition = function () {
            return this.localPosition;
        };
        Transform.prototype.setLocalPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, this.localPosition);
            }
            else {
                this.localPosition.x = p1;
                this.localPosition.y = p2 || 0;
                this.localPosition.z = p3 || 0;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getPosition = function () {
            egret3d.Matrix.getTranslation(this.getWorldMatrix(), this.position);
            return this.position;
        };
        Transform.prototype.setPosition = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, helpVec3);
            }
            else {
                helpVec3.x = p1;
                helpVec3.y = p2 || 0;
                helpVec3.z = p3 || 0;
            }
            if (!this._parent) {
                egret3d.Vector3.copy(helpVec3, this.localPosition);
            }
            else {
                egret3d.Matrix.inverse(this._parent.getWorldMatrix(), helpMat4);
                egret3d.Matrix.transformVector3(helpVec3, helpMat4, this.localPosition); // transform point
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalRotation = function () {
            return this.localRotation;
        };
        Transform.prototype.setLocalRotation = function (p1, p2, p3, p4) {
            if (p1.hasOwnProperty("x")) {
                this.localRotation.copy(p1);
            }
            else {
                this.localRotation.x = p1;
                this.localRotation.y = p2 || 0;
                this.localRotation.z = p3 || 0;
                this.localRotation.w = p4 !== undefined ? p4 : 1;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get rotation
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得旋转
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRotation = function () {
            egret3d.Quaternion.fromMatrix(this.getWorldMatrix(), this.rotation);
            return this.rotation;
        };
        Transform.prototype.setRotation = function (q1, q2, q3, q4) {
            if (q1.hasOwnProperty("x")) {
                egret3d.Quaternion.copy(q1, helpQuat4);
            }
            else {
                helpQuat4.x = q1;
                helpQuat4.y = q2 || 0;
                helpQuat4.z = q3 || 0;
                helpQuat4.w = q4 !== undefined ? q4 : 1;
            }
            if (!this._parent) {
                egret3d.Quaternion.copy(helpQuat4, this.localRotation);
            }
            else {
                var parentRot = this._parent.getRotation();
                egret3d.Quaternion.copy(parentRot, helpQuat4_2);
                egret3d.Quaternion.multiply(helpQuat4_2.inverse(), helpQuat4, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取本地欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalEulerAngles = function () {
            egret3d.Quaternion.toEulerAngles(this.localRotation, this.localEulerAngles);
            return this.localEulerAngles;
        };
        Transform.prototype.setLocalEulerAngles = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                p1 = p1;
                egret3d.Quaternion.fromEulerAngles(p1.x, p1.y, p1.z, this.localRotation);
            }
            else {
                egret3d.Quaternion.fromEulerAngles(p1, p2, p3, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get euler angles
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取欧拉角
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getEulerAngles = function () {
            egret3d.Matrix.toEulerAngles(this.getWorldMatrix(), this.eulerAngles);
            return this.eulerAngles;
        };
        Transform.prototype.setEulerAngles = function (q1, q2, q3) {
            if (q1.hasOwnProperty("x")) {
                q1 = q1;
                egret3d.Quaternion.fromEulerAngles(q1.x, q1.y, q1.z, helpQuat4);
            }
            else {
                egret3d.Quaternion.fromEulerAngles(q1, q2 || 0, q3 || 0, helpQuat4);
            }
            if (!this._parent) {
                egret3d.Quaternion.copy(helpQuat4, this.localRotation);
            }
            else {
                var parentRot = this._parent.getRotation();
                egret3d.Quaternion.copy(parentRot, helpQuat4_2);
                egret3d.Quaternion.multiply(helpQuat4_2.inverse(), helpQuat4, this.localRotation);
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get local scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得本地缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getLocalScale = function () {
            return this.localScale;
        };
        Transform.prototype.setLocalScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, this.localScale);
            }
            else {
                this.localScale.x = p1;
                this.localScale.y = p2 !== undefined ? p2 : 1;
                this.localScale.z = p3 !== undefined ? p3 : 1;
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * get scale
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获得缩放
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getScale = function () {
            egret3d.Matrix.getScale(this.getWorldMatrix(), this.scale);
            return this.scale;
        };
        Transform.prototype.setScale = function (p1, p2, p3) {
            if (p1.hasOwnProperty("x")) {
                egret3d.Vector3.copy(p1, helpVec3);
            }
            else {
                helpVec3.x = p1;
                helpVec3.y = p2 !== undefined ? p2 : 1;
                helpVec3.z = p3 !== undefined ? p3 : 1;
            }
            if (!this._parent) {
                egret3d.Vector3.copy(helpVec3, this.localScale);
            }
            else {
                egret3d.Matrix.inverse(this._parent.getWorldMatrix(), helpMat4);
                egret3d.Matrix.transformVector3(helpVec3, helpMat4, this.localScale); // transform vector3
            }
            if (!this._dirtyLocal) {
                this._dirtify(true);
            }
        };
        /**
         * look at a target
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 旋转当前transform 到指定的目标
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.lookAt = function (target, up) {
            if (target instanceof Transform_1) {
                egret3d.Vector3.copy(target.getPosition(), helpVector);
            }
            else {
                egret3d.Vector3.copy(target, helpVector);
            }
            if (up === undefined) {
                egret3d.Quaternion.lookAt(this.getPosition(), helpVector, helpRotation);
            }
            else {
                egret3d.Quaternion.lookAtWithUp(this.getPosition(), helpVector, up, helpRotation);
            }
            this.setRotation(helpRotation);
        };
        /**
         * z-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前z轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getForward = function (out) {
            egret3d.Matrix.transformNormal(helpFoward, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
            return out;
        };
        /**
         * x-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前x轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getRight = function (out) {
            egret3d.Matrix.transformNormal(helpRight, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
        };
        /**
         * y-axis towards in world space
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取世界坐标系下当前y轴的朝向
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        Transform.prototype.getUp = function (out) {
            egret3d.Matrix.transformNormal(helpUp, this.getWorldMatrix(), out);
            egret3d.Vector3.normalize(out);
        };
        /**
         * Finds a child by name or path and returns it.
         * @param nameOrPath
         */
        Transform.prototype.find = function (nameOrPath) {
            var names = nameOrPath.split("/");
            var ancestor = this;
            var result = null;
            for (var _i = 0, names_1 = names; _i < names_1.length; _i++) {
                var name_1 = names_1[_i];
                for (var _a = 0, _b = ancestor._children; _a < _b.length; _a++) {
                    var child = _b[_a];
                    if (child.gameObject.name === name_1) {
                        result = child;
                        break;
                    }
                }
                if (result) {
                    ancestor = result;
                }
                else {
                    break;
                }
            }
            return result;
        };
        Object.defineProperty(Transform.prototype, "childCount", {
            /**
             * 当前子集对象的数量
             */
            get: function () {
                return this._children.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "aabb", {
            /**
             *
             */
            get: function () {
                if (!this._aabb) {
                    this._aabb = this._buildAABB();
                }
                if (this._dirtyAABB) {
                    this._aabb.update(this.getWorldMatrix());
                    this._dirtyAABB = false;
                }
                return this._aabb;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "children", {
            /**
             * children list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 子物体列表
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._children;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Transform.prototype, "parent", {
            /**
             * instance of parent transform
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 父元素实例
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                return this._parent;
            },
            set: function (value) {
                this.setParent(value, false);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.VECTOR3, { set: "setLocalPosition" })
        ], Transform.prototype, "localPosition", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setPosition" })
        ], Transform.prototype, "position", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.QUATERNION, { set: "setLocalRotation" })
        ], Transform.prototype, "localRotation", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.QUATERNION, { set: "setRotation" })
        ], Transform.prototype, "rotation", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setLocalEulerAngles" })
        ], Transform.prototype, "localEulerAngles", void 0);
        __decorate([
            paper.serializedField,
            paper.editor.property(paper.editor.EditType.VECTOR3, { set: "setLocalScale" })
        ], Transform.prototype, "localScale", void 0);
        __decorate([
            paper.editor.extraProperty(paper.editor.EditType.VECTOR3, { set: "setScale" })
        ], Transform.prototype, "scale", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Transform.prototype, "children", null);
        Transform = Transform_1 = __decorate([
            paper.disallowMultiple
        ], Transform);
        return Transform;
        var Transform_1;
    }(paper.BaseComponent));
    egret3d.Transform = Transform;
    __reflect(Transform.prototype, "egret3d.Transform");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DefaultMaterials = (function (_super) {
        __extends(DefaultMaterials, _super);
        function DefaultMaterials() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        DefaultMaterials.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            DefaultMaterials.DefaultDiffuse = new egret3d.Material(egret3d.DefaultShaders.DIFFUSE);
            DefaultMaterials.MissingMaterial = new egret3d.Material(egret3d.DefaultShaders.GIZMOS_COLOR);
            DefaultMaterials.MissingMaterial.setVector4v("_Color", new Float32Array([1.0, 0.0, 1.0, 1.0]));
            DefaultMaterials.Line = new egret3d.Material(egret3d.DefaultShaders.LINE);
            DefaultMaterials.ShadowDepth = new egret3d.Material(egret3d.DefaultShaders.SHADOW_DEPTH);
            DefaultMaterials.ShadowDistance = new egret3d.Material(egret3d.DefaultShaders.SHADOW_DISTANCE);
        };
        return DefaultMaterials;
    }(paper.SingletonComponent));
    egret3d.DefaultMaterials = DefaultMaterials;
    __reflect(DefaultMaterials.prototype, "egret3d.DefaultMaterials");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var CamerasAndLights = (function (_super) {
        __extends(CamerasAndLights, _super);
        function CamerasAndLights() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.cameras = [];
            _this.lights = [];
            return _this;
        }
        CamerasAndLights.prototype._sortCamera = function (a, b) {
            return a.order - b.order;
        };
        CamerasAndLights.prototype.updateCamera = function (gameObjects) {
            this.cameras.length = 0;
            for (var _i = 0, gameObjects_1 = gameObjects; _i < gameObjects_1.length; _i++) {
                var gameObject = gameObjects_1[_i];
                this.cameras.push(gameObject.getComponent(egret3d.Camera));
            }
        };
        CamerasAndLights.prototype.updateLight = function (gameObjects) {
            this.lights.length = 0;
            for (var _i = 0, gameObjects_2 = gameObjects; _i < gameObjects_2.length; _i++) {
                var gameObject = gameObjects_2[_i];
                this.lights.push(gameObject.getComponent(egret3d.BaseLight, true));
            }
        };
        CamerasAndLights.prototype.sort = function () {
            this.cameras.sort(this._sortCamera);
        };
        return CamerasAndLights;
    }(paper.SingletonComponent));
    egret3d.CamerasAndLights = CamerasAndLights;
    __reflect(CamerasAndLights.prototype, "egret3d.CamerasAndLights");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DrawCalls = (function (_super) {
        __extends(DrawCalls, _super);
        function DrawCalls() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 参与渲染的渲染器列表。
             */
            _this.renderers = [];
            /**
             * 所有的 draw call 列表。
             */
            _this.drawCalls = [];
            /**
             * 非透明列表
             */
            _this.opaqueCalls = [];
            /**
             * 透明列表
             */
            _this.transparentCalls = [];
            /**
             * 阴影列表
             */
            _this.shadowCalls = [];
            return _this;
        }
        /**
         * 所有非透明的, 按照从近到远排序
         * @param a
         * @param b
         */
        DrawCalls.prototype._sortOpaque = function (a, b) {
            if (a.material.renderQueue !== b.material.renderQueue) {
                return a.material.renderQueue - b.material.renderQueue;
            }
            else if (a.material._glTFTechnique.program && b.material._glTFTechnique.program && a.material._glTFTechnique.program.id !== b.material._glTFTechnique.program.id) {
                return a.material._glTFTechnique.program.id - b.material._glTFTechnique.program.id;
            }
            else if (a.material.id !== b.material.id) {
                return a.material.id - b.material.id;
            }
            else {
                return a.zdist - b.zdist;
            }
        };
        /**
         * 所有透明的，按照从远到近排序
         * @param a
         * @param b
         */
        DrawCalls.prototype._sortTransparent = function (a, b) {
            if (a.material.renderQueue === b.material.renderQueue) {
                return b.zdist - a.zdist;
            }
            else {
                return a.material.renderQueue - b.material.renderQueue;
            }
        };
        DrawCalls.prototype.shadowFrustumCulling = function (camera) {
            this.shadowCalls.length = 0;
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var drawTarget = drawCall.renderer.gameObject;
                var visible = (camera.cullingMask & drawTarget.layer) !== 0;
                if (visible && drawCall.renderer.castShadows) {
                    if (!drawCall.frustumTest || (drawCall.frustumTest && camera.testFrustumCulling(drawTarget.transform))) {
                        this.shadowCalls.push(drawCall);
                    }
                }
            }
        };
        DrawCalls.prototype.sortAfterFrustumCulling = function (camera) {
            //每次根据视锥裁切填充TODO，放到StartSystem
            this.opaqueCalls.length = 0;
            this.transparentCalls.length = 0;
            var cameraPos = camera.gameObject.transform.getPosition();
            //
            for (var _i = 0, _a = this.drawCalls; _i < _a.length; _i++) {
                var drawCall = _a[_i];
                var drawTarget = drawCall.renderer.gameObject;
                var visible = ((camera.cullingMask & drawTarget.layer) !== 0 && (!drawCall.frustumTest || (drawCall.frustumTest && camera.testFrustumCulling(drawTarget.transform))));
                //裁切没通过
                if (visible) {
                    var objPos = drawTarget.transform.getPosition();
                    drawCall.zdist = objPos.getDistance(cameraPos);
                    if (drawCall.material.renderQueue >= egret3d.RenderQueue.Transparent && drawCall.material.renderQueue < egret3d.RenderQueue.Overlay) {
                        this.transparentCalls.push(drawCall);
                    }
                    else {
                        this.opaqueCalls.push(drawCall);
                    }
                }
            }
            //
            this.opaqueCalls.sort(this._sortOpaque);
            this.transparentCalls.sort(this._sortTransparent);
        };
        /**
         * 移除指定渲染器的 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.removeDrawCalls = function (renderer) {
            var index = this.renderers.indexOf(renderer);
            if (index < 0) {
                return;
            }
            var i = this.drawCalls.length;
            while (i--) {
                if (this.drawCalls[i].renderer === renderer) {
                    this.drawCalls.splice(i, 1);
                }
            }
            this.renderers.splice(index, 1);
        };
        /**
         * 指定渲染器是否生成了 draw call 列表。
         * @param renderer
         */
        DrawCalls.prototype.hasDrawCalls = function (renderer) {
            return this.renderers.indexOf(renderer) >= 0;
        };
        return DrawCalls;
    }(paper.SingletonComponent));
    egret3d.DrawCalls = DrawCalls;
    __reflect(DrawCalls.prototype, "egret3d.DrawCalls");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Camera系统
     */
    var CameraSystem = (function (_super) {
        __extends(CameraSystem, _super);
        function CameraSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: [egret3d.DirectLight, egret3d.PointLight, egret3d.SpotLight] }
                ]
            ];
            _this._camerasAndLights = _this._globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            return _this;
        }
        CameraSystem.prototype.onAddGameObject = function (gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCamera(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLight(this._groups[1].gameObjects);
            }
        };
        CameraSystem.prototype.onRemoveGameObject = function (gameObject, group) {
            if (group === this._groups[0]) {
                this._camerasAndLights.updateCamera(this._groups[0].gameObjects);
            }
            else if (group === this._groups[1]) {
                this._camerasAndLights.updateLight(this._groups[1].gameObjects);
            }
        };
        CameraSystem.prototype.onUpdate = function (deltaTime) {
            var cameras = this._camerasAndLights.cameras;
            if (cameras.length > 0) {
                var camerasScene = paper.Application.sceneManager.camerasScene || paper.Application.sceneManager.activeScene;
                this._camerasAndLights.sort();
                for (var _i = 0, cameras_1 = cameras; _i < cameras_1.length; _i++) {
                    var component = cameras_1[_i];
                    if (component.gameObject.scene !== camerasScene) {
                        continue;
                    }
                    component.update(deltaTime);
                }
            }
        };
        return CameraSystem;
    }(paper.BaseSystem));
    egret3d.CameraSystem = CameraSystem;
    __reflect(CameraSystem.prototype, "egret3d.CameraSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpRectA = new egret3d.Rectangle();
    /**
     * camera component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 相机组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var Camera = (function (_super) {
        __extends(Camera, _super);
        function Camera() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * clear color option
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 是否清除颜色缓冲区
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.clearOption_Color = true;
            /**
             * clear depth option
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 是否清除深度缓冲区
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.clearOption_Depth = true;
            /**
             * culling mask
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机的渲染剔除，对应GameObject的层级
             * @default CullingMask.Everything
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.cullingMask = 16777215 /* Everything */;
            /**
             * camera render order
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机渲染排序
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.order = 0;
            /**
             * fov
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 透视投影的fov
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.fov = Math.PI * 0.25;
            /**
             * size
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 正交投影的竖向size
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.size = 2.0;
            /**
             * op value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 0=正交， 1=透视 中间值可以在两种相机间过度
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.opvalue = 1.0;
            /**
             * back ground color
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 背景色
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.backgroundColor = new egret3d.Color(0.13, 0.28, 0.51, 1);
            /**
             * camera viewport
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机视窗
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.viewport = new egret3d.Rectangle(0, 0, 1, 1);
            /**
             * TODO 功能完善后开放此接口
             */
            _this.postQueues = [];
            /**
             * 相机渲染上下文
             */
            _this.context = null;
            /**
             * render target
             * @defualt null
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 渲染目标，如果为null，则为画布
             * @defualt null
             * @version paper 1.0
             * @platform Web
             * @language
             */
            _this.renderTarget = null;
            _this._near = 0.01;
            _this._far = 1000;
            _this.matProjP = new egret3d.Matrix;
            _this.matProjO = new egret3d.Matrix;
            _this.frameVecs = [
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3(),
                new egret3d.Vector3()
            ];
            return _this;
        }
        Object.defineProperty(Camera, "main", {
            /**
             * current main camera
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前主相机。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            get: function () {
                var gameObject = paper.Application.sceneManager.activeScene.findWithTag("MainCamera" /* MainCamera */);
                if (gameObject) {
                    return gameObject.getComponent(Camera, true);
                }
                return null;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * 计算相机视锥区域
         */
        Camera.prototype.calcCameraFrame = function () {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var farLD = this.frameVecs[0];
            var nearLD = this.frameVecs[1];
            var farRD = this.frameVecs[2];
            var nearRD = this.frameVecs[3];
            var farLT = this.frameVecs[4];
            var nearLT = this.frameVecs[5];
            var farRT = this.frameVecs[6];
            var nearRT = this.frameVecs[7];
            var near_h = this.near * Math.tan(this.fov * 0.5);
            var asp = vpp.w / vpp.h;
            var near_w = near_h * asp;
            egret3d.Vector3.set(-near_w, near_h, this.near, nearLT);
            egret3d.Vector3.set(-near_w, -near_h, this.near, nearLD);
            egret3d.Vector3.set(near_w, near_h, this.near, nearRT);
            egret3d.Vector3.set(near_w, -near_h, this.near, nearRD);
            var far_h = this.far * Math.tan(this.fov * 0.5);
            var far_w = far_h * asp;
            egret3d.Vector3.set(-far_w, far_h, this.far, farLT);
            egret3d.Vector3.set(-far_w, -far_h, this.far, farLD);
            egret3d.Vector3.set(far_w, far_h, this.far, farRT);
            egret3d.Vector3.set(far_w, -far_h, this.far, farRD);
            var matrix = this.gameObject.transform.getWorldMatrix();
            egret3d.Matrix.transformVector3(farLD, matrix, farLD);
            egret3d.Matrix.transformVector3(nearLD, matrix, nearLD);
            egret3d.Matrix.transformVector3(farRD, matrix, farRD);
            egret3d.Matrix.transformVector3(nearRD, matrix, nearRD);
            egret3d.Matrix.transformVector3(farLT, matrix, farLT);
            egret3d.Matrix.transformVector3(nearLT, matrix, nearLT);
            egret3d.Matrix.transformVector3(farRT, matrix, farRT);
            egret3d.Matrix.transformVector3(nearRT, matrix, nearRT);
        };
        /**
         * 设置render target与viewport
         * @param target render target
         * @param withoutClear 强制不清除缓存
         *
         */
        Camera.prototype._targetAndViewport = function (target, withoutClear) {
            var w;
            var h;
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!target) {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
                egret3d.GlRenderTarget.useNull(webgl);
            }
            else {
                w = target.width;
                h = target.height;
                target.use(webgl);
            }
            webgl.viewport(w * this.viewport.x, h * this.viewport.y, w * this.viewport.w, h * this.viewport.h);
            webgl.depthRange(0, 1);
            if (withoutClear) {
                return;
            }
            // clear buffer
            if (this.clearOption_Color && this.clearOption_Depth) {
                webgl.depthMask(true);
                // webgl.depthMask(true);
                webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            else if (this.clearOption_Depth) {
                webgl.depthMask(true);
                // webgl.depthMask(true);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.DEPTH_BUFFER_BIT);
            }
            else if (this.clearOption_Color) {
                webgl.clearColor(this.backgroundColor.r, this.backgroundColor.g, this.backgroundColor.b, this.backgroundColor.a);
                webgl.clear(webgl.COLOR_BUFFER_BIT);
            }
            else {
            }
        };
        /**
         * @inheritDoc
         */
        Camera.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.context = new egret3d.RenderContext();
            this.near = this._near;
            this.far = this._far;
        };
        /**
         *
         */
        Camera.prototype.update = function (_delta) {
            this.calcCameraFrame();
            this.context.updateCamera(this, this.gameObject.transform.getWorldMatrix());
        };
        /**
         * 计算相机的 view matrix（视图矩阵）
         */
        Camera.prototype.calcViewMatrix = function (matrix) {
            matrix.copy(this.gameObject.transform.getWorldMatrix()).inverse();
            return matrix;
        };
        /**
         * 计算相机的 project matrix（投影矩阵）
         */
        Camera.prototype.calcProjectMatrix = function (asp, matrix) {
            if (this.opvalue > 0) {
                egret3d.Matrix.perspectiveProjectLH(this.fov, asp, this.near, this.far, this.matProjP);
            }
            if (this.opvalue < 1) {
                egret3d.Matrix.orthoProjectLH(this.size * asp, this.size, this.near, this.far, this.matProjO);
            }
            if (this.opvalue === 0.0) {
                egret3d.Matrix.copy(this.matProjO, matrix);
            }
            else if (this.opvalue === 1.0) {
                egret3d.Matrix.copy(this.matProjP, matrix);
            }
            else {
                egret3d.Matrix.lerp(this.matProjO, this.matProjP, this.opvalue, matrix);
            }
            return matrix;
        };
        /**
         * calcViewPortPixel
         * @param viewPortPixel output rect
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 计算相机视口像素rect
         * @param viewPortPixel 输出的rect
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcViewPortPixel = function (viewPortPixel) {
            var w;
            var h;
            var renderTarget = this.renderTarget;
            var viewport = this.viewport;
            if (renderTarget) {
                w = renderTarget.width;
                h = renderTarget.height;
            }
            else {
                w = egret3d.stage.screenViewport.w;
                h = egret3d.stage.screenViewport.h;
            }
            viewPortPixel.x = w * viewport.x;
            viewPortPixel.y = h * viewport.y;
            viewPortPixel.w = w * viewport.w;
            viewPortPixel.h = h * viewport.h;
            //asp = this.viewPortPixel.w / this.viewPortPixel.h;
        };
        /**
         * createRayByScreen
         * @param screenpos screen coords
         * @param app application
         * @return Ray ray
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由屏幕坐标发射射线
         * @param screenpos 屏幕坐标
         * @param app 主程序实例
         * @return Ray 射线
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.createRayByScreen = function (screenPosX, screenPosY) {
            var src1 = egret3d.helpVector3C;
            src1.x = screenPosX;
            src1.y = screenPosY;
            src1.z = 0.0;
            var src2 = egret3d.helpVector3D;
            src2.x = screenPosX;
            src2.y = screenPosY;
            src2.z = 1.0;
            var dest1 = egret3d.helpVector3E;
            var dest2 = egret3d.helpVector3F;
            this.calcWorldPosFromScreenPos(src1, dest1);
            this.calcWorldPosFromScreenPos(src2, dest2);
            var dir = egret3d.helpVector3G;
            egret3d.Vector3.subtract(dest2, dest1, dir);
            egret3d.Vector3.normalize(dir);
            var ray = new egret3d.Ray(dest1, dir);
            return ray;
        };
        /**
         * calcWorldPosFromScreenPos
         * @param app application
         * @param screenpos screen coords
         * @param outWorldPos world coords
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由屏幕坐标得到世界坐标
         * @param app 主程序
         * @param screenpos 屏幕坐标
         * @param outWorldPos 世界坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcWorldPosFromScreenPos = function (screenPos, outWorldPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var vppos = egret3d.helpVector3A;
            vppos.x = screenPos.x / vpp.w * 2.0 - 1.0;
            vppos.y = 1.0 - screenPos.y / vpp.h * 2.0;
            vppos.z = screenPos.z;
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcViewMatrix(matrixView);
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC;
            var matinv = egret3d.helpMatrixD;
            egret3d.Matrix.multiply(matrixProject, matrixView, matrixViewProject);
            egret3d.Matrix.inverse(matrixViewProject, matinv);
            egret3d.Matrix.transformVector3(vppos, matinv, outWorldPos);
        };
        /**
         * calcScreenPosFromWorldPos
         * @param app application
         * @param worldPos world coords
         * @param outScreenPos screen coords
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 由世界坐标得到屏幕坐标
         * @param app 主程序
         * @param worldPos 世界坐标
         * @param outScreenPos 屏幕坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Camera.prototype.calcScreenPosFromWorldPos = function (worldPos, outScreenPos) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var matrixView = egret3d.helpMatrixA;
            var matrixProject = egret3d.helpMatrixB;
            var asp = vpp.w / vpp.h;
            this.calcViewMatrix(matrixView);
            this.calcProjectMatrix(asp, matrixProject);
            var matrixViewProject = egret3d.helpMatrixC;
            egret3d.Matrix.multiply(matrixProject, matrixView, matrixViewProject);
            var ndcPos = egret3d.helpVector3A;
            egret3d.Matrix.transformVector3(worldPos, matrixViewProject, ndcPos);
            outScreenPos.x = (ndcPos.x + 1.0) * vpp.w * 0.5;
            outScreenPos.y = (1.0 - ndcPos.y) * vpp.h * 0.5;
        };
        /**
         *
         */
        Camera.prototype.getPosAtXPanelInViewCoordinateByScreenPos = function (screenPos, z, out) {
            var vpp = helpRectA;
            this.calcViewPortPixel(vpp);
            var nearpos = egret3d.helpVector3A;
            nearpos.z = -this.near;
            nearpos.x = screenPos.x - vpp.w * 0.5;
            nearpos.y = vpp.h * 0.5 - screenPos.y;
            var farpos = egret3d.helpVector3B;
            farpos.z = -this.far;
            farpos.x = this.far * nearpos.x / this.near;
            farpos.y = this.far * nearpos.y / this.near;
            var rate = (nearpos.z - z) / (nearpos.z - farpos.z);
            out.x = nearpos.x - (nearpos.x - farpos.x) * rate;
            out.y = nearpos.y - (nearpos.y - farpos.y) * rate;
        };
        Camera.prototype.testFrustumCulling = function (node) {
            var aabb = node.aabb;
            if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[1], this.frameVecs[5]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[1], this.frameVecs[3], this.frameVecs[7]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[3], this.frameVecs[2], this.frameVecs[6]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[2], this.frameVecs[0], this.frameVecs[4]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[5], this.frameVecs[7], this.frameVecs[6]))
                return false;
            if (!aabb.intersectPlane(this.frameVecs[0], this.frameVecs[2], this.frameVecs[3]))
                return false;
            return true;
        };
        Object.defineProperty(Camera.prototype, "near", {
            /**
             * distance between camera and near plane
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机到近裁剪面距离
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._near;
            },
            set: function (value) {
                if (value >= this.far) {
                    value = this.far - 1.0;
                }
                if (value < 0.01) {
                    value = 0.01;
                }
                this._near = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Camera.prototype, "far", {
            /**
             * distance between camera and far plane
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 相机到远裁剪面距离
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._far;
            },
            set: function (value) {
                if (value <= this.near) {
                    value = this.near + 1.0;
                }
                if (value >= 1000.0) {
                    value = 1000.0;
                }
                this._far = value;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Color", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "clearOption_Depth", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "cullingMask", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "order", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "fov", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "size", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "opvalue", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "backgroundColor", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "viewport", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_near", void 0);
        __decorate([
            paper.serializedField
        ], Camera.prototype, "_far", void 0);
        return Camera;
    }(paper.BaseComponent));
    egret3d.Camera = Camera;
    __reflect(Camera.prototype, "egret3d.Camera");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 深度绘制通道
     * TODO 完善后public给开发者
     */
    var CameraPostQueueDepth = (function () {
        function CameraPostQueueDepth() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueDepth.prototype.render = function (camera, renderSystem) {
            var webgl = egret3d.WebGLCapabilities.webgl;
            camera._targetAndViewport(this.renderTarget, true); // 最后一个参数true 表示不用camera的clear 配置
            webgl.depthMask(true);
            // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
            webgl.clearColor(0, 0, 0, 0);
            webgl.clearDepth(1.0);
            webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            // camera.context.drawtype = "_depth";
            // camera._renderOnce(scene, context, "_depth");
            renderSystem._renderCamera(camera);
            egret3d.GlRenderTarget.useNull(webgl);
        };
        return CameraPostQueueDepth;
    }());
    egret3d.CameraPostQueueDepth = CameraPostQueueDepth;
    __reflect(CameraPostQueueDepth.prototype, "egret3d.CameraPostQueueDepth", ["egret3d.ICameraPostQueue"]);
    // /**
    //  * framebuffer绘制通道
    //  * TODO 完善后public给开发者
    //  */
    // export class CameraPostQueueQuad implements ICameraPostQueue {
    //     /**
    //      * shader & uniform
    //      */
    //     public readonly material: Material = new Material();
    //     /**
    //      * @inheritDoc
    //      */
    //     public renderTarget: GlRenderTarget = null as any;
    //     /**
    //      * @inheritDoc
    //      */
    //     public render(camera: Camera, _renderSystem: CameraSystem) {
    //         const webgl = WebGLKit.webgl;
    //         camera._targetAndViewport(this.renderTarget, true);
    //         WebGLKit.zWrite(true);
    //         // webgl.depthMask(true); // 开启 zwrite 以便正常 clear depth
    //         webgl.clearColor(0, 0.3, 0, 0);
    //         webgl.clearDepth(1.0);
    //         webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
    //         const mesh = DefaultMeshes.QUAD;
    //         camera.context.drawtype = "";
    //         WebGLKit.draw(camera.context, this.material, mesh, 0, "quad");
    //     }
    // }
    /**
     * 颜色绘制通道
     * TODO 完善后public给开发者
     */
    var CameraPostQueueColor = (function () {
        function CameraPostQueueColor() {
            /**
             * @inheritDoc
             */
            this.renderTarget = null;
        }
        /**
         * @inheritDoc
         */
        CameraPostQueueColor.prototype.render = function (camera, renderSystem) {
            var webgl = egret3d.WebGLCapabilities.webgl;
            camera._targetAndViewport(this.renderTarget, false);
            // camera.context.drawtype = "";
            // camera._renderOnce(scene, context, "");
            renderSystem._renderCamera(camera);
            egret3d.GlRenderTarget.useNull(webgl);
        };
        return CameraPostQueueColor;
    }());
    egret3d.CameraPostQueueColor = CameraPostQueueColor;
    __reflect(CameraPostQueueColor.prototype, "egret3d.CameraPostQueueColor", ["egret3d.ICameraPostQueue"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    /**
     * 缓存场景通用数据
     * 包括矩阵信息，灯光，光照贴图，viewport尺寸等等
     */
    var RenderContext = (function () {
        function RenderContext() {
            /**
             *
             */
            this.version = 0;
            /**
             *
             */
            this.lightCount = 0;
            this.directLightCount = 0;
            this.pointLightCount = 0;
            this.spotLightCount = 0;
            /**
             *
             */
            this.lightmap = null;
            this.lightmapUV = 1;
            this.lightmapIntensity = 1.0;
            this.lightmapOffset = null;
            this.boneData = null;
            // 15: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.directLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, shadow, shadowBias, shadowRadius, shadowCameraNear, shadowCameraFar, shadowMapSizeX, shadowMapSizeY
            this.pointLightArray = new Float32Array(0);
            // 19: x, y, z, dirX, dirY, dirZ, colorR, colorG, colorB, intensity, distance, decay, coneCos, penumbraCos, shadow, shadowBias, shadowRadius, shadowMapSizeX, shadowMapSizeY
            this.spotLightArray = new Float32Array(0);
            this.directShadowMatrix = new Float32Array(0);
            this.spotShadowMatrix = new Float32Array(0);
            this.matrix_m = new egret3d.Matrix();
            this.matrix_mvp = new egret3d.Matrix();
            this.directShadowMaps = [];
            this.pointShadowMaps = [];
            this.spotShadowMaps = [];
            this.viewPortPixel = { x: 0, y: 0, w: 0, h: 0 };
            //
            this.cameraPosition = new Float32Array(3);
            this.cameraForward = new Float32Array(3);
            this.cameraUp = new Float32Array(3);
            // transforms
            this.matrix_v = new egret3d.Matrix();
            this.matrix_p = new egret3d.Matrix();
            this.matrix_mv = new egret3d.Matrix();
            this.matrix_vp = new egret3d.Matrix();
            this.lightPosition = new Float32Array([0.0, 0.0, 0.0, 1.0]);
            this.lightShadowCameraNear = 0;
            this.lightShadowCameraFar = 0;
        }
        RenderContext.prototype.updateLightmap = function (texture, uv, offset, intensity) {
            if (this.lightmap !== texture) {
                this.lightmap = texture;
                this.version++;
            }
            if (this.lightmapUV !== uv) {
                this.lightmapUV = uv;
                this.version++;
            }
            if (this.lightmapOffset !== offset ||
                this.lightmapOffset[0] !== offset[0] ||
                this.lightmapOffset[1] !== offset[1] ||
                this.lightmapOffset[2] !== offset[2] ||
                this.lightmapOffset[3] !== offset[3]) {
                this.lightmapOffset = offset;
                this.version++;
            }
            if (this.lightmapIntensity !== intensity) {
                this.lightmapIntensity = intensity;
                this.version++;
            }
        };
        RenderContext.prototype.updateCamera = function (camera, matrix) {
            camera.calcViewPortPixel(this.viewPortPixel); // update viewport
            var asp = this.viewPortPixel.w / this.viewPortPixel.h;
            this.matrix_v.copy(matrix).inverse();
            camera.calcProjectMatrix(asp, this.matrix_p);
            egret3d.Matrix.multiply(this.matrix_p, this.matrix_v, this.matrix_vp);
            var worldMatrix = matrix.rawData;
            if (this.cameraPosition[0] !== worldMatrix[12] ||
                this.cameraPosition[1] !== worldMatrix[13] ||
                this.cameraPosition[2] !== worldMatrix[14]) {
                this.cameraPosition[0] = worldMatrix[12];
                this.cameraPosition[1] = worldMatrix[13];
                this.cameraPosition[2] = worldMatrix[14];
                this.version++;
            }
            if (this.cameraUp[0] !== worldMatrix[4] ||
                this.cameraUp[1] !== worldMatrix[5] ||
                this.cameraUp[2] !== worldMatrix[6]) {
                this.cameraUp[0] = worldMatrix[4];
                this.cameraUp[1] = worldMatrix[5];
                this.cameraUp[2] = worldMatrix[6];
                this.version++;
            }
            if (this.cameraForward[0] !== worldMatrix[8] ||
                this.cameraForward[1] !== worldMatrix[9] ||
                this.cameraForward[2] !== worldMatrix[10]) {
                this.cameraForward[0] = -worldMatrix[8];
                this.cameraForward[1] = -worldMatrix[9];
                this.cameraForward[2] = -worldMatrix[10];
                this.version++;
            }
        };
        RenderContext.prototype.updateLights = function (lights) {
            var allLightCount = 0, directLightCount = 0, pointLightCount = 0, spotLightCount = 0;
            for (var _i = 0, lights_1 = lights; _i < lights_1.length; _i++) {
                var light = lights_1[_i];
                if (light instanceof egret3d.DirectLight) {
                    directLightCount++;
                }
                else if (light instanceof egret3d.PointLight) {
                    pointLightCount++;
                }
                else if (light instanceof egret3d.SpotLight) {
                    spotLightCount++;
                }
                allLightCount++;
            }
            // TODO
            if (this.directLightArray.length !== directLightCount * 15) {
                this.directLightArray = new Float32Array(directLightCount * 15);
            }
            if (this.pointLightArray.length !== pointLightCount * 19) {
                this.pointLightArray = new Float32Array(pointLightCount * 19);
            }
            if (this.spotLightArray.length !== spotLightCount * 19) {
                this.spotLightArray = new Float32Array(spotLightCount * 19);
            }
            if (this.directShadowMatrix.length !== directLightCount * 16) {
                this.directShadowMatrix = new Float32Array(directLightCount * 16);
            }
            if (this.spotShadowMatrix.length !== spotLightCount * 16) {
                this.spotShadowMatrix = new Float32Array(spotLightCount * 16);
            }
            this.directShadowMaps.length = directLightCount;
            this.pointShadowMaps.length = pointLightCount;
            this.spotShadowMaps.length = spotLightCount;
            this.lightCount = allLightCount;
            this.directLightCount = directLightCount;
            this.pointLightCount = pointLightCount;
            this.spotLightCount = spotLightCount;
            var directLightIndex = 0, pointLightIndex = 0, spotLightIndex = 0, index = 0, size = 0;
            for (var _a = 0, lights_2 = lights; _a < lights_2.length; _a++) {
                var light = lights_2[_a];
                var lightArray = this.directLightArray;
                if (light.type === 1 /* Direction */) {
                    lightArray = this.directLightArray;
                    index = directLightIndex;
                    size = 15;
                }
                else if (light.type === 2 /* Point */) {
                    lightArray = this.pointLightArray;
                    index = pointLightIndex;
                    size = 19;
                }
                else if (light.type === 3 /* Spot */) {
                    lightArray = this.spotLightArray;
                    index = spotLightIndex;
                    size = 19;
                }
                var offset = 0;
                var pos = light.gameObject.transform.getPosition();
                lightArray[index * size + offset++] = pos.x;
                lightArray[index * size + offset++] = pos.y;
                lightArray[index * size + offset++] = pos.z;
                var dir = light.gameObject.transform.getForward(helpVec3_1);
                lightArray[index * size + offset++] = dir.x;
                lightArray[index * size + offset++] = dir.y;
                lightArray[index * size + offset++] = dir.z;
                lightArray[index * size + offset++] = light.color.r;
                lightArray[index * size + offset++] = light.color.g;
                lightArray[index * size + offset++] = light.color.b;
                lightArray[index * size + offset++] = light.intensity;
                if (light.type === 2 /* Point */ || light.type === 3 /* Spot */) {
                    lightArray[index * size + offset++] = light.distance;
                    lightArray[index * size + offset++] = light.decay;
                    if (light.type === 3 /* Spot */) {
                        lightArray[index * size + offset++] = Math.cos(light.angle);
                        lightArray[index * size + offset++] = Math.cos(light.angle * (1 - light.penumbra));
                    }
                }
                if (light.castShadows) {
                    lightArray[index * size + offset++] = 1;
                    if (light.type === 1 /* Direction */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.directShadowMatrix.set(light.matrix.rawData, directLightIndex * 16);
                        this.directShadowMaps[directLightIndex] = light.renderTarget.texture;
                    }
                    else if (light.type === 2 /* Point */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowCameraNear;
                        lightArray[index * size + offset++] = light.shadowCameraFar;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.pointShadowMaps[pointLightIndex] = light.renderTarget.texture;
                    }
                    else if (light.type === 3 /* Spot */) {
                        lightArray[index * size + offset++] = light.shadowBias;
                        lightArray[index * size + offset++] = light.shadowRadius;
                        lightArray[index * size + offset++] = light.shadowSize;
                        lightArray[index * size + offset++] = light.shadowSize;
                        this.spotShadowMatrix.set(light.matrix.rawData, spotLightIndex * 16);
                        this.spotShadowMaps[spotLightIndex] = light.renderTarget.texture;
                    }
                }
                else {
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    lightArray[index * size + offset++] = 0;
                    if (light.type === 1 /* Direction */) {
                        this.directShadowMaps[directLightIndex] = null;
                    }
                    else if (light.type === 2 /* Point */) {
                        this.pointShadowMaps[pointLightIndex] = null;
                    }
                    else if (light.type === 3 /* Spot */) {
                        this.spotShadowMaps[spotLightIndex] = null;
                    }
                }
                if (light.type === 1 /* Direction */) {
                    directLightIndex++;
                }
                else if (light.type === 2 /* Point */) {
                    pointLightIndex++;
                }
                else if (light.type === 3 /* Spot */) {
                    spotLightIndex++;
                }
            }
            this.version++;
        };
        RenderContext.prototype.updateModel = function (matrix) {
            egret3d.Matrix.copy(matrix, this.matrix_m); // clone matrix because getWorldMatrix returns a reference
            egret3d.Matrix.multiply(this.matrix_v, this.matrix_m, this.matrix_mv);
            egret3d.Matrix.multiply(this.matrix_vp, this.matrix_m, this.matrix_mvp);
            this.version++;
        };
        RenderContext.prototype.updateBones = function (data) {
            this.boneData = data;
            this.version++;
        };
        RenderContext.prototype.updateLightDepth = function (light) {
            var position = light.gameObject.transform.getPosition();
            if (this.lightPosition[0] !== position.x ||
                this.lightPosition[1] !== position.y ||
                this.lightPosition[2] !== position.z) {
                this.lightPosition[0] = position.x;
                this.lightPosition[1] = position.y;
                this.lightPosition[2] = position.z;
                this.version++;
            }
            if (this.lightShadowCameraNear !== light.shadowCameraNear ||
                this.lightShadowCameraNear !== light.shadowCameraFar) {
                this.lightShadowCameraNear = light.shadowCameraNear;
                this.lightShadowCameraFar = light.shadowCameraFar;
                this.version++;
            }
        };
        return RenderContext;
    }());
    egret3d.RenderContext = RenderContext;
    __reflect(RenderContext.prototype, "egret3d.RenderContext");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * 可以添加egret2d显示对象（包括EUI）进行渲染。
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var Egret2DRenderer = (function (_super) {
        __extends(Egret2DRenderer, _super);
        function Egret2DRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * 是否使用视锥剔除
             */
            _this.frustumTest = false;
            _this._screenAdapter = new egret3d.ConstantAdapter();
            _this._catchedEvent = {};
            _this._stageWidth = 0;
            _this._stageHeight = 0;
            _this._scaler = 1;
            return _this;
        }
        Object.defineProperty(Egret2DRenderer.prototype, "screenAdapter", {
            get: function () {
                return this._screenAdapter;
            },
            set: function (adapter) {
                adapter.$dirty = true;
                this._screenAdapter = adapter;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @inheritDoc
         */
        Egret2DRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.stage = new egret.Stage();
            this.stage.maxTouches = 98;
            this.root = new egret.DisplayObjectContainer();
            this.stage.addChild(this.root);
            if (!this.renderer) {
                this.renderer = egret.web.Renderer.getInstance(egret3d.WebGLCapabilities.webgl);
            }
            var stage = this.stage;
            var displayList = new egret.sys.DisplayList(stage);
            displayList.renderBuffer = new egret.sys.RenderBuffer(undefined, undefined, true);
            stage.$displayList = displayList;
            egret3d.InputManager.touch.addEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.addEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.addEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.addEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.addEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.addEventListener("mousemove", this._onTouchMove, this);
        };
        /**
         * @inheritDoc
         */
        Egret2DRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            egret3d.InputManager.touch.removeEventListener("touchstart", this._onTouchStart, this);
            egret3d.InputManager.touch.removeEventListener("touchend", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchcancel", this._onTouchEnd, this);
            egret3d.InputManager.touch.removeEventListener("touchmove", this._onTouchMove, this);
            egret3d.InputManager.mouse.removeEventListener("mousedown", this._onTouchStart, this);
            egret3d.InputManager.mouse.removeEventListener("mouseup", this._onTouchEnd, this);
            egret3d.InputManager.mouse.removeEventListener("mousemove", this._onTouchMove, this);
            // this.stage.removeChild(this.root);
        };
        /**
         * 检查屏幕接触事件是否能够穿透此2D层
         */
        Egret2DRenderer.prototype.checkEventThrough = function (x, y) {
            return !!this._catchedEvent[x + "_" + y];
        };
        Egret2DRenderer.prototype._onTouchStart = function (event) {
            // console.log(event);
            if (this.stage.$onTouchBegin(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchMove = function (event) {
            // console.log(event);
            if (this.stage.$onTouchMove(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        Egret2DRenderer.prototype._onTouchEnd = function (event) {
            // console.log(event);
            if (this.stage.$onTouchEnd(event.x / this._scaler, event.y / this._scaler, event.identifier)) {
                this._catchedEvent[event.x + "_" + event.y] = true;
            }
        };
        /**
         * screen position to ui position
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 从屏幕坐标转换到当前2D系统的坐标
         * @version paper 1.0
         * @platform Web
         * @language
         */
        Egret2DRenderer.prototype.screenPosToUIPos = function (pos, out) {
            if (out === void 0) { out = new egret3d.Vector2(); }
            out.x = pos.x / this._scaler;
            out.y = pos.y / this._scaler;
            return out;
        };
        Object.defineProperty(Egret2DRenderer.prototype, "scaler", {
            /**
             * 从屏幕坐标到当前2D系统的坐标的缩放系数
             */
            get: function () {
                return this._scaler;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        Egret2DRenderer.prototype.update = function (delta) {
            var stage2d = this.stage;
            var _a = egret3d.stage.screenViewport, w = _a.w, h = _a.h;
            if (this._stageWidth != w || this._stageHeight != h || this.screenAdapter.$dirty) {
                var result = { w: 0, h: 0, s: 0 };
                this.screenAdapter.calculateScaler(w, h, result);
                this.screenAdapter.$dirty = false;
                // this._scaler = this.root.scaleX = this.root.scaleY = result.s;
                stage2d.$displayList["offsetMatrix"].a = result.s;
                stage2d.$displayList["offsetMatrix"].d = result.s;
                this._scaler = result.s;
                var stageWidth = result.w;
                var stageHeight = result.h;
                stage2d.$stageWidth = stageWidth;
                stage2d.$stageHeight = stageHeight;
                // stage.$displayList.setClipRect(screenWidth, screenHeight);
                stage2d.pushResize(w, h);
                stage2d.dispatchEventWith(egret.Event.RESIZE);
                this._stageWidth = w;
                this._stageHeight = h;
            }
            // clear catched events
            this._catchedEvent = {};
        };
        /**
         *
         */
        Egret2DRenderer.prototype.render = function (context, camera) {
            var gl = egret3d.WebGLCapabilities.webgl;
            this.renderer.beforeRender();
            this.stage.drawToSurface();
            // WebGLRenderUtils.resetState(); // 清除3D渲染器中的标脏
        };
        Egret2DRenderer = __decorate([
            paper.disallowMultiple
        ], Egret2DRenderer);
        return Egret2DRenderer;
    }(paper.BaseRenderer));
    egret3d.Egret2DRenderer = Egret2DRenderer;
    __reflect(Egret2DRenderer.prototype, "egret3d.Egret2DRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var Egret2DRendererSystem = (function (_super) {
        __extends(Egret2DRendererSystem, _super);
        function Egret2DRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: egret3d.Egret2DRenderer }
            ];
            return _this;
        }
        Egret2DRendererSystem.prototype.onUpdate = function (deltaTime) {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.getComponent(egret3d.Egret2DRenderer).update(deltaTime);
            }
        };
        return Egret2DRendererSystem;
    }(paper.BaseSystem));
    egret3d.Egret2DRendererSystem = Egret2DRendererSystem;
    __reflect(Egret2DRendererSystem.prototype, "egret3d.Egret2DRendererSystem");
})(egret3d || (egret3d = {}));
//////////////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2014-present, Egret Technology.
//  All rights reserved.
//  Redistribution and use in source and binary forms, with or without
//  modification, are permitted provided that the following conditions are met:
//
//     * Redistributions of source code must retain the above copyright
//       notice, this list of conditions and the following disclaimer.
//     * Redistributions in binary form must reproduce the above copyright
//       notice, this list of conditions and the following disclaimer in the
//       documentation and/or other materials provided with the distribution.
//     * Neither the name of the Egret nor the
//       names of its contributors may be used to endorse or promote products
//       derived from this software without specific prior written permission.
//
//  THIS SOFTWARE IS PROVIDED BY EGRET AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
//  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
//  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
//  IN NO EVENT SHALL EGRET AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
//  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;LOSS OF USE, DATA,
//  OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
//  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
//  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
//  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//////////////////////////////////////////////////////////////////////////////////////
var egret;
(function (egret) {
    var web;
    (function (web) {
        /**
         * @internal
         */
        var Renderer = (function () {
            function Renderer(context) {
                this.context = context;
                var egretWebGLRenderContext = this.egretWebGLRenderContext = egret.web.WebGLRenderContext.getInstance(0, 0);
                egretWebGLRenderContext.setContext(context);
                this.drawCmdManager = egretWebGLRenderContext.drawCmdManager;
                this.vao = egretWebGLRenderContext.vao;
                // egretWebGLRenderContext.drawFunc = this.$drawWebGL.bind(this);
                egretWebGLRenderContext.$drawWebGL = this.$drawWebGL.bind(this);
                egret.sys.RenderBuffer = egret.web.WebGLRenderBuffer;
                egret.sys.systemRenderer = new egret.web.WebGLRenderer();
                egret.sys.canvasRenderer = new egret.CanvasRenderer();
                egret.sys.customHitTestBuffer = new egret.web.WebGLRenderBuffer(3, 3);
                egret.sys.canvasHitTestBuffer = new egret.web.CanvasRenderBuffer(3, 3);
                egret.Capabilities['$renderMode'] = "webgl";
                this.vertexBuffer = context.createBuffer();
                this.indexBuffer = context.createBuffer();
                // app.addEventListener("beforeRender", function() {
                //     egret.ticker.update();
                // }, this);
            }
            Renderer.getInstance = function (context) {
                if (!this._instance) {
                    this._instance = new Renderer(context);
                }
                return this._instance;
            };
            Renderer.prototype.beforeRender = function () {
                var gl = this.context;
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.disable(gl.DEPTH_TEST);
                gl.disable(gl.CULL_FACE);
                gl.enable(gl.BLEND);
                gl.disable(gl.STENCIL_TEST);
                gl.colorMask(true, true, true, true);
                this.setBlendMode("source-over");
                // 目前只使用0号材质单元，默认开启
                gl.activeTexture(gl.TEXTURE0);
            };
            Renderer.prototype.$drawWebGL = function () {
                if (this.drawCmdManager.drawDataLen == 0) {
                    return;
                }
                this.uploadVerticesArray(this.vao.getVertices());
                // 有mesh，则使用indicesForMesh
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getMeshIndices());
                }
                var length = this.drawCmdManager.drawDataLen;
                var offset = 0;
                for (var i = 0; i < length; i++) {
                    var data = this.drawCmdManager.drawData[i];
                    if (!data) {
                        continue;
                    }
                    offset = this.drawData(data, offset);
                    // 计算draw call
                    if (data.type == 6 /* ACT_BUFFER */) {
                        this.activatedBuffer = data.buffer;
                        this.egretWebGLRenderContext.activatedBuffer = data.buffer;
                    }
                    if (data.type == 0 /* TEXTURE */ || data.type == 1 /* PUSH_MASK */ || data.type == 2 /* POP_MASK */) {
                        if (this.activatedBuffer && this.activatedBuffer.$computeDrawCall) {
                            this.activatedBuffer.$drawCalls++;
                        }
                    }
                }
                // 切换回默认indices
                if (this.vao.isMesh()) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                // 清空数据
                this.drawCmdManager.clear();
                this.vao.clear();
            };
            /**
             * 执行绘制命令
             */
            Renderer.prototype.drawData = function (data, offset) {
                if (!data) {
                    return;
                }
                var gl = this.context;
                var program;
                var filter = data.filter;
                switch (data.type) {
                    case 0 /* TEXTURE */:
                        if (filter) {
                            if (filter.type === "custom") {
                                program = web.EgretWebGLProgram.getProgram(gl, filter.$vertexSrc, filter.$fragmentSrc, filter.$shaderKey);
                            }
                            else if (filter.type === "colorTransform") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.colorTransform_frag, "colorTransform");
                            }
                            else if (filter.type === "blurX") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "blurY") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.blur_frag, "blur");
                            }
                            else if (filter.type === "glow") {
                                program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.glow_frag, "glow");
                            }
                        }
                        else {
                            program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.texture_frag, "texture");
                        }
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawTextureElements(data, offset);
                        break;
                    case 1 /* PUSH_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPushMaskElements(data, offset);
                        break;
                    case 2 /* POP_MASK */:
                        program = web.EgretWebGLProgram.getProgram(gl, web.EgretShaderLib.default_vert, web.EgretShaderLib.primitive_frag, "primitive");
                        this.activeProgram(gl, program);
                        this.syncUniforms(program, filter, data.textureWidth, data.textureHeight);
                        offset += this.drawPopMaskElements(data, offset);
                        break;
                    case 3 /* BLEND */:
                        this.setBlendMode(data.value);
                        break;
                    case 4 /* RESIZE_TARGET */:
                        data.buffer.rootRenderTarget.resize(data.width, data.height);
                        this.onResize(data.width, data.height);
                        break;
                    case 5 /* CLEAR_COLOR */:
                        if (this.activatedBuffer) {
                            var target = this.activatedBuffer.rootRenderTarget;
                            if (target.width != 0 || target.height != 0) {
                                target.clear(true);
                            }
                        }
                        break;
                    case 6 /* ACT_BUFFER */:
                        this.activateBuffer(data.buffer, data.width, data.height);
                        break;
                    case 7 /* ENABLE_SCISSOR */:
                        var buffer = this.activatedBuffer;
                        if (buffer) {
                            if (buffer.rootRenderTarget) {
                                buffer.rootRenderTarget.enabledStencil();
                            }
                            buffer.enableScissor(data.x, data.y, data.width, data.height);
                        }
                        break;
                    case 8 /* DISABLE_SCISSOR */:
                        buffer = this.activatedBuffer;
                        if (buffer) {
                            buffer.disableScissor();
                        }
                        break;
                    default:
                        break;
                }
                return offset;
            };
            Renderer.prototype.activeProgram = function (gl, program) {
                // if (program != this.currentProgram) {
                gl.useProgram(program.id);
                // 目前所有attribute buffer的绑定方法都是一致的
                var attribute = program.attributes;
                for (var key in attribute) {
                    if (key === "aVertexPosition") {
                        gl.vertexAttribPointer(attribute["aVertexPosition"].location, 2, gl.FLOAT, false, 4 * 4, 0);
                        gl.enableVertexAttribArray(attribute["aVertexPosition"].location);
                    }
                    else if (key === "aTextureCoord") {
                        gl.vertexAttribPointer(attribute["aTextureCoord"].location, 2, gl.UNSIGNED_SHORT, true, 4 * 4, 2 * 4);
                        gl.enableVertexAttribArray(attribute["aTextureCoord"].location);
                    }
                    else if (key === "aColor") {
                        gl.vertexAttribPointer(attribute["aColor"].location, 1, gl.FLOAT, false, 4 * 4, 3 * 4);
                        gl.enableVertexAttribArray(attribute["aColor"].location);
                    }
                }
                this.currentProgram = program;
                // }
            };
            Renderer.prototype.syncUniforms = function (program, filter, textureWidth, textureHeight) {
                var uniforms = program.uniforms;
                for (var key in uniforms) {
                    if (key === "projectionVector") {
                        uniforms[key].setValue({ x: this.projectionX, y: this.projectionY });
                    }
                    else if (key === "uTextureSize") {
                        uniforms[key].setValue({ x: textureWidth, y: textureHeight });
                    }
                    else if (key === "uSampler") {
                    }
                    else {
                        var value = filter.$uniforms[key];
                        if (value !== undefined) {
                            uniforms[key].setValue(value);
                        }
                        else {
                            // egret.warn("filter custom: uniform " + key + " not defined!");
                        }
                    }
                }
            };
            /**
             * 画texture
             **/
            Renderer.prototype.drawTextureElements = function (data, offset) {
                var gl = this.context;
                gl.bindTexture(gl.TEXTURE_2D, data.texture);
                var size = data.count * 3;
                gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                return size;
            };
            /**
             * 启用RenderBuffer
             */
            Renderer.prototype.activateBuffer = function (buffer, width, height) {
                buffer.rootRenderTarget.activate();
                if (!this.bindIndices) {
                    this.uploadIndicesArray(this.vao.getIndices());
                }
                buffer.restoreStencil();
                buffer.restoreScissor();
                this.onResize(width, height);
            };
            Renderer.prototype.onResize = function (width, height) {
                this.projectionX = width / 2;
                this.projectionY = -height / 2;
                if (this.context) {
                    this.context.viewport(0, 0, width, height);
                }
            };
            /**
             * 上传顶点数据
             */
            Renderer.prototype.uploadVerticesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ARRAY_BUFFER, array, gl.STREAM_DRAW);
            };
            /**
             * 上传索引数据
             */
            Renderer.prototype.uploadIndicesArray = function (array) {
                var gl = this.context;
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, array, gl.STATIC_DRAW);
                this.bindIndices = true;
            };
            /**
             * 画push mask
             **/
            Renderer.prototype.drawPushMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    if (buffer.rootRenderTarget) {
                        buffer.rootRenderTarget.enabledStencil();
                    }
                    if (buffer.stencilHandleCount == 0) {
                        buffer.enableStencil();
                        gl.clear(gl.STENCIL_BUFFER_BIT); // clear
                    }
                    var level = buffer.stencilHandleCount;
                    buffer.stencilHandleCount++;
                    gl.colorMask(false, false, false, false);
                    gl.stencilFunc(gl.EQUAL, level, 0xFF);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.INCR);
                    // gl.bindTexture(gl.TEXTURE_2D, null);
                    gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                    gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                    gl.colorMask(true, true, true, true);
                    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                }
                return size;
            };
            /**
             * 画pop mask
             **/
            Renderer.prototype.drawPopMaskElements = function (data, offset) {
                var gl = this.context;
                var size = data.count * 3;
                var buffer = this.activatedBuffer;
                if (buffer) {
                    buffer.stencilHandleCount--;
                    if (buffer.stencilHandleCount == 0) {
                        buffer.disableStencil(); // skip this draw
                    }
                    else {
                        var level = buffer.stencilHandleCount;
                        gl.colorMask(false, false, false, false);
                        gl.stencilFunc(gl.EQUAL, level + 1, 0xFF);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.DECR);
                        // gl.bindTexture(gl.TEXTURE_2D, null);
                        gl.drawElements(gl.TRIANGLES, size, gl.UNSIGNED_SHORT, offset * 2);
                        gl.stencilFunc(gl.EQUAL, level, 0xFF);
                        gl.colorMask(true, true, true, true);
                        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                    }
                }
                return size;
            };
            /**
             * 设置混色
             */
            Renderer.prototype.setBlendMode = function (value) {
                var gl = this.context;
                var blendModeWebGL = Renderer.blendModesForGL[value];
                if (blendModeWebGL) {
                    gl.blendFunc(blendModeWebGL[0], blendModeWebGL[1]);
                }
            };
            Renderer.initBlendMode = function () {
                Renderer.blendModesForGL = {};
                Renderer.blendModesForGL["source-over"] = [1, 771];
                Renderer.blendModesForGL["lighter"] = [1, 1];
                Renderer.blendModesForGL["lighter-in"] = [770, 771];
                Renderer.blendModesForGL["destination-out"] = [0, 771];
                Renderer.blendModesForGL["destination-in"] = [0, 770];
            };
            Renderer.blendModesForGL = null;
            return Renderer;
        }());
        web.Renderer = Renderer;
        __reflect(Renderer.prototype, "egret.web.Renderer");
        Renderer.initBlendMode();
    })(web = egret.web || (egret.web = {}));
})(egret || (egret = {}));
var egret3d;
(function (egret3d) {
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 恒定像素的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ConstantAdapter = (function () {
        function ConstantAdapter() {
            this.$dirty = true;
            this._scaleFactor = 1;
        }
        Object.defineProperty(ConstantAdapter.prototype, "scaleFactor", {
            /**
             * scaleFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置缩放值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._scaleFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        ConstantAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler = this._scaleFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ConstantAdapter;
    }());
    egret3d.ConstantAdapter = ConstantAdapter;
    __reflect(ConstantAdapter.prototype, "egret3d.ConstantAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ConstantAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 拉伸扩展的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ExpandAdapter = (function () {
        function ExpandAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ExpandAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ExpandAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasHeight / this._resolution.y;
            }
            else {
                scaler = canvasWidth / this._resolution.x;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ExpandAdapter;
    }());
    egret3d.ExpandAdapter = ExpandAdapter;
    __reflect(ExpandAdapter.prototype, "egret3d.ExpandAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * ShrinkAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 缩放的适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var ShrinkAdapter = (function () {
        function ShrinkAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        ShrinkAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        ShrinkAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var canvasRate = canvasWidth / canvasHeight;
            var resolutionRate = this._resolution.x / this._resolution.y;
            var scaler = 1;
            if (canvasRate > resolutionRate) {
                scaler = canvasWidth / this._resolution.x;
            }
            else {
                scaler = canvasHeight / this._resolution.y;
            }
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return ShrinkAdapter;
    }());
    egret3d.ShrinkAdapter = ShrinkAdapter;
    __reflect(ShrinkAdapter.prototype, "egret3d.ShrinkAdapter", ["egret3d.IScreenAdapter"]);
    /**
     * MatchWidthOrHeightAdapter
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 适应宽高适配策略
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MatchWidthOrHeightAdapter = (function () {
        function MatchWidthOrHeightAdapter() {
            this.$dirty = true;
            this._resolution = new egret3d.Vector2(640, 1136);
            this._matchFactor = 0; // width : height
        }
        /**
         * setResolution
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 设置分辨率
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MatchWidthOrHeightAdapter.prototype.setResolution = function (width, height) {
            this._resolution.x = width;
            this._resolution.y = height;
            this.$dirty = true;
        };
        Object.defineProperty(MatchWidthOrHeightAdapter.prototype, "matchFactor", {
            /**
             * matchFactor
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 设置匹配系数，0-1之间，越小越倾向以宽度适配，越大越倾向以高度适配。
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            set: function (value) {
                this._matchFactor = value;
                this.$dirty = true;
            },
            enumerable: true,
            configurable: true
        });
        MatchWidthOrHeightAdapter.prototype.calculateScaler = function (canvasWidth, canvasHeight, out) {
            var scaler1 = canvasWidth / this._resolution.x;
            var scaler2 = canvasHeight / this._resolution.y;
            var scaler = scaler1 + (scaler2 - scaler1) * this._matchFactor;
            out.s = scaler;
            out.w = canvasWidth / scaler;
            out.h = canvasHeight / scaler;
        };
        return MatchWidthOrHeightAdapter;
    }());
    egret3d.MatchWidthOrHeightAdapter = MatchWidthOrHeightAdapter;
    __reflect(MatchWidthOrHeightAdapter.prototype, "egret3d.MatchWidthOrHeightAdapter", ["egret3d.IScreenAdapter"]);
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var MissingComponent = (function (_super) {
        __extends(MissingComponent, _super);
        function MissingComponent() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.missingObject = null;
            return _this;
        }
        MissingComponent.prototype.serialize = function () {
            var rarget = _super.prototype.serialize.call(this);
            rarget.missingObject = this.missingObject;
            return rarget;
        };
        MissingComponent.prototype.deserialize = function (element) {
            this.missingObject = element.missingObject || null;
        };
        return MissingComponent;
    }(paper.BaseComponent));
    paper.MissingComponent = MissingComponent;
    __reflect(MissingComponent.prototype, "paper.MissingComponent");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var DirectLight = (function (_super) {
        __extends(DirectLight, _super);
        function DirectLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 1 /* Direction */;
            _this.renderTarget = new egret3d.GlRenderTarget(egret3d.WebGLCapabilities.webgl, 1024, 1024, true); // TODO
            return _this;
        }
        DirectLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = Math.PI * 0.25; //
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return DirectLight;
    }(egret3d.BaseLight));
    egret3d.DirectLight = DirectLight;
    __reflect(DirectLight.prototype, "egret3d.DirectLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _targets = [
        new egret3d.Vector3(-1, 0, 0), new egret3d.Vector3(1, 0, 0), new egret3d.Vector3(0, 1, 0),
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1), new egret3d.Vector3(0, 0, -1)
    ];
    var _ups = [
        new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, 0, 1),
        new egret3d.Vector3(0, 0, -1), new egret3d.Vector3(0, -1, 0), new egret3d.Vector3(0, -1, 0)
    ];
    /**
     *
     */
    var PointLight = (function (_super) {
        __extends(PointLight, _super);
        function PointLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 2 /* Point */;
            _this.renderTarget = new egret3d.GlRenderTarget(egret3d.WebGLCapabilities.webgl, 1024, 1024, true); // TODO
            return _this;
        }
        PointLight.prototype.update = function (camera, faceIndex) {
            var position = this.gameObject.transform.getPosition();
            egret3d.helpVector3A.set(position.x + _targets[faceIndex].x, position.y + _targets[faceIndex].y, position.z + _targets[faceIndex].z);
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = Math.PI * 0.5;
            camera.gameObject.transform.setPosition(position); // TODO support copy matrix.
            camera.gameObject.transform.setRotation(this.gameObject.transform.getRotation());
            camera.gameObject.transform.lookAt(egret3d.helpVector3A, _ups[faceIndex]);
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return PointLight;
    }(egret3d.BaseLight));
    egret3d.PointLight = PointLight;
    __reflect(PointLight.prototype, "egret3d.PointLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var SpotLight = (function (_super) {
        __extends(SpotLight, _super);
        function SpotLight() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.type = 3 /* Spot */;
            return _this;
        }
        SpotLight.prototype.update = function (camera, faceIndex) {
            camera.near = this.shadowCameraNear;
            camera.far = this.shadowCameraFar;
            camera.size = this.shadowSize;
            camera.fov = this.angle; //
            camera.gameObject.transform.getWorldMatrix().copy(this.gameObject.transform.getWorldMatrix()); //
            _super.prototype.update.call(this, camera, faceIndex);
        };
        return SpotLight;
    }(egret3d.BaseLight));
    egret3d.SpotLight = SpotLight;
    __reflect(SpotLight.prototype, "egret3d.SpotLight");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * MeshFilter 组件
     */
    var MeshFilter = (function (_super) {
        __extends(MeshFilter, _super);
        function MeshFilter() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._mesh = null;
            return _this;
        }
        MeshFilter.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                this._mesh.dispose();
            }
            this._mesh = null;
        };
        Object.defineProperty(MeshFilter.prototype, "mesh", {
            /**
             * 组件挂载的 mesh 模型
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    this._mesh.dispose();
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshFilter.prototype, "_mesh", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MESH)
        ], MeshFilter.prototype, "mesh", null);
        MeshFilter = __decorate([
            paper.disallowMultiple
        ], MeshFilter);
        return MeshFilter;
    }(paper.BaseComponent));
    egret3d.MeshFilter = MeshFilter;
    __reflect(MeshFilter.prototype, "egret3d.MeshFilter");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * mesh的渲染组件
     */
    var MeshRenderer = (function (_super) {
        __extends(MeshRenderer, _super);
        function MeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [egret3d.DefaultMaterials.DefaultDiffuse];
            return _this;
        }
        MeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            this._materials.length = 0;
        };
        Object.defineProperty(MeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value === this._materials) {
                    return;
                }
                this._materials.length = 0;
                for (var _i = 0, value_1 = value; _i < value_1.length; _i++) {
                    var material = value_1[_i];
                    this._materials.push(material);
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], MeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.editor.property(paper.editor.EditType.MATERIAL_ARRAY)
        ], MeshRenderer.prototype, "materials", null);
        MeshRenderer = __decorate([
            paper.disallowMultiple
        ], MeshRenderer);
        return MeshRenderer;
    }(paper.BaseRenderer));
    egret3d.MeshRenderer = MeshRenderer;
    __reflect(MeshRenderer.prototype, "egret3d.MeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var MeshRendererSystem = (function (_super) {
        __extends(MeshRendererSystem, _super);
        function MeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.MeshFilter,
                    listeners: [
                        { type: "mesh" /* Mesh */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
                {
                    componentClass: egret3d.MeshRenderer,
                    listeners: [
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } }
                    ]
                },
            ];
            _this._drawCalls = _this._globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            return _this;
        }
        MeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var filter = gameObject.getComponent(egret3d.MeshFilter);
            var renderer = gameObject.renderer;
            if (!filter.mesh || renderer.materials.length === 0) {
                return;
            }
            this._drawCalls.removeDrawCalls(renderer);
            //
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = filter.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: filter.mesh,
                    material: renderer.materials[primitive.material || 0] || egret3d.DefaultMaterials.MissingMaterial,
                    frustumTest: false,
                    zdist: -1,
                };
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        MeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        MeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        MeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        MeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        return MeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.MeshRendererSystem = MeshRendererSystem;
    __reflect(MeshRendererSystem.prototype, "egret3d.MeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var helpVec3_6 = new egret3d.Vector3();
    var helpVec3_7 = new egret3d.Vector3();
    // const helpVec3_8: Vector3 = new Vector3();
    var helpMat4_1 = new egret3d.Matrix();
    var helpMat4_2 = new egret3d.Matrix();
    var helpMat4_3 = new egret3d.Matrix();
    var helpMat4_4 = new egret3d.Matrix();
    var helpMat4_5 = new egret3d.Matrix();
    var helpMat4_6 = new egret3d.Matrix();
    /**
     * Skinned Mesh Renderer Component
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 蒙皮网格的渲染组件
     * @version paper 1.0
     * @platform Web
     * @language
     */
    var SkinnedMeshRenderer = (function (_super) {
        __extends(SkinnedMeshRenderer, _super);
        function SkinnedMeshRenderer() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._materials = [];
            _this._mesh = null;
            _this._bones = [];
            _this.center = new egret3d.Vector3();
            _this.size = new egret3d.Vector3();
            /**
             *
             */
            _this._boneDirty = true;
            _this._maxBoneCount = 0;
            /**
             *
             */
            _this._retargetBoneNames = null;
            _this._efficient = true; // 是否高效模式
            return _this;
        }
        Object.defineProperty(SkinnedMeshRenderer.prototype, "mesh", {
            /**
             * mesh instance
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * mesh实例
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._mesh;
            },
            set: function (mesh) {
                if (this._mesh === mesh) {
                    return;
                }
                if (this._mesh) {
                    // this._mesh.dispose(); TODO
                }
                this._mesh = mesh;
                paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
            },
            enumerable: true,
            configurable: true
        });
        SkinnedMeshRenderer.prototype._getMatByIndex = function (index, out) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var blendIndices = egret3d.helpVector4E;
            mesh.getAttribute(index, "JOINTS_0" /* JOINTS_0 */, 0, blendIndices);
            if (blendIndices.x >= this._maxBoneCount || blendIndices.y >= this._maxBoneCount || blendIndices.z >= this._maxBoneCount || blendIndices.w >= this._maxBoneCount) {
                return null;
            }
            var blendWeights = egret3d.helpVector4F;
            mesh.getAttribute(index, "WEIGHTS_0" /* WEIGHTS_0 */, 0, blendWeights);
            if (this._efficient) {
                var vec40r = egret3d.helpVector4A;
                var vec30p = egret3d.helpVector3A;
                vec40r.x = this._skeletonMatrixData[8 * blendIndices.x + 0]; // TODO
                vec40r.y = this._skeletonMatrixData[8 * blendIndices.x + 1];
                vec40r.z = this._skeletonMatrixData[8 * blendIndices.x + 2];
                vec40r.w = this._skeletonMatrixData[8 * blendIndices.x + 3];
                vec30p.x = this._skeletonMatrixData[8 * blendIndices.x + 4];
                vec30p.y = this._skeletonMatrixData[8 * blendIndices.x + 5];
                vec30p.z = this._skeletonMatrixData[8 * blendIndices.x + 6];
                var vec41r = egret3d.helpVector4B;
                var vec31p = egret3d.helpVector3B;
                vec41r.x = this._skeletonMatrixData[8 * blendIndices.y + 0];
                vec41r.y = this._skeletonMatrixData[8 * blendIndices.y + 1];
                vec41r.z = this._skeletonMatrixData[8 * blendIndices.y + 2];
                vec41r.w = this._skeletonMatrixData[8 * blendIndices.y + 3];
                vec31p.x = this._skeletonMatrixData[8 * blendIndices.y + 4];
                vec31p.y = this._skeletonMatrixData[8 * blendIndices.y + 5];
                vec31p.z = this._skeletonMatrixData[8 * blendIndices.y + 6];
                var vec42r = egret3d.helpVector4C;
                var vec32p = egret3d.helpVector3C;
                vec42r.x = this._skeletonMatrixData[8 * blendIndices.z + 0];
                vec42r.y = this._skeletonMatrixData[8 * blendIndices.z + 1];
                vec42r.z = this._skeletonMatrixData[8 * blendIndices.z + 2];
                vec42r.w = this._skeletonMatrixData[8 * blendIndices.z + 3];
                vec32p.x = this._skeletonMatrixData[8 * blendIndices.z + 4];
                vec32p.y = this._skeletonMatrixData[8 * blendIndices.z + 5];
                vec32p.z = this._skeletonMatrixData[8 * blendIndices.z + 6];
                var vec43r = egret3d.helpVector4D;
                var vec33p = egret3d.helpVector3D;
                vec43r.x = this._skeletonMatrixData[8 * blendIndices.w + 0];
                vec43r.y = this._skeletonMatrixData[8 * blendIndices.w + 1];
                vec43r.z = this._skeletonMatrixData[8 * blendIndices.w + 2];
                vec43r.w = this._skeletonMatrixData[8 * blendIndices.w + 3];
                vec33p.x = this._skeletonMatrixData[8 * blendIndices.w + 4];
                vec33p.y = this._skeletonMatrixData[8 * blendIndices.w + 5];
                vec33p.z = this._skeletonMatrixData[8 * blendIndices.w + 6];
                var mat0 = egret3d.helpMatrixA;
                var mat1 = egret3d.helpMatrixB;
                var mat2 = egret3d.helpMatrixC;
                var mat3 = egret3d.helpMatrixD;
                egret3d.Matrix.fromRTS(vec30p, egret3d.Vector3.ONE, vec40r, mat0);
                egret3d.Matrix.fromRTS(vec31p, egret3d.Vector3.ONE, vec41r, mat1);
                egret3d.Matrix.fromRTS(vec32p, egret3d.Vector3.ONE, vec42r, mat2);
                egret3d.Matrix.fromRTS(vec33p, egret3d.Vector3.ONE, vec43r, mat3);
                egret3d.Matrix.scale(blendWeights.x, mat0);
                egret3d.Matrix.scale(blendWeights.y, mat1);
                egret3d.Matrix.scale(blendWeights.z, mat2);
                egret3d.Matrix.scale(blendWeights.w, mat3);
                egret3d.Matrix.add(mat0, mat1, out);
                egret3d.Matrix.add(out, mat2, out);
                egret3d.Matrix.add(out, mat3, out);
            }
            else {
                // TODO
                // const mat0 = helpMatrixA;
                // const mat1 = helpMatrixB;
                // const mat2 = helpMatrixC;
                // const mat3 = helpMatrixD;
                // mat0.rawData = this._skeletonMatrixData.slice(16 * blendIndices.x, 16 * blendIndices.x + 16);
                // mat1.rawData = this._skeletonMatrixData.slice(16 * blendIndices.y, 16 * blendIndices.y + 16);
                // mat2.rawData = this._skeletonMatrixData.slice(16 * blendIndices.z, 16 * blendIndices.z + 16);
                // mat3.rawData = this._skeletonMatrixData.slice(16 * blendIndices.w, 16 * blendIndices.w + 16);
                // egret3d.Matrix.scale(blendWeights.x, mat0);
                // egret3d.Matrix.scale(blendWeights.y, mat1);
                // egret3d.Matrix.scale(blendWeights.z, mat2);
                // egret3d.Matrix.scale(blendWeights.w, mat3);
                // egret3d.Matrix.add(mat0, mat1, out);
                // egret3d.Matrix.add(out, mat2, out);
                // egret3d.Matrix.add(out, mat3, out);
            }
            return out;
        };
        SkinnedMeshRenderer.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            var shaderType = 0 /* SQT */;
            //TODO 不支持 pass结构，这里会有影响?
            // if (this._materials.length > 0) {
            //     const materialPasses = this._materials[0].getShader().passes["skin"];
            //     if (!materialPasses || materialPasses.length === 0) {
            //         shaderType = ShaderType.Matrix;
            //     }
            // }
            // TODO _bonePoses 应该是动态长度
            switch (shaderType) {
                // case ShaderType.Matrix:
                //     this._maxBoneCount = 24;
                //     this._skeletonMatrixData = new Float32Array(16 * this._maxBoneCount);
                //     break;
                case 0 /* SQT */:
                    this._maxBoneCount = 55;
                    this._skeletonMatrixData = new Float32Array(8 * this._maxBoneCount);
                    for (var i = 0; i < this._maxBoneCount; ++i) {
                        var iA = i * 8;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 0.0;
                        this._skeletonMatrixData[iA++] = 1.0;
                    }
                    break;
            }
            // TODO 如果layer发生改变，需要重新刷新在renderList中的层级。 可以依赖 event
            // if (this.materials != null && this.materials.length > 0) {
            //     let _mat = this.materials[0];
            //     if (_mat) {
            //         this.layer = _mat.getLayer();
            //         if (!this.issetq) {
            //             this._queue = _mat.getQueue();
            //         }
            //     }
            // }
        };
        SkinnedMeshRenderer.prototype.uninitialize = function () {
            _super.prototype.uninitialize.call(this);
            if (this._mesh) {
                // this._mesh.dispose();
            }
            this._bones.length = 0;
            this._mesh = null;
        };
        SkinnedMeshRenderer.prototype.serialize = function () {
            var target = _super.prototype.serialize.call(this);
            target.center = [this.center.x, this.center.y, this.center.z];
            target.size = [this.size.x, this.size.y, this.size.z];
            target.rootBone = null;
            target._bones = [];
            target._mesh = this._mesh ? this._mesh.serialize() : null;
            target._materials = [];
            if (this.rootBone) {
                target.rootBone = { uuid: this.rootBone.uuid };
            }
            var materials = this._materials;
            target._materials.length = materials.length;
            for (var i = 0, l = materials.length; i < l; i++) {
                var material = materials[i];
                target._materials[i] = material.serialize();
                // target._materials[i] = paper.createAssetReference(material);
            }
            var bones = this._bones;
            target._bones.length = bones.length;
            for (var i = 0, l = bones.length; i < l; i++) {
                var bone = bones[i];
                target._bones[i] = { uuid: bone.uuid };
            }
            return target;
        };
        SkinnedMeshRenderer.prototype.deserialize = function (element) {
            _super.prototype.deserialize.call(this, element);
            this.center.deserialize(element.center);
            this.size.deserialize(element.size);
            if (element._mesh) {
                this._mesh = new egret3d.Mesh(); //
                this._mesh.deserialize(element._mesh);
            }
            if (element.rootBone) {
                this.rootBone = paper.getDeserializedAssetOrComponent(element.rootBone);
            }
            this._materials.length = 0;
            if (element._materials) {
                for (var i = 0, l = element._materials.length; i < l; i++) {
                    var material = new egret3d.Material();
                    material.deserialize(element._materials[i]);
                    this._materials.push(material);
                    // this._materials.push(paper.getDeserializedAssetOrComponent(element._materials[i]) as Material);
                }
            }
            this._bones.length = 0;
            if (element._bones) {
                for (var i = 0, l = element._bones.length; i < l; i++) {
                    this._bones.push(paper.getDeserializedAssetOrComponent(element._bones[i]));
                }
            }
        };
        /**
         * ray intersects
         * @param ray ray
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 射线检测
         * @param ray 射线
         * @version paper 1.0
         * @platform Web
         * @language
         */
        SkinnedMeshRenderer.prototype.intersects = function (ray) {
            var mesh = this._mesh;
            if (!mesh) {
                return null;
            }
            var mvpmat = this.gameObject.transform.getWorldMatrix();
            var pickinfo = null;
            // let data = this.mesh.data;
            var subMeshIndex = 0;
            for (var _i = 0, _a = mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var mat0 = helpMat4_1;
                var mat1 = helpMat4_2;
                var mat2 = helpMat4_3;
                var mat00 = helpMat4_4;
                var mat11 = helpMat4_5;
                var mat22 = helpMat4_6;
                var indices = mesh.getIndices(subMeshIndex);
                if (indices) {
                    var t0 = helpVec3_1;
                    var t1 = helpVec3_2;
                    var t2 = helpVec3_3;
                    var vertices = mesh.getVertices(subMeshIndex);
                    for (var i = 0; i < indices.length; i += 3) {
                        // TODO
                        var verindex0 = indices[i];
                        var verindex1 = indices[i + 1];
                        var verindex2 = indices[i + 2];
                        var p0 = helpVec3_4;
                        var p1 = helpVec3_5;
                        var p2 = helpVec3_6;
                        var index = indices[i] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p0);
                        index = indices[i + 1] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p1);
                        index = indices[i + 2] * 3;
                        egret3d.Vector3.set(vertices[index], vertices[index + 1], vertices[index + 2], p2);
                        this._getMatByIndex(verindex0, mat0);
                        this._getMatByIndex(verindex1, mat1);
                        this._getMatByIndex(verindex2, mat2);
                        if (mat0 === null || mat1 === null || mat2 === null)
                            continue;
                        egret3d.Matrix.multiply(mvpmat, mat0, mat00);
                        egret3d.Matrix.multiply(mvpmat, mat1, mat11);
                        egret3d.Matrix.multiply(mvpmat, mat2, mat22);
                        egret3d.Matrix.transformVector3(p0, mat00, t0);
                        egret3d.Matrix.transformVector3(p1, mat11, t1);
                        egret3d.Matrix.transformVector3(p2, mat22, t2);
                        var result = ray.intersectsTriangle(t0, t1, t2);
                        if (result) {
                            if (result.distance < 0)
                                continue;
                            if (!pickinfo || pickinfo.distance > result.distance) {
                                pickinfo = result;
                                pickinfo.triangleIndex = i / 3;
                                pickinfo.subMeshIndex = subMeshIndex;
                                var tdir = helpVec3_7;
                                egret3d.Vector3.copy(ray.direction, tdir);
                                egret3d.Vector3.scale(tdir, result.distance);
                                egret3d.Vector3.add(ray.origin, tdir, pickinfo.position);
                            }
                        }
                    }
                }
                subMeshIndex++;
            }
            return pickinfo;
        };
        Object.defineProperty(SkinnedMeshRenderer.prototype, "materials", {
            /**
             * material list
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 材质数组
             * @version paper 1.0
             * @platform Web
             * @language
             */
            get: function () {
                return this._materials;
            },
            set: function (value) {
                if (value !== this._materials) {
                    for (var _i = 0, value_2 = value; _i < value_2.length; _i++) {
                        var material = value_2[_i];
                        this._materials.push(material);
                    }
                }
                paper.EventPool.dispatchEvent("materials" /* Materials */, this);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "bones", {
            /**
             * 骨骼列表
             *
             */
            get: function () {
                return this._bones;
            },
            set: function (value) {
                if (value !== this._bones) {
                    this._bones.length = 0;
                    for (var _i = 0, value_3 = value; _i < value_3.length; _i++) {
                        var bone = value_3[_i];
                        this._bones.push(bone);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(SkinnedMeshRenderer.prototype, "boneBuffer", {
            /**
             *
             */
            get: function () {
                return this.cacheData || this._skeletonMatrixData;
            },
            enumerable: true,
            configurable: true
        });
        /**
         *
         */
        SkinnedMeshRenderer.dataCaches = [];
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_materials", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_mesh", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "_bones", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "rootBone", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "center", void 0);
        __decorate([
            paper.serializedField
        ], SkinnedMeshRenderer.prototype, "size", void 0);
        SkinnedMeshRenderer = __decorate([
            paper.disallowMultiple
        ], SkinnedMeshRenderer);
        return SkinnedMeshRenderer;
    }(paper.BaseRenderer));
    egret3d.SkinnedMeshRenderer = SkinnedMeshRenderer;
    __reflect(SkinnedMeshRenderer.prototype, "egret3d.SkinnedMeshRenderer");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * TODO 需要完善
     */
    var SkinnedMeshRendererSystem = (function (_super) {
        __extends(SkinnedMeshRendererSystem, _super);
        function SkinnedMeshRendererSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                {
                    componentClass: egret3d.SkinnedMeshRenderer,
                    listeners: [
                        { type: "mesh" /* Mesh */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                        { type: "materials" /* Materials */, listener: function (component) { _this._updateDrawCalls(component.gameObject); } },
                    ]
                }
            ];
            _this._drawCalls = _this._globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            return _this;
        }
        SkinnedMeshRendererSystem.prototype._updateDrawCalls = function (gameObject) {
            if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                return;
            }
            var renderer = gameObject.renderer;
            if (!renderer.mesh || renderer.materials.length === 0) {
                return;
            }
            //
            this._drawCalls.removeDrawCalls(renderer);
            //
            this._drawCalls.renderers.push(renderer);
            //
            var subMeshIndex = 0;
            for (var _i = 0, _a = renderer.mesh.glTFMesh.primitives; _i < _a.length; _i++) {
                var primitive = _a[_i];
                var material = renderer.materials[primitive.material || 0];
                var drawCall = {
                    renderer: renderer,
                    subMeshIndex: subMeshIndex++,
                    mesh: renderer.mesh,
                    material: renderer.materials[primitive.material || 0] || egret3d.DefaultMaterials.MissingMaterial,
                    frustumTest: false,
                    zdist: -1,
                    boneData: renderer.boneBuffer,
                };
                material.addDefine("SKINNING");
                this._drawCalls.drawCalls.push(drawCall);
            }
        };
        SkinnedMeshRendererSystem.prototype.onEnable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._updateDrawCalls(gameObject);
            }
        };
        SkinnedMeshRendererSystem.prototype.onAddGameObject = function (gameObject) {
            this._updateDrawCalls(gameObject);
        };
        SkinnedMeshRendererSystem.prototype.onRemoveGameObject = function (gameObject) {
            this._drawCalls.removeDrawCalls(gameObject.renderer);
        };
        SkinnedMeshRendererSystem.prototype.onUpdate = function () {
            // TODO
        };
        SkinnedMeshRendererSystem.prototype.onDisable = function () {
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                this._drawCalls.removeDrawCalls(gameObject.renderer);
            }
        };
        return SkinnedMeshRendererSystem;
    }(paper.BaseSystem));
    egret3d.SkinnedMeshRendererSystem = SkinnedMeshRendererSystem;
    __reflect(SkinnedMeshRendererSystem.prototype, "egret3d.SkinnedMeshRendererSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     */
    var BoneBlendLayer = (function () {
        function BoneBlendLayer() {
            this.dirty = 0;
            this.layer = 0;
            this.leftWeight = 0;
            this.layerWeight = 0;
            this.blendWeight = 0;
            this.target = null;
        }
        BoneBlendLayer.prototype.update = function (animationState) {
            var animationLayer = animationState.layer;
            var animationWeight = animationState._globalWeight;
            if (this.dirty > 0) {
                if (this.leftWeight > 0.0) {
                    if (animationState.additive && this.layer !== animationLayer) {
                        if (this.layerWeight >= this.leftWeight) {
                            this.leftWeight = 0.0;
                            return false;
                        }
                        this.layer = animationLayer;
                        this.leftWeight -= this.layerWeight;
                        this.layerWeight = animationWeight * this.leftWeight;
                    }
                    animationWeight *= this.leftWeight;
                    this.dirty++;
                    this.blendWeight = animationWeight;
                    return true;
                }
                return false;
            }
            this.dirty++;
            this.layer = animationLayer;
            this.leftWeight = 1.0;
            this.layerWeight = animationWeight;
            this.blendWeight = animationWeight;
        };
        return BoneBlendLayer;
    }());
    egret3d.BoneBlendLayer = BoneBlendLayer;
    __reflect(BoneBlendLayer.prototype, "egret3d.BoneBlendLayer");
    /**
     *
     */
    var AnimationChannel = (function () {
        function AnimationChannel() {
            this.update = null;
        }
        return AnimationChannel;
    }());
    __reflect(AnimationChannel.prototype, "AnimationChannel");
    /**
     * 动画混合节点。
     */
    var BlendNode = (function () {
        function BlendNode() {
            /**
             * @private
             */
            this.additive = false;
            /**
             * 动画混合模式。（根节点有效）
             */
            this.layer = 0;
            /**
             * 节点权重。
             */
            this.weight = 1.0;
            /**
             * 淡入淡出的时间。
             */
            this.fadeTime = 1.0;
            /**
             * 父节点。
             */
            this.parent = null;
            /**
             * -1: Fade in, 0: Fade complete, 1: Fade out;
             * @internal
             */
            this._fadeState = -1;
            /**
             * -1: Fade start, 0: Fading, 1: Fade complete;
             * @internal
             */
            this._subFadeState = -1;
            /**
             * 累计权重。
             * @internal
             */
            this._globalWeight = 0.0;
            /**
             * 融合进度。
             * @internal
             */
            this._fadeProgress = 0.0;
            /**
             * 全局融合时间标记。
             */
            this._fadeTimeStart = 0.0;
        }
        BlendNode.prototype._onFadeStateChange = function () {
        };
        BlendNode.prototype.update = function (globalTime) {
            var isFadeOut = this._fadeState > 0;
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._subFadeState < 0) {
                this._subFadeState = 0;
                this._onFadeStateChange();
            }
            if (localFadeTime >= this.fadeTime) {
                this._subFadeState = 1;
                this._fadeProgress = isFadeOut ? 0.0 : 1.0;
            }
            else if (localFadeTime > 0.0) {
                this._fadeProgress = isFadeOut ? (1.0 - localFadeTime / this.fadeTime) : (localFadeTime / this.fadeTime);
            }
            else {
                this._fadeProgress = isFadeOut ? 1.0 : 0.0;
            }
            if (this._subFadeState > 0) {
                if (!isFadeOut) {
                    this._fadeState = 0;
                    this._onFadeStateChange();
                }
            }
            this._globalWeight = this.weight * this._fadeProgress;
            if (this.parent) {
                this._globalWeight *= this.parent._globalWeight;
            }
        };
        BlendNode.prototype.fadeOut = function (fadeTime) {
            var globalTime = paper.Time.time; //
            var localFadeTime = globalTime - this._fadeTimeStart;
            if (this._fadeState > 0) {
                if (fadeTime > this.fadeTime - localFadeTime) {
                    return;
                }
            }
            else {
                this._fadeState = 1;
                this._subFadeState = -1;
                if (fadeTime <= 0.0 || this._fadeProgress <= 0.0) {
                    this._fadeProgress = 0.000001; // Modify fade progress to different value.
                }
            }
            this.fadeTime = this._fadeProgress > 0.000001 ? fadeTime / this._fadeProgress : 0.0;
            this._fadeTimeStart = globalTime - this.fadeTime * (1.0 - this._fadeProgress);
        };
        return BlendNode;
    }());
    egret3d.BlendNode = BlendNode;
    __reflect(BlendNode.prototype, "egret3d.BlendNode");
    /**
     * 动画混合树节点。
     */
    var BlendTree = (function (_super) {
        __extends(BlendTree, _super);
        function BlendTree() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._blendNodes = [];
            return _this;
        }
        return BlendTree;
    }(BlendNode));
    egret3d.BlendTree = BlendTree;
    __reflect(BlendTree.prototype, "egret3d.BlendTree");
    /**
     * 动画状态。
     */
    var AnimationState = (function (_super) {
        __extends(AnimationState, _super);
        function AnimationState() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.layer = 0;
            /**
             * 动画总播放次数。
             */
            _this.playTimes = 0;
            /**
             * 动画当前播放次数。
             */
            _this.currentPlayTimes = 0;
            /**
             * 播放速度。
             */
            _this.timeScale = 1.0;
            /**
             * @private
             */
            _this.animationAsset = null;
            /**
             * 播放的动画数据。
             */
            _this.animation = null;
            /**
             * 播放的动画剪辑。
             */
            _this.animationClip = null;
            /**
             * 是否允许播放。
             */
            _this._isPlaying = true;
            /**
             * 播放状态。
             * -1: start, 0: playing, 1: complete;
             */
            _this._playState = -1;
            /**
             * 帧率。
             */
            _this._frameRate = 0;
            /**
             * 起始帧。
             */
            _this._frameStart = 0;
            /**
             * 总帧数。
             */
            _this._frameCount = 0;
            /**
             * 全局播放时间标记。
             */
            _this._playTimeStart = 0.0;
            /**
             * 本地播放时间。
             */
            _this._playTime = 0.0;
            /**
             * 帧插值进度。
             */
            _this._frameProgress = 0.0;
            _this._animationComponent = null;
            // TODO
            _this._channels = [];
            // TODO
            _this._retargetBoneIndices = [];
            _this._delta = [];
            _this._frameBuffer = null;
            _this._frameOffset = -1;
            _this._nextFrameOffset = -1;
            _this._frameOffsets = null;
            return _this;
        }
        AnimationState.prototype._onArriveAtFrame = function () {
        };
        AnimationState.prototype._onUpdateFrame = function () {
            var delta = this._delta;
            var result = this._animationComponent._skinnedMeshRenderer._skeletonMatrixData;
            var boneBlendLayers = this._animationComponent._boneBlendLayers;
            var frameBuffer = this._frameBuffer;
            for (var i = 0, l = this._retargetBoneIndices.length; i < l; ++i) {
                var boneIndex = this._retargetBoneIndices[i];
                if (boneIndex < 0) {
                    continue;
                }
                var poseBoneOffsetA = i * 7;
                var poseBoneOffsetC = boneIndex * 8;
                var frameOffset = this._frameOffset + poseBoneOffsetA;
                var boneBlendNode = boneBlendLayers[boneIndex];
                if (boneBlendNode.update(this)) {
                    for (var j = 0; j < 7; ++j) {
                        result[poseBoneOffsetC + j] = frameBuffer[frameOffset + j];
                    }
                    result[poseBoneOffsetC + 7] = 1.0;
                }
            }
        };
        AnimationState.prototype._onUpdateTranslation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalPosition(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalPosition(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateRotation = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 4;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            var w = outputBuffer[offset + 3];
            if (isInterpolation) {
                var nextIndex = offset + 4;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalRotation(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress, w + (outputBuffer[nextIndex + 3] - w) * progress);
            }
            else {
                transform.setLocalRotation(x, y, z, w);
            }
        };
        AnimationState.prototype._onUpdateScale = function (channel) {
            var isInterpolation = false;
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                isInterpolation = channel.glTFSampler.interpolation !== "STEP";
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            var x = outputBuffer[offset];
            var y = outputBuffer[offset + 1];
            var z = outputBuffer[offset + 2];
            if (isInterpolation) {
                var nextIndex = offset + 3;
                var progress = (this._playTime - inputBuffer[frameIndex]) / (inputBuffer[frameIndex + 1] - inputBuffer[frameIndex]);
                transform.setLocalScale(x + (outputBuffer[nextIndex] - x) * progress, y + (outputBuffer[nextIndex + 1] - y) * progress, z + (outputBuffer[nextIndex + 2] - z) * progress);
            }
            else {
                transform.setLocalScale(x, y, z);
            }
        };
        AnimationState.prototype._onUpdateActive = function (channel) {
            var frameIndex = 0;
            var inputBuffer = channel.inputBuffer;
            var outputBuffer = channel.outputBuffer;
            var transform = channel.component;
            if (this._playTime <= inputBuffer[0]) {
            }
            else if (this._playTime >= inputBuffer[inputBuffer.length - 1]) {
                frameIndex = inputBuffer.length - 1;
            }
            else {
                for (var i = 0, l = inputBuffer.length; i < l; ++i) {
                    if (this._playTime < inputBuffer[i]) {
                        break;
                    }
                    frameIndex = i;
                }
            }
            var offset = frameIndex * 3;
            transform.gameObject.activeSelf = outputBuffer[offset] !== 0;
        };
        /**
         *
         */
        AnimationState.prototype.initialize = function (animationComponent, animationAsset, animationClip) {
            var globalTime = paper.Time.time; //
            var assetConfig = animationAsset.config;
            //
            this.animationAsset = animationAsset;
            this.animationClip = animationClip;
            this.animation = assetConfig.animations[0]; // TODO 动画数据暂不合并。
            //
            var paperAnimation = this.animation.extensions.paper;
            var dataAccessor = this.animationAsset.getAccessor(paperAnimation.data);
            //
            this._frameRate = paperAnimation.frameRate;
            this._frameStart = Math.floor(this.animationClip.position * paperAnimation.frameRate);
            this._frameCount = Math.floor(this.animationClip.duration * paperAnimation.frameRate); // ceil.
            this._fadeTimeStart = globalTime;
            this._playTimeStart = globalTime;
            this._animationComponent = animationComponent;
            //
            var skinnedMeshRenderer = this._animationComponent._skinnedMeshRenderer;
            if (skinnedMeshRenderer) {
                // Retargeting.
                var skeletonRetarget = skinnedMeshRenderer._retargetBoneNames || skinnedMeshRenderer.bones.map(function (bone) { return bone.gameObject.name; });
                var animationRetarget = paperAnimation.retarget ? paperAnimation.retarget.joints : paperAnimation.joints;
                //
                this._delta.length = skeletonRetarget.length * 7;
                this._frameBuffer = this.animationAsset.createTypeArrayFromAccessor(dataAccessor);
                this._frameOffsets = this.animation.extensions.paper.frames;
                for (var _i = 0, animationRetarget_1 = animationRetarget; _i < animationRetarget_1.length; _i++) {
                    var boneName = animationRetarget_1[_i];
                    var index = skeletonRetarget.indexOf(boneName);
                    this._retargetBoneIndices.push(index);
                }
                // if (assetConfig.extensions.paper.skeletons) {
                //     for (const skeleton of assetConfig.extensions.paper.skeletons) {
                //         if (skeleton.name === this.animationAsset.name) {
                //             this._skeleton = skeleton;
                //             if (this._skeleton && !this._skeleton.do) {
                //                 const tPose = this._skeleton.tPose;
                //                 let iA = 0;
                //                 let iB = 0;
                //                 for (let i = 0; i < skeletonRetarget.length; i++) {
                //                     helpQuaternionA.x = tPose[iA++];
                //                     helpQuaternionA.y = tPose[iA++];
                //                     helpQuaternionA.z = tPose[iA++];
                //                     helpQuaternionA.w = tPose[iA++];
                //                     helpVec3A.x = tPose[iA++];
                //                     helpVec3A.y = tPose[iA++];
                //                     helpVec3A.z = tPose[iA++];
                //                     Quaternion.inverse(helpQuaternionA);
                //                     Quaternion.transformVector3(helpQuaternionA, helpVec3A, helpVec3A);
                //                     helpVec3A.x *= -1;
                //                     helpVec3A.y *= -1;
                //                     helpVec3A.z *= -1;
                //                     tPose[iB++] = helpQuaternionA.x;
                //                     tPose[iB++] = helpQuaternionA.y;
                //                     tPose[iB++] = helpQuaternionA.z;
                //                     tPose[iB++] = helpQuaternionA.w;
                //                     tPose[iB++] = helpVec3A.x;
                //                     tPose[iB++] = helpVec3A.y;
                //                     tPose[iB++] = helpVec3A.z;
                //                 }
                //             }
                //         }
                //     }
                // }
            }
            else if (this.animation.channels) {
                var rootGameObject = this._animationComponent.gameObject;
                var transforms = rootGameObject.transform.getAllChildren();
                var gameObjects = {};
                gameObjects[rootGameObject.name] = rootGameObject;
                for (var _a = 0, transforms_1 = transforms; _a < transforms_1.length; _a++) {
                    var gameObject = transforms_1[_a].gameObject;
                    gameObjects[gameObject.name] = gameObject;
                }
                for (var _b = 0, _c = this.animation.channels; _b < _c.length; _b++) {
                    var glTFChannel = _c[_b];
                    var node = this.animationAsset.getNode(glTFChannel.target.node || 0);
                    var gameObject = gameObjects[node.name];
                    if (!gameObject) {
                        continue;
                    }
                    var channel = new AnimationChannel();
                    channel.glTFChannel = glTFChannel;
                    channel.glTFSampler = this.animation.samplers[glTFChannel.sampler];
                    channel.gameObject = gameObject;
                    channel.component = gameObject.transform; // TODO 更多组件
                    channel.inputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.input));
                    channel.outputBuffer = this.animationAsset.createTypeArrayFromAccessor(this.animationAsset.getAccessor(channel.glTFSampler.output));
                    switch (channel.glTFChannel.target.path) {
                        case "translation":
                            channel.update = this._onUpdateTranslation.bind(this);
                            break;
                        case "rotation":
                            channel.update = this._onUpdateRotation.bind(this);
                            break;
                        case "scale":
                            channel.update = this._onUpdateScale.bind(this);
                            break;
                        case "weights":
                            // TODO
                            break;
                        case "custom":
                            switch (channel.glTFChannel.extensions.paper.type) {
                                case "paper.GameObject":
                                    switch (channel.glTFChannel.extensions.paper.property) {
                                        case "activeSelf":
                                            channel.update = this._onUpdateActive.bind(this);
                                            break;
                                    }
                                    break;
                            }
                            break;
                        default:
                            console.warn("Unknown animation channel.", channel.glTFChannel.target.path);
                            break;
                    }
                    this._channels.push(channel);
                }
            }
        };
        /**
         *
         */
        AnimationState.prototype.update = function (globalTime) {
            _super.prototype.update.call(this, globalTime);
            var prevPlayTimes = this.currentPlayTimes;
            var prevPlayState = this._playState;
            var timeScale = this.timeScale * this._animationComponent.timeScale;
            var timeScaleR = timeScale === 0.0 ? 0.0 : 1.0 / timeScale;
            var position = this.animationClip.position;
            var duration = this.animationClip.duration;
            var totalTime = this.playTimes * duration;
            var localPlayTime = (globalTime - this._playTimeStart) * timeScaleR;
            var currentTime = 0.0;
            if (this.playTimes > 0 && (timeScale >= 0.0 ? localPlayTime >= totalTime : localPlayTime <= 0.0)) {
                if (this._playState <= 0 && this._isPlaying) {
                    this._playState = 1;
                }
                this.currentPlayTimes = this.playTimes;
                if (localPlayTime >= totalTime) {
                    currentTime = duration + 0.000001; // Precision problem.
                }
                else {
                    currentTime = 0.0;
                }
            }
            else {
                if (this._playState !== 0 && this._isPlaying) {
                    this._playState = 0;
                }
                if (localPlayTime < 0.0) {
                    localPlayTime = -localPlayTime;
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = duration - (localPlayTime % duration);
                }
                else {
                    this.currentPlayTimes = Math.floor(localPlayTime / duration);
                    currentTime = localPlayTime % duration;
                }
            }
            currentTime += position;
            this._playTime = currentTime;
            if (this._channels.length > 0) {
                for (var _i = 0, _a = this._channels; _i < _a.length; _i++) {
                    var channel = _a[_i];
                    if (channel.update) {
                        channel.update(channel);
                    }
                }
            }
            else if (this._animationComponent._skinnedMeshRenderer) {
                // Clear frame flag when timeline start or loopComplete.
                if ((prevPlayState < 0 && this._playState !== prevPlayState) ||
                    (this._playState <= 0 && this.currentPlayTimes !== prevPlayTimes)) {
                    this._frameOffset = -1;
                }
                if (this._frameCount > 1) {
                    var frameIndexF = this._playTime * this._frameRate;
                    var frameIndex = Math.min(Math.floor(frameIndexF), this._frameStart + this._frameCount - 1);
                    var frameOffset = this._frameOffsets[frameIndex];
                    if (this._frameOffset !== frameOffset) {
                        this._frameOffset = frameOffset;
                        this._nextFrameOffset = this._frameOffsets[frameIndex + 1];
                        this._onArriveAtFrame();
                    }
                    this._frameProgress = frameIndexF - frameIndex;
                    this._onUpdateFrame();
                }
                else if (this._frameOffset < 0) {
                    this._frameOffset = this._frameOffsets[0];
                    this._nextFrameOffset = -1;
                    this._onArriveAtFrame();
                }
            }
            if (prevPlayState !== this._playState && this._playState === 1) {
                this._animationComponent._dispatchEvent("complete", this);
                var animationNames = this._animationComponent._animationNames;
                if (animationNames.length > 0) {
                    var animationName = animationNames.shift();
                    this._animationComponent.play(animationName);
                }
            }
        };
        AnimationState.prototype.fateOut = function () {
            this._fadeState = 1;
            this._subFadeState = -1;
        };
        return AnimationState;
    }(BlendNode));
    egret3d.AnimationState = AnimationState;
    __reflect(AnimationState.prototype, "egret3d.AnimationState");
    /**
     * 动画组件。
     */
    var Animation = (function (_super) {
        __extends(Animation, _super);
        function Animation() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             * @private
             */
            _this.autoPlay = false;
            /**
             * 动画速度。
             */
            _this.timeScale = 1.0;
            /**
             * @internal
             */
            _this._addToSystem = false;
            /**
             * 动画数据列表。
             */
            _this._animations = [];
            /**
             * 骨骼姿势列表。
             * @internal
             */
            _this._boneBlendLayers = [];
            /**
             * 混合节点列表。
             */
            _this._blendNodes = [];
            /**
             * @internal
             */
            _this._animationNames = [];
            _this._fadeInParamter = null;
            /**
             * 最后一个播放的动画状态。
             * 当进行动画混合时，该值通常没有任何意义。
             */
            _this._lastAnimationState = null;
            /**
             * @internal
             */
            _this._skinnedMeshRenderer = null;
            return _this;
        }
        /**
         * @internal
         */
        Animation.prototype._dispatchEvent = function (type, animationState, eventObject) {
            for (var _i = 0, _a = this.gameObject.getComponents(paper.Behaviour, true); _i < _a.length; _i++) {
                var component = _a[_i];
                if (component.onAnimationEvent) {
                    component.onAnimationEvent(type, animationState, eventObject);
                }
            }
        };
        /**
         *
         */
        Animation.prototype.update = function (globalTime) {
            if (this._fadeInParamter) {
                this.fadeIn.apply(this, this._fadeInParamter);
                this._fadeInParamter = null;
            }
            var blendNodes = this._blendNodes;
            var blendNodeCount = blendNodes.length;
            if (blendNodeCount === 1) {
                var blendNode = blendNodes[0];
                if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                    blendNodes.length = 0;
                    if (this._lastAnimationState === blendNode) {
                        this._lastAnimationState = null;
                    }
                }
                else {
                    blendNode.update(globalTime);
                }
                // if (this._lastAnimationState) {
                //     const skeleton = this._lastAnimationState._skeleton;
                //     if (skeleton) {
                //         const result = this._skinnedMeshRenderer._skeletonMatrixData;
                //         const bones = this._skinnedMeshRenderer.bones;
                //         let iA = 0;
                //         let iB = 0;
                //         for (let i = 0, l = this._boneBlendLayers.length; i < l; ++i) {
                //             const boneBlendLayer = this._boneBlendLayers[i];
                //             boneBlendLayer.dirty = false;
                //             if (i < bones.length) {
                //                 const bone = bones[i];
                //                 const dir = helpVec3A;
                //                 const dirtran = helpVec3B;
                //                 helpQuaternionB.x = skeleton.tPose[iA++];
                //                 helpQuaternionB.y = skeleton.tPose[iA++];
                //                 helpQuaternionB.z = skeleton.tPose[iA++];
                //                 helpQuaternionB.w = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.x = skeleton.tPose[iA++];
                //                 dir.y = skeleton.tPose[iA++];
                //                 helpQuaternionA.x = result[iB];
                //                 helpQuaternionA.y = result[iB];
                //                 helpQuaternionA.z = result[iB];
                //                 helpQuaternionA.w = result[iB];
                //                 Quaternion.transformVector3(helpQuaternionA, dir, dirtran);
                //                 dirtran.x += result[iB];
                //                 dirtran.y += result[iB];
                //                 dirtran.z += result[iB];
                //                 iB++;
                //                 Quaternion.multiply(helpQuaternionA, helpQuaternionB, helpQuaternionC);
                //                 const position = helpVec3A;
                //                 const rotation = helpQuaternionA;
                //                 Vector3.add(bone.getPosition(), dirtran, position);
                //                 Quaternion.multiply(helpQuaternionC, bone.getRotation(), rotation);
                //                 bone.setPosition(position);
                //                 bone.setRotation(rotation);
                //             }
                //         }
                //     }
                // }
            }
            else if (blendNodeCount > 1) {
                for (var i = 0, r = 0; i < blendNodeCount; ++i) {
                    var blendNode = blendNodes[i];
                    if (blendNode._fadeState > 0 && blendNode._subFadeState > 0) {
                        r++;
                        if (this._lastAnimationState === blendNode) {
                            this._lastAnimationState = null;
                        }
                    }
                    else {
                        if (r > 0) {
                            blendNodes[i - r] = blendNode;
                        }
                        blendNode.update(globalTime);
                    }
                    if (i === blendNodeCount - 1 && r > 0) {
                        blendNodes.length -= r;
                        if (this._lastAnimationState === null && blendNodes.length > 0) {
                            var blendNode_1 = blendNodes[blendNodes.length - 1];
                            if (blendNode_1 instanceof AnimationState) {
                                this._lastAnimationState = blendNode_1;
                            }
                        }
                    }
                }
            }
            else {
            }
        };
        Animation.prototype.fadeIn = function (animationName, fadeTime, playTimes, layer, additive) {
            if (animationName === void 0) { animationName = null; }
            if (playTimes === void 0) { playTimes = -1; }
            if (layer === void 0) { layer = 0; }
            if (additive === void 0) { additive = false; }
            if (!this._addToSystem) {
                console.warn("The animation component is not add to system yet.");
                this._fadeInParamter = arguments;
                return null;
            }
            var animationAsset = null;
            var animationClip = null;
            for (var _i = 0, _a = this._animations; _i < _a.length; _i++) {
                var animation = _a[_i];
                animationAsset = animation;
                if (animationName) {
                    animationClip = animation.getAnimationClip(animationName);
                    if (animationClip !== null) {
                        break;
                    }
                }
                else {
                    animationClip = animation.getAnimationClip("");
                    break;
                }
            }
            if (!animationAsset || !animationClip) {
                return null;
            }
            for (var _b = 0, _c = this._blendNodes; _b < _c.length; _b++) {
                var blendNode = _c[_b];
                if ((!blendNode.parent && blendNode.layer === layer)) {
                    blendNode.fadeOut(fadeTime);
                }
            }
            var animationState = new AnimationState();
            animationState.initialize(this, animationAsset, animationClip);
            animationState.additive = additive;
            animationState.fadeTime = fadeTime;
            animationState.playTimes = playTimes < 0 ? (animationClip.playTimes || 0) : playTimes;
            // TODO sort by layer and blend tree.
            this._blendNodes.push(animationState);
            this._lastAnimationState = animationState;
            return animationState;
        };
        Animation.prototype.play = function (animationNameOrNames, playTimes) {
            if (animationNameOrNames === void 0) { animationNameOrNames = null; }
            if (playTimes === void 0) { playTimes = -1; }
            this._animationNames.length = 0;
            if (Array.isArray(animationNameOrNames)) {
                if (animationNameOrNames.length > 0) {
                    for (var _i = 0, animationNameOrNames_1 = animationNameOrNames; _i < animationNameOrNames_1.length; _i++) {
                        var animationName = animationNameOrNames_1[_i];
                        this._animationNames.push(animationName);
                    }
                    return this.fadeIn(this._animationNames.shift(), 0.0, playTimes);
                }
                return this.fadeIn(null, 0.0, playTimes);
            }
            return this.fadeIn(animationNameOrNames, 0.0, playTimes);
        };
        Object.defineProperty(Animation.prototype, "lastAnimationnName", {
            get: function () {
                return this._lastAnimationState ? this._lastAnimationState.animationClip.name : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Animation.prototype, "animations", {
            get: function () {
                return this._animations;
            },
            /**
             * 动画数据列表。
             */
            set: function (animations) {
                for (var i = 0, l = animations.length; i < l; i++) {
                    this._animations[i] = animations[i];
                }
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Animation.prototype, "autoPlay", void 0);
        __decorate([
            paper.serializedField
        ], Animation.prototype, "_animations", void 0);
        Animation = __decorate([
            paper.disallowMultiple
        ], Animation);
        return Animation;
    }(paper.BaseComponent));
    egret3d.Animation = Animation;
    __reflect(Animation.prototype, "egret3d.Animation");
    /**
     *
     */
    var AnimationSystem = (function (_super) {
        __extends(AnimationSystem, _super);
        function AnimationSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: Animation }
            ];
            return _this;
        }
        AnimationSystem.prototype.onAddGameObject = function (gameObject, group) {
            var component = gameObject.getComponent(Animation);
            component._addToSystem = true;
            if (!component._skinnedMeshRenderer) {
                component._skinnedMeshRenderer = gameObject.getComponentsInChildren(egret3d.SkinnedMeshRenderer)[0];
                if (component._skinnedMeshRenderer) {
                    for (var _i = 0, _a = component._skinnedMeshRenderer.bones; _i < _a.length; _i++) {
                        var bone = _a[_i];
                        var boneBlendLayer = new BoneBlendLayer();
                        component._boneBlendLayers.push(boneBlendLayer);
                    }
                }
            }
            if (component.autoPlay) {
                component.play();
            }
        };
        AnimationSystem.prototype.onUpdate = function () {
            var globalTime = this._clock.time;
            for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                gameObject.getComponent(Animation).update(globalTime);
            }
        };
        AnimationSystem.prototype.onRemoveGameObject = function (gameObject, group) {
            gameObject.getComponent(Animation)._addToSystem = false;
        };
        return AnimationSystem;
    }(paper.BaseSystem));
    egret3d.AnimationSystem = AnimationSystem;
    __reflect(AnimationSystem.prototype, "egret3d.AnimationSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
        * @internal
        */
        function createBatchMesh(renderer, maxParticleCount) {
            var meshAttributes = [];
            var meshAttributesType = [];
            if (renderer._renderMode === 4 /* Mesh */) {
                var mesh = renderer.mesh;
                var orginIndexBuffer = mesh.getIndices();
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _i = 0, MeshShaderAttributeFormat_1 = particle.MeshShaderAttributeFormat; _i < MeshShaderAttributeFormat_1.length; _i++) {
                    var attribute = MeshShaderAttributeFormat_1[_i];
                    meshAttributes.push(attribute.key);
                    meshAttributesType.push(attribute.type);
                }
                var totalVertexCount = mesh.vertexCount * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, totalIndexCount, meshAttributes, meshAttributesType, 2 /* Dynamic */);
                //
                var index = 0;
                //提前填充
                var orginPostionBuffer = mesh.getAttributes("POSITION" /* POSITION */);
                var orginUVBuffer = mesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                var orginColorBuffer = mesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var positionBuffer = batchMesh.getAttributes("POSITION" /* POSITION */);
                var colorBuffer = batchMesh.getAttributes("COLOR_0" /* COLOR_0 */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var vector2Offset = i * 2;
                    var vector3Offset = i * 3;
                    var vector4Offset = i * 4;
                    var orginVertexIndex = i % mesh.vertexCount;
                    positionBuffer[vector3Offset] = orginPostionBuffer[orginVertexIndex * 3];
                    positionBuffer[vector3Offset + 1] = orginPostionBuffer[orginVertexIndex * 3 + 1];
                    positionBuffer[vector3Offset + 2] = orginPostionBuffer[orginVertexIndex * 3 + 2];
                    if (orginUVBuffer) {
                        uvBuffer[vector2Offset] = orginUVBuffer[orginVertexIndex * 2];
                        uvBuffer[vector2Offset + 1] = orginUVBuffer[orginVertexIndex * 2 + 1];
                    }
                    if (orginColorBuffer) {
                        colorBuffer[vector4Offset] = orginColorBuffer[orginVertexIndex * 4];
                        colorBuffer[vector4Offset + 1] = orginColorBuffer[orginVertexIndex * 4 + 1];
                        colorBuffer[vector4Offset + 2] = orginColorBuffer[orginVertexIndex * 4 + 2];
                        colorBuffer[vector4Offset + 3] = orginColorBuffer[orginVertexIndex * 4 + 3];
                    }
                    else {
                        colorBuffer[vector4Offset] = 1;
                        colorBuffer[vector4Offset + 1] = 1;
                        colorBuffer[vector4Offset + 2] = 1;
                        colorBuffer[vector4Offset + 3] = 1;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * mesh.vertexCount;
                    for (var j = 0; j < orginIndexBufferCount; j++) {
                        indexBuffer[index++] = orginIndexBuffer[j] + indexOffset;
                    }
                }
                return batchMesh;
            }
            else {
                var orginIndexBuffer = [0, 2, 1, 0, 3, 2];
                var orginIndexBufferCount = orginIndexBuffer.length;
                for (var _a = 0, BillboardShaderAttributeFormat_1 = particle.BillboardShaderAttributeFormat; _a < BillboardShaderAttributeFormat_1.length; _a++) {
                    var attribute = BillboardShaderAttributeFormat_1[_a];
                    meshAttributes.push(attribute.key);
                    meshAttributesType.push(attribute.type);
                }
                var vertexStride = 4;
                var totalVertexCount = vertexStride * maxParticleCount;
                var totalIndexCount = orginIndexBufferCount * maxParticleCount;
                var batchMesh = new egret3d.Mesh(totalVertexCount, totalIndexCount, totalIndexCount, meshAttributes, meshAttributesType, 2 /* Dynamic */);
                var cornerBuffer = batchMesh.getAttributes("CORNER" /* CORNER */);
                var uvBuffer = batchMesh.getAttributes("TEXCOORD_0" /* TEXCOORD_0 */);
                for (var i = 0; i < totalVertexCount; i++) {
                    var orginVertexIndex = i % vertexStride;
                    var vector2Offset = i * 2;
                    switch (orginVertexIndex) {
                        case 0:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 1:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = -0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 1.0;
                            break;
                        case 2:
                            cornerBuffer[vector2Offset] = 0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 1.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                        case 3:
                            cornerBuffer[vector2Offset] = -0.5;
                            cornerBuffer[vector2Offset + 1] = 0.5;
                            uvBuffer[vector2Offset] = 0.0;
                            uvBuffer[vector2Offset + 1] = 0.0;
                            break;
                    }
                }
                var indexBuffer = batchMesh.getIndices();
                for (var i = 0; i < maxParticleCount; i++) {
                    var indexOffset = i * 6;
                    var firstVertex = i * vertexStride;
                    var secondVertex = firstVertex + 2;
                    indexBuffer[indexOffset + 0] = firstVertex;
                    indexBuffer[indexOffset + 1] = secondVertex;
                    indexBuffer[indexOffset + 2] = firstVertex + 1;
                    indexBuffer[indexOffset + 3] = firstVertex;
                    indexBuffer[indexOffset + 4] = firstVertex + 3;
                    indexBuffer[indexOffset + 5] = secondVertex;
                }
                return batchMesh;
            }
        }
        particle.createBatchMesh = createBatchMesh;
        /**
         * @internal
         */
        function generatePositionAndDirection(position, direction, shape) {
            if (!shape.enable) {
                position.x = position.y = position.z = 0;
                direction.x = direction.y = 0;
                direction.z = 1.0;
                return;
            }
            //
            switch (shape.shapeType) {
                case 4 /* Cone */:
                case 7 /* ConeShell */:
                    {
                        _generateConeParticlePosition(shape, position, direction);
                    }
                    break;
                case 8 /* ConeVolume */:
                case 9 /* ConeVolumeShell */:
                    {
                        _generateConeVolumeParticlePosition(shape, position, direction);
                    }
                    break;
                case 5 /* Box */:
                    {
                        _generateBoxParticlePosition(shape, position, direction);
                    }
                    break;
                case 0 /* Sphere */:
                case 1 /* SphereShell */:
                    {
                        _generateSphereParticlePosition(shape, position, direction);
                    }
                    break;
                case 10 /* Circle */:
                    {
                        _generateCircleParticlePosition(shape, position, direction);
                    }
                    break;
                default:
                    {
                        position.x = position.y = position.z = 0;
                        direction.x = direction.y = 0;
                        direction.z = 1;
                    }
            }
        }
        particle.generatePositionAndDirection = generatePositionAndDirection;
        function _randomPostionCircle(out) {
            var angle = Math.random() * Math.PI * 2;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideCircle(out) {
            _randomPostionCircle(out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionArcCircle(arc, out) {
            var angle = Math.random() * arc;
            out.x = Math.cos(angle);
            out.y = Math.sin(angle);
        }
        function _randomPositionInsideArcCircle(arc, out) {
            _randomPositionArcCircle(arc, out);
            var range = Math.pow(Math.random(), 0.5);
            out.x = out.x * range;
            out.y = out.y * range;
        }
        function _randomPositionSphere(out) {
            var ranZ = Math.random() * 2 - 1.0;
            var angle = Math.random() * Math.PI * 2;
            var range = Math.sqrt(1.0 - ranZ * ranZ);
            out.x = Math.cos(angle) * range;
            out.y = Math.sin(angle) * range;
            out.z = ranZ;
        }
        function _randomPositionInsideSphere(out) {
            _randomPositionSphere(out);
            var range = Math.pow(Math.random(), 1.0 / 3.0);
            out.x = out.x * range;
            out.y = out.y * range;
            out.z = out.z * range;
        }
        function _generateConeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 4 /* Cone */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = temp.z * shape.radius;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            if (shape.randomDirection) {
                _randomPositionInsideCircle(direction);
                direction.x = direction.x * sinValue;
                direction.y = direction.y * sinValue;
                direction.z = cosValue;
            }
            else {
                direction.x = temp.x * sinValue;
                direction.y = temp.y * sinValue;
                direction.z = cosValue;
            }
        }
        function _generateConeVolumeParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 8 /* ConeVolume */) {
                _randomPositionInsideCircle(temp);
            }
            else {
                _randomPostionCircle(temp);
            }
            position.x = temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            var angle = shape.angle * Math.PI / 180.0;
            var sinValue = Math.sin(angle);
            var cosValue = Math.cos(angle);
            direction.x = temp.x * sinValue;
            direction.y = temp.y * sinValue;
            direction.z = cosValue;
            egret3d.Vector3.normalize(direction);
            var len = Math.random() * shape.length;
            direction.x = direction.x * len;
            direction.y = direction.y * len;
            direction.z = direction.z * len;
            position.x += direction.x;
            position.y += direction.y;
            position.z += direction.z;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
        }
        function _generateBoxParticlePosition(shape, position, direction) {
            position.x = shape.box.x * (Math.random() - 0.5);
            position.y = shape.box.y * (Math.random() - 0.5);
            position.z = shape.box.z * (Math.random() - 0.5);
            if (shape.randomDirection) {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
            else {
                direction.x = 0.0;
                direction.y = 0.0;
                direction.z = 1.0;
            }
        }
        function _generateSphereParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (!shape.spherizeDirection) {
                if (shape.shapeType == 0 /* Sphere */) {
                    _randomPositionInsideSphere(position);
                }
                else {
                    _randomPositionSphere(position);
                }
            }
            position.x = position.x * shape.radius;
            position.y = position.y * shape.radius;
            position.z = position.z * shape.radius;
            if (shape.randomDirection || shape.spherizeDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
        function _generateCircleParticlePosition(shape, position, direction) {
            var temp = new egret3d.Vector3();
            if (shape.shapeType == 10 /* Circle */) {
                _randomPositionInsideArcCircle(shape.radiusSpread, temp);
            }
            else {
                _randomPositionArcCircle(shape.radiusSpread, temp);
            }
            position.x = -temp.x * shape.radius;
            position.y = temp.y * shape.radius;
            position.z = 0;
            if (shape.randomDirection) {
                _randomPositionSphere(direction);
            }
            else {
                direction.x = position.x;
                direction.y = position.y;
                direction.z = position.z;
            }
        }
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var colorHelper1 = new egret3d.Color();
        var colorHelper2 = new egret3d.Color();
        var Keyframe = (function () {
            function Keyframe() {
            }
            Keyframe.prototype.serialize = function () {
                return [this.time, this.value];
            };
            Keyframe.prototype.deserialize = function (element) {
                this.time = element[0];
                this.value = element[1];
            };
            Keyframe.prototype.clone = function (source) {
                this.time = source.time;
                this.value = source.value;
            };
            return Keyframe;
        }());
        particle.Keyframe = Keyframe;
        __reflect(Keyframe.prototype, "egret3d.particle.Keyframe", ["paper.ISerializable"]);
        var AnimationCurve = (function () {
            function AnimationCurve() {
                /**
                 * 功能与效率平衡长度取4
                 */
                this._keys = new Array();
                this._floatValues = new Float32Array(8);
            }
            AnimationCurve.prototype.serialize = function () {
                return this._keys.map(function (keyFrame) { return keyFrame.serialize(); });
            };
            AnimationCurve.prototype.deserialize = function (element) {
                this._keys.length = 0;
                for (var i = 0, l = element.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.deserialize(element[i]);
                    this._keys.push(keyframe);
                }
            };
            AnimationCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this._keys.length; i < l; i++) {
                    var curKeyFrame = this._keys[i];
                    if (curKeyFrame.time < t) {
                        continue;
                    }
                    //
                    var lastIndex = i === 0 ? 0 : i - 1;
                    var lastKeyFrame = this._keys[lastIndex];
                    var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                    return egret3d.numberLerp(lastKeyFrame.value, curKeyFrame.value, tt);
                }
                throw "AnimationCurve: invalid t or keys.length is 0";
            };
            Object.defineProperty(AnimationCurve.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    var offset = 0;
                    for (var _i = 0, _a = this._keys; _i < _a.length; _i++) {
                        var keyFrame = _a[_i];
                        res[offset++] = keyFrame.time;
                        res[offset++] = keyFrame.value;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            AnimationCurve.prototype.clone = function (source) {
                this._keys.length = 0;
                var sourceKeys = source._keys;
                for (var i = 0, l = sourceKeys.length; i < l; i++) {
                    var keyframe = new Keyframe();
                    keyframe.time = sourceKeys[i].time;
                    keyframe.value = sourceKeys[i].value;
                    this._keys.push(keyframe);
                }
            };
            return AnimationCurve;
        }());
        particle.AnimationCurve = AnimationCurve;
        __reflect(AnimationCurve.prototype, "egret3d.particle.AnimationCurve", ["paper.ISerializable"]);
        var GradientColorKey = (function (_super) {
            __extends(GradientColorKey, _super);
            function GradientColorKey() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.color = new egret3d.Color();
                return _this;
            }
            GradientColorKey.prototype.deserialize = function (element) {
                this.color.deserialize(element.color);
                this.time = element.time;
            };
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], GradientColorKey.prototype, "time", void 0);
            return GradientColorKey;
        }(paper.SerializableObject));
        particle.GradientColorKey = GradientColorKey;
        __reflect(GradientColorKey.prototype, "egret3d.particle.GradientColorKey");
        var GradientAlphaKey = (function (_super) {
            __extends(GradientAlphaKey, _super);
            function GradientAlphaKey() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            GradientAlphaKey.prototype.deserialize = function (element) {
                this.alpha = element.alpha;
                this.time = element.time;
            };
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "alpha", void 0);
            __decorate([
                paper.serializedField
            ], GradientAlphaKey.prototype, "time", void 0);
            return GradientAlphaKey;
        }(paper.SerializableObject));
        particle.GradientAlphaKey = GradientAlphaKey;
        __reflect(GradientAlphaKey.prototype, "egret3d.particle.GradientAlphaKey");
        var Gradient = (function (_super) {
            __extends(Gradient, _super);
            function Gradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Blend */;
                _this.alphaKeys = new Array();
                _this.colorKeys = new Array();
                _this._alphaValue = new Float32Array(8);
                _this._colorValue = new Float32Array(16);
                return _this;
            }
            Gradient.prototype.deserialize = function (element) {
                this.colorKeys.length = 0;
                for (var i = 0, l = element.colorKeys.length; i < l; i++) {
                    var color = new GradientColorKey();
                    color.deserialize(element.colorKeys[i]);
                    this.colorKeys.push(color);
                }
                //
                this.alphaKeys.length = 0;
                for (var i = 0, l = element.alphaKeys.length; i < l; i++) {
                    var alpha = new GradientAlphaKey();
                    alpha.deserialize(element.alphaKeys[i]);
                    this.alphaKeys.push(alpha);
                }
            };
            Gradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                for (var i = 0, l = this.alphaKeys.length; i < l; i++) {
                    var curKeyFrame = this.alphaKeys[i];
                    if (curKeyFrame.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.alphaKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (curKeyFrame.time - lastKeyFrame.time);
                        out.a = egret3d.numberLerp(lastKeyFrame.alpha, curKeyFrame.alpha, tt);
                        break;
                    }
                }
                for (var i = 0, l = this.colorKeys.length; i < l; i++) {
                    var colorKey = this.colorKeys[i];
                    if (colorKey.time > t) {
                        var lastIndex = i == 0 ? 0 : i - 1;
                        var lastKeyFrame = this.colorKeys[lastIndex];
                        var tt = (t - lastKeyFrame.time) / (colorKey.time - lastKeyFrame.time);
                        out.r = egret3d.numberLerp(lastKeyFrame.color.r, colorKey.color.r, tt);
                        out.g = egret3d.numberLerp(lastKeyFrame.color.g, colorKey.color.g, tt);
                        out.b = egret3d.numberLerp(lastKeyFrame.color.b, colorKey.color.b, tt);
                        break;
                    }
                }
                return out;
            };
            Object.defineProperty(Gradient.prototype, "alphaValues", {
                get: function () {
                    var res = this._alphaValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.alphaKeys; _i < _a.length; _i++) {
                        var alpha = _a[_i];
                        res[offset++] = alpha.time;
                        res[offset++] = alpha.alpha;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Gradient.prototype, "colorValues", {
                get: function () {
                    var res = this._colorValue;
                    var offset = 0;
                    for (var _i = 0, _a = this.colorKeys; _i < _a.length; _i++) {
                        var color = _a[_i];
                        res[offset++] = color.time;
                        res[offset++] = color.color.r;
                        res[offset++] = color.color.g;
                        res[offset++] = color.color.b;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "alphaKeys", void 0);
            __decorate([
                paper.serializedField
            ], Gradient.prototype, "colorKeys", void 0);
            return Gradient;
        }(paper.SerializableObject));
        particle.Gradient = Gradient;
        __reflect(Gradient.prototype, "egret3d.particle.Gradient");
        var MinMaxCurve = (function (_super) {
            __extends(MinMaxCurve, _super);
            function MinMaxCurve() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 0 /* Constant */;
                _this.curve = new AnimationCurve();
                _this.curveMin = new AnimationCurve();
                _this.curveMax = new AnimationCurve();
                return _this;
            }
            MinMaxCurve.prototype.deserialize = function (element) {
                this.mode = element.mode;
                this.constant = element.constant || 0;
                this.constantMin = element.constantMin || 0;
                this.constantMax = element.constantMax || 0;
                element.curve && this.curve.deserialize(element.curve);
                element.curveMin && this.curveMin.deserialize(element.curveMin);
                element.curveMax && this.curveMax.deserialize(element.curveMax);
            };
            MinMaxCurve.prototype.evaluate = function (t) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Constant */) {
                    return this.constant;
                }
                else if (this.mode === 3 /* TwoConstants */) {
                    return (Math.random() * (this.constantMax - this.constantMin) + this.constantMin);
                }
                else if (this.mode === 1 /* Curve */) {
                    return this.curve.evaluate(t);
                }
                else {
                    var min = this.curveMin.evaluate(t);
                    var max = this.curveMax.evaluate(t);
                    return (Math.random() * (min - max) + min);
                }
            };
            MinMaxCurve.prototype.clone = function (source) {
                this.mode = source.mode;
                this.constant = source.constant;
                this.constantMin = source.constantMin;
                this.constantMax = source.constantMax;
                this.curve.clone(source.curve);
                this.curveMin.clone(source.curveMin);
                this.curveMax.clone(source.curveMax);
            };
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constant", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "constantMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curve", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxCurve.prototype, "curveMax", void 0);
            return MinMaxCurve;
        }(paper.SerializableObject));
        particle.MinMaxCurve = MinMaxCurve;
        __reflect(MinMaxCurve.prototype, "egret3d.particle.MinMaxCurve");
        var MinMaxGradient = (function (_super) {
            __extends(MinMaxGradient, _super);
            function MinMaxGradient() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.mode = 1 /* Gradient */;
                _this.color = new egret3d.Color();
                _this.colorMin = new egret3d.Color();
                _this.colorMax = new egret3d.Color();
                _this.gradient = new Gradient();
                _this.gradientMin = new Gradient();
                _this.gradientMax = new Gradient();
                return _this;
            }
            MinMaxGradient.prototype.deserialize = function (element) {
                // super.deserialize(element);
                this.mode = element.mode;
                if (element.color) {
                    this.color.deserialize(element.color);
                }
                if (element.colorMin) {
                    this.colorMin.deserialize(element.colorMin);
                }
                if (element.colorMax) {
                    this.colorMax.deserialize(element.colorMax);
                }
                if (element.gradient) {
                    this.gradient.deserialize(element.gradient);
                }
                if (element.gradientMin) {
                    this.gradientMin.deserialize(element.gradientMin);
                }
                if (element.gradientMax) {
                    this.gradientMax.deserialize(element.gradientMax);
                }
            };
            MinMaxGradient.prototype.evaluate = function (t, out) {
                if (t === void 0) { t = 0; }
                if (this.mode === 0 /* Color */) {
                    out.r = this.color.r;
                    out.g = this.color.g;
                    out.b = this.color.b;
                    out.a = this.color.a;
                }
                else if (this.mode === 2 /* TwoColors */) {
                    out.r = Math.random() * (this.colorMax.r - this.colorMin.r) + this.colorMin.r;
                    out.g = Math.random() * (this.colorMax.g - this.colorMin.g) + this.colorMin.g;
                    out.b = Math.random() * (this.colorMax.b - this.colorMin.b) + this.colorMin.b;
                    out.a = Math.random() * (this.colorMax.a - this.colorMin.a) + this.colorMin.a;
                }
                else if (this.mode === 1 /* Gradient */) {
                    return this.gradient.evaluate(t, out);
                }
                else if (this.mode === 3 /* TwoGradients */) {
                    this.gradientMin.evaluate(t, colorHelper1);
                    this.gradientMax.evaluate(t, colorHelper2);
                    out.r = (Math.random() * (colorHelper1.r - colorHelper2.r) + colorHelper1.r);
                    out.g = (Math.random() * (colorHelper1.g - colorHelper2.g) + colorHelper1.g);
                    out.b = (Math.random() * (colorHelper1.b - colorHelper2.b) + colorHelper1.b);
                    out.a = (Math.random() * (colorHelper1.a - colorHelper2.a) + colorHelper1.a);
                }
                else {
                    out.r = Math.random();
                    out.g = Math.random();
                    out.b = Math.random();
                    out.a = Math.random();
                }
                return out;
            };
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "mode", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "color", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "colorMax", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradient", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMin", void 0);
            __decorate([
                paper.serializedField
            ], MinMaxGradient.prototype, "gradientMax", void 0);
            return MinMaxGradient;
        }(paper.SerializableObject));
        particle.MinMaxGradient = MinMaxGradient;
        __reflect(MinMaxGradient.prototype, "egret3d.particle.MinMaxGradient");
        var Burst = (function () {
            function Burst() {
            }
            Burst.prototype.serialize = function () {
                return [this.time, this.minCount, this.maxCount, this.cycleCount, this.repeatInterval];
            };
            Burst.prototype.deserialize = function (element) {
                this.time = element[0];
                this.minCount = element[1];
                this.maxCount = element[2];
                this.cycleCount = element[3];
                this.repeatInterval = element[4];
            };
            return Burst;
        }());
        particle.Burst = Burst;
        __reflect(Burst.prototype, "egret3d.particle.Burst", ["paper.ISerializable"]);
        var ParticleSystemModule = (function (_super) {
            __extends(ParticleSystemModule, _super);
            function ParticleSystemModule(comp) {
                var _this = _super.call(this) || this;
                _this.enable = false;
                _this._comp = comp;
                return _this;
            }
            /**
             * @internal
             */
            ParticleSystemModule.prototype.initialize = function () { };
            ParticleSystemModule.prototype.deserialize = function (element) {
                this.enable = true;
            };
            __decorate([
                paper.serializedField
            ], ParticleSystemModule.prototype, "enable", void 0);
            return ParticleSystemModule;
        }(paper.SerializableObject));
        particle.ParticleSystemModule = ParticleSystemModule;
        __reflect(ParticleSystemModule.prototype, "egret3d.particle.ParticleSystemModule");
        var MainModule = (function (_super) {
            __extends(MainModule, _super);
            function MainModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.duration = 0.0;
                _this.loop = false;
                //
                _this.startDelay = new MinMaxCurve();
                //
                _this.startLifetime = new MinMaxCurve();
                //
                _this.startSpeed = new MinMaxCurve();
                //
                _this.startSizeX = new MinMaxCurve();
                _this.startSizeY = new MinMaxCurve();
                _this.startSizeZ = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startRotation3D = false;
                _this.startRotationX = new MinMaxCurve();
                _this.startRotationY = new MinMaxCurve();
                _this.startRotationZ = new MinMaxCurve();
                //
                _this.startColor = new MinMaxGradient();
                //
                _this.gravityModifier = new MinMaxCurve(); //TODO
                /**
                 * @internal
                 */
                _this._simulationSpace = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._scaleMode = 0 /* Hierarchy */;
                //
                _this.playOnAwake = false;
                /**
                 * @internal
                 */
                _this._maxParticles = 0;
                return _this;
            }
            MainModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.duration = element.duration;
                this.loop = element.loop || element.looping; // TODO 兼容代码 looping。
                this.startDelay.deserialize(element.startDelay);
                this.startLifetime.deserialize(element.startLifetime);
                this.startSpeed.deserialize(element.startSpeed);
                this.startSizeX.deserialize(element.startSizeX);
                this.startSizeY.deserialize(element.startSizeY);
                this.startSizeZ.deserialize(element.startSizeZ);
                this._startRotation3D = (element._startRotation3D || element.startRotation3D) || false;
                this.startRotationX.deserialize(element.startRotationX);
                this.startRotationY.deserialize(element.startRotationY);
                this.startRotationZ.deserialize(element.startRotationZ);
                this.startColor.deserialize(element.startColor);
                this.gravityModifier.deserialize(element.gravityModifier);
                this._simulationSpace = (element._simulationSpace || element.simulationSpace) || 0;
                this._scaleMode = (element._scaleMode || element.scaleMode) || 0 /* Hierarchy */;
                this.playOnAwake = element.playOnAwake;
                this._maxParticles = (element._maxParticles || element.maxParticles) || 0;
            };
            Object.defineProperty(MainModule.prototype, "startRotation3D", {
                get: function () {
                    return this._startRotation3D;
                },
                set: function (value) {
                    if (this._startRotation3D !== value) {
                        this._startRotation3D = value;
                        paper.EventPool.dispatchEvent("rotation3DChanged" /* StartRotation3DChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "simulationSpace", {
                get: function () {
                    return this._simulationSpace;
                },
                set: function (value) {
                    if (this._simulationSpace !== value) {
                        this._simulationSpace = value;
                        paper.EventPool.dispatchEvent("simulationSpace" /* SimulationSpaceChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "scaleMode", {
                get: function () {
                    return this._scaleMode;
                },
                set: function (value) {
                    if (this._scaleMode !== value) {
                        this._scaleMode = value;
                        paper.EventPool.dispatchEvent("scaleMode" /* ScaleModeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MainModule.prototype, "maxParticles", {
                get: function () {
                    return this._maxParticles;
                },
                set: function (value) {
                    if (this._maxParticles !== value) {
                        this._maxParticles = value;
                        paper.EventPool.dispatchEvent("maxParticles" /* MaxParticlesChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "duration", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "loop", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startDelay", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startLifetime", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSpeed", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startSizeZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_startRotation3D", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationX", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationY", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startRotationZ", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "startColor", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "gravityModifier", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_simulationSpace", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_scaleMode", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "playOnAwake", void 0);
            __decorate([
                paper.serializedField
            ], MainModule.prototype, "_maxParticles", void 0);
            return MainModule;
        }(ParticleSystemModule));
        particle.MainModule = MainModule;
        __reflect(MainModule.prototype, "egret3d.particle.MainModule");
        var EmissionModule = (function (_super) {
            __extends(EmissionModule, _super);
            function EmissionModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.rateOverTime = new MinMaxCurve();
                _this.bursts = new Array();
                return _this;
            }
            EmissionModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.rateOverTime.deserialize(element.rateOverTime);
                if (element.bursts) {
                    this.bursts.length = 0;
                    for (var i = 0, l = element.bursts.length; i < l; i++) {
                        var burst = new Burst();
                        burst.deserialize(element.bursts[i]);
                        this.bursts.push(burst);
                    }
                }
            };
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "rateOverTime", void 0);
            __decorate([
                paper.serializedField
            ], EmissionModule.prototype, "bursts", void 0);
            return EmissionModule;
        }(ParticleSystemModule));
        particle.EmissionModule = EmissionModule;
        __reflect(EmissionModule.prototype, "egret3d.particle.EmissionModule");
        var ShapeModule = (function (_super) {
            __extends(ShapeModule, _super);
            function ShapeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.shapeType = 0 /* Sphere */;
                _this.radius = 0.0;
                _this.angle = 0.0;
                _this.length = 0.0;
                _this.arcSpeed = new MinMaxCurve();
                _this.arcMode = 0 /* Random */;
                _this.radiusMode = 0 /* Random */;
                _this.box = new egret3d.Vector3();
                _this.randomDirection = false;
                _this.spherizeDirection = false;
                return _this;
            }
            ShapeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.shapeType = element.shapeType;
                this.radius = element.radius;
                this.angle = element.angle;
                this.length = element.length;
                this.arcSpeed.deserialize(element.arcSpeed);
                this.arcMode = element.arcMode;
                this.radiusSpread = element.radiusSpread;
                this.radiusMode = element.radiusMode;
                this.box.deserialize(element.box);
                this.randomDirection = element.randomDirection;
                this.spherizeDirection = element.spherizeDirection;
            };
            ShapeModule.prototype.invalidUpdate = function () {
                paper.EventPool.dispatchEvent("shapeChanged" /* ShapeChanged */, this._comp);
            };
            ShapeModule.prototype.generatePositionAndDirection = function (position, direction) {
                particle.generatePositionAndDirection(position, direction, this);
            };
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "shapeType", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radius", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "angle", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "length", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcSpeed", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "arcMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusSpread", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "radiusMode", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "box", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "randomDirection", void 0);
            __decorate([
                paper.serializedField
            ], ShapeModule.prototype, "spherizeDirection", void 0);
            return ShapeModule;
        }(ParticleSystemModule));
        particle.ShapeModule = ShapeModule;
        __reflect(ShapeModule.prototype, "egret3d.particle.ShapeModule");
        var VelocityOverLifetimeModule = (function (_super) {
            __extends(VelocityOverLifetimeModule, _super);
            function VelocityOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._mode = 0 /* Constant */;
                /**
                 * @internal
                 */
                _this._space = 0 /* Local */;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            VelocityOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._mode = (element._mode || element.mode) || 0 /* Constant */;
                this._space = (element._space || element.space) || 0 /* Local */;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "mode", {
                get: function () {
                    return this._mode;
                },
                set: function (value) {
                    if (this._mode !== value) {
                        this._mode = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "space", {
                get: function () {
                    return this._space;
                },
                set: function (value) {
                    if (this._space !== value) {
                        this._space = value;
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(VelocityOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("velocityChanged" /* VelocityChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_mode", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_space", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], VelocityOverLifetimeModule.prototype, "_z", void 0);
            return VelocityOverLifetimeModule;
        }(ParticleSystemModule));
        particle.VelocityOverLifetimeModule = VelocityOverLifetimeModule;
        __reflect(VelocityOverLifetimeModule.prototype, "egret3d.particle.VelocityOverLifetimeModule");
        var ColorOverLifetimeModule = (function (_super) {
            __extends(ColorOverLifetimeModule, _super);
            function ColorOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._color = new MinMaxGradient();
                return _this;
            }
            ColorOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._color.deserialize(element._color || element.color);
            };
            Object.defineProperty(ColorOverLifetimeModule.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    if (this._color !== value) {
                        this._color = value;
                        paper.EventPool.dispatchEvent("colorChanged" /* ColorChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ColorOverLifetimeModule.prototype, "_color", void 0);
            return ColorOverLifetimeModule;
        }(ParticleSystemModule));
        particle.ColorOverLifetimeModule = ColorOverLifetimeModule;
        __reflect(ColorOverLifetimeModule.prototype, "egret3d.particle.ColorOverLifetimeModule");
        var SizeOverLifetimeModule = (function (_super) {
            __extends(SizeOverLifetimeModule, _super);
            function SizeOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._separateAxes = false;
                /**
                 * @internal
                 */
                _this._size = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            SizeOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._size.deserialize(element._size || element.size);
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(SizeOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "size", {
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._size !== value) {
                        this._size.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SizeOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("sizeChanged" /* SizeChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_size", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], SizeOverLifetimeModule.prototype, "_z", void 0);
            return SizeOverLifetimeModule;
        }(ParticleSystemModule));
        particle.SizeOverLifetimeModule = SizeOverLifetimeModule;
        __reflect(SizeOverLifetimeModule.prototype, "egret3d.particle.SizeOverLifetimeModule");
        var RotationOverLifetimeModule = (function (_super) {
            __extends(RotationOverLifetimeModule, _super);
            function RotationOverLifetimeModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._x = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._y = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._z = new MinMaxCurve();
                return _this;
            }
            RotationOverLifetimeModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._separateAxes = (element._separateAxes || element.separateAxes) || false;
                this._x.deserialize(element._x || element.x);
                this._y.deserialize(element._y || element.y);
                this._z.deserialize(element._z || element.z);
            };
            Object.defineProperty(RotationOverLifetimeModule.prototype, "separateAxes", {
                get: function () {
                    return this._separateAxes;
                },
                set: function (value) {
                    if (this._separateAxes !== value) {
                        this._separateAxes = value;
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "x", {
                get: function () {
                    return this._x;
                },
                set: function (value) {
                    if (this._x !== value) {
                        this._x.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "y", {
                get: function () {
                    return this._y;
                },
                set: function (value) {
                    if (this._y !== value) {
                        this._y.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(RotationOverLifetimeModule.prototype, "z", {
                get: function () {
                    return this._z;
                },
                set: function (value) {
                    if (this._z !== value) {
                        this._z.clone(value);
                        paper.EventPool.dispatchEvent("rotationChanged" /* RotationChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_separateAxes", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_x", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_y", void 0);
            __decorate([
                paper.serializedField
            ], RotationOverLifetimeModule.prototype, "_z", void 0);
            return RotationOverLifetimeModule;
        }(ParticleSystemModule));
        particle.RotationOverLifetimeModule = RotationOverLifetimeModule;
        __reflect(RotationOverLifetimeModule.prototype, "egret3d.particle.RotationOverLifetimeModule");
        var TextureSheetAnimationModule = (function (_super) {
            __extends(TextureSheetAnimationModule, _super);
            function TextureSheetAnimationModule() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                /**
                 * @internal
                 */
                _this._animation = 0 /* WholeSheet */;
                /**
                 * @internal
                 */
                _this._frameOverTime = new MinMaxCurve();
                /**
                 * @internal
                 */
                _this._startFrame = new MinMaxCurve();
                _this._floatValues = new Float32Array(4);
                return _this;
            }
            TextureSheetAnimationModule.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this._numTilesX = (element._numTilesX || element.numTilesX) || 0;
                this._numTilesY = (element._numTilesY || element.numTilesY) || 0;
                this._animation = (element._animation || element.animation) || 0 /* WholeSheet */;
                this._useRandomRow = (element._useRandomRow || element.useRandomRow) || false;
                this._frameOverTime.deserialize(element._frameOverTime || element.frameOverTime);
                this._startFrame.deserialize(element._startFrame || element.startFrame);
                this._cycleCount = (element._cycleCount || element.cycleCount) || 0;
                this._rowIndex = (element._rowIndex || element.rowIndex) || 0;
            };
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesX", {
                get: function () {
                    return this._numTilesX;
                },
                set: function (value) {
                    if (this._numTilesX !== value) {
                        this._numTilesX = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "numTilesY", {
                get: function () {
                    return this._numTilesY;
                },
                set: function (value) {
                    if (this._numTilesY !== value) {
                        this._numTilesY = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "animation", {
                get: function () {
                    return this._animation;
                },
                set: function (value) {
                    if (this._animation !== value) {
                        this._animation = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "useRandomRow", {
                get: function () {
                    return this._useRandomRow;
                },
                set: function (value) {
                    if (this._useRandomRow !== value) {
                        this._useRandomRow = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "frameOverTime", {
                get: function () {
                    return this._frameOverTime;
                },
                set: function (value) {
                    if (this._frameOverTime !== value) {
                        this._frameOverTime.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "startFrame", {
                get: function () {
                    return this._startFrame;
                },
                set: function (value) {
                    if (this._startFrame !== value) {
                        this._startFrame.clone(value);
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "cycleCount", {
                get: function () {
                    return this._cycleCount;
                },
                set: function (value) {
                    if (this._cycleCount !== value) {
                        this._cycleCount = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "rowIndex", {
                get: function () {
                    return this._rowIndex;
                },
                set: function (value) {
                    if (this._rowIndex !== value) {
                        this._rowIndex = value;
                        paper.EventPool.dispatchEvent("textureSheetChanged" /* TextureSheetChanged */, this._comp);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextureSheetAnimationModule.prototype, "floatValues", {
                get: function () {
                    var res = this._floatValues;
                    if (this.enable) {
                        var subU = 1.0 / this._numTilesX;
                        var subV = 1.0 / this._numTilesY;
                        var startFrmaeCount = Math.floor(this._startFrame.constant);
                        var startRow = 0;
                        switch (this._animation) {
                            case 1 /* SingleRow */:
                                {
                                    if (this._useRandomRow) {
                                        startRow = Math.floor(Math.random() * this._numTilesY);
                                    }
                                    else {
                                        startRow = this._rowIndex;
                                    }
                                    break;
                                }
                            case 0 /* WholeSheet */:
                                {
                                    startRow = Math.floor(startFrmaeCount / this._numTilesX);
                                    break;
                                }
                        }
                        var startCol = Math.floor(startFrmaeCount % this._numTilesX);
                        res[0] = subU;
                        res[1] = subV;
                        res[2] = startCol * subU;
                        res[3] = startRow * subV;
                    }
                    else {
                        res[0] = 1.0;
                        res[1] = 1.0;
                        res[2] = 0.0;
                        res[3] = 0.0;
                    }
                    return res;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesX", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_numTilesY", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_animation", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_useRandomRow", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_frameOverTime", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_startFrame", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_cycleCount", void 0);
            __decorate([
                paper.serializedField
            ], TextureSheetAnimationModule.prototype, "_rowIndex", void 0);
            return TextureSheetAnimationModule;
        }(ParticleSystemModule));
        particle.TextureSheetAnimationModule = TextureSheetAnimationModule;
        __reflect(TextureSheetAnimationModule.prototype, "egret3d.particle.TextureSheetAnimationModule");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        //
        var positionHelper = new egret3d.Vector3();
        var velocityHelper = new egret3d.Vector3();
        var startSizeHelper = new egret3d.Vector3();
        var startColorHelper = new egret3d.Color();
        var startRotationHelper = new egret3d.Vector3();
        var uvHelper = new egret3d.Vector4(1.0, 1.0, 0.0, 0.0);
        var helpVec2 = new egret3d.Vector2();
        var helpVec3 = new egret3d.Vector3();
        var helpVec4 = new egret3d.Vector4();
        var GRAVITY = new egret3d.Vector3(0, -9.81, 0); //TODO没有物理系统，暂时先放到这里
        /**
         * @internal
         */
        var ParticleBatcher = (function () {
            function ParticleBatcher() {
                this._dirty = false;
                this._time = 0.0;
                this._emittsionTime = 0;
                this._frameRateTime = 0;
                //最新存活位置
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                //最后存活位置
                this._lastAliveCursor = 0;
                //原始顶点数量
                this._vertexStride = 0;
                //当前爆发的索引
                this._burstIndex = 0;
                //最终重力
                this._finalGravity = new egret3d.Vector3();
            }
            /**
            * 计算粒子爆发数量
            * @param startTime
            * @param endTime
            */
            ParticleBatcher.prototype._getBurstCount = function (startTime, endTime) {
                var totalEmitCount = 0;
                var bursts = this._comp.emission.bursts;
                for (var l = bursts.length; this._burstIndex < l; this._burstIndex++) {
                    var burst = bursts[this._burstIndex];
                    if (burst.time >= startTime && burst.time < endTime) {
                        totalEmitCount += egret3d.numberLerp(burst.minCount, burst.maxCount, Math.random());
                    }
                    else {
                        break;
                    }
                }
                return totalEmitCount;
            };
            /**
             * 判断粒子是否已经过期
             * @param particleIndex
             */
            ParticleBatcher.prototype._isParticleExpired = function (particleIndex) {
                var startTimeOffset = particleIndex * this._vertexStride * 2;
                return this._time - this._startTimeBuffer[startTimeOffset + 1] + 0.0001 > this._startTimeBuffer[startTimeOffset];
            };
            /**
             *
             * @param time 批量增加粒子
             * @param startCursor
             * @param endCursor
             */
            ParticleBatcher.prototype._addParticles = function (time, startCursor, count) {
                var comp = this._comp;
                var main = comp.main;
                var velocityModule = comp.velocityOverLifetime;
                var colorModule = comp.colorOverLifetime;
                var sizeModule = comp.sizeOverLifetime;
                var rotationModule = comp.rotationOverLifetime;
                var textureSheetModule = comp.textureSheetAnimation;
                var isVelocityRandom = velocityModule.enable && (velocityModule._mode === 3 /* TwoConstants */ || velocityModule._mode === 2 /* TwoCurves */);
                var isColorRandom = colorModule.enable && colorModule._color.mode === 3 /* TwoGradients */;
                var isSizeRandom = sizeModule.enable && (sizeModule._size.mode === 3 /* TwoConstants */ || sizeModule._size.mode === 2 /* TwoCurves */);
                var isRotationRandom = rotationModule.enable && (rotationModule._x.mode === 3 /* TwoConstants */ || rotationModule._x.mode === 2 /* TwoCurves */);
                var isTextureRandom = textureSheetModule.enable && (textureSheetModule._startFrame.mode === 3 /* TwoConstants */ || textureSheetModule._startFrame.mode === 2 /* TwoCurves */);
                var needRandom0 = isColorRandom || isSizeRandom || isRotationRandom || isTextureRandom;
                var worldPosition = this._worldPostionCache;
                var worldRotation = this._worldRotationCache;
                var isWorldSpace = main._simulationSpace === 1 /* World */;
                var startPositionBuffer = this._startPositionBuffer;
                var startVelocityBuffer = this._startVelocityBuffer;
                var startColorBuffer = this._startColorBuffer;
                var startSizeBuffer = this._startSizeBuffer;
                var startRotationBuffer = this._startRotationBuffer;
                var startTimeBuffer = this._startTimeBuffer;
                var random0Buffer = this._random0Buffer;
                var random1Buffer = this._random1Buffer;
                var worldPostionBuffer = this._worldPostionBuffer;
                var worldRoationBuffer = this._worldRoationBuffer;
                var age = Math.min(this._emittsionTime / main.duration, 1.0);
                var vertexStride = this._vertexStride;
                var addCount = 0, startIndex = 0, endIndex = 0;
                var lifetime = 0.0;
                var startSpeed = 0.0;
                var randomVelocityX = 0.0, randomVelocityY = 0.0, randomVelocityZ = 0.0;
                var randomColor = 0.0, randomSize = 0.0, randomRotation = 0.0, randomTextureAnimation = 0.0;
                var vector2Offset = 0, vector3Offset = 0, vector4Offset = 0;
                while (addCount !== count) {
                    //发射粒子要根据粒子发射器的形状发射
                    comp.shape.generatePositionAndDirection(positionHelper, velocityHelper);
                    main.startColor.evaluate(age, startColorHelper);
                    lifetime = main.startLifetime.evaluate(age);
                    startSpeed = main.startSpeed.evaluate(age);
                    velocityHelper.x *= startSpeed;
                    velocityHelper.y *= startSpeed;
                    velocityHelper.z *= startSpeed;
                    startSizeHelper.x = main.startSizeX.evaluate(age);
                    startSizeHelper.y = main.startSizeY.evaluate(age);
                    startSizeHelper.z = main.startSizeZ.evaluate(age);
                    startRotationHelper.x = main.startRotationX.evaluate(age);
                    startRotationHelper.y = main.startRotationY.evaluate(age);
                    startRotationHelper.z = main.startRotationZ.evaluate(age);
                    randomVelocityX = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityY = isVelocityRandom ? Math.random() : 0.0;
                    randomVelocityZ = isVelocityRandom ? Math.random() : 0.0;
                    randomColor = isColorRandom ? Math.random() : 0.0;
                    randomSize = isSizeRandom ? Math.random() : 0.0;
                    randomRotation = isRotationRandom ? Math.random() : 0.0;
                    randomTextureAnimation = isTextureRandom ? Math.random() : 0.0;
                    for (startIndex = startCursor * vertexStride, endIndex = startIndex + vertexStride; startIndex < endIndex; startIndex++) {
                        vector2Offset = startIndex * 2;
                        vector3Offset = startIndex * 3;
                        vector4Offset = startIndex * 4;
                        //
                        startPositionBuffer[vector3Offset] = positionHelper.x;
                        startPositionBuffer[vector3Offset + 1] = positionHelper.y;
                        startPositionBuffer[vector3Offset + 2] = positionHelper.z;
                        startVelocityBuffer[vector3Offset] = velocityHelper.x;
                        startVelocityBuffer[vector3Offset + 1] = velocityHelper.y;
                        startVelocityBuffer[vector3Offset + 2] = velocityHelper.z;
                        startColorBuffer[vector4Offset] = startColorHelper.r;
                        startColorBuffer[vector4Offset + 1] = startColorHelper.g;
                        startColorBuffer[vector4Offset + 2] = startColorHelper.b;
                        startColorBuffer[vector4Offset + 3] = startColorHelper.a;
                        startSizeBuffer[vector3Offset] = startSizeHelper.x;
                        startSizeBuffer[vector3Offset + 1] = startSizeHelper.y;
                        startSizeBuffer[vector3Offset + 2] = startSizeHelper.z;
                        startRotationBuffer[vector3Offset] = startRotationHelper.x;
                        startRotationBuffer[vector3Offset + 1] = startRotationHelper.y;
                        startRotationBuffer[vector3Offset + 2] = startRotationHelper.z;
                        startTimeBuffer[vector2Offset] = lifetime;
                        startTimeBuffer[vector2Offset + 1] = time;
                        //
                        if (needRandom0) {
                            random0Buffer[vector4Offset] = randomColor;
                            random0Buffer[vector4Offset + 1] = randomSize;
                            random0Buffer[vector4Offset + 2] = randomRotation;
                            random0Buffer[vector4Offset + 3] = randomTextureAnimation;
                        }
                        if (isVelocityRandom) {
                            random1Buffer[vector4Offset] = randomVelocityX;
                            random1Buffer[vector4Offset + 1] = randomVelocityY;
                            random1Buffer[vector4Offset + 2] = randomVelocityZ;
                            random1Buffer[vector4Offset + 3] = 0;
                        }
                        if (isWorldSpace) {
                            worldPostionBuffer[vector3Offset] = worldPosition.x;
                            worldPostionBuffer[vector3Offset + 1] = worldPosition.y;
                            worldPostionBuffer[vector3Offset + 2] = worldPosition.z;
                            worldRoationBuffer[vector4Offset] = worldRotation.x;
                            worldRoationBuffer[vector4Offset + 1] = worldRotation.y;
                            worldRoationBuffer[vector4Offset + 2] = worldRotation.z;
                            worldRoationBuffer[vector4Offset + 3] = worldRotation.w;
                        }
                    }
                    ;
                    startCursor++;
                    if (startCursor >= main._maxParticles) {
                        startCursor = 0;
                    }
                    addCount++;
                }
                //TODO理论上应该是每帧更新，不过现在没有物理系统，先放到这里
                var gravityModifier = main.gravityModifier.constant;
                this._finalGravity.x = GRAVITY.x * gravityModifier;
                this._finalGravity.y = GRAVITY.y * gravityModifier;
                this._finalGravity.z = GRAVITY.z * gravityModifier;
            };
            ParticleBatcher.prototype._tryEmit = function (time) {
                var maxParticles = this._comp.main._maxParticles;
                var nextCursor = this._firstAliveCursor + 1 > maxParticles ? 0 : this._firstAliveCursor + 1;
                if (nextCursor >= maxParticles) {
                    nextCursor = 0;
                }
                if (!this._isParticleExpired(nextCursor)) {
                    return false;
                }
                //
                this._firstAliveCursor = nextCursor;
                this._dirty = true;
                return true;
            };
            ParticleBatcher.prototype.clean = function () {
                this._time = 0.0;
                this._dirty = false;
                this._emittsionTime = 0.0;
                this._frameRateTime = 0.0;
                this._firstAliveCursor = 0;
                this._lastFrameFirstCursor = 0;
                this._lastAliveCursor = 0;
                this._vertexStride = 0;
                this._vertexAttributes = null;
                this._burstIndex = 0;
                this._startPositionBuffer = null;
                this._startVelocityBuffer = null;
                this._startColorBuffer = null;
                this._startSizeBuffer = null;
                this._startRotationBuffer = null;
                this._startTimeBuffer = null;
                this._random0Buffer = null;
                this._random1Buffer = null;
                this._worldPostionBuffer = null;
                this._worldRoationBuffer = null;
                this._worldPostionCache = null;
                this._worldRotationCache = null;
                this._comp = null;
                this._renderer = null;
            };
            ParticleBatcher.prototype.resetTime = function () {
                this._burstIndex = 0;
                this._emittsionTime = 0;
            };
            ParticleBatcher.prototype.init = function (comp, renderer) {
                this._comp = comp;
                this._renderer = renderer;
                var mesh = particle.createBatchMesh(renderer, comp.main._maxParticles);
                this._vertexStride = renderer._renderMode === 4 /* Mesh */ ? renderer.mesh.vertexCount : 4;
                this._startPositionBuffer = mesh.getAttributes("START_POSITION" /* START_POSITION */);
                this._startVelocityBuffer = mesh.getAttributes("START_VELOCITY" /* START_VELOCITY */);
                this._startColorBuffer = mesh.getAttributes("START_COLOR" /* START_COLOR */);
                this._startSizeBuffer = mesh.getAttributes("START_SIZE" /* START_SIZE */);
                this._startRotationBuffer = mesh.getAttributes("START_ROTATION" /* START_ROTATION */);
                this._startTimeBuffer = mesh.getAttributes("TIME" /* TIME */);
                this._random0Buffer = mesh.getAttributes("RANDOM0" /* RANDOM0 */);
                this._random1Buffer = mesh.getAttributes("RANDOM1" /* RANDOM1 */);
                this._worldPostionBuffer = mesh.getAttributes("WORLD_POSITION" /* WORLD_POSITION */);
                this._worldRoationBuffer = mesh.getAttributes("WORLD_ROTATION" /* WORLD_ROTATION */);
                var primitive = mesh.glTFMesh.primitives[0];
                this._vertexAttributes = [];
                for (var k in primitive.attributes) {
                    this._vertexAttributes.push(k);
                }
                renderer.batchMesh = mesh;
                //粒子系统不能用共享材质
                renderer.batchMaterial = renderer.materials[0].clone();
                mesh.uploadSubIndexBuffer();
            };
            ParticleBatcher.prototype.update = function (elapsedTime) {
                if (this._comp.isPaused) {
                    return;
                }
                //
                this._time += elapsedTime;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                while (this._lastAliveCursor != this._firstAliveCursor) {
                    if (!this._isParticleExpired(this._lastAliveCursor)) {
                        break;
                    }
                    this._lastAliveCursor++;
                    if (this._lastAliveCursor >= mainModule._maxParticles) {
                        this._lastAliveCursor = 0;
                    }
                }
                var transform = comp.gameObject.transform;
                this._worldPostionCache = transform.getPosition();
                this._worldRotationCache = transform.getRotation();
                //检测是否已经过了Delay时间，否则不能发射
                if (comp._isPlaying && this._time >= mainModule.startDelay.constant && comp.emission.enable) {
                    this._updateEmission(elapsedTime);
                }
                this._updateRender();
            };
            ParticleBatcher.prototype._updateEmission = function (elapsedTime) {
                var comp = this._comp;
                var mainModule = comp.main;
                //根据时间判断
                var lastEmittsionTime = this._emittsionTime;
                this._emittsionTime += elapsedTime;
                var isOver = this._emittsionTime > mainModule.duration;
                if (!isOver) {
                    //由爆发触发的粒子发射
                    var totalEmitCount = 0;
                    if (comp.emission.bursts.length > 0) {
                        var readyEmitCount = 0;
                        readyEmitCount += this._getBurstCount(lastEmittsionTime, this._emittsionTime);
                        readyEmitCount = Math.min(mainModule._maxParticles - this.aliveParticleCount, readyEmitCount);
                        //
                        for (var i = 0; i < readyEmitCount; i++) {
                            if (this._tryEmit(this._time)) {
                                totalEmitCount++;
                            }
                        }
                    }
                    //由时间触发的粒子发射,不支持曲线
                    var rateOverTime = comp.emission.rateOverTime.constant;
                    if (rateOverTime > 0) {
                        var minEmissionTime = 1 / rateOverTime;
                        this._frameRateTime += elapsedTime;
                        while (this._frameRateTime > minEmissionTime) {
                            if (!this._tryEmit(this._time)) {
                                break;
                            }
                            totalEmitCount++;
                            this._frameRateTime -= minEmissionTime;
                        }
                    }
                    if (totalEmitCount > 0) {
                        this._addParticles(this._time, this._lastFrameFirstCursor, totalEmitCount);
                    }
                }
                else {
                    //一个生命周期结束
                    if (mainModule.loop) {
                        //直接置零，对时间敏感的可能有问题
                        this._emittsionTime = 0;
                        this._burstIndex = 0;
                    }
                    else {
                        //自己停止，不要影响子粒子播放状态
                        comp.stop(false);
                    }
                }
            };
            ParticleBatcher.prototype._updateRender = function () {
                var renderer = this._renderer;
                var comp = this._comp;
                var mainModule = comp.main;
                //
                if (this._dirty) {
                    //为了性能，不能提交整个buffer，只提交改变的buffer
                    var bufferOffset = this._lastFrameFirstCursor * this._vertexStride;
                    if (this._firstAliveCursor > this._lastFrameFirstCursor) {
                        var bufferCount = (this._firstAliveCursor - this._lastFrameFirstCursor) * this._vertexStride;
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, bufferOffset, bufferCount);
                    }
                    else {
                        var addCount = mainModule._maxParticles - this._lastFrameFirstCursor;
                        //先更新尾部的，再更新头部的
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, bufferOffset, addCount * this._vertexStride);
                        renderer.batchMesh.uploadVertexSubData(this._vertexAttributes, 0, this._firstAliveCursor * this._vertexStride);
                    }
                    this._lastFrameFirstCursor = this._firstAliveCursor;
                    this._dirty = false;
                }
                var transform = comp.gameObject.transform;
                if (mainModule._simulationSpace === 0 /* Local */) {
                    renderer._setVector3("u_worldPosition" /* WORLD_POSITION */, this._worldPostionCache);
                    renderer._setVector4("u_worldRotation" /* WORLD_ROTATION */, this._worldRotationCache);
                }
                //
                switch (mainModule._scaleMode) {
                    case 1 /* Local */:
                        {
                            var scale = transform.getLocalScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                    case 2 /* Shape */:
                        {
                            var scale = transform.getScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, egret3d.Vector3.ONE);
                        }
                        break;
                    case 0 /* Hierarchy */:
                        {
                            var scale = transform.getScale();
                            renderer._setVector3("u_positionScale" /* POSITION_SCALE */, scale);
                            renderer._setVector3("u_sizeScale" /* SIZE_SCALE */, scale);
                        }
                        break;
                }
                renderer._setFloat("u_currentTime" /* CURRENTTIME */, this._time);
                renderer._setVector3("u_gravity" /* GRAVIT */, this._finalGravity);
            };
            Object.defineProperty(ParticleBatcher.prototype, "aliveParticleCount", {
                get: function () {
                    if (this._firstAliveCursor >= this._lastAliveCursor) {
                        return this._firstAliveCursor - this._lastAliveCursor;
                    }
                    else {
                        return this._comp.main._maxParticles - this._lastAliveCursor + this._firstAliveCursor;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return ParticleBatcher;
        }());
        particle.ParticleBatcher = ParticleBatcher;
        __reflect(ParticleBatcher.prototype, "egret3d.particle.ParticleBatcher");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        var ParticleComponent = (function (_super) {
            __extends(ParticleComponent, _super);
            function ParticleComponent() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                //主模块
                _this.main = new particle.MainModule(_this);
                //发射模块
                _this.emission = new particle.EmissionModule(_this);
                //发射形状模块
                _this.shape = new particle.ShapeModule(_this);
                //速率变换模块
                _this.velocityOverLifetime = new particle.VelocityOverLifetimeModule(_this);
                //旋转变换模块
                _this.rotationOverLifetime = new particle.RotationOverLifetimeModule(_this);
                //尺寸变化模块
                _this.sizeOverLifetime = new particle.SizeOverLifetimeModule(_this);
                //颜色变化模块
                _this.colorOverLifetime = new particle.ColorOverLifetimeModule(_this);
                //序列帧变化模块
                _this.textureSheetAnimation = new particle.TextureSheetAnimationModule(_this);
                /**
                 * @internal
                 */
                _this._isPlaying = false;
                /**
                 * @internal
                 */
                _this._isPaused = false;
                _this._batcher = new particle.ParticleBatcher();
                return _this;
            }
            /**
             * @internal
             */
            ParticleComponent.prototype._clean = function () {
                //
                this._batcher.clean();
                this._isPlaying = false;
                this._isPaused = false;
            };
            ParticleComponent.prototype.deserialize = function (element) {
                _super.prototype.deserialize.call(this, element);
                this.main.deserialize(element.main);
                this.emission.deserialize(element.emission);
                if (element.shape) {
                    this.shape.deserialize(element.shape);
                }
                if (element.velocityOverLifetime) {
                    this.velocityOverLifetime.deserialize(element.velocityOverLifetime);
                }
                if (element.rotationOverLifetime) {
                    this.rotationOverLifetime.deserialize(element.rotationOverLifetime);
                }
                if (element.sizeOverLifetime) {
                    this.sizeOverLifetime.deserialize(element.sizeOverLifetime);
                }
                if (element.colorOverLifetime) {
                    this.colorOverLifetime.deserialize(element.colorOverLifetime);
                }
                if (element.textureSheetAnimation) {
                    this.textureSheetAnimation.deserialize(element.textureSheetAnimation);
                }
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initialize = function () {
                _super.prototype.initialize.call(this);
                this._clean();
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.initBatcher = function () {
                this._clean();
                this._batcher.init(this, this.gameObject.getComponent(particle.ParticleRenderer));
            };
            /**
             * @internal
             */
            ParticleComponent.prototype.update = function (elapsedTime) {
                this._batcher.update(elapsedTime);
            };
            ParticleComponent.prototype.play = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (this._isPaused) {
                    this._isPaused = false;
                }
                else {
                    this._isPlaying = true;
                    this._isPaused = false;
                    this._batcher.resetTime();
                }
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
                        var child = children_1[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.play(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.pause = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPaused = true;
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_2 = children; _i < children_2.length; _i++) {
                        var child = children_2[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.pause(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.stop = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                this._isPlaying = false;
                this._batcher.resetTime();
                //
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_3 = children; _i < children_3.length; _i++) {
                        var child = children_3[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            ParticleComponent.prototype.clear = function (withChildren) {
                if (withChildren === void 0) { withChildren = true; }
                if (withChildren) {
                    var children = this.gameObject.transform.children;
                    for (var _i = 0, children_4 = children; _i < children_4.length; _i++) {
                        var child = children_4[_i];
                        var particleComp = child.gameObject.getComponent(ParticleComponent);
                        if (particleComp && particleComp.isActiveAndEnabled) {
                            particleComp.stop(withChildren);
                        }
                    }
                }
            };
            Object.defineProperty(ParticleComponent.prototype, "loop", {
                get: function () {
                    return this.main.loop;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPlaying", {
                get: function () {
                    return this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isPaused", {
                get: function () {
                    return this._isPaused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleComponent.prototype, "isAlive", {
                get: function () {
                    return this._batcher.aliveParticleCount > 0 || this._isPlaying;
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "main", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "emission", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "shape", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "velocityOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "rotationOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "sizeOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "colorOverLifetime", void 0);
            __decorate([
                paper.serializedField
            ], ParticleComponent.prototype, "textureSheetAnimation", void 0);
            return ParticleComponent;
        }(paper.BaseComponent));
        particle.ParticleComponent = ParticleComponent;
        __reflect(ParticleComponent.prototype, "egret3d.particle.ParticleComponent");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    paper.serializeClassMap = {
        0: "paper.Scene",
        1: "paper.GameObject",
        2: "egret3d.AniPlayer",
        3: "egret3d.BoxCollider",
        4: "egret3d.Camera",
        5: "egret3d.MeshFilter",
        6: "egret3d.MeshRenderer",
        7: "egret3d.particle.ParticleComponent",
        8: "egret3d.particle.ParticleRenderer",
        9: "egret3d.SkinnedMeshRenderer",
        10: "egret3d.SphereCollider",
        11: "egret3d.Transform",
        12: "egret3d.Shader",
        13: "egret3d.Mesh",
        14: "egret3d.Material",
        15: "egret3d.AnimationClip",
        16: "egret3d.TPoseInfo",
        17: "egret3d.PoseBoneMatrix",
        18: "egret3d.Texture",
        19: "egret3d.Texture",
        20: "egret3d.Vector2",
        21: "egret3d.Vector3",
        22: "egret3d.Vector4",
        23: "egret3d.Quaternion",
        24: "egret3d.Color",
        25: "egret3d.Gradient",
        26: "egret3d.Curve",
        27: "egret3d.Keyframe",
        28: "egret3d.Rect",
        29: "egret3d.MainModule",
        30: "egret3d.EmissionModule",
        31: "egret3d.ShapeModule",
        32: "egret3d.VelocityOverLifetimeModule",
        33: "egret3d.RotationOverLifetimeModule",
        34: "egret3d.ColorOverLifetimeModule",
        35: "egret3d.SizeOverLifetimeModule",
        36: "egret3d.MinMaxCurve",
        37: "egret3d.MinMaxGradient",
        38: "egret3d.alphaKey",
        39: "egret3d.colorKey",
        40: "egret3d.Animation",
        41: "egret3d.GLTFAsset",
        //
        "egret3d.Light": "egret3d.DirectLight",
    };
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        /**
         *
         */
        var ParticleSystem = (function (_super) {
            __extends(ParticleSystem, _super);
            function ParticleSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    {
                        componentClass: particle.ParticleComponent,
                        listeners: [
                            { type: "rotation3DChanged" /* StartRotation3DChanged */, listener: function (comp) { _this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */); } },
                            { type: "simulationSpace" /* SimulationSpaceChanged */, listener: function (comp) { _this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */); } },
                            { type: "scaleMode" /* ScaleModeChanged */, listener: function (comp) { _this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */); } },
                            { type: "velocityChanged" /* VelocityChanged */, listener: _this._onVelocityOverLifetime.bind(_this) },
                            { type: "colorChanged" /* ColorChanged */, listener: _this._onColorOverLifetime.bind(_this) },
                            { type: "sizeChanged" /* SizeChanged */, listener: _this._onSizeOverLifetime.bind(_this) },
                            { type: "rotationChanged" /* RotationChanged */, listener: _this._onRotationOverLifetime.bind(_this) },
                            { type: "textureSheetChanged" /* TextureSheetChanged */, listener: _this._onTextureSheetAnimation.bind(_this) },
                        ]
                    },
                    {
                        componentClass: particle.ParticleRenderer,
                        listeners: [
                            { type: "mesh" /* Mesh */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "materials" /* Materials */, listener: function (comp) { _this._updateDrawCalls(comp.gameObject); } },
                            { type: "lengthScale" /* LengthScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "lengthScale" /* LengthScaleChanged */); } },
                            { type: "velocityScale" /* VelocityScaleChanged */, listener: function (comp) { _this._onRenderUpdate(comp, "velocityScale" /* VelocityScaleChanged */); } },
                            { type: "renderMode" /* RenderMode */, listener: function (comp) { _this._onRenderUpdate(comp, "renderMode" /* RenderMode */); } },
                        ]
                    }
                ];
                _this._drawCalls = _this._globalGameObject.getOrAddComponent(egret3d.DrawCalls);
                return _this;
            }
            /**
            * Buffer改变的时候，有可能是初始化，也有可能是mesh改变，此时全部刷一下
            */
            ParticleSystem.prototype._onUpdateBatchMesh = function (comp) {
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                comp.initBatcher();
                //
                this._onRenderUpdate(renderer, "renderMode" /* RenderMode */);
                this._onRenderUpdate(renderer, "lengthScale" /* LengthScaleChanged */);
                this._onRenderUpdate(renderer, "velocityScale" /* VelocityScaleChanged */);
                //
                this._onMainUpdate(comp, "rotation3DChanged" /* StartRotation3DChanged */);
                this._onMainUpdate(comp, "simulationSpace" /* SimulationSpaceChanged */);
                this._onMainUpdate(comp, "scaleMode" /* ScaleModeChanged */);
                this._onShapeChanged(comp);
                this._onVelocityOverLifetime(comp);
                this._onColorOverLifetime(comp);
                this._onSizeOverLifetime(comp);
                this._onRotationOverLifetime(comp);
                this._onTextureSheetAnimation(comp);
            };
            ParticleSystem.prototype._onRenderUpdate = function (render, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(render.gameObject)) {
                    return;
                }
                switch (type) {
                    case "renderMode" /* RenderMode */: {
                        this._onRenderMode(render);
                        break;
                    }
                    case "lengthScale" /* LengthScaleChanged */: {
                        render._setFloat("u_lengthScale" /* LENGTH_SCALE */, render.lengthScale);
                        break;
                    }
                    case "velocityScale" /* VelocityScaleChanged */: {
                        render._setFloat("u_speeaScale" /* SPEED_SCALE */, render.velocityScale);
                        break;
                    }
                }
            };
            /**
             *
             * @param render 渲染模式改变
             */
            ParticleSystem.prototype._onRenderMode = function (render) {
                render._removeShaderDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                render._removeShaderDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                render._removeShaderDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                render._removeShaderDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                render._removeShaderDefine("RENDERMESH" /* RENDERMESH */);
                var mode = render.renderMode;
                switch (mode) {
                    case 0 /* Billboard */: {
                        render._addShaderDefine("SPHERHBILLBOARD" /* SPHERHBILLBOARD */);
                        break;
                    }
                    case 1 /* Stretch */: {
                        render._addShaderDefine("STRETCHEDBILLBOARD" /* STRETCHEDBILLBOARD */);
                        break;
                    }
                    case 2 /* HorizontalBillboard */: {
                        render._addShaderDefine("HORIZONTALBILLBOARD" /* HORIZONTALBILLBOARD */);
                        break;
                    }
                    case 3 /* VerticalBillboard */: {
                        render._addShaderDefine("VERTICALBILLBOARD" /* VERTICALBILLBOARD */);
                        break;
                    }
                    case 4 /* Mesh */: {
                        render._addShaderDefine("RENDERMESH" /* RENDERMESH */);
                        break;
                    }
                    default: {
                        throw "_onRenderMode:invalid renderMode";
                    }
                }
            };
            ParticleSystem.prototype._onMainUpdate = function (component, type) {
                if (!this._enabled || !this._groups[0].hasGameObject(component.gameObject)) {
                    return;
                }
                var renderer = component.gameObject.getComponent(particle.ParticleRenderer);
                var mainModule = component.main;
                switch (type) {
                    case "rotation3DChanged" /* StartRotation3DChanged */: {
                        renderer._setBoolean("u_startRotation3D" /* START_ROTATION3D */, mainModule._startRotation3D);
                        break;
                    }
                    case "simulationSpace" /* SimulationSpaceChanged */: {
                        renderer._setInt("u_simulationSpace" /* SIMULATION_SPACE */, mainModule._simulationSpace);
                        break;
                    }
                    case "scaleMode" /* ScaleModeChanged */: {
                        renderer._setInt("u_scalingMode" /* SCALING_MODE */, mainModule._scaleMode);
                        break;
                    }
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onShapeChanged = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("SHAPE" /* SHAPE */);
                if (comp.shape.enable) {
                    renderer._addShaderDefine("SHAPE" /* SHAPE */);
                }
            };
            /**
             * 更新速率模块
             * @param component
             */
            ParticleSystem.prototype._onVelocityOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                renderer._removeShaderDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                renderer._removeShaderDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                renderer._removeShaderDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                var velocityModule = comp.velocityOverLifetime;
                if (velocityModule.enable) {
                    var mode = velocityModule._mode;
                    switch (mode) {
                        case 0 /* Constant */: {
                            renderer._addShaderDefine("VELOCITYCONSTANT" /* VELOCITYCONSTANT */);
                            //
                            var vec3 = new egret3d.Vector3(velocityModule._x.evaluate(), velocityModule._y.evaluate(), velocityModule._z.evaluate());
                            renderer._setVector3("u_velocityConst" /* VELOCITY_CONST */, vec3);
                            break;
                        }
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("VELOCITYCURVE" /* VELOCITYCURVE */);
                            //
                            renderer._setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curve.floatValues);
                            renderer._setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curve.floatValues);
                            renderer._setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curve.floatValues);
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            renderer._addShaderDefine("VELOCITYTWOCONSTANT" /* VELOCITYTWOCONSTANT */);
                            //
                            var minVec3 = new egret3d.Vector3(velocityModule._x.constantMin, velocityModule._y.constantMin, velocityModule._z.constantMin);
                            var maxVec3 = new egret3d.Vector3(velocityModule._x.constantMax, velocityModule._y.constantMax, velocityModule._z.constantMax);
                            renderer._setVector3("u_velocityConst" /* VELOCITY_CONST */, minVec3);
                            renderer._setVector3("u_velocityConstMax" /* VELOCITY_CONST_MAX */, maxVec3);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("VELOCITYTWOCURVE" /* VELOCITYTWOCURVE */);
                            //
                            renderer._setVector2v("u_velocityCurveX[0]" /* VELOCITY_CURVE_X */, velocityModule._x.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveY[0]" /* VELOCITY_CURVE_Y */, velocityModule._y.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveZ[0]" /* VELOCITY_CURVE_Z */, velocityModule._z.curveMin.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxX[0]" /* VELOCITY_CURVE_MAX_X */, velocityModule._x.curveMax.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxY[0]" /* VELOCITY_CURVE_MAX_Y */, velocityModule._y.curveMax.floatValues);
                            renderer._setVector2v("u_velocityCurveMaxZ[0]" /* VELOCITY_CURVE_MAX_Z */, velocityModule._z.curveMax.floatValues);
                            break;
                        }
                    }
                    renderer._setInt("u_spaceType" /* SPACE_TYPE */, velocityModule._space);
                }
            };
            /**
             * 更新颜色模块
             * @param component
             */
            ParticleSystem.prototype._onColorOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                renderer._removeShaderDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                var colorModule = comp.colorOverLifetime;
                if (colorModule.enable) {
                    var color = colorModule._color;
                    switch (color.mode) {
                        case 1 /* Gradient */: {
                            renderer._addShaderDefine("COLOROGRADIENT" /* COLOROGRADIENT */);
                            //
                            renderer._setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradient.alphaValues);
                            renderer._setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradient.colorValues);
                            break;
                        }
                        case 3 /* TwoGradients */: {
                            renderer._addShaderDefine("COLORTWOGRADIENTS" /* COLORTWOGRADIENTS */);
                            //
                            renderer._setVector2v("u_alphaGradient[0]" /* ALPHAS_GRADIENT */, color.gradientMin.alphaValues);
                            renderer._setVector2v("u_alphaGradientMax[0]" /* ALPHA_GRADIENT_MAX */, color.gradientMax.alphaValues);
                            renderer._setVector4v("u_colorGradient[0]" /* COLOR_GRADIENT */, color.gradientMin.colorValues);
                            renderer._setVector4v("u_colorGradientMax[0]" /* COLOR_GRADIENT_MAX */, color.gradientMax.colorValues);
                            break;
                        }
                    }
                }
            };
            /**
             * 更新大小模块
             * @param component
             */
            ParticleSystem.prototype._onSizeOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("SIZECURVE" /* SIZECURVE */);
                renderer._removeShaderDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                renderer._removeShaderDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                renderer._removeShaderDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                var sizeModule = comp.sizeOverLifetime;
                if (sizeModule.enable) {
                    var separateAxes = sizeModule._separateAxes;
                    var mode = sizeModule._x.mode;
                    switch (mode) {
                        case 1 /* Curve */: {
                            if (separateAxes) {
                                renderer._addShaderDefine("SIZECURVESEPERATE" /* SIZECURVESEPERATE */);
                                //
                                renderer._setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curve.floatValues);
                                renderer._setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curve.floatValues);
                                renderer._setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curve.floatValues);
                            }
                            else {
                                renderer._addShaderDefine("SIZECURVE" /* SIZECURVE */);
                                //
                                renderer._setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            if (separateAxes) {
                                renderer._addShaderDefine("SIZETWOCURVESSEPERATE" /* SIZETWOCURVESSEPERATE */);
                                //
                                renderer._setVector2v("u_sizeCurveX[0]" /* SIZE_CURVE_X */, sizeModule._x.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveY[0]" /* SIZE_CURVE_Y */, sizeModule._y.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveZ[0]" /* SIZE_CURVE_Z */, sizeModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxX[0]" /* SIZE_CURVE_MAX_X */, sizeModule._x.curveMax.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxY[0]" /* SIZE_CURVE_MAX_Y */, sizeModule._y.curveMax.floatValues);
                                renderer._setVector2v("u_sizeCurveMaxZ[0]" /* SIZE_CURVE_MAX_Z */, sizeModule._z.curveMax.floatValues);
                            }
                            else {
                                renderer._addShaderDefine("SIZETWOCURVES" /* SIZETWOCURVES */);
                                //
                                renderer._setVector2v("u_sizeCurve[0]" /* SIZE_CURVE */, sizeModule._size.curveMin.floatValues);
                                renderer._setVector2v("u_sizeCurveMax[0]" /* SIZE_CURVE_MAX */, sizeModule._size.curveMax.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            /**
             * 更新旋转模块
             * @param comp
             */
            ParticleSystem.prototype._onRotationOverLifetime = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                renderer._removeShaderDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                renderer._removeShaderDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                renderer._removeShaderDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                renderer._removeShaderDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                renderer._removeShaderDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                var rotationModule = comp.rotationOverLifetime;
                if (rotationModule.enable) {
                    var mode = comp.rotationOverLifetime._x.mode;
                    var separateAxes = rotationModule._separateAxes;
                    if (separateAxes) {
                        renderer._addShaderDefine("ROTATIONSEPERATE" /* ROTATIONSEPERATE */);
                    }
                    else {
                        renderer._addShaderDefine("ROTATIONOVERLIFETIME" /* ROTATIONOVERLIFETIME */);
                    }
                    switch (mode) {
                        case 0 /* Constant */: {
                            renderer._addShaderDefine("ROTATIONCONSTANT" /* ROTATIONCONSTANT */);
                            //
                            if (separateAxes) {
                                renderer._setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constant, rotationModule._y.constant, rotationModule._z.constant));
                            }
                            else {
                                renderer._setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constant);
                            }
                            break;
                        }
                        case 3 /* TwoConstants */: {
                            renderer._addShaderDefine("ROTATIONTWOCONSTANTS" /* ROTATIONTWOCONSTANTS */);
                            //
                            if (separateAxes) {
                                renderer._setVector3("u_rotationConstSeprarate" /* ROTATION_CONST_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMin, rotationModule._y.constantMin, rotationModule._z.constantMin));
                                renderer._setVector3("u_rotationConstMaxSeprarate" /* ROTATION_CONST_MAX_SEPRARATE */, new egret3d.Vector3(rotationModule._x.constantMax, rotationModule._y.constantMax, rotationModule._z.constantMax));
                            }
                            else {
                                renderer._setFloat("u_rotationConst" /* ROTATION_CONST */, rotationModule._z.constantMin);
                                renderer._setFloat("u_rotationConstMax" /* ROTATION_CONST_MAX */, rotationModule._z.constantMax);
                            }
                            break;
                        }
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("ROTATIONCURVE" /* ROTATIONCURVE */);
                            //
                            if (separateAxes) {
                                renderer._setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curve.floatValues);
                                renderer._setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curve.floatValues);
                                renderer._setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curve.floatValues);
                            }
                            else {
                                renderer._setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curve.floatValues);
                            }
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("ROTATIONTWOCURVES" /* ROTATIONTWOCURVES */);
                            //
                            if (separateAxes) {
                                renderer._setVector2v("u_rotationCurveX[0]" /* ROTATE_CURVE_X */, rotationModule._x.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveY[0]" /* ROTATE_CURVE_y */, rotationModule._y.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveZ[0]" /* ROTATE_CURVE_Z */, rotationModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxX[0]" /* ROTATION_CURVE_MAX_X */, rotationModule._x.curveMax.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxY[0]" /* ROTATION_CURVE_MAX_Y */, rotationModule._y.curveMax.floatValues);
                                renderer._setVector2v("u_rotationCurveMaxZ[0]" /* ROTATION_CURVE_MAX_Z */, rotationModule._z.curveMax.floatValues);
                            }
                            else {
                                renderer._setVector2v("u_rotationCurve[0]" /* ROTATION_CURVE */, rotationModule._z.curveMin.floatValues);
                                renderer._setVector2v("u_rotationCurveMax[0]" /* ROTATION_CURVE_MAX */, rotationModule._z.curveMin.floatValues);
                            }
                            break;
                        }
                    }
                }
            };
            ParticleSystem.prototype._onTextureSheetAnimation = function (comp) {
                if (!this._enabled || !this._groups[0].hasGameObject(comp.gameObject)) {
                    return;
                }
                var renderer = comp.gameObject.getComponent(particle.ParticleRenderer);
                renderer._removeShaderDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                renderer._removeShaderDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                var module = comp.textureSheetAnimation;
                if (module.enable) {
                    var type = module._frameOverTime.mode;
                    switch (type) {
                        case 1 /* Curve */: {
                            renderer._addShaderDefine("TEXTURESHEETANIMATIONCURVE" /* TEXTURESHEETANIMATIONCURVE */);
                            //
                            renderer._setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curve.floatValues);
                            break;
                        }
                        case 2 /* TwoCurves */: {
                            renderer._addShaderDefine("TEXTURESHEETANIMATIONTWOCURVE" /* TEXTURESHEETANIMATIONTWOCURVE */);
                            //
                            renderer._setVector2v("u_uvCurve[0]" /* UV_CURVE */, module._frameOverTime.curveMin.floatValues);
                            renderer._setVector2v("u_uvCurveMax[0]" /* UV_CURVE_MAX */, module._frameOverTime.curveMax.floatValues);
                            break;
                        }
                    }
                    if (type === 1 /* Curve */ || type === 2 /* TwoCurves */) {
                        renderer._setFloat("u_cycles" /* CYCLES */, module._cycleCount);
                        renderer._setVector4v("u_subUV" /* SUB_UV */, module.floatValues);
                    }
                }
            };
            ParticleSystem.prototype._updateDrawCalls = function (gameObject) {
                if (!this._enabled || !this._groups[0].hasGameObject(gameObject)) {
                    return;
                }
                var component = gameObject.getComponent(particle.ParticleComponent);
                var renderer = gameObject.getComponent(particle.ParticleRenderer);
                //
                this._onUpdateBatchMesh(component);
                if (!renderer.batchMesh || !renderer.batchMaterial) {
                    return;
                }
                //
                this._drawCalls.removeDrawCalls(renderer);
                //
                this._drawCalls.renderers.push(renderer);
                //
                var subMeshIndex = 0;
                var primitives = renderer.batchMesh.glTFMesh.primitives;
                if (primitives.length !== 1) {
                    console.error("ParticleSystem : materials.length != 1");
                }
                if (renderer._renderMode === 5 /* None */) {
                    console.error("ParticleSystem : error renderMode");
                }
                for (var _i = 0, primitives_1 = primitives; _i < primitives_1.length; _i++) {
                    var primitive = primitives_1[_i];
                    var drawCall = {
                        renderer: renderer,
                        subMeshIndex: subMeshIndex++,
                        mesh: renderer.batchMesh,
                        material: renderer.batchMaterial || egret3d.DefaultMaterials.MissingMaterial,
                        frustumTest: false,
                        zdist: -1,
                    };
                    this._drawCalls.drawCalls.push(drawCall);
                }
            };
            ParticleSystem.prototype.onEnable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._updateDrawCalls(gameObject);
                }
            };
            ParticleSystem.prototype.onAddGameObject = function (gameObject, group) {
                this._updateDrawCalls(gameObject);
                var component = gameObject.getComponent(particle.ParticleComponent);
                if (component.main.playOnAwake) {
                    component.play();
                }
            };
            ParticleSystem.prototype.onRemoveGameObject = function (gameObject) {
                this._drawCalls.removeDrawCalls(gameObject.renderer);
                // component.stop();
            };
            ParticleSystem.prototype.onUpdate = function (deltaTime) {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    gameObject.getComponent(particle.ParticleComponent).update(deltaTime);
                }
            };
            ParticleSystem.prototype.onDisable = function () {
                for (var _i = 0, _a = this._groups[0].gameObjects; _i < _a.length; _i++) {
                    var gameObject = _a[_i];
                    this._drawCalls.removeDrawCalls(gameObject.renderer);
                }
            };
            return ParticleSystem;
        }(paper.BaseSystem));
        particle.ParticleSystem = ParticleSystem;
        __reflect(ParticleSystem.prototype, "egret3d.particle.ParticleSystem");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Audio = (function (_super) {
        __extends(Audio, _super);
        function Audio() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Audio;
    }(paper.BaseComponent));
    egret3d.Audio = Audio;
    __reflect(Audio.prototype, "egret3d.Audio");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL窗口信息
     */
    var Stage3D = (function () {
        function Stage3D() {
            this.screenViewport = { x: 0, y: 0, w: 0, h: 0 };
            this.absolutePosition = { x: 0, y: 0, w: 0, h: 0 };
            this._resizeDirty = true;
        }
        /**
         * @internal
         */
        Stage3D.prototype.init = function (canvas, options) {
            var _this = this;
            this._canvas = canvas;
            window.addEventListener("resize", function () { return _this._resizeDirty = true; }, false);
            this.isLandscape = options.contentWidth > options.contentHeight;
            this.contentWidth = options.contentWidth;
            this.contentHeight = options.contentHeight;
        };
        Stage3D.prototype.update = function () {
            if (this._resizeDirty) {
                this._resize();
                this._resizeDirty = false;
            }
        };
        Stage3D.prototype._resize = function () {
            var displayWidth = window.innerWidth;
            var displayHeight = window.innerHeight;
            var absolutePosition = this.absolutePosition;
            absolutePosition.w = displayWidth;
            absolutePosition.h = displayHeight;
            // 计算视口区域
            var screenViewport = this.screenViewport;
            var shouldRotate = (this.isLandscape && window.innerHeight > window.innerWidth)
                || (!this.isLandscape && window.innerWidth > window.innerHeight);
            if (shouldRotate) {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayHeight * displayWidth);
                screenViewport.h = screenH;
            }
            else {
                screenViewport.w = this.contentWidth;
                var screenH = Math.ceil(screenViewport.w / displayWidth * displayHeight);
                screenViewport.h = screenH;
            }
            var canvas = this._canvas;
            canvas.width = screenViewport.w;
            canvas.height = screenViewport.h;
            // 设置canvas.style
            var x = absolutePosition.x, y = absolutePosition.y, w = absolutePosition.w, h = absolutePosition.h;
            canvas.style.top = y + "px";
            canvas.style.position = "absolute";
            canvas.style[egret.web.getPrefixStyleName("transformOrigin")] = "0% 0% 0px";
            if (shouldRotate) {
                canvas.style.width = h + "px";
                canvas.style.height = w + "px";
                canvas.style.left = window.innerWidth + "px";
                var transform = "matrix(0,1,-1,0,0,0)";
                canvas.style[egret.web.getPrefixStyleName("transform")] = transform;
            }
            else {
                canvas.style.width = w + "px";
                canvas.style.height = h + "px";
                canvas.style.left = x + "px";
                canvas.style[egret.web.getPrefixStyleName("transform")] = null;
            }
            // 更新触摸信息
            var touchScaleX;
            var touchScaleY;
            if (shouldRotate) {
                touchScaleX = egret3d.stage.screenViewport.w / h;
                touchScaleY = egret3d.stage.screenViewport.h / w;
            }
            else {
                touchScaleX = egret3d.stage.screenViewport.w / w;
                touchScaleY = egret3d.stage.screenViewport.h / h;
            }
            egret3d.InputManager.touch.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
            egret3d.InputManager.mouse.updateOffsetAndScale(x, y, touchScaleX, touchScaleY, shouldRotate);
        };
        return Stage3D;
    }());
    egret3d.Stage3D = Stage3D;
    __reflect(Stage3D.prototype, "egret3d.Stage3D");
    egret3d.stage = new Stage3D();
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * get max precision
     * @param gl
     * @param precision {string} the expect precision, can be: "highp"|"mediump"|"lowp"
     */
    function getMaxPrecision(gl, precision) {
        if (precision === void 0) { precision = "highp"; }
        if (precision === 'highp') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
                return 'highp';
            }
            precision = 'mediump';
        }
        if (precision === 'mediump') {
            if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 &&
                gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
                return 'mediump';
            }
        }
        return 'lowp';
    }
    function getExtension(gl, name) {
        var browserPrefixes = [
            "",
            "MOZ_",
            "OP_",
            "WEBKIT_"
        ];
        for (var ii = 0; ii < browserPrefixes.length; ++ii) {
            var prefixedName = browserPrefixes[ii] + name;
            var ext = gl.getExtension(prefixedName);
            if (ext) {
                return ext;
            }
        }
        return null;
    }
    function getConstDefines(maxPrecision) {
        var defines = "precision " + maxPrecision + " float; \n";
        defines += "precision " + maxPrecision + " int; \n";
        // defines += '#extension GL_OES_standard_derivatives : enable \n';
        return defines;
    }
    var WebGLCapabilities = (function (_super) {
        __extends(WebGLCapabilities, _super);
        function WebGLCapabilities() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.precision = "highp";
            return _this;
        }
        WebGLCapabilities.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this.webgl = paper.Application._webgl;
            WebGLCapabilities.webgl = this.webgl;
            var gl = this.webgl;
            this.version = parseFloat(/^WebGL\ ([0-9])/.exec(gl.getParameter(gl.VERSION))[1]);
            this.maxPrecision = getMaxPrecision(gl, this.precision);
            this.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
            this.maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
            this.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            this.maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
            this.maxVertexUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
            this.floatTextures = !!getExtension(gl, 'OES_texture_float');
            this.anisotropyExt = getExtension(gl, 'EXT_texture_filter_anisotropic');
            this.shaderTextureLOD = getExtension(gl, 'EXT_shader_texture_lod');
            this.maxAnisotropy = (this.anisotropyExt !== null) ? gl.getParameter(this.anisotropyExt.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            // use dfdx and dfdy must enable OES_standard_derivatives
            getExtension(gl, "OES_standard_derivatives");
            // GL_OES_standard_derivatives
            getExtension(gl, "GL_OES_standard_derivatives");
            //TODO
            WebGLCapabilities.commonDefines = getConstDefines(this.maxPrecision);
        };
        return WebGLCapabilities;
    }(paper.SingletonComponent));
    egret3d.WebGLCapabilities = WebGLCapabilities;
    __reflect(WebGLCapabilities.prototype, "egret3d.WebGLCapabilities");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
         * 渲染排序
         */
    var RenderQueue;
    (function (RenderQueue) {
        RenderQueue[RenderQueue["Background"] = 1000] = "Background";
        RenderQueue[RenderQueue["Geometry"] = 2000] = "Geometry";
        RenderQueue[RenderQueue["AlphaTest"] = 2450] = "AlphaTest";
        RenderQueue[RenderQueue["Transparent"] = 3000] = "Transparent";
        RenderQueue[RenderQueue["Overlay"] = 4000] = "Overlay";
    })(RenderQueue = egret3d.RenderQueue || (egret3d.RenderQueue = {}));
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0;
    /**
    * 材质资源
    */
    var Material = (function (_super) {
        __extends(Material, _super);
        function Material() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var _this = _super.call(this) || this;
            _this._glTFMaterialIndex = 0;
            _this._glTFAsset = null;
            _this._cacheDefines = '';
            _this._textureRef = []; //TODO
            _this._defines = new Array();
            _this._glTFMaterial = null;
            /**
            * @internal
            */
            _this._glTFTechnique = null;
            /**
             * @internal
             */
            _this._glTFShader = null;
            /**
              * @internal
              */
            _this.id = _hashCode++;
            _this.version = 0;
            if (args.length === 0) {
                return _this;
            }
            if (args.length === 1) {
                _this._glTFShader = args[0];
                _this._glTFMaterialIndex = 0;
                _this._glTFAsset = egret3d.GLTFAsset.createGLTFExtensionsAsset();
                var newGLTFMat = { extensions: { KHR_techniques_webgl: { technique: _this._glTFShader.name, values: {} }, paper: { renderQueue: -1 } } };
                _this._glTFAsset.config.materials = [newGLTFMat];
            }
            else if (args.length === 2) {
                _this._glTFAsset = args[0];
                _this._glTFMaterialIndex = args[1];
            }
            _this.initialize();
            return _this;
        }
        /**
         * 释放资源。
         */
        Material.prototype.dispose = function () {
            this._glTFMaterialIndex = 0;
            this._glTFAsset = null;
            this._glTFMaterial = null;
            this._glTFTechnique = null;
            this._glTFShader = null;
            this._cacheDefines = "";
            this._defines.length = 0;
            for (var _i = 0, _a = this._textureRef; _i < _a.length; _i++) {
                var tex = _a[_i];
                tex.dispose();
            }
            this._textureRef.length = 0;
            this.version++;
        };
        /**
         * 克隆材质资源。
         */
        Material.prototype.clone = function () {
            var mat = new Material(this._glTFShader);
            mat._glTFMaterial.extensions.paper.renderQueue = this._glTFMaterial.extensions.paper.renderQueue;
            // for (const key in this._gltfUnifromMap) {
            //     const value = Array.isArray(this._gltfUnifromMap[key]) ? this._gltfUnifromMap[key].concat() : this._gltfUnifromMap[key];
            //     mat._gltfUnifromMap[key] = value;
            // }
            //
            var unifroms = this._glTFTechnique.uniforms;
            var targetUniforms = mat._glTFTechnique.uniforms;
            for (var key in unifroms) {
                var uniform = unifroms[key];
                var value = Array.isArray(uniform.value) ? uniform.value.concat() : uniform.value;
                targetUniforms[key] = { type: uniform.type, semantic: uniform.semantic, value: value, extensions: { paper: { enable: false, location: -1 } } };
            }
            var states = this._glTFTechnique.states;
            var targetStates = mat._glTFTechnique.states;
            if (states.enable) {
                targetStates.enable = states.enable.concat();
            }
            for (var fun in states.functions) {
                if (Array.isArray(states.functions[fun])) {
                    targetStates.functions[fun] = states.functions[fun].concat();
                }
                else {
                    targetStates.functions[fun] = states.functions[fun];
                }
            }
            return mat;
        };
        Material.prototype.serialize = function () {
            if (!this._glTFAsset.name) {
                return null;
            }
            var target = paper.createStruct(this);
            target._gltfMaterialIndex = this._glTFMaterialIndex;
            target._glTFAsset = paper.createAssetReference(this._glTFAsset);
            return target;
        };
        Material.prototype.deserialize = function (element) {
            this._glTFMaterialIndex = element._glTFMaterialIndex;
            this._glTFAsset = paper.getDeserializedAssetOrComponent(element._glTFAsset);
            this.initialize();
        };
        Material.prototype.initialize = function () {
            var config = this._glTFAsset.config;
            if (!config.materials) {
                console.error("Error glTF asset.");
                return;
            }
            //
            this._glTFMaterial = config.materials[this._glTFMaterialIndex];
            if (!this._glTFMaterial ||
                !this._glTFMaterial.extensions.KHR_techniques_webgl ||
                !this._glTFMaterial.extensions.KHR_techniques_webgl.technique) {
                console.error("Error glTF asset.");
            }
            if (!this._glTFShader) {
                //不存在，那就从材质中获取
                this._glTFShader = paper.Asset.find(this._glTFMaterial.extensions.KHR_techniques_webgl.technique);
                if (!this._glTFShader) {
                    console.error("材质中获取着色器错误");
                }
            }
            if (!this._glTFShader.config ||
                !this._glTFShader.config.extensions ||
                !this._glTFShader.config.extensions.KHR_techniques_webgl ||
                this._glTFShader.config.extensions.KHR_techniques_webgl.techniques.length <= 0) {
                console.error("找不到着色器扩展KHR_techniques_webgl");
            }
            //
            var template = this._glTFShader.config.extensions.KHR_techniques_webgl.techniques[0];
            this._glTFTechnique = egret3d.GLTFAsset.createTechnique(template);
            if (!this._glTFTechnique) {
                console.error("Error glTF asset.");
            }
            var gltfUnifromMap = this._glTFMaterial.extensions.KHR_techniques_webgl.values;
            var uniformMap = this._glTFTechnique.uniforms;
            //使用Shader替换Material中没有默认值的Uniform
            for (var key in gltfUnifromMap) {
                if (uniformMap[key]) {
                    var value = gltfUnifromMap[key];
                    if (Array.isArray(value)) {
                        uniformMap[key].value = value.concat();
                    }
                    else {
                        uniformMap[key].value = value;
                    }
                }
            }
        };
        Material.prototype.addDefine = function (key) {
            if (this._defines.indexOf(key) < 0) {
                this._defines.push(key);
                this.version++;
            }
        };
        Material.prototype.removeDefine = function (key) {
            var delIndex = this._defines.indexOf(key);
            if (delIndex >= 0) {
                this._defines.splice(delIndex, 1);
                this.version++;
            }
        };
        Material.prototype.setBoolean = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setInt = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setIntv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setFloat = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value !== value) {
                    uniform.value = value;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setFloatv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector2 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector2v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector3 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector3v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector4 = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value[0] !== value.x || uniform.value[1] !== value.y || uniform.value[2] !== value.z || uniform.value[3] !== value.w) {
                    uniform.value[0] = value.x;
                    uniform.value[1] = value.y;
                    uniform.value[2] = value.z;
                    uniform.value[3] = value.w;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setVector4v = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setMatrix = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value.rawData;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setMatrixv = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                uniform.value = value;
                this.version++;
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
        };
        Material.prototype.setTexture = function (id, value) {
            var uniform = this._glTFTechnique.uniforms[id];
            if (uniform !== undefined) {
                if (uniform.value) {
                    var index = this._textureRef.indexOf(uniform.value);
                    if (index > -1) {
                        this._textureRef.splice(index, 1);
                    }
                }
                if (uniform.value !== value) {
                    uniform.value = value;
                    this.version++;
                }
            }
            else {
                console.warn("尝试设置不存在的Uniform值:" + id);
            }
            if (value) {
                this._textureRef.push(value);
            }
        };
        Object.defineProperty(Material.prototype, "shader", {
            get: function () {
                return this._glTFShader;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "renderQueue", {
            get: function () {
                var renderQueue = this._glTFMaterial.extensions.paper.renderQueue;
                return renderQueue === -1 ? this._glTFShader.config.extensions.paper.renderQueue : renderQueue;
            },
            set: function (value) {
                this._glTFMaterial.extensions.paper.renderQueue = value;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Material.prototype, "shaderDefine", {
            get: function () {
                this._cacheDefines = "";
                for (var _i = 0, _a = this._defines; _i < _a.length; _i++) {
                    var key = _a[_i];
                    this._cacheDefines += "#define " + key + " \n";
                }
                return this._cacheDefines;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Material.prototype, "_glTFMaterialIndex", void 0);
        __decorate([
            paper.serializedField
        ], Material.prototype, "_glTFAsset", void 0);
        return Material;
    }(paper.SerializableObject));
    egret3d.Material = Material;
    __reflect(Material.prototype, "egret3d.Material");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _helpVector3A = new egret3d.Vector3();
    var _helpVector3B = new egret3d.Vector3();
    var _helpVector3C = new egret3d.Vector3();
    var _helpVector3D = new egret3d.Vector3();
    var _helpVector3E = new egret3d.Vector3();
    var _helpVector3F = new egret3d.Vector3();
    var _helpVector3G = new egret3d.Vector3();
    var _helpVector3H = new egret3d.Vector3();
    var _helpVectors = [
        _helpVector3A,
        _helpVector3B,
        _helpVector3C,
        _helpVector3D,
        _helpVector3E,
        _helpVector3F,
        _helpVector3G,
        _helpVector3H,
    ];
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpVec3_3 = new egret3d.Vector3();
    var helpVec3_4 = new egret3d.Vector3();
    var helpVec3_5 = new egret3d.Vector3();
    var boxIndices = [
        0, 1, 2, 3,
        4, 5, 6, 7,
        1, 3, 5, 7,
        0, 2, 4, 6,
        6, 2, 7, 3,
        0, 4, 1, 5
    ];
    /**
     * 射线
     */
    var Ray = (function () {
        /**
         * 构建一条射线
         * @param origin 射线起点
         * @param dir 射线方向
         */
        function Ray(origin, direction) {
            this.origin = egret3d.Vector3.copy(origin, new egret3d.Vector3());
            this.direction = egret3d.Vector3.copy(direction, new egret3d.Vector3());
        }
        /**
         * 与aabb碰撞相交检测
         */
        Ray.prototype.intersectAABB = function (aabb) {
            return this.intersectBoxMinMax(aabb.minimum, aabb.maximum);
        };
        /**
         * 与transform表示的plane碰撞相交检测，主要用于2d检测
         * @param transform transform实例
         */
        Ray.prototype.intersectPlaneTransform = function (transform) {
            var pickinfo = null;
            var panelpoint = transform.getPosition();
            var forward = helpVec3_1;
            transform.getForward(forward);
            var hitposition = this.intersectPlane(panelpoint, forward);
            if (hitposition) {
                pickinfo = new PickInfo();
                pickinfo.hitposition = hitposition;
                pickinfo.distance = egret3d.Vector3.getDistance(pickinfo.hitposition, this.origin);
            }
            return pickinfo;
        };
        Ray.prototype.intersectPlane = function (planePoint, planeNormal) {
            var vp1 = planeNormal.x;
            var vp2 = planeNormal.y;
            var vp3 = planeNormal.z;
            var n1 = planePoint.x;
            var n2 = planePoint.y;
            var n3 = planePoint.z;
            var v1 = this.direction.x;
            var v2 = this.direction.y;
            var v3 = this.direction.z;
            var m1 = this.origin.x;
            var m2 = this.origin.y;
            var m3 = this.origin.z;
            var vpt = v1 * vp1 + v2 * vp2 + v3 * vp3;
            if (vpt === 0) {
                return null;
            }
            else {
                var t = ((n1 - m1) * vp1 + (n2 - m2) * vp2 + (n3 - m3) * vp3) / vpt;
                return new egret3d.Vector3(m1 + v1 * t, m2 + v2 * t, m3 + v3 * t);
            }
        };
        /**
         * 与最大最小点表示的box相交检测
         * @param minimum 最小点
         * @param maximum 最大点
         * @version paper 1.0
         */
        Ray.prototype.intersectBoxMinMax = function (minimum, maximum) {
            var d = 0.0;
            var maxValue = Number.MAX_VALUE;
            var inv;
            var min;
            var max;
            var temp;
            if (Math.abs(this.direction.x) < 0.0000001) {
                if (this.origin.x < minimum.x || this.origin.x > maximum.x) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.x;
                min = (minimum.x - this.origin.x) * inv;
                max = (maximum.x - this.origin.x) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.y) < 0.0000001) {
                if (this.origin.y < minimum.y || this.origin.y > maximum.y) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.y;
                min = (minimum.y - this.origin.y) * inv;
                max = (maximum.y - this.origin.y) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            if (Math.abs(this.direction.z) < 0.0000001) {
                if (this.origin.z < minimum.z || this.origin.z > maximum.z) {
                    return false;
                }
            }
            else {
                inv = 1.0 / this.direction.z;
                min = (minimum.z - this.origin.z) * inv;
                max = (maximum.z - this.origin.z) * inv;
                if (max === -Infinity) {
                    max = Infinity;
                }
                if (min > max) {
                    temp = min;
                    min = max;
                    max = temp;
                }
                d = Math.max(min, d);
                maxValue = Math.min(max, maxValue);
                if (d > maxValue) {
                    return false;
                }
            }
            return true;
        };
        /**
         * 与球相交检测
         */
        Ray.prototype.intersectsSphere = function (center, radius) {
            var center_ori = helpVec3_1;
            egret3d.Vector3.subtract(center, this.origin, center_ori);
            var raydist = egret3d.Vector3.dot(this.direction, center_ori);
            if (raydist < 0)
                return false; // 到圆心的向量在方向向量上的投影为负，夹角不在-90与90之间
            var orilen2 = egret3d.Vector3.getSqrLength(center_ori);
            var rad2 = radius * radius;
            if (orilen2 < rad2)
                return true; // 射线起点在球里
            var d = rad2 - (orilen2 - raydist * raydist);
            if (d < 0)
                return false;
            return true;
        };
        /**
         * 与三角形相交检测
         */
        Ray.prototype.intersectsTriangle = function (vertex0, vertex1, vertex2) {
            var _edge1 = helpVec3_1;
            var _edge2 = helpVec3_2;
            var _pvec = helpVec3_3;
            var _tvec = helpVec3_4;
            var _qvec = helpVec3_5;
            egret3d.Vector3.subtract(vertex1, vertex0, _edge1);
            egret3d.Vector3.subtract(vertex2, vertex0, _edge2);
            egret3d.Vector3.cross(this.direction, _edge2, _pvec);
            var det = egret3d.Vector3.dot(_edge1, _pvec);
            if (det === 0) {
                return null;
            }
            var invdet = 1 / det;
            egret3d.Vector3.subtract(this.origin, vertex0, _tvec);
            var bu = egret3d.Vector3.dot(_tvec, _pvec) * invdet;
            if (bu < 0 || bu > 1.0) {
                return null;
            }
            egret3d.Vector3.cross(_tvec, _edge1, _qvec);
            var bv = egret3d.Vector3.dot(this.direction, _qvec) * invdet;
            if (bv < 0 || bu + bv > 1.0) {
                return null;
            }
            var pickInfo = new PickInfo();
            pickInfo.distance = egret3d.Vector3.dot(_edge2, _qvec) * invdet;
            pickInfo.textureCoordA.x = bu;
            pickInfo.textureCoordA.y = bv;
            return pickInfo;
        };
        /**
         * 获取射线拾取到的最近物体。
         */
        Ray.raycast = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, false, isPickMesh);
        };
        /**
         * 获取射线路径上的所有物体。
         */
        Ray.raycastAll = function (ray, isPickMesh, maxDistance, layerMask) {
            if (isPickMesh === void 0) { isPickMesh = false; }
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (layerMask === void 0) { layerMask = 2 /* Default */ | 4 /* UI */; }
            return this._doPick(ray, maxDistance, layerMask, true, isPickMesh);
        };
        Ray._doPick = function (ray, maxDistance, layerMask, pickAll, isPickMesh) {
            if (maxDistance === void 0) { maxDistance = Number.MAX_VALUE; }
            if (pickAll === void 0) { pickAll = false; }
            if (isPickMesh === void 0) { isPickMesh = false; }
            var pickedList = [];
            for (var _i = 0, _a = paper.Application.sceneManager.activeScene.getRootGameObjects(); _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.layer & layerMask) {
                    if (isPickMesh) {
                        this._pickMesh(ray, gameObject.transform, pickedList);
                    }
                    else {
                        this._pickCollider(ray, gameObject.transform, pickedList);
                    }
                }
            }
            if (pickedList.length === 0) {
                return null;
            }
            if (pickAll) {
                return pickedList;
            }
            var index = 0;
            for (var i = 1; i < pickedList.length; i++) {
                if (pickedList[i].distance < pickedList[index].distance) {
                    index = i;
                }
            }
            return pickedList[index];
        };
        Ray._pickMesh = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                var meshFilter = transform.gameObject.getComponent(egret3d.MeshFilter);
                if (meshFilter) {
                    var mesh = meshFilter.mesh;
                    if (mesh) {
                        var pickinfo = mesh.intersects(ray, transform.getWorldMatrix());
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
                else {
                    var skinmesh = transform.gameObject.getComponent(egret3d.SkinnedMeshRenderer);
                    if (skinmesh) {
                        var pickinfo = skinmesh.intersects(ray);
                        if (pickinfo) {
                            pickInfos.push(pickinfo);
                            pickinfo.transform = transform;
                        }
                    }
                }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickMesh(ray, child, pickInfos);
            }
        };
        Ray._pickCollider = function (ray, transform, pickInfos) {
            if (transform.gameObject.activeInHierarchy) {
                // const pickInfo = ray.intersectCollider(transform);
                // if (pickInfo) {
                //     pickInfos.push(pickInfo);
                //     pickInfo.transform = transform;
                // }
            }
            for (var _i = 0, _a = transform.children; _i < _a.length; _i++) {
                var child = _a[_i];
                this._pickCollider(ray, child, pickInfos);
            }
        };
        return Ray;
    }());
    egret3d.Ray = Ray;
    __reflect(Ray.prototype, "egret3d.Ray");
    /**
     * 场景拣选信息
     */
    var PickInfo = (function () {
        function PickInfo() {
            this.subMeshIndex = -1;
            this.triangleIndex = -1;
            this.distance = 0.0;
            this.position = new egret3d.Vector3();
            this.textureCoordA = new egret3d.Vector2();
            this.textureCoordB = new egret3d.Vector2();
            this.transform = null;
        }
        return PickInfo;
    }());
    egret3d.PickInfo = PickInfo;
    __reflect(PickInfo.prototype, "egret3d.PickInfo");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderLib;
    (function (ShaderLib) {
        ShaderLib.alphaBlend_frag = "\n#include <common>\nuniform sampler2D _MainTex;\nuniform vec4 _TintColor;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{   \n gl_FragColor=texture2D(_MainTex,xlv_TEXCOORD0)*_TintColor*2.0;\n    gl_FragColor.a = clamp(gl_FragColor.a, 0.0, 1.0);\n}";
        ShaderLib.alphaCut_frag = "#include <common>\nuniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main()\n{   \n lowp vec4 outColor=texture2D(_MainTex,xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    gl_FragColor = outColor;\n}";
        ShaderLib.boneeff_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp vec4 glstate_vec4_bones[110];\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n int i = int(blendIndex.x);  \n    int i2 =int(blendIndex.y);\n int i3 =int(blendIndex.z);\n int i4 =int(blendIndex.w);\n \n    mat4 mat = buildMat4(i)*blendWeight.x \n    + buildMat4(i2)*blendWeight.y \n    + buildMat4(i3)*blendWeight.z \n    + buildMat4(i4)*blendWeight.w;\n return mat* srcVertex;\n}\n\n\nvoid main()\n{                                               \n    highp vec4 tmpvar_1 = vec4(calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz, 1.0);\n    \n    gl_Position = glstate_matrix_mvp *  tmpvar_1;\n\n xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n}";
        ShaderLib.bonelambert_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec3 _glesNormal; \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;             \nattribute vec4 _glesMultiTexCoord0;    \n\nuniform mat4 glstate_matrix_mvp;      \nuniform mat4 glstate_matrix_model;\n\nuniform highp vec4 glstate_vec4_bones[110];\nuniform highp vec4 _MainTex_ST; \n\n#include <shadowMap_pars_vert>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;                \nvarying vec2 xlv_TEXCOORD0;\n\n#include <transpose>\n#include <inverse>\n\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n\nhighp vec4 calcVertex(highp vec4 srcVertex,highp vec4 blendIndex,highp vec4 blendWeight)\n{\n int i = int(blendIndex.x);  \n    int i2 =int(blendIndex.y);\n int i3 =int(blendIndex.z);\n int i4 =int(blendIndex.w);\n \n    mat4 mat = buildMat4(i)*blendWeight.x \n    + buildMat4(i2)*blendWeight.y \n    + buildMat4(i3)*blendWeight.z \n    + buildMat4(i4)*blendWeight.w;\n return mat* srcVertex;\n}\n\nvoid main() {   \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz;                            \n\n    vec3 normal = (transpose(inverse(glstate_matrix_model)) * vec4(_glesNormal, 1.0)).xyz;\n    xlv_NORMAL = normal;\n    #ifdef FLIP_SIDED\n     xlv_NORMAL = - xlv_NORMAL;\n    #endif\n\n    vec3 worldpos = (glstate_matrix_model * tmpvar_1).xyz;\n    xlv_POS = worldpos; \n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\n    #include <shadowMap_vert>\n     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.bone_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp mat4 glstate_matrix_bones[24];\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;  \n \n    int i = int(_glesBlendIndex4.x);  \n    int i2 =int(_glesBlendIndex4.y);\n int i3 =int(_glesBlendIndex4.z);\n int i4 =int(_glesBlendIndex4.w);\n \n    mat4 mat = glstate_matrix_bones[i]*_glesBlendWeight4.x \n    + glstate_matrix_bones[i2]*_glesBlendWeight4.y \n    + glstate_matrix_bones[i3]*_glesBlendWeight4.z \n    + glstate_matrix_bones[i4]*_glesBlendWeight4.w;\n    \n    gl_Position = (glstate_matrix_mvp * mat)* tmpvar_1;\n\n xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n}";
        ShaderLib.code2_frag = "#include <common>\nvoid main() {\n    gl_FragData[0] = vec4(1.0, 1.0, 1.0, 1.0);\n}";
        ShaderLib.code_frag = "#include <common>\nuniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() {\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    prev_2 = tmpvar_3;\n    mediump vec4 tmpvar_4;\n    tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    col_1 = tmpvar_4;\n    col_1.x =xlv_TEXCOORD0.x;\n    col_1.y =xlv_TEXCOORD0.y;\n    gl_FragData[0] = col_1;\n}";
        ShaderLib.code_vert = "#include <common>\nattribute vec4 _glesVertex;\nattribute vec4 _glesColor;             \nattribute vec4 _glesMultiTexCoord0;    \nuniform highp mat4 glstate_matrix_mvp; \nvarying lowp vec4 xlv_COLOR;           \nvarying highp vec2 xlv_TEXCOORD0;      \nvoid main() {                                          \n    highp vec4 tmpvar_1;                   \n    tmpvar_1.w = 1.0;                      \n    tmpvar_1.xyz = _glesVertex.xyz;        \n    xlv_COLOR = _glesColor;                \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.depthpackage_frag = "#include <common>\n#include <packing>\n\nvoid main() {\n gl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n}";
        ShaderLib.depthpackage_vert = "#include <common>\nattribute vec3 _glesVertex;\n\nuniform mat4 glstate_matrix_mvp;\n\nvoid main() { \n    gl_Position = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}";
        ShaderLib.diffuselightmap_frag = "#include <common>\nuniform sampler2D _MainTex;\nuniform sampler2D _LightmapTex;\nuniform lowp float _LightmapIntensity;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nlowp vec3 decode_hdr(lowp vec4 data, lowp float intensity)\n{\n    highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n    return data.rgb * power * intensity;\n}\nvoid main() \n{\n    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    lowp vec4 lightmap = texture2D(_LightmapTex, xlv_TEXCOORD1);\n    outColor.xyz *= decode_hdr(lightmap, _LightmapIntensity);\n    gl_FragData[0] = outColor;\n}";
        ShaderLib.diffuselightmap_vert = "#include <common>\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nattribute vec4 _glesMultiTexCoord1;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 glstate_lightmapOffset;\nuniform lowp float glstate_lightmapUV;\nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;\nvarying highp vec2 xlv_TEXCOORD1;\nvoid main()\n{\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;  \n\n    highp vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    if(glstate_lightmapUV == 0.0)\n    {\n        beforelightUV = _glesMultiTexCoord0.xy;\n    }\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = 1.0 - ((1.0 - beforelightUV.y) * glstate_lightmapOffset.y + glstate_lightmapOffset.w);\n    xlv_TEXCOORD1 = vec2(u,v);\n\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.diffuse_frag = "#include <common>\n#include <lightmap_pars_frag>\nuniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0);\n    if(outColor.a < _AlphaCut)\n        discard;\n    #include <lightmap_frag>    \n}";
        ShaderLib.diffuse_vert = "#include <common>\n#include <skinning_pars_vert>\n#include <lightmap_pars_vert> \nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0;\nuniform highp mat4 glstate_matrix_mvp;\nuniform highp vec4 _MainTex_ST;  \nvarying highp vec2 xlv_TEXCOORD0;\n\nvoid main() {\n    // highp vec4 tmpVertex;\n    #include <skinning_base_vert>\n    // tmpVertex.w = 1.0;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;\n    #include <lightmap_vert>\n    gl_Position = (glstate_matrix_mvp * tmpVertex);\n}";
        ShaderLib.distancepackage_frag = "#include <common>\n#include <packing>\n\nvarying vec3 xlv_POS;\nuniform vec4 glstate_referencePosition;\nuniform float glstate_nearDistance;\nuniform float glstate_farDistance;\n\nvoid main() {\n    float dist = length( xlv_POS - glstate_referencePosition.xyz );\n dist = ( dist - glstate_nearDistance ) / ( glstate_farDistance - glstate_nearDistance );\n dist = saturate( dist ); // clamp to [ 0, 1 ]\n\n gl_FragColor = packDepthToRGBA( dist );\n}";
        ShaderLib.distancepackage_vert = "#include <common>\nattribute vec3 _glesVertex;\n\nuniform mat4 glstate_matrix_mvp;\nuniform mat4 glstate_matrix_model;\n\nvarying vec3 xlv_POS;\n\nvoid main() {   \n    xlv_POS = (glstate_matrix_model * vec4(_glesVertex, 1.0)).xyz;\n    gl_Position = glstate_matrix_mvp * vec4(_glesVertex, 1.0);\n}";
        ShaderLib.lambert_frag = "// #extension GL_OES_standard_derivatives : enable\n#include <common>\nuniform sampler2D _MainTex;\nuniform vec4 _Color;         \n\n#include <bsdfs>\n#include <light_pars_frag>\n#include <shadowMap_pars_frag>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;                \nvarying vec2 xlv_TEXCOORD0;\n\n#ifdef USE_NORMAL_MAP\n    #include <tbn>\n    #include <tsn>\n    uniform sampler2D _NormalTex;\n#endif\n\n#include <bumpMap_pars_frag>\n\nvoid main() {\n    vec4 outColor = vec4(0., 0., 0., 1.);\n\n    vec4 diffuseColor = _Color * texture2D(_MainTex, xlv_TEXCOORD0);\n\n    #include <normal_frag>\n    #include <light_frag>\n    \n    outColor.a = diffuseColor.a;\n\n    gl_FragColor = outColor;\n}";
        ShaderLib.lambert_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec3 _glesNormal;               \nattribute vec4 _glesMultiTexCoord0;\n#include <skinning_pars_vert>\n\nuniform mat4 glstate_matrix_mvp;      \nuniform mat4 glstate_matrix_model;\n\n#include <shadowMap_pars_vert>\n\nvarying vec3 xlv_POS;\nvarying vec3 xlv_NORMAL;             \nvarying vec2 xlv_TEXCOORD0;\n\n#include <transpose>\n#include <inverse>\n\nvoid main() {   \n    #include <skinning_base_vert>\n\n    vec3 tmpNormal;      \n    #include <skinning_normal_vert>              \n\n    vec3 normal = (transpose(inverse(glstate_matrix_model)) * vec4(tmpNormal, 1.0)).xyz;\n    xlv_NORMAL = normal;\n    #ifdef FLIP_SIDED\n     xlv_NORMAL = - xlv_NORMAL;\n    #endif\n\n    vec3 worldpos = (glstate_matrix_model * tmpVertex).xyz;\n    xlv_POS = worldpos; \n\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;\n\n    #include <shadowMap_vert>\n     \n    gl_Position = (glstate_matrix_mvp * tmpVertex);\n}";
        ShaderLib.line_frag = "#include <common>\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    gl_FragData[0] = xlv_COLOR;\n}";
        ShaderLib.line_vert = "#include <common>\nattribute vec4 _glesVertex;\nattribute vec4 _glesColor;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _glesColor;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.materialcolor_vert = "#include <common>\nattribute vec4 _glesVertex;\nuniform vec4 _Color;\nuniform highp mat4 glstate_matrix_mvp;\nvarying lowp vec4 xlv_COLOR;\nvoid main() {\n    highp vec4 tmpvar_1;\n    tmpvar_1.w = 1.0;\n    tmpvar_1.xyz = _glesVertex.xyz;\n    xlv_COLOR = _Color;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);\n}";
        ShaderLib.particlesystem_frag = "\n//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\n#include <common>\nuniform sampler2D _MainTex;\nuniform vec4 _TintColor;\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n\n#ifdef RENDERMODE_MESH\n varying vec4 v_mesh_color;\n#endif\n\nvoid main()\n{ \n #ifdef RENDERMODE_MESH\n  gl_FragColor=v_mesh_color;\n #else\n  gl_FragColor=vec4(1.0); \n #endif\n\n if(v_discard!=0.0)\n  discard;\n gl_FragColor*=texture2D(_MainTex,v_texcoord)*_TintColor*v_color*2.0;\n}";
        ShaderLib.particlesystem_vert = "//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\n#include <common>\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\n attribute vec2 _glesCorner;\n#endif\n#ifdef RENDERMESH\n attribute vec3 _glesVertex;\n attribute vec4 _glesColor;\n#endif\nattribute vec2 _glesMultiTexCoord0;\nattribute vec3 _startPosition;\nattribute vec3 _startVelocity;\nattribute vec4 _startColor;\nattribute vec3 _startSize;\nattribute vec3 _startRotation;\nattribute vec2 _time;\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\n  attribute vec4 _random0;\n#endif\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  attribute vec4 _random1;\n#endif\nattribute vec3 _startWorldPosition;\nattribute vec4 _startWorldRotation;\n\n#include <particle_common>\n\nvoid main()\n{\n float age = u_currentTime - _time.y;\n float t = age/_time.x;\n if(t>1.0){    \n   v_discard=1.0;\n   return;\n  }\n   \n #include <particle_affector>\n gl_Position=glstate_matrix_vp*vec4(center,1.0);\n v_color = computeColor(_startColor, t);\n v_texcoord =computeUV(_glesMultiTexCoord0, t);\n v_discard=0.0;\n}\n\n";
        ShaderLib.postdepth_frag = "#include <common>\n//varying highp vec3 xlv_Normal;   \n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( const in float v ) \n{\n    vec2 r = vec2( fract( v * PackFactors.z ), v );\n r.y -= r.x * ShiftRight8;\n    return r * PackUpscale;\n}\nfloat unpackRGToDepth( const in vec2 v ) \n{\n    return dot( v.xy, UnpackFactors.zw );\n}\nvec3 packDepthToRGB( const in float v ) \n{\n    vec3 r = vec3( fract( v * PackFactors.yz ), v );\n r.yz -= r.xy * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBToDepth( const in vec3 v ) \n{\n    return dot( v.xyz, UnpackFactors.yzw );\n}\nvoid main() \n{\n    float z = gl_FragCoord.z;// fract(gl_FragCoord.z *256.*256.);\n    // highp vec2 normal =xlv_Normal.xy;\n    gl_FragColor=packDepthToRGBA(z);\n}";
        ShaderLib.postdepth_vert = "#include <common>\nprecision highp float;\nattribute vec4 _glesVertex;    \n\nuniform highp mat4 glstate_matrix_mvp;      \n            \nvoid main()                                     \n{        \n    gl_Position = (glstate_matrix_mvp * _glesVertex);  \n}";
        ShaderLib.postquaddepth_frag = "#include <common>\nprecision mediump float;\nvarying highp vec2 xlv_TEXCOORD0;       \nuniform sampler2D _DepthTex;   \nuniform sampler2D _MainTex;  \n\n\nconst float PackUpscale = 256. / 255.; \n// fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; \n// 0..1 -> fraction (excluding 1)\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) \n{\n    vec4 r = vec4( fract( v * PackFactors ), v );\n r.yzw -= r.xyz * ShiftRight8;\n // tidy overflow\n    return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) \n{\n    return dot( v, UnpackFactors );\n}\n\n\nfloat planeDistance(const in vec3 positionA, const in vec3 normalA, \n                    const in vec3 positionB, const in vec3 normalB) \n{\n  vec3 positionDelta = positionB-positionA;\n  float planeDistanceDelta = max(abs(dot(positionDelta, normalA)), abs(dot(positionDelta, normalB)));\n  return planeDistanceDelta;\n}\n\nvoid main()         \n{\n    lowp vec4 c1=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0.001,0));\n    lowp vec4 c2=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(-0.001,0));\n    lowp vec4 c3=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,0.001));\n    lowp vec4 c4=texture2D(_DepthTex, xlv_TEXCOORD0+vec2(0,-0.001));\n    highp float z1 = unpackRGBAToDepth(c1);\n    highp float z2 = unpackRGBAToDepth(c2);\n    highp float z3 = unpackRGBAToDepth(c3);\n    highp float z4 = unpackRGBAToDepth(c4);\n    highp float d = clamp(  (abs(z2-z1)+abs(z4-z3))*10.0,0.0,1.0);\n    lowp vec4 c=texture2D(_MainTex, xlv_TEXCOORD0);\n    lowp float g = c.r*0.3+c.g*0.6+c.b*0.1;\n\n    gl_FragColor =mix(vec4(g,g,g,1.),vec4(1.0,1.0,0.0,1.0),d);// vec4(g*d,g*d,g*d,1.0);\n}";
        ShaderLib.postquad_vert = "#include <common>\nattribute vec4 _glesVertex;\nattribute vec4 _glesMultiTexCoord0; \nuniform highp vec4 _MainTex_ST; \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main()                     \n{ \n    gl_Position = _glesVertex;\n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw; \n}   ";
        ShaderLib.tintcolor_frag = "#include <common>\nuniform sampler2D _MainTex;\nuniform lowp float _AlphaCut;\nuniform lowp vec4 _TintColor;\n\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() \n{\n    lowp vec4 tmpvar_3 = _TintColor*texture2D(_MainTex, xlv_TEXCOORD0);\n    if(tmpvar_3.a < _AlphaCut)\n        discard;\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.transparentdiffuse_vert = "";
        ShaderLib.uifont_frag = "#include <common>\nprecision mediump float;\nuniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying lowp vec4 xlv_COLOREx;\nvarying highp vec2 xlv_TEXCOORD0;  \nvoid main() {\n    float scale = 10.0;\n    float d = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.5) * scale;  //0.5\n    float bd = (texture2D(_MainTex, xlv_TEXCOORD0).r - 0.34) * scale;  //0.34\n\n    float c=xlv_COLOR.a * clamp ( d,0.0,1.0);\n    float bc=xlv_COLOREx.a * clamp ( bd,0.0,1.0);\n    bc =min(1.0-c,bc);\n\n    gl_FragData[0] =xlv_COLOR*c + xlv_COLOREx*bc;\n}";
        ShaderLib.uifont_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesColorEx;                  \nattribute vec4 _glesMultiTexCoord0;         \nuniform highp mat4 glstate_matrix_mvp;      \nvarying lowp vec4 xlv_COLOR;                \nvarying lowp vec4 xlv_COLOREx;                                                 \nvarying highp vec2 xlv_TEXCOORD0;           \nvoid main() {                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_COLOREx = _glesColorEx;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy;     \n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}";
        ShaderLib.ui_frag = "#include <common>\nuniform sampler2D _MainTex;\nvarying lowp vec4 xlv_COLOR;\nvarying highp vec2 xlv_TEXCOORD0;\nvoid main() {\n    lowp vec4 tmpvar_3;\n    tmpvar_3 = (xlv_COLOR * texture2D(_MainTex, xlv_TEXCOORD0));\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.vertcolor_frag = "#include <common>\nuniform sampler2D _MainTex;                                                 \nvarying lowp vec4 xlv_COLOR;                                                 \nvarying highp vec2 xlv_TEXCOORD0;   \nvoid main() \n{\n    lowp vec4 col_1;    \n    mediump vec4 prev_2;\n    lowp vec4 tmpvar_3;\n\n    tmpvar_3 = (texture2D(_MainTex, xlv_TEXCOORD0));\n    //prev_2 = tmpvar_3;\n    //mediump vec4 tmpvar_4;\n    //tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\n    //col_1 = tmpvar_4;\n    //col_1.x = xlv_TEXCOORD0.x;\n    //col_1.y = xlv_TEXCOORD0.y;\n    gl_FragData[0] = tmpvar_3;\n}";
        ShaderLib.vertcolor_vert = "#include <common>\nattribute vec4 _glesVertex;   \nattribute vec4 _glesNormal;   \nattribute vec4 _glesColor;                  \nattribute vec4 _glesMultiTexCoord0;        \nuniform highp mat4 glstate_matrix_mvp;   \nvarying lowp vec4 xlv_COLOR;                \nvarying highp vec2 xlv_TEXCOORD0;   \n\nuniform highp vec4 _MainTex_ST;       \n\nvoid main()                                     \n{                                               \n    highp vec4 tmpvar_1;                        \n    tmpvar_1.w = 1.0;                           \n    tmpvar_1.xyz = _glesVertex.xyz;             \n    xlv_COLOR = _glesColor;                     \n    xlv_TEXCOORD0 = _glesMultiTexCoord0.xy * _MainTex_ST.xy + _MainTex_ST.zw;   \n\n    //xlv_COLOR.xyz =pos.xyz;\n    gl_Position = (glstate_matrix_mvp * tmpvar_1);  \n}\n";
    })(ShaderLib = egret3d.ShaderLib || (egret3d.ShaderLib = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var ShaderChunk;
    (function (ShaderChunk) {
        ShaderChunk.begin_vert = "vec3 transformed = vec3(_glesVertex);\n// #if defined(USE_NORMAL) || defined(USE_ENV_MAP)\n    vec3 objectNormal = vec3(_glesNormal);\n// #endif";
        ShaderChunk.bsdfs = "// diffuse just use lambert\n\nvec3 BRDF_Diffuse_Lambert(vec3 diffuseColor) {\n    return RECIPROCAL_PI * diffuseColor;\n}\n\n// specular use Cook-Torrance microfacet model, http://ruh.li/GraphicsCookTorrance.html\n// About RECIPROCAL_PI: referenced by http://www.joshbarczak.com/blog/?p=272\n\nvec4 F_Schlick( const in vec4 specularColor, const in float dotLH ) {\n // Original approximation by Christophe Schlick '94\n float fresnel = pow( 1.0 - dotLH, 5.0 );\n\n // Optimized variant (presented by Epic at SIGGRAPH '13)\n // float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\n return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\n\n// use blinn phong instead of phong\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n    // ( shininess * 0.5 + 1.0 ), three.js do this, but why ???\n return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\n\nfloat G_BlinnPhong_Implicit( /* const in float dotNL, const in float dotNV */ ) {\n // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n return 0.25;\n}\n\nvec4 BRDF_Specular_BlinnPhong(vec4 specularColor, vec3 N, vec3 L, vec3 V, float shininess) {\n    vec3 H = normalize(L + V);\n\n    float dotNH = saturate(dot(N, H));\n    float dotLH = saturate(dot(L, H));\n\n    vec4 F = F_Schlick(specularColor, dotLH);\n\n    float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n    float D = D_BlinnPhong(shininess, dotNH);\n\n    return F * G * D;\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (33)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\n float a2 = pow2( alpha );\n\n float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0; // avoid alpha = 0 with dotNH = 1\n\n return RECIPROCAL_PI * a2 / pow2( denom );\n\n}\n\n// Microfacet Models for Refraction through Rough Surfaces - equation (34)\n// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html\n// alpha is \"roughness squared\" in Disney’s reparameterization\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n // geometry term = G(l)⋅G(v) / 4(n⋅l)(n⋅v)\n\n float a2 = pow2( alpha );\n\n float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\n return 1.0 / ( gl * gv );\n\n}\n\n// Moving Frostbite to Physically Based Rendering 2.0 - page 12, listing 2\n// http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr_v2.pdf\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\n float a2 = pow2( alpha );\n\n // dotNL and dotNV are explicitly swapped. This is not a mistake.\n float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\n return 0.5 / max( gv + gl, EPSILON );\n}\n\n// GGX Distribution, Schlick Fresnel, GGX-Smith Visibility\nvec4 BRDF_Specular_GGX(vec4 specularColor, vec3 N, vec3 L, vec3 V, float roughness) {\n\n float alpha = pow2( roughness ); // UE4's roughness\n\n vec3 H = normalize(L + V);\n\n float dotNL = saturate( dot(N, L) );\n float dotNV = saturate( dot(N, V) );\n float dotNH = saturate( dot(N, H) );\n float dotLH = saturate( dot(L, H) );\n\n vec4 F = F_Schlick( specularColor, dotLH );\n\n float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\n float D = D_GGX( alpha, dotNH );\n\n return F * G * D;\n\n}\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nvec4 BRDF_Specular_GGX_Environment( const in vec3 N, const in vec3 V, const in vec4 specularColor, const in float roughness ) {\n\n float dotNV = saturate( dot( N, V ) );\n\n const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\n const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\n vec4 r = roughness * c0 + c1;\n\n float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\n vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\n return specularColor * AB.x + AB.y;\n\n}\n\n// source: http://simonstechblog.blogspot.ca/2011/12/microfacet-brdf.html\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\n\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
        ShaderChunk.bumpMap_pars_frag = "#ifdef USE_BUMPMAP\n\n uniform sampler2D bumpMap;\n uniform float bumpScale;\n\n // Derivative maps - bump mapping unparametrized surfaces by Morten Mikkelsen\n // http://mmikkelsen3d.blogspot.sk/2011/07/derivative-maps.html\n\n // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n vec2 dHdxy_fwd(vec2 uv) {\n\n  vec2 dSTdx = dFdx( uv );\n  vec2 dSTdy = dFdy( uv );\n\n  float Hll = bumpScale * texture2D( bumpMap, uv ).x;\n  float dBx = bumpScale * texture2D( bumpMap, uv + dSTdx ).x - Hll;\n  float dBy = bumpScale * texture2D( bumpMap, uv + dSTdy ).x - Hll;\n\n  return vec2( dBx, dBy );\n\n }\n\n vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy) {\n\n  vec3 vSigmaX = dFdx( surf_pos );\n  vec3 vSigmaY = dFdy( surf_pos );\n  vec3 vN = surf_norm;  // normalized\n\n  vec3 R1 = cross( vSigmaY, vN );\n  vec3 R2 = cross( vN, vSigmaX );\n\n  float fDet = dot( vSigmaX, R1 );\n\n  vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n  return normalize( abs( fDet ) * surf_norm - vGrad );\n\n }\n\n#endif\n";
        ShaderChunk.common = "#define PI 3.14159265359\n#define EPSILON 1e-6\n#define LOG2 1.442695\n#define RECIPROCAL_PI 0.31830988618\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\n\nfloat pow2( const in float x ) { return x*x; } ";
        ShaderChunk.inverse = "mat4 inverse(mat4 m) {\n    float\n    a00 = m[0][0], a01 = m[0][1], a02 = m[0][2], a03 = m[0][3],\n    a10 = m[1][0], a11 = m[1][1], a12 = m[1][2], a13 = m[1][3],\n    a20 = m[2][0], a21 = m[2][1], a22 = m[2][2], a23 = m[2][3],\n    a30 = m[3][0], a31 = m[3][1], a32 = m[3][2], a33 = m[3][3],\n    b00 = a00 * a11 - a01 * a10,\n    b01 = a00 * a12 - a02 * a10,\n    b02 = a00 * a13 - a03 * a10,\n    b03 = a01 * a12 - a02 * a11,\n    b04 = a01 * a13 - a03 * a11,\n    b05 = a02 * a13 - a03 * a12,\n    b06 = a20 * a31 - a21 * a30,\n    b07 = a20 * a32 - a22 * a30,\n    b08 = a20 * a33 - a23 * a30,\n    b09 = a21 * a32 - a22 * a31,\n    b10 = a21 * a33 - a23 * a31,\n    b11 = a22 * a33 - a23 * a32,\n    det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n    return mat4(\n        a11 * b11 - a12 * b10 + a13 * b09,\n        a02 * b10 - a01 * b11 - a03 * b09,\n        a31 * b05 - a32 * b04 + a33 * b03,\n        a22 * b04 - a21 * b05 - a23 * b03,\n        a12 * b08 - a10 * b11 - a13 * b07,\n        a00 * b11 - a02 * b08 + a03 * b07,\n        a32 * b02 - a30 * b05 - a33 * b01,\n        a20 * b05 - a22 * b02 + a23 * b01,\n        a10 * b10 - a11 * b08 + a13 * b06,\n        a01 * b08 - a00 * b10 - a03 * b06,\n        a30 * b04 - a31 * b02 + a33 * b00,\n        a21 * b02 - a20 * b04 - a23 * b00,\n        a11 * b07 - a10 * b09 - a12 * b06,\n        a00 * b09 - a01 * b07 + a02 * b06,\n        a31 * b01 - a30 * b03 - a32 * b00,\n        a20 * b03 - a21 * b01 + a22 * b00) / det;\n}";
        ShaderChunk.lightmap_frag = "#ifdef LIGHTMAP\n    lowp vec4 lightmap = texture2D(_LightmapTex, xlv_TEXCOORD1);\n    outColor.xyz *= decode_hdr(lightmap, _LightmapIntensity);\n    gl_FragData[0] = outColor;\n#else\n    gl_FragData[0] = outColor;\n#endif";
        ShaderChunk.lightmap_pars_frag = "#ifdef LIGHTMAP\n    uniform sampler2D _LightmapTex;\n    uniform lowp float _LightmapIntensity;\n    varying highp vec2 xlv_TEXCOORD1;\n\n    lowp vec3 decode_hdr(lowp vec4 data, lowp float intensity)\n    {\n        highp float power =pow( 2.0 ,data.a * 255.0 - 128.0);\n        return data.rgb * power * intensity;\n    }\n#endif";
        ShaderChunk.lightmap_pars_vert = "#ifdef LIGHTMAP\n    uniform highp vec4 glstate_lightmapOffset;\n    uniform lowp float glstate_lightmapUV;\n#endif";
        ShaderChunk.lightmap_vert = "#ifdef LIGHTMAP\n    highp vec2 beforelightUV = _glesMultiTexCoord1.xy;\n    if(glstate_lightmapUV == 0.0)\n    {\n        beforelightUV = _glesMultiTexCoord0.xy;\n    }\n    highp float u = beforelightUV.x * glstate_lightmapOffset.x + glstate_lightmapOffset.z;\n    highp float v = 1.0 - ((1.0 - beforelightUV.y) * glstate_lightmapOffset.y + glstate_lightmapOffset.w);\n    xlv_TEXCOORD1 = vec2(u,v);\n#endif";
        ShaderChunk.light_frag = "#ifdef USE_LIGHT    \n    vec3 L;\n    vec3 light;\n    vec3 totalReflect = vec3(0., 0., 0.);\n\n    #ifdef USE_DIRECT_LIGHT\n        for(int i = 0; i < USE_DIRECT_LIGHT; i++) {\n            light = vec3(glstate_directLights[i * 15 + 6], glstate_directLights[i * 15 + 7], glstate_directLights[i * 15 + 8]) * glstate_directLights[i * 15 + 9];\n\n            L.x = glstate_directLights[i * 15 + 3];\n            L.y = glstate_directLights[i * 15 + 4];\n            L.z = glstate_directLights[i * 15 + 5];\n            L = normalize(-L);\n\n            float dotNL = saturate( dot(N, L) );\n            vec3 irradiance = light * dotNL;\n\n            #ifdef USE_PBR\n                irradiance *= PI;\n            #endif\n\n            #ifdef USE_SHADOW\n                irradiance *= bool( glstate_directLights[i * 15 + 10] ) ? getShadow( glstate_directionalShadowMap[ i ], vDirectionalShadowCoord[ i ], glstate_directLights[i * 15 + 11], glstate_directLights[i * 15 + 12], vec2(glstate_directLights[i * 15 + 13], glstate_directLights[i * 15 + 14]) ) : 1.0;\n            #endif\n\n            vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n            totalReflect += reflectLight;\n        }\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n        for(int i = 0; i < USE_POINT_LIGHT; i++) {\n            L = vec3(glstate_pointLights[i * 19 + 0], glstate_pointLights[i * 19 + 1], glstate_pointLights[i * 19 + 2]) - xlv_POS;\n            float dist = pow(clamp(1. - length(L) / glstate_pointLights[i * 19 + 10], 0.0, 1.0), glstate_pointLights[i * 19 + 11]);\n            light = vec3(glstate_pointLights[i * 19 + 6], glstate_pointLights[i * 19 + 7], glstate_pointLights[i * 19 + 8]) * glstate_pointLights[i * 19 + 9] * dist;\n            L = normalize(L);\n\n            float dotNL = saturate( dot(N, L) );\n            vec3 irradiance = light * dotNL;\n\n            #ifdef USE_PBR\n                irradiance *= PI;\n            #endif\n\n            #ifdef USE_SHADOW\n                vec3 worldV = xlv_POS - vec3(glstate_pointLights[i * 19 + 0], glstate_pointLights[i * 19 + 1], glstate_pointLights[i * 19 + 2]);\n                irradiance *= bool( glstate_pointLights[i * 19 + 12] ) ? getPointShadow( glstate_pointShadowMap[ i ], worldV, glstate_pointLights[i * 19 + 13], glstate_pointLights[i * 19 + 14], vec2(glstate_pointLights[i * 19 + 17], glstate_pointLights[i * 19 + 18]), glstate_pointLights[i * 19 + 15], glstate_pointLights[i * 19 + 16]) : 1.0;\n            #endif\n\n            vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n            totalReflect += reflectLight;\n        }\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n        for(int i = 0; i < USE_SPOT_LIGHT; i++) {\n            L = vec3(glstate_spotLights[i * 19 + 0], glstate_spotLights[i * 19 + 1], glstate_spotLights[i * 19 + 2]) - xlv_POS;\n            float lightDistance = length(L);\n            L = normalize(L);\n            float angleCos = dot( L, -normalize(vec3(glstate_spotLights[i * 19 + 3], glstate_spotLights[i * 19 + 4], glstate_spotLights[i * 19 + 5])) );\n\n            if( all( bvec2(angleCos > glstate_spotLights[i * 19 + 12], lightDistance < glstate_spotLights[i * 19 + 10]) ) ) {\n\n                float spotEffect = smoothstep( glstate_spotLights[i * 19 + 12], glstate_spotLights[i * 19 + 13], angleCos );\n                float dist = pow(clamp(1. - lightDistance / glstate_spotLights[i * 19 + 10], 0.0, 1.0), glstate_spotLights[i * 19 + 11]);\n                light = vec3(glstate_spotLights[i * 19 + 6], glstate_spotLights[i * 19 + 7], glstate_spotLights[i * 19 + 8]) * glstate_spotLights[i * 19 + 9] * dist * spotEffect;\n\n                float dotNL = saturate( dot(N, L) );\n                vec3 irradiance = light * dotNL;\n\n                #ifdef USE_PBR\n                    irradiance *= PI;\n                #endif\n\n                #ifdef USE_SHADOW\n                    irradiance *= bool( glstate_spotLights[i * 17 + 14] ) ? getShadow( glstate_spotShadowMap[ i ], vSpotShadowCoord[ i ], glstate_spotLights[i * 17 + 15], glstate_spotLights[i * 17 + 16], vec2(glstate_spotLights[i * 17 + 17], glstate_spotLights[i * 17 + 18])) : 1.0;\n                #endif\n\n                vec3 reflectLight = irradiance * BRDF_Diffuse_Lambert(diffuseColor.xyz);\n\n                totalReflect += reflectLight;\n            }\n\n        }\n    #endif\n\n    outColor.xyz = totalReflect;\n#endif";
        ShaderChunk.light_pars_frag = "#ifdef USE_DIRECT_LIGHT\n    uniform float glstate_directLights[USE_DIRECT_LIGHT * 15];\n#endif\n\n#ifdef USE_POINT_LIGHT\n    uniform float glstate_pointLights[USE_POINT_LIGHT * 19];\n#endif\n\n#ifdef USE_SPOT_LIGHT\n    uniform float glstate_spotLights[USE_SPOT_LIGHT * 19];\n#endif";
        ShaderChunk.normal_frag = "#ifdef DOUBLE_SIDED\n    float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n    float flipNormal = 1.0;\n#endif\n#ifdef FLAT_SHADED\n    // Workaround for Adreno/Nexus5 not able able to do dFdx( vViewPosition ) ...\n    vec3 fdx = vec3( dFdx( xlv_POS.x ), dFdx( xlv_POS.y ), dFdx( xlv_POS.z ) );\n    vec3 fdy = vec3( dFdy( xlv_POS.x ), dFdy( xlv_POS.y ), dFdy( xlv_POS.z ) );\n    vec3 N = normalize( cross( fdx, fdy ) );\n#else\n    vec3 N = normalize(xlv_NORMAL) * flipNormal;\n#endif\n#ifdef USE_NORMAL_MAP\n    vec3 normalMapColor = texture2D(_NormalTex, xlv_TEXCOORD0).rgb;\n    // for now, uv coord is flip Y\n    mat3 tspace = tsn(N, -xlv_POS, vec2(xlv_TEXCOORD0.x, 1.0 - xlv_TEXCOORD0.y));\n    // mat3 tspace = tbn(normalize(v_Normal), v_ViewModelPos, vec2(xlv_TEXCOORD0.x, 1.0 - xlv_TEXCOORD0.y));\n    N = normalize(tspace * (normalMapColor * 2.0 - 1.0));\n#elif defined(USE_BUMPMAP)\n    N = perturbNormalArb(-xlv_POS, N, dHdxy_fwd(xlv_TEXCOORD0));\n#endif";
        ShaderChunk.packing = "const float PackUpscale = 256. / 255.; // fraction -> 0..1 (including 1)\nconst float UnpackDownscale = 255. / 256.; // 0..1 -> fraction (excluding 1)\n\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\n\nconst float ShiftRight8 = 1. / 256.;\n\nvec4 packDepthToRGBA( const in float v ) {\n\n    vec4 r = vec4( fract( v * PackFactors ), v );\n    r.yzw -= r.xyz * ShiftRight8; // tidy overflow\n    return r * PackUpscale;\n\n}\n\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\n    return dot( v, UnpackFactors );\n\n}";
        ShaderChunk.particle_affector = "vec3 lifeVelocity = computeVelocity(t);\nvec4 worldRotation;\nif(u_simulationSpace==1)\n worldRotation=_startWorldRotation;\nelse\n worldRotation=u_worldRotation;\nvec3 gravity=u_gravity*age;\n\nvec3 center=computePosition(_startVelocity, lifeVelocity, age, t,gravity,worldRotation); \n#ifdef SPHERHBILLBOARD\n   vec2 corner=_glesCorner.xy;\n      vec3 cameraUpVector =normalize(glstate_cameraUp);\n      vec3 sideVector = normalize(cross(glstate_cameraForward,cameraUpVector));\n      vec3 upVector = normalize(cross(sideVector,glstate_cameraForward));\n     corner*=computeBillbardSize(_startSize.xy,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n   if(u_startRotation3D){\n    vec3 rotation=vec3(_startRotation.xy,computeRotation(_startRotation.z,age,t));\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,rotation);\n   }\n   else{\n    float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #else\n   if(u_startRotation3D){\n    center += u_sizeScale.xzy*rotation_euler(corner.x*sideVector+corner.y*upVector,_startRotation);\n   }\n   else{\n    float c = cos(_startRotation.x);\n    float s = sin(_startRotation.x);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n    center += u_sizeScale.xzy*(corner.x*sideVector+corner.y*upVector);\n   }\n  #endif\n #endif\n #ifdef STRETCHEDBILLBOARD\n  vec2 corner=_glesCorner.xy;\n  vec3 velocity;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n      if(u_spaceType==0)\n       velocity=rotation_quaternions(u_sizeScale*(_startVelocity+lifeVelocity),worldRotation)+gravity;\n      else\n       velocity=rotation_quaternions(u_sizeScale*_startVelocity,worldRotation)+lifeVelocity+gravity;\n   #else\n      velocity= rotation_quaternions(u_sizeScale*_startVelocity,worldRotation)+gravity;\n   #endif \n  vec3 cameraUpVector = normalize(velocity);\n  vec3 direction = normalize(center-glstate_cameraPos);\n    vec3 sideVector = normalize(cross(direction,normalize(velocity)));\n  sideVector=u_sizeScale.xzy*sideVector;\n  cameraUpVector=length(vec3(u_sizeScale.x,0.0,0.0))*cameraUpVector;\n    vec2 size=computeBillbardSize(_startSize.xy,t);\n    const mat2 rotaionZHalfPI=mat2(0.0, -1.0, 1.0, 0.0);\n    corner=rotaionZHalfPI*corner;\n    corner.y=corner.y-abs(corner.y);\n    float speed=length(velocity);\n    center +=sign(u_sizeScale.x)*(sign(u_lengthScale)*size.x*corner.x*sideVector+(speed*u_speeaScale+size.y*u_lengthScale)*corner.y*cameraUpVector);\n #endif\n #ifdef HORIZONTALBILLBOARD\n  vec2 corner=_glesCorner.xy;\n    const vec3 cameraUpVector=vec3(0.0,0.0,1.0);\n    const vec3 sideVector = vec3(-1.0,0.0,0.0);\n  float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(_startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef VERTICALBILLBOARD\n  vec2 corner=_glesCorner.xy;\n    const vec3 cameraUpVector =vec3(0.0,1.0,0.0);\n    vec3 sideVector = normalize(cross(glstate_cameraForward,cameraUpVector));\n  float rot = computeRotation(_startRotation.x, age,t);\n    float c = cos(rot);\n    float s = sin(rot);\n    mat2 rotation= mat2(c, -s, s, c);\n    corner=rotation*corner;\n  corner*=computeBillbardSize(_startSize.xy,t);\n    center +=u_sizeScale.xzy*(corner.x*sideVector+ corner.y*cameraUpVector);\n #endif\n #ifdef RENDERMESH\n    vec3 size=computeMeshSize(_startSize,t);\n  #if defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE)\n    if(u_startRotation3D){\n     vec3 rotation=vec3(_startRotation.xy,-computeRotation(_startRotation.z, age,t));\n     center+= rotation_quaternions(u_sizeScale*rotation_euler(_glesVertex*size,rotation),worldRotation);\n    }\n    else{\n     #ifdef ROTATIONOVERLIFETIME\n      float angle=computeRotation(_startRotation.x, age,t);\n      if(_startPosition.x>0.1 || _startPosition.x < -0.1||_startPosition.y>0.1 || _startPosition.y < -0.1){\n       center+= (rotation_quaternions(rotation_axis(u_sizeScale*_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),angle),worldRotation));//已验证\n      }\n      else{\n       #ifdef SHAPE\n        center+= u_sizeScale.xzy*(rotation_quaternions(rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),angle),worldRotation));\n       #else\n        if(u_simulationSpace==1)\n         center+=rotation_axis(u_sizeScale*_glesVertex*size,vec3(0.0,0.0,-1.0),angle);\n        else if(u_simulationSpace==0)\n         center+=rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,0.0,-1.0),angle),worldRotation);\n       #endif\n      }\n     #endif\n     #ifdef ROTATIONSEPERATE\n      vec3 angle=compute3DRotation(vec3(0.0,0.0,_startRotation.z), age,t);\n      center+= (rotation_quaternions(rotation_euler(u_sizeScale*_glesVertex*size,vec3(angle.x,angle.y,angle.z)),worldRotation));\n     #endif \n    }\n  #else\n  if(u_startRotation3D){\n   center+= rotation_quaternions(u_sizeScale*rotation_euler(_glesVertex*size,_startRotation),worldRotation);\n  }\n  else{\n   if(_startPosition.x>0.1 || _startPosition.x < -0.1||_startPosition.y>0.1 || _startPosition.y < -0.1){\n    if(u_simulationSpace==1)\n     center+= rotation_axis(u_sizeScale*_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),_startRotation.x);\n    else if(u_simulationSpace==0)\n     center+= (rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,normalize(cross(vec3(0.0,0.0,1.0),vec3(_startPosition.xy,0.0))),_startRotation.x),worldRotation));\n   }\n   else{\n    #ifdef SHAPE\n     if(u_simulationSpace==1)\n      center+= u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),_startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,-1.0,0.0),_startRotation.x),worldRotation); \n    #else\n     if(u_simulationSpace==1)\n      center+= rotation_axis(u_sizeScale*_glesVertex*size,vec3(0.0,0.0,-1.0),_startRotation.x);\n     else if(u_simulationSpace==0)\n      center+= rotation_quaternions(u_sizeScale*rotation_axis(_glesVertex*size,vec3(0.0,0.0,-1.0),_startRotation.x),worldRotation);\n    #endif\n   }\n  }\n  #endif\n  v_mesh_color=_glesColor;\n  #endif";
        ShaderChunk.particle_common = "\n\nuniform float u_currentTime;\nuniform vec3 u_gravity;\n\nuniform vec3 u_worldPosition;\nuniform vec4 u_worldRotation;\nuniform bool u_startRotation3D;\nuniform int u_scalingMode;\nuniform vec3 u_positionScale;\nuniform vec3 u_sizeScale;\nuniform mat4 glstate_matrix_vp;\n\n#ifdef STRETCHEDBILLBOARD\n uniform vec3 glstate_cameraPos;\n#endif\nuniform vec3 glstate_cameraForward;\nuniform vec3 glstate_cameraUp;\n\nuniform float u_lengthScale;\nuniform float u_speeaScale;\nuniform int u_simulationSpace;\n\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n  uniform int u_spaceType;\n#endif\n#if defined(VELOCITYCONSTANT)||defined(VELOCITYTWOCONSTANT)\n  uniform vec3 u_velocityConst;\n#endif\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)\n  uniform vec2 u_velocityCurveX[4];\n  uniform vec2 u_velocityCurveY[4];\n  uniform vec2 u_velocityCurveZ[4];\n#endif\n#ifdef VELOCITYTWOCONSTANT\n  uniform vec3 u_velocityConstMax;\n#endif\n#ifdef VELOCITYTWOCURVE\n  uniform vec2 u_velocityCurveMaxX[4];\n  uniform vec2 u_velocityCurveMaxY[4];\n  uniform vec2 u_velocityCurveMaxZ[4];\n#endif\n\n#ifdef COLOROGRADIENT\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n#endif\n#ifdef COLORTWOGRADIENTS\n  uniform vec4 u_colorGradient[4];\n  uniform vec2 u_alphaGradient[4];\n  uniform vec4 u_colorGradientMax[4];\n  uniform vec2 u_alphaGradientMax[4];\n#endif\n\n#if defined(SIZECURVE)||defined(SIZETWOCURVES)\n  uniform vec2 u_sizeCurve[4];\n#endif\n#ifdef SIZETWOCURVES\n  uniform vec2 u_sizeCurveMax[4];\n#endif\n#if defined(SIZECURVESEPERATE)||defined(SIZETWOCURVESSEPERATE)\n  uniform vec2 u_sizeCurveX[4];\n  uniform vec2 u_sizeCurveY[4];\n  uniform vec2 u_sizeCurveZ[4];\n#endif\n#ifdef SIZETWOCURVESSEPERATE\n  uniform vec2 u_sizeCurveMaxX[4];\n  uniform vec2 u_sizeCurveMaxY[4];\n  uniform vec2 u_sizeCurveMaxZ[4];\n#endif\n\n#ifdef ROTATIONOVERLIFETIME\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform float u_rotationConst;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform float u_rotationConstMax;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurve[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMax[4];\n  #endif\n#endif\n#ifdef ROTATIONSEPERATE\n  #if defined(ROTATIONCONSTANT)||defined(ROTATIONTWOCONSTANTS)\n    uniform vec3 u_rotationConstSeprarate;\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n    uniform vec3 u_rotationConstMaxSeprarate;\n  #endif\n  #if defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\n    uniform vec2 u_rotationCurveX[4];\n    uniform vec2 u_rotationCurveY[4];\n    uniform vec2 u_rotationCurveZ[4];\n  uniform vec2 u_rotationCurveW[4];\n  #endif\n  #ifdef ROTATIONTWOCURVES\n    uniform vec2 u_rotationCurveMaxX[4];\n    uniform vec2 u_rotationCurveMaxY[4];\n    uniform vec2 u_rotationCurveMaxZ[4];\n  uniform vec2 u_rotationCurveMaxW[4];\n  #endif\n#endif\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\n  uniform float u_cycles;\n  uniform vec4 u_subUV;\n  uniform vec2 u_uvCurve[4];\n#endif\n#ifdef TEXTURESHEETANIMATIONTWOCURVE\n  uniform vec2 u_uvCurveMax[4];\n#endif\n\nvarying float v_discard;\nvarying vec4 v_color;\nvarying vec2 v_texcoord;\n#ifdef RENDERMESH\n varying vec4 v_mesh_color;\n#endif\n\nvec3 rotation_euler(in vec3 vector,in vec3 euler)\n{\n  float halfPitch = euler.x * 0.5;\n float halfYaw = euler.y * 0.5;\n float halfRoll = euler.z * 0.5;\n\n float sinPitch = sin(halfPitch);\n float cosPitch = cos(halfPitch);\n float sinYaw = sin(halfYaw);\n float cosYaw = cos(halfYaw);\n float sinRoll = sin(halfRoll);\n float cosRoll = cos(halfRoll);\n\n float quaX = (cosYaw * sinPitch * cosRoll) + (sinYaw * cosPitch * sinRoll);\n float quaY = (sinYaw * cosPitch * cosRoll) - (cosYaw * sinPitch * sinRoll);\n float quaZ = (cosYaw * cosPitch * sinRoll) - (sinYaw * sinPitch * cosRoll);\n float quaW = (cosYaw * cosPitch * cosRoll) + (sinYaw * sinPitch * sinRoll);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n \n}\n\nvec3 rotation_axis(in vec3 vector,in vec3 axis, in float angle)\n{\n float halfAngle = angle * 0.5;\n float sin = sin(halfAngle);\n \n float quaX = axis.x * sin;\n float quaY = axis.y * sin;\n float quaZ = axis.z * sin;\n float quaW = cos(halfAngle);\n \n float x = quaX + quaX;\n  float y = quaY + quaY;\n  float z = quaZ + quaZ;\n  float wx = quaW * x;\n  float wy = quaW * y;\n  float wz = quaW * z;\n float xx = quaX * x;\n  float xy = quaX * y;\n float xz = quaX * z;\n  float yy = quaY * y;\n  float yz = quaY * z;\n  float zz = quaZ * z;\n\n  return vec3(((vector.x * ((1.0 - yy) - zz)) + (vector.y * (xy - wz))) + (vector.z * (xz + wy)),\n              ((vector.x * (xy + wz)) + (vector.y * ((1.0 - xx) - zz))) + (vector.z * (yz - wx)),\n              ((vector.x * (xz - wy)) + (vector.y * (yz + wx))) + (vector.z * ((1.0 - xx) - yy)));\n}\n\nvec3 rotation_quaternions(in vec3 v,in vec4 q) \n{\n return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(SIZECURVE)||defined(SIZECURVESEPERATE)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)\nfloat evaluate_curve_float(in vec2 curves[4],in float t)\n{\n float res;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  if(curTime>=t)\n  {\n   vec2 lastCurve=curves[i-1];\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res=mix(lastCurve.y,curve.y,tt);\n   break;\n  }\n }\n return res;\n}\n#endif\n\n#if defined(VELOCITYCURVE)||defined(VELOCITYTWOCURVE)||defined(ROTATIONCURVE)||defined(ROTATIONTWOCURVES)\nfloat evaluate_curve_total(in vec2 curves[4],in float t)\n{\n float res=0.0;\n for(int i=1;i<4;i++)\n {\n  vec2 curve=curves[i];\n  float curTime=curve.x;\n  vec2 lastCurve=curves[i-1];\n  float lastValue=lastCurve.y;\n  \n  if(curTime>=t){\n   float lastTime=lastCurve.x;\n   float tt=(t-lastTime)/(curTime-lastTime);\n   res+=(lastValue+mix(lastValue,curve.y,tt))/2.0*_time.x*(t-lastTime);\n   break;\n  }\n  else{\n   res+=(lastValue+curve.y)/2.0*_time.x*(curTime-lastCurve.x);\n  }\n }\n return res;\n}\n#endif\n\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)\nvec4 evaluate_curve_color(in vec2 gradientAlphas[4],in vec4 gradientColors[4],in float t)\n{\n vec4 overTimeColor;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientAlpha=gradientAlphas[i];\n  float alphaKey=gradientAlpha.x;\n  if(alphaKey>=t)\n  {\n   vec2 lastGradientAlpha=gradientAlphas[i-1];\n   float lastAlphaKey=lastGradientAlpha.x;\n   float age=(t-lastAlphaKey)/(alphaKey-lastAlphaKey);\n   overTimeColor.a=mix(lastGradientAlpha.y,gradientAlpha.y,age);\n   break;\n  }\n }\n \n for(int i=1;i<4;i++)\n {\n  vec4 gradientColor=gradientColors[i];\n  float colorKey=gradientColor.x;\n  if(colorKey>=t)\n  {\n   vec4 lastGradientColor=gradientColors[i-1];\n   float lastColorKey=lastGradientColor.x;\n   float age=(t-lastColorKey)/(colorKey-lastColorKey);\n   overTimeColor.rgb=mix(gradientColors[i-1].yzw,gradientColor.yzw,age);\n   break;\n  }\n }\n return overTimeColor;\n}\n#endif\n\n\n#if defined(TEXTURESHEETANIMATIONCURVE)||defined(TEXTURESHEETANIMATIONTWOCURVE)\nfloat evaluate_curve_frame(in vec2 gradientFrames[4],in float t)\n{\n float overTimeFrame;\n for(int i=1;i<4;i++)\n {\n  vec2 gradientFrame=gradientFrames[i];\n  float key=gradientFrame.x;\n  if(key>=t)\n  {\n   vec2 lastGradientFrame=gradientFrames[i-1];\n   float lastKey=lastGradientFrame.x;\n   float age=(t-lastKey)/(key-lastKey);\n   overTimeFrame=mix(lastGradientFrame.y,gradientFrame.y,age);\n   break;\n  }\n }\n return floor(overTimeFrame);\n}\n#endif\n\nvec3 computeVelocity(in float t)\n{\n  vec3 res;\n  #ifdef VELOCITYCONSTANT\n  res=u_velocityConst; \n  #endif\n  #ifdef VELOCITYCURVE\n     res= vec3(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveZ,t));\n  #endif\n  #ifdef VELOCITYTWOCONSTANT\n  res=mix(u_velocityConst,u_velocityConstMax,vec3(_random1.y,_random1.z,_random1.w)); \n  #endif\n  #ifdef VELOCITYTWOCURVE\n     res=vec3(mix(evaluate_curve_float(u_velocityCurveX,t),evaluate_curve_float(u_velocityCurveMaxX,t),_random1.y),\n             mix(evaluate_curve_float(u_velocityCurveY,t),evaluate_curve_float(u_velocityCurveMaxY,t),_random1.z),\n        mix(evaluate_curve_float(u_velocityCurveZ,t),evaluate_curve_float(u_velocityCurveMaxZ,t),_random1.w));\n  #endif\n     \n  return res;\n} \n\nvec3 computePosition(in vec3 startVelocity, in vec3 lifeVelocity,in float age,in float t,vec3 gravityVelocity,vec4 worldRotation)\n{\n    vec3 startPosition;\n    vec3 lifePosition;\n  #if defined(VELOCITYCONSTANT)||defined(VELOCITYCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\n   #ifdef VELOCITYCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveZ,t));\n   #endif\n   #ifdef VELOCITYTWOCONSTANT\n      startPosition=startVelocity*age;\n      lifePosition=lifeVelocity*age;\n   #endif\n   #ifdef VELOCITYTWOCURVE\n      startPosition=startVelocity*age;\n      lifePosition=vec3(mix(evaluate_curve_total(u_velocityCurveX,t),evaluate_curve_total(u_velocityCurveMaxX,t),_random1.y)\n                 ,mix(evaluate_curve_total(u_velocityCurveY,t),evaluate_curve_total(u_velocityCurveMaxY,t),_random1.z)\n                 ,mix(evaluate_curve_total(u_velocityCurveZ,t),evaluate_curve_total(u_velocityCurveMaxZ,t),_random1.w));\n   #endif\n\n   vec3 finalPosition;\n   if(u_spaceType==0){\n     if(u_scalingMode!=2)\n      finalPosition =rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition+lifePosition),worldRotation);\n     else\n      finalPosition =rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition+lifePosition,worldRotation);\n   }\n   else{\n     if(u_scalingMode!=2)\n       finalPosition = rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition),worldRotation)+lifePosition;\n     else\n       finalPosition = rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition,worldRotation)+lifePosition;\n   }\n    #else\n    startPosition=startVelocity*age;\n    vec3 finalPosition;\n    if(u_scalingMode!=2)\n      finalPosition = rotation_quaternions(u_positionScale*(_startPosition.xyz+startPosition),worldRotation);\n    else\n      finalPosition = rotation_quaternions(u_positionScale*_startPosition.xyz+startPosition,worldRotation);\n  #endif\n  \n  if(u_simulationSpace==1)\n    finalPosition=finalPosition+_startWorldPosition;\n  else if(u_simulationSpace==0) \n    finalPosition=finalPosition+u_worldPosition;\n  \n  finalPosition+=0.5*gravityVelocity*age;\n \n  return finalPosition;\n}\n\n\nvec4 computeColor(in vec4 color,in float t)\n{\n #ifdef COLOROGRADIENT\n   color*=evaluate_curve_color(u_alphaGradient,u_colorGradient,t);\n #endif \n #ifdef COLORTWOGRADIENTS\n   color*=mix(evaluate_curve_color(u_alphaGradient,u_colorGradient,t),evaluate_curve_color(u_alphaGradientMax,u_colorGradientMax,t),_random0.y);\n #endif\n\n  return color;\n}\n\nvec2 computeBillbardSize(in vec2 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),_random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec2(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec2(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),_random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),_random0.z));\n #endif\n return size;\n}\n\n#ifdef RENDERMESH\nvec3 computeMeshSize(in vec3 size,in float t)\n{\n #ifdef SIZECURVE\n  size*=evaluate_curve_float(u_sizeCurve,t);\n #endif\n #ifdef SIZETWOCURVES\n   size*=mix(evaluate_curve_float(u_sizeCurve,t),evaluate_curve_float(u_sizeCurveMax,t),_random0.z); \n #endif\n #ifdef SIZECURVESEPERATE\n  size*=vec3(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveZ,t));\n #endif\n #ifdef SIZETWOCURVESSEPERATE\n   size*=vec3(mix(evaluate_curve_float(u_sizeCurveX,t),evaluate_curve_float(u_sizeCurveMaxX,t),_random0.z)\n         ,mix(evaluate_curve_float(u_sizeCurveY,t),evaluate_curve_float(u_sizeCurveMaxY,t),_random0.z)\n       ,mix(evaluate_curve_float(u_sizeCurveZ,t),evaluate_curve_float(u_sizeCurveMaxZ,t),_random0.z));\n #endif\n return size;\n}\n#endif\n\nfloat computeRotation(in float rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConst*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurve,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConst,u_rotationConstMax,_random0.w)*age;\n     rotation+=ageRot;\n   #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),_random0.w);\n  #endif\n #endif\n #ifdef ROTATIONSEPERATE\n  #ifdef ROTATIONCONSTANT\n   float ageRot=u_rotationConstSeprarate.z*age;\n         rotation+=ageRot;\n  #endif\n  #ifdef ROTATIONCURVE\n   rotation+=evaluate_curve_total(u_rotationCurveZ,t);\n  #endif\n  #ifdef ROTATIONTWOCONSTANTS\n   float ageRot=mix(u_rotationConstSeprarate.z,u_rotationConstMaxSeprarate.z,_random0.w)*age;\n         rotation+=ageRot;\n     #endif\n  #ifdef ROTATIONTWOCURVES\n   rotation+=mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),_random0.w));\n  #endif\n #endif\n return rotation;\n}\n\n#if defined(RENDERMESH)&&(defined(ROTATIONOVERLIFETIME)||defined(ROTATIONSEPERATE))\nvec3 compute3DRotation(in vec3 rotation,in float age,in float t)\n{ \n #ifdef ROTATIONOVERLIFETIME\n   #ifdef ROTATIONCONSTANT\n     float ageRot=u_rotationConst*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONCURVE\n     rotation+=evaluate_curve_total(u_rotationCurve,t);\n   #endif\n   #ifdef ROTATIONTWOCONSTANTS\n     float ageRot=mix(u_rotationConst,u_rotationConstMax,_random0.w)*age;\n       rotation+=ageRot;\n   #endif\n   #ifdef ROTATIONTWOCURVES\n     rotation+=mix(evaluate_curve_total(u_rotationCurve,t),evaluate_curve_total(u_rotationCurveMax,t),_random0.w);\n   #endif\n #endif\n #ifdef ROTATIONSEPERATE\n    #ifdef ROTATIONCONSTANT\n     vec3 ageRot=u_rotationConstSeprarate*age;\n           rotation+=ageRot;\n    #endif\n    #ifdef ROTATIONCURVE\n     rotation+=vec3(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveZ,t));\n    #endif\n    #ifdef ROTATIONTWOCONSTANTS\n     vec3 ageRot=mix(u_rotationConstSeprarate,u_rotationConstMaxSeprarate,_random0.w)*age;\n           rotation+=ageRot;\n     #endif\n    #ifdef ROTATIONTWOCURVES\n     rotation+=vec3(mix(evaluate_curve_total(u_rotationCurveX,t),evaluate_curve_total(u_rotationCurveMaxX,t),_random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveY,t),evaluate_curve_total(u_rotationCurveMaxY,t),_random0.w)\n           ,mix(evaluate_curve_total(u_rotationCurveZ,t),evaluate_curve_total(u_rotationCurveMaxZ,t),_random0.w));\n    #endif\n #endif\n return rotation;\n}\n#endif\n\nvec2 computeUV(in vec2 uv,in float t)\n{ \n #ifdef TEXTURESHEETANIMATIONCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n  float frame=evaluate_curve_frame(u_uvCurve,uvNormalizedAge);\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n #ifdef TEXTURESHEETANIMATIONTWOCURVE\n  float cycleNormalizedAge=t*u_cycles;\n  float uvNormalizedAge=cycleNormalizedAge-floor(cycleNormalizedAge);\n   float frame=floor(mix(evaluate_curve_frame(u_uvCurve,uvNormalizedAge),evaluate_curve_frame(u_uvCurveMax,uvNormalizedAge),_random1.x));\n  uv.x *= u_subUV.x + u_subUV.z;\n  uv.y *= u_subUV.y + u_subUV.w;\n  float totalULength=frame*u_subUV.x;\n  float floorTotalULength=floor(totalULength);\n   uv.x+=totalULength-floorTotalULength;\n  uv.y+=floorTotalULength*u_subUV.y;\n    #endif\n return uv;\n}";
        ShaderChunk.shadowMap_frag = "#ifdef USE_SHADOW\n    // outColor *= getShadowMask();\n#endif";
        ShaderChunk.shadowMap_pars_frag = "#ifdef USE_SHADOW\n\n    #include <packing>\n\n    #ifdef USE_DIRECT_LIGHT\n\n        uniform sampler2D glstate_directionalShadowMap[ USE_DIRECT_LIGHT ];\n        varying vec4 vDirectionalShadowCoord[ USE_DIRECT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        uniform samplerCube glstate_pointShadowMap[ USE_POINT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        uniform sampler2D glstate_spotShadowMap[ USE_SPOT_LIGHT ];\n        varying vec4 vSpotShadowCoord[ USE_SPOT_LIGHT ];\n\n    #endif\n\n    float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\n    }\n\n    float textureCubeCompare( samplerCube depths, vec3 uv, float compare ) {\n\n        return step( compare, unpackRGBAToDepth( textureCube( depths, uv ) ) );\n\n    }\n\n    float getShadow( sampler2D shadowMap, vec4 shadowCoord, float shadowBias, float shadowRadius, vec2 shadowMapSize ) {\n        shadowCoord.xyz /= shadowCoord.w;\n\n        float depth = shadowCoord.z + shadowBias;\n\n        bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n        bool inFrustum = all( inFrustumVec );\n\n        bvec2 frustumTestVec = bvec2( inFrustum, depth <= 1.0 );\n\n        bool frustumTest = all( frustumTestVec );\n\n        if ( frustumTest ) {\n            #ifdef USE_PCF_SOFT_SHADOW\n                // TODO x, y not equal\n                float texelSize = shadowRadius / shadowMapSize.x;\n\n                vec2 poissonDisk[4];\n                poissonDisk[0] = vec2(-0.94201624, -0.39906216);\n                poissonDisk[1] = vec2(0.94558609, -0.76890725);\n                poissonDisk[2] = vec2(-0.094184101, -0.92938870);\n                poissonDisk[3] = vec2(0.34495938, 0.29387760);\n\n                return texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[0] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[1] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[2] * texelSize, depth ) * 0.25 +\n                    texture2DCompare( shadowMap, shadowCoord.xy + poissonDisk[3] * texelSize, depth ) * 0.25;\n            #else\n                return texture2DCompare( shadowMap, shadowCoord.xy, depth );\n            #endif\n        }\n\n        return 1.0;\n\n    }\n\n    float getPointShadow( samplerCube shadowMap, vec3 V, float shadowBias, float shadowRadius, vec2 shadowMapSize, float shadowCameraNear, float shadowCameraFar ) {\n\n        // depth = normalized distance from light to fragment position\n  float depth = ( length( V ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\n  depth += shadowBias;\n\n        V.x = -V.x; // for left-hand?\n\n        #ifdef USE_PCF_SOFT_SHADOW\n            // TODO x, y equal force\n            float texelSize = shadowRadius / shadowMapSize.x;\n\n            vec3 poissonDisk[4];\n      poissonDisk[0] = vec3(-1.0, 1.0, -1.0);\n      poissonDisk[1] = vec3(1.0, -1.0, -1.0);\n      poissonDisk[2] = vec3(-1.0, -1.0, -1.0);\n      poissonDisk[3] = vec3(1.0, -1.0, 1.0);\n\n            return textureCubeCompare( shadowMap, normalize(V) + poissonDisk[0] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[1] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[2] * texelSize, depth ) * 0.25 +\n                textureCubeCompare( shadowMap, normalize(V) + poissonDisk[3] * texelSize, depth ) * 0.25;\n        #else\n            return textureCubeCompare( shadowMap, normalize(V), depth);\n        #endif\n    }\n\n#endif";
        ShaderChunk.shadowMap_pars_vert = "#ifdef USE_SHADOW\n\n    #ifdef USE_DIRECT_LIGHT\n\n        uniform mat4 glstate_directionalShadowMatrix[ USE_DIRECT_LIGHT ];\n        varying vec4 vDirectionalShadowCoord[ USE_DIRECT_LIGHT ];\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        // nothing\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        uniform mat4 glstate_spotShadowMatrix[ USE_SPOT_LIGHT ];\n        varying vec4 vSpotShadowCoord[ USE_SPOT_LIGHT ];\n\n    #endif\n\n#endif";
        ShaderChunk.shadowMap_vert = "#ifdef USE_SHADOW\n\n    vec4 worldPosition = glstate_matrix_model * tmpVertex;\n\n    #ifdef USE_DIRECT_LIGHT\n\n        for ( int i = 0; i < USE_DIRECT_LIGHT; i ++ ) {\n\n            vDirectionalShadowCoord[ i ] = glstate_directionalShadowMatrix[ i ] * worldPosition;\n\n        }\n\n    #endif\n\n    #ifdef USE_POINT_LIGHT\n\n        // nothing\n\n    #endif\n\n    #ifdef USE_SPOT_LIGHT\n\n        for ( int i = 0; i < USE_SPOT_LIGHT; i ++ ) {\n\n            vSpotShadowCoord[ i ] = glstate_spotShadowMatrix[ i ] * worldPosition;\n\n        }\n\n    #endif\n\n#endif";
        ShaderChunk.skinning_base_vert = "#ifdef SKINNING\n    mat4 boneMatX = buildMat4(int(_glesBlendIndex4.x));\n mat4 boneMatY = buildMat4(int(_glesBlendIndex4.y));\n mat4 boneMatZ = buildMat4(int(_glesBlendIndex4.z));\n mat4 boneMatW = buildMat4(int(_glesBlendIndex4.w));\n \n    mat4 mat = boneMatX*_glesBlendWeight4.x \n    + boneMatY*_glesBlendWeight4.y \n    + boneMatZ*_glesBlendWeight4.z \n    + boneMatW*_glesBlendWeight4.w;\n    \n    highp vec4 tmpVertex = vec4((mat* _glesVertex).xyz, 1.0);\n // highp vec4 tmpVertex = vec4(calcVertex(_glesVertex,_glesBlendIndex4,_glesBlendWeight4).xyz, 1.0);\n#else\n    // tmpVertex.xyz = _glesVertex.xyz;\n highp vec4 tmpVertex = vec4(_glesVertex.xyz, 1.0);\n#endif";
        ShaderChunk.skinning_normal_vert = "#ifdef SKINNING\n    tmpNormal = vec4((mat* vec4(_glesNormal, 0.0))).xyz;\n    // tmpNormal = _glesNormal; \n#else\n    tmpNormal = _glesNormal;    \n#endif";
        ShaderChunk.skinning_pars_vert = "#ifdef SKINNING\nattribute vec4 _glesBlendIndex4;\nattribute vec4 _glesBlendWeight4;\nuniform vec4 glstate_vec4_bones[110];\n\nmat4 buildMat4(int index)\n{\n vec4 quat = glstate_vec4_bones[index * 2 + 0];\n vec4 translation = glstate_vec4_bones[index * 2 + 1];\n float xy2 = 2.0 * quat.x * quat.y;\n float xz2 = 2.0 * quat.x * quat.z;\n float xw2 = 2.0 * quat.x * quat.w;\n float yz2 = 2.0 * quat.y * quat.z;\n float yw2 = 2.0 * quat.y * quat.w;\n float zw2 = 2.0 * quat.z * quat.w;\n float xx = quat.x * quat.x;\n float yy = quat.y * quat.y;\n float zz = quat.z * quat.z;\n float ww = quat.w * quat.w;\n mat4 matrix = mat4(\n xx - yy - zz + ww, xy2 + zw2, xz2 - yw2, 0,\n xy2 - zw2, -xx + yy - zz + ww, yz2 + xw2, 0,\n xz2 + yw2, yz2 - xw2, -xx - yy + zz + ww, 0,\n translation.x, translation.y, translation.z, 1);\n return matrix;\n}\n#endif";
        ShaderChunk.tbn = "mat3 tbn(vec3 N, vec3 p, vec2 uv) {\n    vec3 dp1 = dFdx(p.xyz);\n    vec3 dp2 = dFdy(p.xyz);\n    vec2 duv1 = dFdx(uv.st);\n    vec2 duv2 = dFdy(uv.st);\n    vec3 dp2perp = cross(dp2, N);\n    vec3 dp1perp = cross(N, dp1);\n    vec3 T = dp2perp * duv1.x + dp1perp * duv2.x;\n    vec3 B = dp2perp * duv1.y + dp1perp * duv2.y;\n    float invmax = 1.0 / sqrt(max(dot(T,T), dot(B,B)));\n    return mat3(T * invmax, B * invmax, N);\n}";
        ShaderChunk.transpose = "mat4 transpose(mat4 inMatrix) {\n    vec4 i0 = inMatrix[0];\n    vec4 i1 = inMatrix[1];\n    vec4 i2 = inMatrix[2];\n    vec4 i3 = inMatrix[3];\n    mat4 outMatrix = mat4(\n        vec4(i0.x, i1.x, i2.x, i3.x),\n        vec4(i0.y, i1.y, i2.y, i3.y),\n        vec4(i0.z, i1.z, i2.z, i3.z),\n        vec4(i0.w, i1.w, i2.w, i3.w)\n    );\n    return outMatrix;\n}";
        ShaderChunk.tsn = "mat3 tsn(vec3 N, vec3 V, vec2 uv) {\n\n    vec3 q0 = dFdx( V.xyz );\n    vec3 q1 = dFdy( V.xyz );\n    vec2 st0 = dFdx( uv.st );\n    vec2 st1 = dFdy( uv.st );\n\n    vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n    vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n    // vec3 N = normalize( N );\n\n    mat3 tsn = mat3( S, T, N );\n    return tsn;\n}";
    })(ShaderChunk = egret3d.ShaderChunk || (egret3d.ShaderChunk = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var DefaultTextures = (function () {
        function DefaultTextures() {
        }
        DefaultTextures.init = function () {
            var gl = egret3d.WebGLCapabilities.webgl;
            var t1 = new egret3d.Texture("buildin/white.image.json");
            t1.glTexture = egret3d.GlTexture2D.createColorTexture(gl, 255, 255, 255);
            this.WHITE = t1;
            var t2 = new egret3d.Texture("buildin/gray.image.json");
            t2.glTexture = egret3d.GlTexture2D.createColorTexture(gl, 128, 128, 128);
            this.GRAY = t2;
            var t3 = new egret3d.Texture("buildin/grid.image.json");
            t3.glTexture = egret3d.GlTexture2D.createGridTexture(gl);
            this.GRID = t3;
            paper.Asset.register(t1);
            paper.Asset.register(t2);
            paper.Asset.register(t3);
        };
        return DefaultTextures;
    }());
    egret3d.DefaultTextures = DefaultTextures;
    __reflect(DefaultTextures.prototype, "egret3d.DefaultTextures");
})(egret3d || (egret3d = {}));
var RES;
(function (RES) {
    var processor;
    (function (processor) {
        function getFileName(url, removeEX) {
            if (removeEX === void 0) { removeEX = false; }
            var filei = url.lastIndexOf("/");
            var file = url.substr(filei + 1);
            if (removeEX) {
                file = file.substring(0, file.indexOf("."));
            }
            return file;
        }
        ;
        function dirname(url) {
            return url.substring(0, url.lastIndexOf("/"));
        }
        function getUrl(resource) {
            return resource.root + resource.url;
        }
        function combinePath(base, relative) {
            var stack = base.split("/"), parts = relative.split("/");
            stack.pop(); // remove current file name (or empty string)
            // (omit if "base" is the current folder without trailing slash)
            for (var i = 0; i < parts.length; i++) {
                if (parts[i] == ".")
                    continue;
                if (parts[i] == "..")
                    stack.pop();
                else
                    stack.push(parts[i]);
            }
            return stack.join("/");
        }
        function formatUrlAndSort(assets, path) {
            return assets.map(function (item) {
                return item;
            });
        }
        function promisify(loader, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    return [2 /*return*/, new Promise(function (resolve, reject) {
                            var onSuccess = function () {
                                var texture = loader['data'] ? loader['data'] : loader['response'];
                                resolve(texture);
                            };
                            var onError = function () {
                                var e = new RES.ResourceManagerError(1001, resource.url);
                                reject(e);
                            };
                            loader.addEventListener(egret.Event.COMPLETE, onSuccess, _this);
                            loader.addEventListener(egret.IOErrorEvent.IO_ERROR, onError, _this);
                        })];
                });
            });
        }
        // export const GLVertexShaderProcessor: RES.processor.Processor = {
        //     async onLoadStart(host, resource) {
        //         let text = await host.load(resource, "text");
        //         let url = getUrl(resource);
        //         let filename = getFileName(url);
        //         let name = filename.substring(0, filename.indexOf("."));
        //         return egret3d.Shader.registerVertShader(name, text);
        //     },
        //     async onRemoveStart(host, resource) {
        //     }
        //     // getData(host, resource, key, subkey) { //可选函数
        //     // }
        // };
        // export const GLFragmentShaderProcessor: RES.processor.Processor = {
        //     async onLoadStart(host, resource) {
        //         let text = await host.load(resource, "text");
        //         let url = getUrl(resource);
        //         let filename = getFileName(url);
        //         let name = filename.substring(0, filename.indexOf("."));
        //         return egret3d.Shader.registerFragShader(name, text);
        //     },
        //     async onRemoveStart(host, resource) {
        //     }
        // };
        // export const ShaderProcessor: RES.processor.Processor = {
        //     async onLoadStart(host, resource) {
        //         let data = await host.load(resource, "json");
        //         // const url = getUrl(resource);
        //         let shader = new egret3d.Shader(resource.url);
        //         shader.$parse(data);
        //         paper.Asset.register(shader);
        //         return shader;
        //     },
        //     async onRemoveStart(host, resource) {
        //         let data = host.get(resource);
        //         data.dispose();
        //     }
        // };
        processor.TextureDescProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, _name, _filterMode, _format, _mipmap, _wrap, _textureFormat, _linear, _repeat, url, filename, textureUrl, loader, image, texture, gl, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                _name = data["name"];
                                _filterMode = data["filterMode"];
                                _format = data["format"];
                                _mipmap = data["mipmap"];
                                _wrap = data["wrap"];
                                _textureFormat = 1 /* RGBA */;
                                if (_format == "RGB") {
                                    _textureFormat = 2 /* RGB */;
                                }
                                else if (_format == "Gray") {
                                    _textureFormat = 3 /* Gray */;
                                }
                                _linear = true;
                                if (_filterMode.indexOf("linear") < 0) {
                                    _linear = false;
                                }
                                _repeat = false;
                                if (_wrap.indexOf("Repeat") >= 0) {
                                    _repeat = true;
                                }
                                url = getUrl(resource);
                                filename = getFileName(resource.url);
                                textureUrl = url.replace(filename, _name);
                                loader = new egret.ImageLoader();
                                loader.load(textureUrl);
                                return [4 /*yield*/, promisify(loader, resource)];
                            case 2:
                                image = _a.sent();
                                texture = new egret3d.Texture(resource.url);
                                texture.realName = _name;
                                gl = egret3d.WebGLCapabilities.webgl;
                                t2d = new egret3d.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, _mipmap, _linear, true, _repeat);
                                texture.glTexture = t2d;
                                paper.Asset.register(texture);
                                return [2 /*return*/, texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.TextureProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var gl, loader, image, _texture, _textureFormat, t2d;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                gl = egret3d.WebGLCapabilities.webgl;
                                loader = new egret.ImageLoader();
                                loader.load(resource.url);
                                return [4 /*yield*/, promisify(loader, resource)];
                            case 1:
                                image = _a.sent();
                                _texture = new egret3d.Texture(resource.url);
                                _textureFormat = 1 /* RGBA */;
                                t2d = new egret3d.GlTexture2D(gl, _textureFormat);
                                t2d.uploadImage(image.source, true, true, true, true);
                                _texture.glTexture = t2d;
                                paper.Asset.register(_texture);
                                return [2 /*return*/, _texture];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.MaterialProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        // let json = await host.load(resource, "json") as egret3d.MaterialConfig
                        // let material = new egret3d.Material(resource.url);
                        // // const shader = paper.Asset.find<egret3d.Shader>(json.shader);
                        // const shader = paper.Asset.find<egret3d.GLTFAsset>(json.shader);
                        // material.setShader(shader);
                        // //现根据shaderName找出对应的Technique，然后再填充
                        // if (material._gltfTechnique) {
                        //     const gltfTechnique = material._gltfTechnique;
                        //     const mapUniform = json.mapUniform;
                        //     for (let i in mapUniform) {
                        //         const jsonChild = mapUniform[i];
                        //         switch (jsonChild.type) {
                        //             case egret3d.UniformTypeEnum.Texture:
                        //                 const value = jsonChild.value;
                        //                 const url = combinePath(dirname(resource.url) + "/", value)
                        //                 let texture = paper.Asset.find<egret3d.Texture>(url);
                        //                 if (!texture) {
                        //                     const r = RES.host.resourceConfig["getResource"](url);
                        //                     if (r) {
                        //                         texture = await RES.getResAsync(r.name)
                        //                     }
                        //                     else {
                        //                         texture = egret3d.DefaultTextures.GRID;
                        //                     }
                        //                 }
                        //                 if (gltfTechnique.uniforms[i] && gltfTechnique.uniforms[i].type === gltf.UniformType.SAMPLER_2D) {
                        //                     material.setTexture(i, texture);
                        //                 }
                        //                 else {
                        //                     console.warn(`不存在的 Uniform 参数：${material.name},${i}`);
                        //                 }
                        //                 break;
                        //             case egret3d.UniformTypeEnum.Float:
                        //                 if (gltfTechnique.uniforms[i] && gltfTechnique.uniforms[i].type === gltf.UniformType.FLOAT) {
                        //                     material.setFloat(i, jsonChild.value);
                        //                 }
                        //                 else {
                        //                     console.warn(`不存在的 Uniform 参数：${material.name},${i}`);
                        //                 }
                        //                 break;
                        //             case egret3d.UniformTypeEnum.Float4:
                        //                 if (gltfTechnique.uniforms[i] && gltfTechnique.uniforms[i].type === gltf.UniformType.FLOAT_VEC4) {
                        //                     material.setVector4v(i, jsonChild.value);
                        //                 }
                        //                 else {
                        //                     console.warn(`不存在的 Uniform 参数：${material.name},${i}`);
                        //                 }
                        //                 break;
                        //             default:
                        //                 console.warn(`不支持的 Uniform 参数：${material.name},${i}`);
                        //         }
                        //     }
                        // }
                        // paper.Asset.register(material);
                        // return material;
                        return [2 /*return*/, null];
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.GLTFProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var result, glTF, glTFBuffers, buffers, _i, glTFBuffers_1, buffer, url, r, buffer_1, _a, _b, mat, values, _c, _d, _e, key, value, url, texture, r, extensions, techniques, _f, techniques_1, technique, _g, _h, _j, key, uniform, value, url, texture, r;
                    return __generator(this, function (_k) {
                        switch (_k.label) {
                            case 0: return [4 /*yield*/, host.load(resource, resource.type === "GLTF" ? RES.processor.JsonProcessor : RES.processor.BinaryProcessor)];
                            case 1:
                                result = _k.sent();
                                glTF = new egret3d.GLTFAsset(resource.url);
                                if (!(resource.type === "GLTF")) return [3 /*break*/, 22];
                                glTFBuffers = result.buffers;
                                buffers = [];
                                if (!glTFBuffers) return [3 /*break*/, 5];
                                _i = 0, glTFBuffers_1 = glTFBuffers;
                                _k.label = 2;
                            case 2:
                                if (!(_i < glTFBuffers_1.length)) return [3 /*break*/, 5];
                                buffer = glTFBuffers_1[_i];
                                url = combinePath(dirname(resource.url) + "/", buffer.uri);
                                r = RES.host.resourceConfig["getResource"](url);
                                if (!r) return [3 /*break*/, 4];
                                return [4 /*yield*/, host.load(r, RES.processor.BinaryProcessor)];
                            case 3:
                                buffer_1 = _k.sent();
                                if (buffer_1) {
                                    buffers.push(new Uint32Array(buffer_1));
                                }
                                else {
                                    console.error("Load glTF resource error.", url);
                                }
                                _k.label = 4;
                            case 4:
                                _i++;
                                return [3 /*break*/, 2];
                            case 5:
                                glTF.parse(result, buffers);
                                if (!(glTF.config.materials && glTF.config.materials.length > 0)) return [3 /*break*/, 13];
                                _a = 0, _b = glTF.config.materials;
                                _k.label = 6;
                            case 6:
                                if (!(_a < _b.length)) return [3 /*break*/, 13];
                                mat = _b[_a];
                                values = mat.extensions.KHR_techniques_webgl.values;
                                _c = [];
                                for (_d in values)
                                    _c.push(_d);
                                _e = 0;
                                _k.label = 7;
                            case 7:
                                if (!(_e < _c.length)) return [3 /*break*/, 12];
                                key = _c[_e];
                                value = values[key];
                                if (!(typeof value === "string")) return [3 /*break*/, 11];
                                url = combinePath(dirname(resource.url) + "/", value);
                                texture = paper.Asset.find(url);
                                if (!!texture) return [3 /*break*/, 10];
                                r = RES.host.resourceConfig["getResource"](url);
                                if (!r) return [3 /*break*/, 9];
                                return [4 /*yield*/, RES.getResAsync(r.name)];
                            case 8:
                                texture = _k.sent();
                                return [3 /*break*/, 10];
                            case 9:
                                texture = egret3d.DefaultTextures.GRID;
                                _k.label = 10;
                            case 10:
                                values[key] = texture;
                                _k.label = 11;
                            case 11:
                                _e++;
                                return [3 /*break*/, 7];
                            case 12:
                                _a++;
                                return [3 /*break*/, 6];
                            case 13:
                                extensions = glTF.config.extensions;
                                if (!(extensions && extensions.KHR_techniques_webgl)) return [3 /*break*/, 21];
                                techniques = extensions.KHR_techniques_webgl.techniques;
                                _f = 0, techniques_1 = techniques;
                                _k.label = 14;
                            case 14:
                                if (!(_f < techniques_1.length)) return [3 /*break*/, 21];
                                technique = techniques_1[_f];
                                _g = [];
                                for (_h in technique.uniforms)
                                    _g.push(_h);
                                _j = 0;
                                _k.label = 15;
                            case 15:
                                if (!(_j < _g.length)) return [3 /*break*/, 20];
                                key = _g[_j];
                                uniform = technique.uniforms[key];
                                if (!(uniform.type === 35678 /* SAMPLER_2D */)) return [3 /*break*/, 19];
                                value = uniform.value.uri;
                                url = combinePath(dirname(resource.url) + "/", value);
                                texture = paper.Asset.find(url);
                                if (!!texture) return [3 /*break*/, 18];
                                r = RES.host.resourceConfig["getResource"](url);
                                if (!r) return [3 /*break*/, 17];
                                return [4 /*yield*/, RES.getResAsync(r.name)];
                            case 16:
                                texture = _k.sent();
                                return [3 /*break*/, 18];
                            case 17:
                                texture = egret3d.DefaultTextures.GRID;
                                _k.label = 18;
                            case 18:
                                uniform.value = texture;
                                _k.label = 19;
                            case 19:
                                _j++;
                                return [3 /*break*/, 15];
                            case 20:
                                _f++;
                                return [3 /*break*/, 14];
                            case 21: return [3 /*break*/, 23];
                            case 22:
                                glTF.parseFromBinary(new Uint32Array(result));
                                _k.label = 23;
                            case 23:
                                paper.Asset.register(glTF);
                                return [2 /*return*/, glTF];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.PrefabProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, prefab;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                prefab = new paper.Prefab(resource.url);
                                return [4 /*yield*/, loadSubAssets(data, resource)];
                            case 2:
                                _a.sent();
                                prefab.$parse(data);
                                paper.Asset.register(prefab);
                                return [2 /*return*/, prefab];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        processor.SceneProcessor = {
            onLoadStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data, rawScene;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, host.load(resource, "json")];
                            case 1:
                                data = _a.sent();
                                rawScene = new paper.RawScene(resource.url);
                                return [4 /*yield*/, loadSubAssets(data, resource)];
                            case 2:
                                _a.sent();
                                rawScene.$parse(data);
                                paper.Asset.register(rawScene);
                                return [2 /*return*/, rawScene];
                        }
                    });
                });
            },
            onRemoveStart: function (host, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var data;
                    return __generator(this, function (_a) {
                        data = host.get(resource);
                        data.dispose();
                        return [2 /*return*/];
                    });
                });
            }
        };
        function loadSubAssets(data, resource) {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: 
                        // const list = formatUrlAndSort(data.assets, dirname(resource.url));
                        return [4 /*yield*/, Promise.all(data.assets.map((function (item) { return __awaiter(_this, void 0, void 0, function () {
                                var r;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            r = RES.host.resourceConfig["getResource"](item);
                                            if (!r) return [3 /*break*/, 2];
                                            return [4 /*yield*/, RES.host.load(r)];
                                        case 1:
                                            _a.sent();
                                            _a.label = 2;
                                        case 2: return [2 /*return*/];
                                    }
                                });
                            }); })))];
                        case 1:
                            // const list = formatUrlAndSort(data.assets, dirname(resource.url));
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        }
        // RES.processor.map("GLVertexShader", GLVertexShaderProcessor);
        // RES.processor.map("GLFragmentShader", GLFragmentShaderProcessor);
        // RES.processor.map("Shader", ShaderProcessor);
        RES.processor.map("Texture", processor.TextureProcessor);
        RES.processor.map("TextureDesc", processor.TextureDescProcessor);
        // RES.processor.map("Material", MaterialProcessor);
        RES.processor.map("GLTF", processor.GLTFProcessor);
        RES.processor.map("GLTFBinary", processor.GLTFProcessor);
        RES.processor.map("Prefab", processor.PrefabProcessor);
        RES.processor.map("Scene", processor.SceneProcessor);
    })(processor = RES.processor || (RES.processor = {}));
})(RES || (RES = {}));
var egret3d;
(function (egret3d) {
    /**
     * @private
     */
    var BlendModeEnum;
    (function (BlendModeEnum) {
        BlendModeEnum[BlendModeEnum["Close"] = 0] = "Close";
        BlendModeEnum[BlendModeEnum["Blend"] = 1] = "Blend";
        BlendModeEnum[BlendModeEnum["Blend_PreMultiply"] = 2] = "Blend_PreMultiply";
        BlendModeEnum[BlendModeEnum["Add"] = 3] = "Add";
        BlendModeEnum[BlendModeEnum["Add_PreMultiply"] = 4] = "Add_PreMultiply";
    })(BlendModeEnum || (BlendModeEnum = {}));
    var DefaultShaders = (function () {
        function DefaultShaders() {
        }
        DefaultShaders.createBuildinShader = function (url, vertName, vertSource, fragName, fragSource, renderQueue) {
            var asset = egret3d.GLTFAsset.createGLTFExtensionsAsset(url);
            var KHRExtensions = asset.config.extensions.KHR_techniques_webgl;
            KHRExtensions.shaders = [];
            KHRExtensions.shaders.push({ type: 35633 /* VERTEX_SHADER */, name: vertName, uri: vertSource });
            KHRExtensions.shaders.push({ type: 35632 /* FRAGMENT_SHADER */, name: fragName, uri: fragSource });
            KHRExtensions.techniques = [];
            KHRExtensions.techniques.push({ attributes: {}, uniforms: {}, states: { enable: [], functions: {} } });
            asset.config.extensions.paper = { renderQueue: renderQueue };
            return asset;
        };
        DefaultShaders._setBlend = function (technique, blend) {
            var funs = technique.states.functions;
            var enables = technique.states.enable;
            switch (blend) {
                case BlendModeEnum.Add:
                    funs.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    funs.blendFuncSeparate = [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */];
                    break;
                case BlendModeEnum.Add_PreMultiply:
                    funs.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    funs.blendFuncSeparate = [1 /* ONE */, 1 /* ONE */, 1 /* ONE */, 1 /* ONE */];
                    break;
                case BlendModeEnum.Blend:
                    funs.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    funs.blendFuncSeparate = [770 /* SRC_ALPHA */, 771 /* ONE_MINUS_SRC_ALPHA */, 1 /* ONE */, 771 /* ONE_MINUS_SRC_ALPHA */];
                    break;
                case BlendModeEnum.Blend_PreMultiply:
                    funs.blendEquationSeparate = [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */];
                    funs.blendFuncSeparate = [1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */, 1 /* ONE */, 32772 /* ONE_MINUS_CONSTANT_ALPHA */];
                    break;
                default:
                    delete funs.blendEquationSeparate;
                    delete funs.blendFuncSeparate;
                    break;
            }
            var index = enables.indexOf(3042 /* BLEND */);
            if (blend === BlendModeEnum.Close) {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            else {
                if (index < 0) {
                    enables.push(3042 /* BLEND */);
                }
            }
        };
        DefaultShaders._setCullFace = function (technique, cull, frontFace, cullFace) {
            var funs = technique.states.functions;
            var enables = technique.states.enable;
            var index = enables.indexOf(2884 /* CULL_FACE */);
            if (cull && frontFace && cullFace) {
                funs.frontFace = [frontFace];
                funs.cullFace = [cullFace];
                if (index < 0) {
                    enables.push(2884 /* CULL_FACE */);
                }
            }
            else {
                delete funs.frontFace;
                delete funs.cullFace;
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
        };
        DefaultShaders._setDepth = function (technique, zTest, zWrite) {
            var funs = technique.states.functions;
            var enables = technique.states.enable;
            var index = enables.indexOf(2929 /* DEPTH_TEST */);
            if (zTest) {
                if (index < 0) {
                    enables.push(2929 /* DEPTH_TEST */);
                }
                funs.depthFunc = [515 /* LEQUAL */];
            }
            else {
                if (index >= 0) {
                    enables.splice(index, 1);
                }
            }
            if (zWrite) {
                funs.depthMask = [true];
            }
            else {
                funs.depthMask = [false];
            }
        };
        DefaultShaders._createColorShaderTemplate = function (url) {
            var shader = this.createBuildinShader(url, "color_vs", egret3d.ShaderLib.materialcolor_vert, "color_fs", egret3d.ShaderLib.line_frag, egret3d.RenderQueue.Geometry);
            var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
            technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
            technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
            technique.uniforms["_Color"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 1, 1] };
            return shader;
        };
        DefaultShaders._createDiffuseShaderTemplate = function (url) {
            var shader = this.createBuildinShader(url, "diffuse_vs", egret3d.ShaderLib.diffuse_vert, "diffuse_fs", egret3d.ShaderLib.diffuse_frag, egret3d.RenderQueue.Geometry);
            var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
            technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
            technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
            technique.attributes["_glesBlendIndex4"] = { semantic: "JOINTS_0" /* JOINTS_0 */ };
            technique.attributes["_glesBlendWeight4"] = { semantic: "WEIGHTS_0" /* WEIGHTS_0 */ };
            technique.uniforms["glstate_lightmapOffset"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_LIGHTMAPOFFSET" /* _LIGHTMAPOFFSET */, value: [] };
            technique.uniforms["glstate_lightmapUV"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPUV" /* _LIGHTMAPUV */, value: {} };
            technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
            technique.uniforms["glstate_vec4_bones[0]"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_BONESVEC4" /* _BONESVEC4 */, value: [] };
            technique.uniforms["_LightmapTex"] = { type: 35678 /* SAMPLER_2D */, semantic: "_LIGHTMAPTEX" /* _LIGHTMAPTEX */, value: {} };
            technique.uniforms["_LightmapIntensity"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */, value: 1.0 };
            technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
            technique.uniforms["_MainTex_ST"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 0, 0] };
            technique.uniforms["_AlphaCut"] = { type: 5126 /* FLOAT */, value: 0 };
            return shader;
        };
        DefaultShaders._createLambertShaderTemplate = function () {
            var shader = this.createBuildinShader("buildin/lambert.shader.gltf", "lambert_vs", egret3d.ShaderLib.lambert_vert, "lambert_fs", egret3d.ShaderLib.lambert_frag, egret3d.RenderQueue.Geometry);
            var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
            technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
            technique.attributes["_glesNormal"] = { semantic: "NORMAL" /* NORMAL */ };
            technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
            technique.attributes["_glesBlendIndex4"] = { semantic: "JOINTS_0" /* JOINTS_0 */ };
            technique.attributes["_glesBlendWeight4"] = { semantic: "WEIGHTS_0" /* WEIGHTS_0 */ };
            technique.uniforms["glstate_directionalShadowMatrix[0]"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */, value: [] };
            technique.uniforms["glstate_directionalShadowMap[0]"] = { type: 35678 /* SAMPLER_2D */, semantic: "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */, value: [] };
            technique.uniforms["glstate_directLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_DIRECTLIGHTS" /* _DIRECTLIGHTS */, value: [] };
            technique.uniforms["glstate_pointShadowMap[0]"] = { type: 35680 /* SAMPLER_CUBE */, semantic: "_POINTSHADOWMAP" /* _POINTSHADOWMAP */, value: [] };
            technique.uniforms["glstate_pointLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_POINTLIGHTS" /* _POINTLIGHTS */, value: [] };
            technique.uniforms["glstate_spotShadowMatrix[0]"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */, value: [] };
            technique.uniforms["glstate_spotShadowMap[0]"] = { type: 35678 /* SAMPLER_2D */, semantic: "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */, value: [] };
            technique.uniforms["glstate_spotLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_SPOTLIGHTS" /* _SPOTLIGHTS */, value: [] };
            technique.uniforms["glstate_vec4_bones[0]"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_BONESVEC4" /* _BONESVEC4 */, value: [] };
            technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
            technique.uniforms["glstate_matrix_model"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODEL" /* MODEL */, value: [] };
            technique.uniforms["_NormalTex"] = { type: 35678 /* SAMPLER_2D */, semantic: "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */, value: {} };
            technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
            technique.uniforms["_Color"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 1, 1] };
            return shader;
        };
        DefaultShaders._createParticleShaderTemplate = function (url) {
            var shader = this.createBuildinShader(url, "particle_vs", egret3d.ShaderLib.particlesystem_vert, "particle_fs", egret3d.ShaderLib.particlesystem_frag, egret3d.RenderQueue.Transparent);
            var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
            technique.attributes["_glesCorner"] = { semantic: "CORNER" /* _CORNER */ };
            technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
            technique.attributes["_glesColor"] = { semantic: "COLOR_0" /* COLOR_0 */ };
            technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
            technique.attributes["_startPosition"] = { semantic: "START_POSITION" /* _START_POSITION */ };
            technique.attributes["_startVelocity"] = { semantic: "START_VELOCITY" /* _START_VELOCITY */ };
            technique.attributes["_startColor"] = { semantic: "START_COLOR" /* _START_COLOR */ };
            technique.attributes["_startSize"] = { semantic: "START_SIZE" /* _START_SIZE */ };
            technique.attributes["_startRotation"] = { semantic: "START_ROTATION" /* _START_ROTATION */ };
            technique.attributes["_time"] = { semantic: "TIME" /* _TIME */ };
            technique.attributes["_random0"] = { semantic: "RANDOM0" /* _RANDOM0 */ };
            technique.attributes["_random1"] = { semantic: "RANDOM1" /* _RANDOM1 */ };
            technique.attributes["_startWorldPosition"] = { semantic: "WORLD_POSITION" /* _WORLD_POSITION */ };
            technique.attributes["_startWorldRotation"] = { semantic: "WORLD_ROTATION" /* _WORLD_ROTATION */ };
            technique.uniforms["glstate_matrix_vp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_VIEWPROJECTION" /* _VIEWPROJECTION */, value: [] };
            technique.uniforms["glstate_cameraPos"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "_CAMERA_POS" /* _CAMERA_POS */, value: [] };
            technique.uniforms["glstate_cameraForward"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "_CAMERA_FORWARD" /* _CAMERA_FORWARD */, value: [] };
            technique.uniforms["glstate_cameraUp"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "CAMERA_UP" /* _CAMERA_UP */, value: [] };
            technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
            technique.uniforms["_TintColor"] = { type: 35666 /* FLOAT_VEC4 */, value: [0.5, 0.5, 0.5, 0.5] };
            technique.uniforms["u_currentTime"] = { type: 5126 /* FLOAT */, value: 0 };
            technique.uniforms["u_gravity"] = { type: 35665 /* FLOAT_VEC3 */, value: [0, 0, 0] };
            technique.uniforms["u_worldPosition"] = { type: 35665 /* FLOAT_VEC3 */, value: [0, 0, 0] };
            technique.uniforms["u_worldRotation"] = { type: 35666 /* FLOAT_VEC4 */, value: [0, 0, 0, 1] };
            technique.uniforms["u_startRotation3D"] = { type: 35670 /* BOOL */, value: false };
            technique.uniforms["u_scalingMode"] = { type: 5124 /* Int */, value: 0 };
            technique.uniforms["u_positionScale"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
            technique.uniforms["u_sizeScale"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
            technique.uniforms["u_lengthScale"] = { type: 5126 /* FLOAT */, value: [1, 1, 1] };
            technique.uniforms["u_speeaScale"] = { type: 5126 /* FLOAT */, value: [1, 1, 1] };
            technique.uniforms["u_simulationSpace"] = { type: 5124 /* Int */, value: 0 };
            technique.uniforms["u_spaceType"] = { type: 5124 /* Int */, value: 0 };
            technique.uniforms["u_velocityConst"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
            technique.uniforms["u_velocityCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_velocityCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_velocityCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_velocityConstMax"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
            technique.uniforms["u_velocityCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_velocityCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_velocityCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_colorGradient[0]"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
            technique.uniforms["u_alphaGradient[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_colorGradientMax[0]"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
            technique.uniforms["u_alphaGradientMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_sizeCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationConst"] = { type: 5126 /* FLOAT */, value: 0 };
            technique.uniforms["u_rotationConstMax"] = { type: 5126 /* FLOAT */, value: 0 };
            technique.uniforms["u_rotationCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationConstSeprarate"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
            technique.uniforms["u_rotationConstMaxSeprarate"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
            technique.uniforms["u_rotationCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveW[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_rotationCurveMaxW[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_cycles"] = { type: 5126 /* FLOAT */, value: {} };
            technique.uniforms["u_subUV"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
            technique.uniforms["u_uvCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            technique.uniforms["u_uvCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
            return shader;
        };
        DefaultShaders.init = function () {
            if (this._inited) {
                return;
            }
            this._inited = true;
            {
                var shader = this.createBuildinShader("buildin/depth.shader.gltf", "depth_vs", egret3d.ShaderLib.depthpackage_vert, "depth_fs", egret3d.ShaderLib.depthpackage_frag, egret3d.RenderQueue.Geometry);
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                //
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.SHADOW_DEPTH = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this.createBuildinShader("buildin/distance.shader.gltf", "distance_vs", egret3d.ShaderLib.distancepackage_vert, "distance_fs", egret3d.ShaderLib.distancepackage_frag, egret3d.RenderQueue.Geometry);
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.uniforms["glstate_matrix_model"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODEL" /* MODEL */, value: [] };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["glstate_referencePosition"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_REFERENCEPOSITION" /* _REFERENCEPOSITION */, value: [] };
                technique.uniforms["glstate_nearDistance"] = { type: 5126 /* FLOAT */, semantic: "_NEARDICTANCE" /* _NEARDICTANCE */, value: {} };
                technique.uniforms["glstate_farDistance"] = { type: 5126 /* FLOAT */, semantic: "_FARDISTANCE" /* _FARDISTANCE */, value: {} };
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.SHADOW_DISTANCE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this.createBuildinShader("buildin/line.shader.gltf", "line_vs", egret3d.ShaderLib.line_vert, "line_fs", egret3d.ShaderLib.line_frag, egret3d.RenderQueue.Geometry);
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesColor"] = { semantic: "COLOR_0" /* COLOR_0 */ };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.LINE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/diffuse.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.DIFFUSE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/diffuse_tintcolor.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.DIFFUSE_TINT_COLOR = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/diffuse_bothside.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.DIFFUSE_BOTH_SIDE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, false);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Blend);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent_tintColor.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, false);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Add);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT_TINTCOLOR = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent_alphaCut.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT_ALPHACUT = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent_additive.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, false);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Add);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT_ADDITIVE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent_additive_bothside.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Add);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT_ADDITIVE_BOTH_SIDE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createDiffuseShaderTemplate("buildin/transparent_bothside.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Blend);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.TRANSPARENT_ADDITIVE_BOTH_SIDE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createLambertShaderTemplate();
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.LAMBERT = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createColorShaderTemplate("buildin/gizmos.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, false, false);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Blend);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Overlay;
                this.GIZMOS_COLOR = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createColorShaderTemplate("buildin/materialcolor.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                this._setDepth(technique, true, true);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.MATERIAL_COLOR = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this.createBuildinShader("buildin/vertcolor.shader.gltf", "vertcolor_vs", egret3d.ShaderLib.vertcolor_vert, "vertcolor_fs", egret3d.ShaderLib.vertcolor_frag, egret3d.RenderQueue.Geometry);
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesNormal"] = { semantic: "NORMAL" /* NORMAL */ };
                technique.attributes["_glesColor"] = { semantic: "COLOR_0" /* COLOR_0 */ };
                technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: {} };
                technique.uniforms["_MainTex_ST"] = { type: 35676 /* FLOAT_MAT4 */, value: {} };
                this._setDepth(technique, true, true);
                this._setCullFace(technique, true, 2305 /* CCW */, 1029 /* BACK */);
                this._setBlend(technique, BlendModeEnum.Close);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Geometry;
                this.VERT_COLOR = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particle.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, true);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Close);
                this.PARTICLE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particles_additive.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Add);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.PARTICLE_ADDITIVE = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particles_additive_premultiply.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Add_PreMultiply);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.PARTICLE_ADDITIVE_PREMYLTIPLY = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particles_blend1.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, true);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Blend);
                technique.states.functions.depthFunc = [514 /* EQUAL */]; //TODO
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particles_blend.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Blend);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.PARTICLE_BLEND = shader;
                paper.Asset.register(shader);
            }
            {
                var shader = this._createParticleShaderTemplate("buildin/particles_blend_premultiply.shader.gltf");
                var technique = shader.config.extensions.KHR_techniques_webgl.techniques[0];
                //
                this._setDepth(technique, true, false);
                this._setCullFace(technique, false);
                this._setBlend(technique, BlendModeEnum.Blend_PreMultiply);
                shader.config.extensions.paper.renderQueue = egret3d.RenderQueue.Transparent;
                this.PARTICLE_BLEND_PREMYLTIPLY = shader;
                paper.Asset.register(shader);
            }
        };
        DefaultShaders._inited = false;
        return DefaultShaders;
    }());
    egret3d.DefaultShaders = DefaultShaders;
    __reflect(DefaultShaders.prototype, "egret3d.DefaultShaders");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _plane = {
        vbo: new Float32Array([
            -5, 0, 5, -5, 0, -5, 5, 0, 5, 5, 0, -5,
            0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,
            1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            0, 0, 0, 1, 1, 0, 1, 1
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _cube = {
        vbo: new Float32Array([
            -0.5, -0.5, -0.5,
            -0.5, -0.5, 0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            0.5, 0.5, 0.5,
            0.5, 0.5, -0.5,
            -0.5, -0.5, 0.5,
            -0.5, 0.5, 0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            -0.5, -0.5, -0.5,
            0.5, 0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, -0.5,
            0.5, -0.5, 0.5,
            0.5, 0.5, -0.5,
            0.5, 0.5, 0.5,
            -0.5, -0.5, 0.5,
            -0.5, -0.5, -0.5,
            -0.5, 0.5, 0.5,
            -0.5, 0.5, -0.5,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 1, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            0, 0, -1,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            -1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, 1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            0, 0, -1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            1, 1,
            1, 0,
            0, 1,
            0, 0,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
            0, 1,
            1, 1,
            0, 0,
            1, 0,
            0, 1,
            1, 1,
            0, 0,
            1, 0,
        ]),
        ibo: new Uint16Array([
            0, 1, 2, 2, 1, 3,
            4, 5, 6, 6, 5, 7,
            8, 9, 10, 10, 9, 11,
            12, 13, 14, 14, 13, 15,
            16, 17, 18, 18, 17, 19,
            20, 21, 22, 22, 21, 23
        ])
    };
    var _circleLine = {
        vbo: new Float32Array([
            -0.5, 0.5, 0,
            -0.5, -0.5, 0,
            0.5, 0.5, 0,
            0.5, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _quadParticle = {
        vbo: new Float32Array([
            0, 0.5, 0,
            0, -0.5, 0,
            1, 0.5, 0,
            1, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _quad = {
        vbo: new Float32Array([
            -0.5, 0.5, 0,
            -0.5, -0.5, 0,
            0.5, 0.5, 0,
            0.5, -0.5, 0,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0, 1,
            1, 0,
            1, 1,
        ]),
        ibo: new Uint16Array([
            0, 1, 2,
            2, 1, 3
        ])
    };
    var _pyramid = {
        vbo: new Float32Array([
            -0.5, -1, -0.5,
            0, 1, 0,
            0.5, -1, -0.5,
            0.5, -1, -0.5,
            0, 1, 0,
            0.5, -1, 0.5,
            0.5, -1, 0.5,
            0, 1, 0,
            -0.5, -1, 0.5,
            -0.5, -1, 0.5,
            0, 1, 0,
            -0.5, -1, -0.5,
            -0.5, -1, -0.5,
            0.5, -1, -0.5,
            0.5, -1, 0.5,
            -0.5, -1, 0.5,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, 0, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, -1, 0,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            0, 0, 0, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            1, 1, 1, 1,
            0, 0,
            0.5, 0.5,
            0, 1,
            0, 1,
            0.5, 0.5,
            1, 1,
            1, 1,
            0.5, 0.5,
            1, 0,
            1, 0,
            0.5, 0.5,
            0, 0,
            0, 0,
            1, 0,
            1, 1,
            0, 1,
        ]),
        ibo: new Uint16Array([
            0, 2, 1, 3, 5, 4,
            6, 8, 7, 9, 11, 10,
            12, 14, 13, 15, 14, 12
        ])
    };
    var _box = {
        ibo: new Uint16Array([
            0, 1, 2, 2, 1, 3,
            4, 5, 6, 6, 5, 7,
            1, 3, 5, 5, 3, 7,
            0, 2, 4, 4, 2, 6,
            6, 2, 7, 7, 2, 3,
            0, 4, 1, 1, 4, 5,
        ])
    };
    var _attributesA = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TANGENT" /* TANGENT */,
        "COLOR_0" /* COLOR_0 */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    var _attributesB = [
        "POSITION" /* POSITION */,
        "NORMAL" /* NORMAL */,
        "TEXCOORD_0" /* TEXCOORD_0 */,
    ];
    var DefaultMeshes = (function () {
        function DefaultMeshes() {
        }
        DefaultMeshes.init = function () {
            if (this._inited) {
                return;
            }
            this._inited = true;
            this.QUAD = this._createDefaultMeshA(_quad, "builtin/DefaultQuad");
            this.QUAD_PARTICLE = this._createDefaultMeshA(_quadParticle, "builtin/DefaultQuadParticle");
            this.PLANE = this._createDefaultMeshA(_plane, "builtin/DefaultPlane");
            this.CIRCLE_LINE = this._createDefaultMeshA(_circleLine, "builtin/DefaultCircleLine");
            this.CUBE = this._createDefaultMeshA(_cube, "builtin/DefaultCube");
            this.PYRAMID = this._createDefaultMeshA(_pyramid, "builtin/DefaultPyramid");
            this.CYLINDER = this.createCylinderCCW(2, 0.5);
            this.SPHERE = this.createSphereCCW();
        };
        DefaultMeshes._createDefaultMeshA = function (data, assetName) {
            var mesh = new egret3d.Mesh(data.vbo, data.ibo, _attributesA);
            mesh.glTFAsset._isBuiltin = true;
            mesh.glTFAsset.name = assetName;
            paper.Asset.register(mesh.glTFAsset);
            return mesh;
        };
        // public static createBoxMesh(width: number, height: number, depth: number, widthSegments: uint = 1, heightSegments: uint = 1, depthSegments: uint = 1) {
        //     // const vertexCount = 8;
        //     // const mesh = new Mesh(vertexCount, _box.ibo, _attributesC);
        //     // const vertices = mesh.getVertices();
        //     // for (let i = 0; i < vertexCount; ++i) {
        //     //     const iD = i * 3;
        //     //     const vertex = array[i];
        //     //     vertices[iD] = vertex.x;
        //     //     vertices[iD + 1] = vertex.y;
        //     //     vertices[iD + 2] = vertex.z;
        //     // }
        //     // mesh.uploadSubVertexBuffer(_attributesC);
        //     return mesh;
        // }
        DefaultMeshes.createCylinderCCW = function (height, radius, segment) {
            if (segment === void 0) { segment = 20; }
            var index = 0;
            var mesh = new egret3d.Mesh(4 * segment + 2, 3 * 4 * segment, _attributesB);
            var normal = new egret3d.Vector3(0.0, 1.0, 0.0);
            var indices = mesh.getIndices();
            for (var s = 0; s < 4; s++) {
                var y = (s < 2 ? 0.5 : -0.5) * height;
                if (s === 3) {
                    normal.x = 0.0;
                    normal.y = -1.0;
                    normal.z = 0.0;
                }
                for (var i = 0; i < segment; i++) {
                    var r = i / segment * Math.PI * 2.0;
                    var x = Math.sin(r);
                    var z = Math.cos(r);
                    if (s === 1 || s === 2) {
                        normal.x = x;
                        normal.y = 0.0;
                        normal.z = z;
                    }
                    mesh.setAttribute(index, "POSITION" /* POSITION */, 0, x * radius, y, z * radius);
                    // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, normal.x, normal.y, normal.z);
                    if (s === 0 || s === 3) {
                        mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, x * 0.5 + 0.5, z * 0.5 + 0.5);
                    }
                    else {
                        mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, i / segment, y < 0.0 ? 0.0 : 1.0);
                    }
                    index++;
                }
            }
            // Top
            mesh.setAttribute(index, "POSITION" /* POSITION */, 0, 0.0, 0.5 * height, 0.0);
            // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, 0.0, 1.0, 0.0);
            mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 0.5, 0.5);
            index++;
            // Bottom
            mesh.setAttribute(index, "POSITION" /* POSITION */, 0, 0.0, -0.5 * height, 0.0);
            // mesh.setVertexAttribute(index, gltf.MeshAttributeType.NORMAL, 0, 0.0, -1.0, 0.0);
            mesh.setAttribute(index, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 0.5, 0.5);
            index++;
            //
            index = 0;
            var iTop = 4 * segment;
            var iBottom = 4 * segment + 1;
            for (var i = 0; i < segment; i++) {
                // Top
                indices[index++] = iTop;
                indices[index++] = i === segment - 1 ? segment * 0 + 0 : segment * 0 + i + 1;
                indices[index++] = segment * 0 + i + 0;
                // Bottom
                indices[index++] = iBottom;
                indices[index++] = segment * 3 + i + 0;
                indices[index++] = i === segment - 1 ? segment * 3 + 0 : segment * 3 + i + 1;
                // Side
                var t = segment * 1 + i;
                var t2 = i === segment - 1 ? segment * 1 + 0 : segment * 1 + i + 1;
                var b = segment * 2 + i;
                var b2 = i === segment - 1 ? segment * 2 + 0 : segment * 2 + i + 1;
                indices[index++] = t;
                indices[index++] = t2;
                indices[index++] = b;
                indices[index++] = t2;
                indices[index++] = b2;
                indices[index++] = b;
            }
            mesh.uploadSubVertexBuffer(_attributesB);
            mesh.uploadSubIndexBuffer();
            return mesh;
        };
        DefaultMeshes.createSphereCCW = function (radius, widthSegments, heightSegments) {
            if (radius === void 0) { radius = 1.0; }
            if (widthSegments === void 0) { widthSegments = 24; }
            if (heightSegments === void 0) { heightSegments = 12; }
            widthSegments = Math.max(3, Math.floor(widthSegments));
            heightSegments = Math.max(2, Math.floor(heightSegments));
            var mesh = new egret3d.Mesh((widthSegments + 1) * (heightSegments + 1), widthSegments * heightSegments * 6 - 6, _attributesB);
            //
            var index = 0;
            var iv = 0;
            var vertex = new egret3d.Vector3();
            var normal = new egret3d.Vector3();
            var grid = new Array();
            for (var iy = 0; iy <= heightSegments; iy++) {
                var verticesRow = new Array();
                var v = iy / heightSegments;
                for (var ix = 0; ix <= widthSegments; ix++) {
                    var u = ix / widthSegments;
                    // Vertex.
                    vertex.x = -radius * Math.cos(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    vertex.y = radius * Math.cos(v * Math.PI);
                    vertex.z = radius * Math.sin(u * Math.PI * 2) * Math.sin(v * Math.PI);
                    mesh.setAttribute(iv, "POSITION" /* POSITION */, 0, vertex.x, vertex.y, vertex.z);
                    // Normal.
                    normal.x = vertex.x;
                    normal.y = vertex.y;
                    normal.z = vertex.z;
                    var num = Math.sqrt(normal.x * normal.x + normal.y * normal.y + normal.z * normal.z);
                    if (num > Number.MIN_VALUE) {
                        mesh.setAttribute(iv, "NORMAL" /* NORMAL */, 0, normal.x / num, normal.y / num, normal.z / num);
                    }
                    else {
                        mesh.setAttribute(iv, "NORMAL" /* NORMAL */, 0, 0.0, 0.0, 0.0);
                    }
                    mesh.setAttribute(iv, "TEXCOORD_0" /* TEXCOORD_0 */, 0, 1.0 - u, v);
                    iv++;
                    verticesRow.push(index++);
                }
                grid.push(verticesRow);
            }
            // Indices.
            var tris = new Array();
            for (var iy = 0; iy < heightSegments; iy++) {
                for (var ix = 0; ix < widthSegments; ix++) {
                    var a = grid[iy][ix + 1];
                    var b = grid[iy][ix];
                    var c = grid[iy + 1][ix];
                    var d = grid[iy + 1][ix + 1];
                    if (iy !== 0) {
                        tris.push(a, d, b);
                    }
                    if (iy !== heightSegments - 1) {
                        tris.push(b, d, c);
                    }
                }
            }
            var indices = mesh.getIndices();
            for (var i = 0, l = tris.length; i < l; i++) {
                indices[i] = tris[i];
            }
            mesh.uploadSubVertexBuffer(_attributesB);
            mesh.uploadSubIndexBuffer();
            return mesh;
        };
        DefaultMeshes._inited = false;
        return DefaultMeshes;
    }());
    egret3d.DefaultMeshes = DefaultMeshes;
    __reflect(DefaultMeshes.prototype, "egret3d.DefaultMeshes");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @internal
     */
    var DefaultTechnique = (function () {
        function DefaultTechnique() {
        }
        DefaultTechnique.registerTechnique = function (technique) {
            //
            for (var key_1 in technique.attributes) {
                var att = technique.attributes[key_1];
                technique.attributes[key_1] = { semantic: att.semantic, extensions: { paper: { enable: true, location: -1 } } };
            }
            for (var key in technique.uniforms) {
                var uniform = technique.uniforms[key];
                technique.uniforms[key] = { type: uniform.type, semantic: uniform.semantic, value: uniform.value, extensions: { paper: { enable: false, location: -1 } } };
            }
            this.techniqueTemplates[technique.name] = technique;
        };
        DefaultTechnique.findTechniqueTemplate = function (name) {
            if (this.techniqueTemplates[name]) {
                return this.techniqueTemplates[name];
            }
            console.error("没有找到对应的Technique:" + name);
            return null;
        };
        DefaultTechnique.createTechniqueByTemplate = function (name) {
            var source = this.findTechniqueTemplate(name);
            var target = { name: source.name, attributes: {}, uniforms: {}, states: { enable: [], functions: {} } };
            for (var key in source.attributes) {
                var attribute = source.attributes[key];
                target.attributes[key] = { semantic: attribute.semantic, extensions: { paper: { enable: true, location: -1 } } };
            }
            for (var key in source.uniforms) {
                var uniform = source.uniforms[key];
                target.uniforms[key] = { type: uniform.type, semantic: uniform.semantic, value: uniform.value, extensions: { paper: { enable: false, location: -1 } } };
                if (Array.isArray(uniform.value)) {
                    target.uniforms[key].value = [];
                    target.uniforms[key].value.length = uniform.value.length;
                    for (var i = 0; i < uniform.value.length; i++) {
                        target.uniforms[key].value[i] = uniform.value[i];
                    }
                }
            }
            return target;
        };
        DefaultTechnique.init = function () {
            if (this._inited) {
                return;
            }
            this._inited = true;
            //
            {
                var technique = { name: egret3d.DefaultShaders.LAMBERT.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */, 2884 /* CULL_FACE */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesNormal"] = { semantic: "NORMAL" /* NORMAL */ };
                technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
                technique.attributes["_glesBlendIndex4"] = { semantic: "JOINTS_0" /* JOINTS_0 */ };
                technique.attributes["_glesBlendWeight4"] = { semantic: "WEIGHTS_0" /* WEIGHTS_0 */ };
                technique.uniforms["glstate_directionalShadowMatrix[0]"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */, value: [] };
                technique.uniforms["glstate_directionalShadowMap[0]"] = { type: 35678 /* SAMPLER_2D */, semantic: "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */, value: [] };
                technique.uniforms["glstate_directLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_DIRECTLIGHTS" /* _DIRECTLIGHTS */, value: [] };
                technique.uniforms["glstate_pointShadowMap[0]"] = { type: 35680 /* SAMPLER_CUBE */, semantic: "_POINTSHADOWMAP" /* _POINTSHADOWMAP */, value: [] };
                technique.uniforms["glstate_pointLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_POINTLIGHTS" /* _POINTLIGHTS */, value: [] };
                technique.uniforms["glstate_spotShadowMatrix[0]"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */, value: [] };
                technique.uniforms["glstate_spotShadowMap[0]"] = { type: 35678 /* SAMPLER_2D */, semantic: "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */, value: [] };
                technique.uniforms["glstate_spotLights[0]"] = { type: 5126 /* FLOAT */, semantic: "_SPOTLIGHTS" /* _SPOTLIGHTS */, value: [] };
                technique.uniforms["glstate_vec4_bones[0]"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_BONESVEC4" /* _BONESVEC4 */, value: [] };
                technique.uniforms["_NormalTex"] = { type: 35678 /* SAMPLER_2D */, semantic: "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */, value: {} };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["glstate_matrix_model"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODEL" /* MODEL */, value: [] };
                technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
                technique.uniforms["_Color"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 1, 1] };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.DIFFUSE.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */, 2884 /* CULL_FACE */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
                technique.attributes["_glesBlendIndex4"] = { semantic: "JOINTS_0" /* JOINTS_0 */ };
                technique.attributes["_glesBlendWeight4"] = { semantic: "WEIGHTS_0" /* WEIGHTS_0 */ };
                technique.uniforms["glstate_lightmapOffset"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_LIGHTMAPOFFSET" /* _LIGHTMAPOFFSET */, value: [] };
                technique.uniforms["glstate_lightmapUV"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPUV" /* _LIGHTMAPUV */, value: {} };
                technique.uniforms["_LightmapTex"] = { type: 35678 /* SAMPLER_2D */, semantic: "_LIGHTMAPTEX" /* _LIGHTMAPTEX */, value: {} };
                technique.uniforms["_LightmapIntensity"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */, value: 1.0 };
                technique.uniforms["glstate_vec4_bones[0]"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_BONESVEC4" /* _BONESVEC4 */, value: [] };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
                technique.uniforms["_MainTex_ST"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 0, 0] };
                technique.uniforms["_AlphaCut"] = { type: 5126 /* FLOAT */, value: 0 };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.DIFFUSE_TINT_COLOR.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */, 2884 /* CULL_FACE */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
                technique.attributes["_glesBlendIndex4"] = { semantic: "JOINTS_0" /* JOINTS_0 */ };
                technique.attributes["_glesBlendWeight4"] = { semantic: "WEIGHTS_0" /* WEIGHTS_0 */ };
                technique.uniforms["glstate_lightmapOffset"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_LIGHTMAPOFFSET" /* _LIGHTMAPOFFSET */, value: [] };
                technique.uniforms["glstate_lightmapUV"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPUV" /* _LIGHTMAPUV */, value: {} };
                technique.uniforms["_LightmapTex"] = { type: 35678 /* SAMPLER_2D */, semantic: "_LIGHTMAPTEX" /* _LIGHTMAPTEX */, value: {} };
                technique.uniforms["_LightmapIntensity"] = { type: 5126 /* FLOAT */, semantic: "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */, value: 1.0 };
                technique.uniforms["glstate_vec4_bones[0]"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_BONESVEC4" /* _BONESVEC4 */, value: [] };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
                technique.uniforms["_MainTex_ST"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 0, 0] };
                technique.uniforms["_AlphaCut"] = { type: 5126 /* FLOAT */, value: 0 };
                technique.uniforms["_TintColor"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.MATERIAL_COLOR.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */, 2884 /* CULL_FACE */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["_Color"] = { type: 35666 /* FLOAT_VEC4 */, value: [1, 1, 1, 1] };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.PARTICLE.name, attributes: {}, uniforms: {}, states: { enable: [3042 /* BLEND */, 2929 /* DEPTH_TEST */, 2884 /* CULL_FACE */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [false], frontFace: [2305 /* CCW */], blendEquationSeparate: [32774 /* FUNC_ADD */, 32774 /* FUNC_ADD */], blendFuncSeparate: [770 /* SRC_ALPHA */, 1 /* ONE */, 770 /* SRC_ALPHA */, 1 /* ONE */] } } };
                technique.attributes["_glesCorner"] = { semantic: "CORNER" /* _CORNER */ };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.attributes["_glesColor"] = { semantic: "COLOR_0" /* COLOR_0 */ };
                technique.attributes["_glesMultiTexCoord0"] = { semantic: "TEXCOORD_0" /* TEXCOORD_0 */ };
                technique.attributes["_startPosition"] = { semantic: "START_POSITION" /* _START_POSITION */ };
                technique.attributes["_startVelocity"] = { semantic: "START_VELOCITY" /* _START_VELOCITY */ };
                technique.attributes["_startColor"] = { semantic: "START_COLOR" /* _START_COLOR */ };
                technique.attributes["_startSize"] = { semantic: "START_SIZE" /* _START_SIZE */ };
                technique.attributes["_startRotation"] = { semantic: "START_ROTATION" /* _START_ROTATION */ };
                technique.attributes["_time"] = { semantic: "TIME" /* _TIME */ };
                technique.attributes["_random0"] = { semantic: "RANDOM0" /* _RANDOM0 */ };
                technique.attributes["_random1"] = { semantic: "RANDOM1" /* _RANDOM1 */ };
                technique.attributes["_startWorldPosition"] = { semantic: "START_POSITION" /* _START_POSITION */ };
                technique.attributes["_startWorldRotation"] = { semantic: "START_ROTATION" /* _START_ROTATION */ };
                technique.uniforms["_MainTex"] = { type: 35678 /* SAMPLER_2D */, value: egret3d.DefaultTextures.GRAY };
                technique.uniforms["_TintColor"] = { type: 35666 /* FLOAT_VEC4 */, value: [0.5, 0.5, 0.5, 0.5] };
                technique.uniforms["u_currentTime"] = { type: 5126 /* FLOAT */, value: 0 };
                technique.uniforms["u_gravity"] = { type: 35665 /* FLOAT_VEC3 */, value: [0, 0, 0] };
                technique.uniforms["u_worldPosition"] = { type: 35665 /* FLOAT_VEC3 */, value: [0, 0, 0] };
                technique.uniforms["u_worldRotation"] = { type: 35666 /* FLOAT_VEC4 */, value: [0, 0, 0, 1] };
                technique.uniforms["u_startRotation3D"] = { type: 35670 /* BOOL */, value: false };
                technique.uniforms["u_scalingMode"] = { type: 5124 /* Int */, value: 0 };
                technique.uniforms["u_positionScale"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
                technique.uniforms["u_sizeScale"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
                technique.uniforms["glstate_matrix_vp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "_VIEWPROJECTION" /* _VIEWPROJECTION */, value: [] };
                technique.uniforms["glstate_cameraPos"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "_CAMERA_POS" /* _CAMERA_POS */, value: [] };
                technique.uniforms["glstate_cameraForward"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "_CAMERA_FORWARD" /* _CAMERA_FORWARD */, value: [] };
                technique.uniforms["glstate_cameraUp"] = { type: 35665 /* FLOAT_VEC3 */, semantic: "CAMERA_UP" /* _CAMERA_UP */, value: [] };
                technique.uniforms["u_lengthScale"] = { type: 5126 /* FLOAT */, value: [1, 1, 1] };
                technique.uniforms["u_speeaScale"] = { type: 5126 /* FLOAT */, value: [1, 1, 1] };
                technique.uniforms["u_simulationSpace"] = { type: 5124 /* Int */, value: 0 };
                technique.uniforms["u_spaceType"] = { type: 5124 /* Int */, value: 0 };
                technique.uniforms["u_velocityConst"] = { type: 35665 /* FLOAT_VEC3 */, value: [1, 1, 1] };
                technique.uniforms["u_velocityCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_velocityCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_velocityCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_velocityConstMax"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
                technique.uniforms["u_velocityCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_velocityCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_velocityCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_colorGradient[0]"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
                technique.uniforms["u_alphaGradient[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_colorGradientMax[0]"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
                technique.uniforms["u_alphaGradientMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_sizeCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationConst"] = { type: 5126 /* FLOAT */, value: 0 };
                technique.uniforms["u_rotationConstMax"] = { type: 5126 /* FLOAT */, value: 0 };
                technique.uniforms["u_rotationCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationConstSeprarate"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
                technique.uniforms["u_rotationConstMaxSeprarate"] = { type: 35665 /* FLOAT_VEC3 */, value: [] };
                technique.uniforms["u_rotationCurveX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveW[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveMaxX[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveMaxY[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveMaxZ[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_rotationCurveMaxW[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_cycles"] = { type: 5126 /* FLOAT */, value: {} };
                technique.uniforms["u_subUV"] = { type: 35666 /* FLOAT_VEC4 */, value: [] };
                technique.uniforms["u_uvCurve[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                technique.uniforms["u_uvCurveMax[0]"] = { type: 35664 /* FLOAT_VEC2 */, value: [] };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.SHADOW_DEPTH.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                this.registerTechnique(technique);
            }
            {
                var technique = { name: egret3d.DefaultShaders.SHADOW_DISTANCE.name, attributes: {}, uniforms: {}, states: { enable: [2929 /* DEPTH_TEST */], functions: { depthFunc: [515 /* LEQUAL */], depthMask: [true], frontFace: [2305 /* CCW */] } } };
                technique.attributes["_glesVertex"] = { semantic: "POSITION" /* POSITION */ };
                technique.uniforms["glstate_matrix_model"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODEL" /* MODEL */, value: [] };
                technique.uniforms["glstate_matrix_mvp"] = { type: 35676 /* FLOAT_MAT4 */, semantic: "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */, value: [] };
                technique.uniforms["glstate_referencePosition"] = { type: 35666 /* FLOAT_VEC4 */, semantic: "_REFERENCEPOSITION" /* _REFERENCEPOSITION */, value: [] };
                technique.uniforms["glstate_nearDistance"] = { type: 5126 /* FLOAT */, semantic: "_NEARDICTANCE" /* _NEARDICTANCE */, value: {} };
                technique.uniforms["glstate_farDistance"] = { type: 5126 /* FLOAT */, semantic: "_FARDISTANCE" /* _FARDISTANCE */, value: {} };
                this.registerTechnique(technique);
            }
        };
        DefaultTechnique._inited = false;
        DefaultTechnique.techniqueTemplates = {};
        return DefaultTechnique;
    }());
    egret3d.DefaultTechnique = DefaultTechnique;
    __reflect(DefaultTechnique.prototype, "egret3d.DefaultTechnique");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     *
     * 正则表达式的工具类，提供一些引擎用到的正则表达式
     */
    var RegexpUtil = (function () {
        function RegexpUtil() {
        }
        // shader properties
        RegexpUtil.textureRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*'(.+)'[ ]*\{[ ]*([a-zA-Z]*)[ ]*([a-zA-Z]*)[ ]*\}/;
        RegexpUtil.vectorRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        RegexpUtil.floatRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        RegexpUtil.rangeRegexp = /([_0-9a-zA-Z]+)[ ]*\([ ]*'(.+)'[ ]*,[ ]*([0-9a-zA-Z]+)[ ]*\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)[ ]*\)[ ]*=[ ]*([0-9.-]+)/;
        // material
        RegexpUtil.vector4Regexp = /\([ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*,[ ]*([0-9.-]+)[ ]*\)/;
        // 特效解析，[1,2],2,1
        RegexpUtil.vector3FloatOrRangeRegexp = /([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\]),([0-9.-]+|\[[0-9.-]+,[0-9.-]+\])/;
        return RegexpUtil;
    }());
    egret3d.RegexpUtil = RegexpUtil;
    __reflect(RegexpUtil.prototype, "egret3d.RegexpUtil");
})(egret3d || (egret3d = {}));
// 0.04 处理utf8 string 不能用encode decode
var egret3d;
(function (egret3d) {
    var io;
    (function (io) {
        var BinReader = (function () {
            function BinReader(buf, seek) {
                if (seek === void 0) { seek = 0; }
                this._seek = seek;
                this._data = new DataView(buf, seek);
            }
            BinReader.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinReader.prototype.peek = function () {
                return this._seek;
            };
            BinReader.prototype.length = function () {
                return this._data.byteLength;
            };
            BinReader.prototype.canread = function () {
                return this._data.byteLength - this._seek;
            };
            BinReader.prototype.readStringAnsi = function () {
                var slen = this._data.getUint8(this._seek);
                this._seek++;
                var bs = "";
                for (var i = 0; i < slen; i++) {
                    bs += String.fromCharCode(this._data.getUint8(this._seek));
                    this._seek++;
                }
                return bs;
            };
            BinReader.utf8ArrayToString = function (array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    var cc = array[i];
                    if (cc == 0)
                        break;
                    var ct = 0;
                    if (cc > 0xE0) {
                        ct = (cc & 0x0F) << 12;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        cc = array[++i];
                        ct |= cc & 0x3F;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0xC0) {
                        ct = (cc & 0x1F) << 6;
                        cc = array[++i];
                        ct |= (cc & 0x3F) << 6;
                        ret.push(String.fromCharCode(ct));
                    }
                    else if (cc > 0x80) {
                        throw new Error("InvalidCharacterError");
                    }
                    else {
                        ret.push(String.fromCharCode(array[i]));
                    }
                }
                return ret.join('');
            };
            BinReader.prototype.readStringUtf8 = function () {
                var length = this._data.getInt8(this._seek);
                this._seek++;
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readStringUtf8FixLength = function (length) {
                var arr = new Uint8Array(length);
                this.readUint8Array(arr);
                return BinReader.utf8ArrayToString(arr);
            };
            BinReader.prototype.readSingle = function () {
                var num = this._data.getFloat32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readDouble = function () {
                var num = this._data.getFloat64(this._seek, true);
                this._seek += 8;
                return num;
            };
            BinReader.prototype.readInt8 = function () {
                var num = this._data.getInt8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readUInt8 = function () {
                var num = this._data.getUint8(this._seek);
                this._seek += 1;
                return num;
            };
            BinReader.prototype.readInt16 = function () {
                var num = this._data.getInt16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readUInt16 = function () {
                var num = this._data.getUint16(this._seek, true);
                this._seek += 2;
                return num;
            };
            BinReader.prototype.readInt32 = function () {
                var num = this._data.getInt32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUInt32 = function () {
                var num = this._data.getUint32(this._seek, true);
                this._seek += 4;
                return num;
            };
            BinReader.prototype.readUint8Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(this._seek);
                    this._seek++;
                }
                return target;
            };
            BinReader.prototype.readUint8ArrayByOffset = function (target, offset, length) {
                if (length === void 0) { length = 0; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this._data.getUint8(offset);
                    offset++;
                }
                return target;
            };
            BinReader.prototype.readUint16Array = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                for (var i = 0; i < length; i++) {
                    target[i] = this.readUInt16();
                }
                return target;
            };
            BinReader.prototype.readSingleArray = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = target.length;
                // console.log(this._data.byteLength, this._data.byteOffset);
                for (var i = 0; i < length; i++) {
                    // target[i] = this._data.getFloat32(this._seek, true);
                    // this._seek += 4;
                    target[i] = this.readSingle();
                }
                return target;
            };
            Object.defineProperty(BinReader.prototype, "position", {
                get: function () {
                    return this.peek();
                },
                set: function (value) {
                    this.seek(value);
                },
                enumerable: true,
                configurable: true
            });
            BinReader.prototype.readBoolean = function () {
                return this.readUInt8() > 0;
            };
            BinReader.prototype.readByte = function () {
                return this.readUInt8();
            };
            BinReader.prototype.readBytes = function (target, offset, length) {
                if (target === void 0) { target = null; }
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                return this.readUint8Array(target, offset, length);
            };
            BinReader.prototype.readUnsignedShort = function () {
                return this.readUInt16();
            };
            BinReader.prototype.readUnsignedInt = function () {
                return this.readUInt32();
            };
            BinReader.prototype.readFloat = function () {
                return this.readSingle();
            };
            BinReader.prototype.readUTFBytes = function (length) {
                var arry = new Uint8Array(length);
                return BinReader.utf8ArrayToString(this.readUint8Array(arry));
            };
            BinReader.prototype.readSymbolByte = function () {
                return this.readInt8();
            };
            BinReader.prototype.readShort = function () {
                return this.readInt16();
            };
            BinReader.prototype.readInt = function () {
                return this.readInt32();
            };
            return BinReader;
        }());
        io.BinReader = BinReader;
        __reflect(BinReader.prototype, "egret3d.io.BinReader");
        var BinWriter = (function () {
            function BinWriter() {
                var buf = new ArrayBuffer(1024);
                this._length = 0;
                this._buf = new Uint8Array(buf);
                this._data = new DataView(this._buf.buffer);
                this._seek = 0;
            }
            BinWriter.prototype.sureData = function (addlen) {
                var nextlen = this._buf.byteLength;
                while (nextlen < (this._length + addlen)) {
                    nextlen += 1024;
                }
                if (nextlen != this._buf.byteLength) {
                    var newbuf = new Uint8Array(nextlen);
                    for (var i = 0; i < this._length; i++) {
                        newbuf[i] = this._buf[i];
                    }
                    this._buf = newbuf;
                    this._data = new DataView(this._buf.buffer);
                }
                this._length += addlen;
            };
            BinWriter.prototype.getLength = function () {
                return length;
            };
            BinWriter.prototype.getBuffer = function () {
                return this._buf.buffer.slice(0, this._length);
            };
            BinWriter.prototype.seek = function (seek) {
                this._seek = seek;
            };
            BinWriter.prototype.peek = function () {
                return this._seek;
            };
            BinWriter.prototype.writeInt8 = function (num) {
                this.sureData(1);
                this._data.setInt8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeUInt8 = function (num) {
                this.sureData(1);
                this._data.setUint8(this._seek, num);
                this._seek++;
            };
            BinWriter.prototype.writeInt16 = function (num) {
                this.sureData(2);
                this._data.setInt16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeUInt16 = function (num) {
                this.sureData(2);
                this._data.setUint16(this._seek, num, true);
                this._seek += 2;
            };
            BinWriter.prototype.writeInt32 = function (num) {
                this.sureData(4);
                this._data.setInt32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeUInt32 = function (num) {
                this.sureData(4);
                this._data.setUint32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeSingle = function (num) {
                this.sureData(4);
                this._data.setFloat32(this._seek, num, true);
                this._seek += 4;
            };
            BinWriter.prototype.writeDouble = function (num) {
                this.sureData(8);
                this._data.setFloat64(this._seek, num, true);
                this._seek += 8;
            };
            BinWriter.prototype.writeStringAnsi = function (str) {
                var slen = str.length;
                this.sureData(slen + 1);
                this._data.setUint8(this._seek, slen);
                this._seek++;
                for (var i = 0; i < slen; i++) {
                    this._data.setUint8(this._seek, str.charCodeAt(i));
                    this._seek++;
                }
            };
            BinWriter.prototype.writeStringUtf8 = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUInt8(bstr.length);
                this.writeUint8Array(bstr);
            };
            BinWriter.stringToUtf8Array = function (str) {
                var bstr = [];
                for (var i = 0; i < str.length; i++) {
                    var c = str.charAt(i);
                    var cc = c.charCodeAt(0);
                    if (cc > 0xFFFF) {
                        throw new Error("InvalidCharacterError");
                    }
                    if (cc > 0x80) {
                        if (cc < 0x07FF) {
                            var c1 = (cc >>> 6) | 0xC0;
                            var c2 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2);
                        }
                        else {
                            var c1 = (cc >>> 12) | 0xE0;
                            var c2 = ((cc >>> 6) & 0x3F) | 0x80;
                            var c3 = (cc & 0x3F) | 0x80;
                            bstr.push(c1, c2, c3);
                        }
                    }
                    else {
                        bstr.push(cc);
                    }
                }
                return bstr;
            };
            BinWriter.prototype.writeStringUtf8DataOnly = function (str) {
                var bstr = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(bstr);
            };
            BinWriter.prototype.writeUint8Array = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = -1; }
                if (length < 0)
                    length = array.length;
                this.sureData(length);
                for (var i = offset; i < offset + length; i++) {
                    this._data.setUint8(this._seek, array[i]);
                    this._seek++;
                }
            };
            Object.defineProperty(BinWriter.prototype, "length", {
                get: function () {
                    return this._seek;
                },
                enumerable: true,
                configurable: true
            });
            BinWriter.prototype.writeByte = function (num) {
                this.writeUInt8(num);
            };
            BinWriter.prototype.writeBytes = function (array, offset, length) {
                if (offset === void 0) { offset = 0; }
                if (length === void 0) { length = 0; }
                this.writeUint8Array(array, offset, length);
            };
            BinWriter.prototype.writeUnsignedShort = function (num) {
                this.writeUInt16(num);
            };
            BinWriter.prototype.writeUnsignedInt = function (num) {
                this.writeUInt32(num);
            };
            BinWriter.prototype.writeFloat = function (num) {
                this.writeSingle(num);
            };
            BinWriter.prototype.writeUTFBytes = function (str) {
                var strArray = BinWriter.stringToUtf8Array(str);
                this.writeUint8Array(strArray);
            };
            BinWriter.prototype.writeSymbolByte = function (num) {
                this.writeInt8(num);
            };
            BinWriter.prototype.writeShort = function (num) {
                this.writeInt16(num);
            };
            BinWriter.prototype.writeInt = function (num) {
                this.writeInt32(num);
            };
            return BinWriter;
        }());
        io.BinWriter = BinWriter;
        __reflect(BinWriter.prototype, "egret3d.io.BinWriter");
    })(io = egret3d.io || (egret3d.io = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var utils;
    (function (utils) {
        function getRelativePath(targetPath, sourcePath) {
            var relPath = "";
            targetPath = targetPath.replace("\\", "/");
            sourcePath = sourcePath.replace("\\", "/");
            var targetPathArr = targetPath.split('/');
            var sourcePathArr = sourcePath.split('/');
            var targetPathLen = targetPathArr.length;
            var sourcePathLen = sourcePathArr.length;
            var i = 0;
            while (targetPathArr[i] == sourcePathArr[i] && i < targetPathLen && i < sourcePathLen) {
                i++;
            }
            for (var j = 0; j < sourcePathLen - i - 1; j++) {
                relPath += "../";
            }
            targetPathArr = targetPathArr.slice(i, targetPathArr.length);
            relPath = relPath + targetPathArr.join("/");
            relPath = relPath.replace(" ", "_");
            return relPath;
        }
        utils.getRelativePath = getRelativePath;
    })(utils = egret3d.utils || (egret3d.utils = {}));
})(egret3d || (egret3d = {}));
var Stats;
(function (Stats_1) {
    var stats;
    var loop;
    /**
     * 显示调试面板
     */
    function show(container, refreshTime) {
        if (refreshTime === void 0) { refreshTime = 500; }
        if (stats == null) {
            stats = new Stats();
            stats.container.style.position = 'absolute';
            stats.container.style.left = '0px';
            stats.container.style.top = '0px';
            container.appendChild(stats.container);
        }
        else {
            container.appendChild(stats.container);
        }
        if (loop) {
            hide();
        }
        loop = setInterval(function () {
            stats.update();
        }, refreshTime);
        egret3d.Performance.enable = true;
    }
    Stats_1.show = show;
    /**
     * 关闭调试面板
     */
    function hide() {
        if (loop) {
            clearInterval(loop);
        }
        if (stats != null && stats.container.parentNode) {
            stats.container.parentNode.removeChild(stats.container);
        }
        egret3d.Performance.enable = false;
    }
    Stats_1.hide = hide;
    /**
     *
     * @author mrdoob / http://mrdoob.com/
     * @modify egret
     */
    var Stats = (function () {
        function Stats() {
            var _this = this;
            this.mode = 0;
            this.container = document.createElement('div');
            this.container.style.cssText = 'position:fixed;top:0;left:0;cursor:pointer;opacity:0.7;z-index:1';
            this.container.addEventListener('click', function (event) {
                event.preventDefault();
                _this.showPanel(++_this.mode % _this.container.children.length);
            }, false);
            this.fpsPanel = this.addPanel(new Panel('FPS', '#0ff', '#002'));
            this.msPanel = this.addPanel(new Panel('MS', '#0f0', '#020'));
            this.renderPanel = this.addPanel(new Panel('R%', '#0f0', '#020'));
            if (self.performance && self.performance["memory"]) {
                this.memPanel = this.addPanel(new Panel('MB', '#f08', '#201'));
            }
            this.showPanel(0);
        }
        Stats.prototype.update = function () {
            var fps = egret3d.Performance.getFPS();
            var fpsEntity = egret3d.Performance.getEntity("fps");
            var allEntity = egret3d.Performance.getEntity("all");
            var renderEntity = egret3d.Performance.getEntity("render");
            this.fpsPanel.update(fps, 100);
            this.msPanel.update(allEntity.delta, 200);
            this.renderPanel.update(Math.floor(renderEntity.delta / fpsEntity.delta * 100), 100);
            if (this.memPanel) {
                var memory = performance["memory"];
                this.memPanel.update(memory.usedJSHeapSize / 1048576, memory.jsHeapSizeLimit / 1048576);
            }
        };
        Stats.prototype.showPanel = function (id) {
            for (var i = 0; i < this.container.children.length; i++) {
                this.container.children[i]["style"].display = i === id ? 'block' : 'none';
            }
            this.mode = id;
        };
        Stats.prototype.addPanel = function (panel) {
            this.container.appendChild(panel.canvas);
            return panel;
        };
        return Stats;
    }());
    __reflect(Stats.prototype, "Stats");
    /**
     *
     */
    var Panel = (function () {
        function Panel(name, fg, bg) {
            this.name = name;
            this.fg = fg;
            this.bg = bg;
            this.min = Infinity;
            this.max = 0;
            this.PR = Math.round(window.devicePixelRatio || 1);
            this.WIDTH = 80 * this.PR;
            this.HEIGHT = 48 * this.PR;
            this.TEXT_X = 3 * this.PR;
            this.TEXT_Y = 2 * this.PR;
            this.GRAPH_X = 3 * this.PR;
            this.GRAPH_Y = 15 * this.PR;
            this.GRAPH_WIDTH = 74 * this.PR, this.GRAPH_HEIGHT = 30 * this.PR;
            this.canvas = document.createElement('canvas');
            this.canvas.width = this.WIDTH;
            this.canvas.height = this.HEIGHT;
            this.canvas.style.cssText = 'width:80px;height:48px';
            this.context = this.canvas.getContext('2d');
            this.context.font = 'bold ' + (9 * this.PR) + 'px Helvetica,Arial,sans-serif';
            this.context.textBaseline = 'top';
            this.context.fillStyle = bg;
            this.context.fillRect(0, 0, this.WIDTH, this.HEIGHT);
            this.context.fillStyle = fg;
            this.context.fillText(name, this.TEXT_X, this.TEXT_Y);
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
            this.context.fillStyle = bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH, this.GRAPH_HEIGHT);
        }
        Panel.prototype.update = function (value, maxValue) {
            this.min = Math.min(this.min, value);
            this.max = Math.max(this.max, value);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 1;
            this.context.fillRect(0, 0, this.WIDTH, this.GRAPH_Y);
            this.context.fillStyle = this.fg;
            this.context.fillText(Math.round(value) + ' ' + this.name + ' (' + Math.round(this.min) + '-' + Math.round(this.max) + ')', this.TEXT_X, this.TEXT_Y);
            this.context.drawImage(this.canvas, this.GRAPH_X + this.PR, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT, this.GRAPH_X, this.GRAPH_Y, this.GRAPH_WIDTH - this.PR, this.GRAPH_HEIGHT);
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, this.GRAPH_HEIGHT);
            this.context.fillStyle = this.bg;
            this.context.globalAlpha = 0.9;
            this.context.fillRect(this.GRAPH_X + this.GRAPH_WIDTH - this.PR, this.GRAPH_Y, this.PR, Math.round((1 - (value / maxValue)) * this.GRAPH_HEIGHT));
        };
        return Panel;
    }());
    __reflect(Panel.prototype, "Panel");
})(Stats || (Stats = {}));
var egret3d;
(function (egret3d) {
    /**
     * device input manager
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 用户输入设备管理器
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var InputManager = (function () {
        function InputManager() {
        }
        /**
         *
         */
        InputManager.init = function (canvas) {
            if (this._isInit) {
                return;
            }
            this._isInit = true;
            this.keyboard = new egret3d.KeyboardDevice(window);
            this.mouse = new egret3d.MouseDevice(canvas);
            this.touch = new egret3d.TouchDevice(canvas);
        };
        /**
         *
         */
        InputManager.update = function (deltaTime) {
            this.keyboard.update();
            this.mouse.update();
            this.touch.update();
        };
        /**
         * is pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否正在被点击或者触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.isPressed = function () {
            if (this.mouse.isPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.MOVED || t.phase == egret3d.TouchPhase.STATIONARY) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was pressed
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次点击或触摸
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasPressed = function () {
            if (this.mouse.wasPressed(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.BEGAN) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * was released
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 是否完成一次鼠标或触摸释放。
         * 只有单点触摸才被触发，多点触摸请使用 MouseDivice
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.wasReleased = function () {
            if (this.mouse.wasReleased(0)) {
                return true;
            }
            else {
                var t = this.touch.getTouch(0);
                if (t && this.touch.touchCount == 1) {
                    if (t.phase == egret3d.TouchPhase.ENDED || t.phase == egret3d.TouchPhase.CANCELED) {
                        return true;
                    }
                }
            }
            return false;
        };
        /**
         * get touch point
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取点击或触摸位置
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        InputManager.getTouchPoint = function () {
            var t = this.touch.getTouch(0);
            if (t) {
                this._touchPoint.x = t.position.x;
                this._touchPoint.y = t.position.y;
            }
            else {
                this._touchPoint.x = this.mouse.position.x;
                this._touchPoint.y = this.mouse.position.y;
            }
            return this._touchPoint;
        };
        InputManager._isInit = false;
        InputManager._touchPoint = new egret3d.Vector2();
        return InputManager;
    }());
    egret3d.InputManager = InputManager;
    __reflect(InputManager.prototype, "egret3d.InputManager");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var _keyCodeToKeyIdentifier = {
        'TAB': 9,
        'ENTER': 13,
        'SHIFT': 16,
        'CONTROL': 17,
        'ALT': 18,
        'ESCAPE': 27,
        'LEFT': 37,
        'UP': 38,
        'RIGHT': 39,
        'DOWN': 40,
        'DELETE': 46,
        'WIN': 91
    };
    /**
     * keyboard input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 键盘输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var KeyboardDevice = (function () {
        /**
         *
         */
        function KeyboardDevice(element, options) {
            if (options === void 0) { options = { preventDefault: false, stopPropagation: false }; }
            this._element = null;
            this._keymap = {};
            this._lastmap = {};
            this._keyDownHandler = this._handleKeyDown.bind(this);
            this._keyUpHandler = this._handleKeyUp.bind(this);
            this._keyPressHandler = this._handleKeyPress.bind(this);
            this._cacheKeyCodeMap = {};
            this.attach(element);
            this.preventDefault = options.preventDefault;
            this.stopPropagation = options.stopPropagation;
        }
        KeyboardDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("keydown", this._keyDownHandler, false);
            this._element.addEventListener("keypress", this._keyPressHandler, false);
            this._element.addEventListener("keyup", this._keyUpHandler, false);
        };
        KeyboardDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("keydown", this._keyDownHandler, false);
            this._element.removeEventListener("keypress", this._keyPressHandler, false);
            this._element.removeEventListener("keyup", this._keyUpHandler, false);
            this._element = null;
        };
        KeyboardDevice.prototype._handleKeyDown = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            this._keymap[id] = true;
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyPress = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            // do nothing
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._handleKeyUp = function (event) {
            var code = event.keyCode || event.charCode;
            var id = this._toKeyIdentifier(code);
            delete this._keymap[id];
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        KeyboardDevice.prototype._toKeyIdentifier = function (keyCode) {
            var code;
            if (typeof (keyCode) == "string") {
                var upperCode = keyCode.toUpperCase();
                if (!this._cacheKeyCodeMap[keyCode]) {
                    var _code = _keyCodeToKeyIdentifier[upperCode] || upperCode.charCodeAt(0);
                    this._cacheKeyCodeMap[upperCode] = _code;
                }
                code = this._cacheKeyCodeMap[upperCode];
            }
            else {
                code = keyCode;
            }
            // Convert to hex and add leading 0's
            var hex = code.toString(16).toUpperCase();
            var length = hex.length;
            for (var count = 0; count < (4 - length); count++) {
                hex = '0' + hex;
            }
            return 'U+' + hex;
        };
        /**
         *
         */
        KeyboardDevice.prototype.update = function () {
            var prop;
            for (prop in this._lastmap) {
                delete this._lastmap[prop];
            }
            for (prop in this._keymap) {
                if (this._keymap.hasOwnProperty(prop)) {
                    this._lastmap[prop] = this._keymap[prop];
                }
            }
        };
        /**
         * is pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.isPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return this._keymap[id];
        };
        /**
         * was pressed
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasPressed = function (key) {
            var id = this._toKeyIdentifier(key);
            return (this._keymap[id] && !this._lastmap[id]);
        };
        /**
         * was released
         * @param key key code or char string
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键，可以为健值或者字符。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        KeyboardDevice.prototype.wasReleased = function (key) {
            var id = this._toKeyIdentifier(key);
            return (!this._keymap[id] && this._lastmap[id]);
        };
        return KeyboardDevice;
    }());
    egret3d.KeyboardDevice = KeyboardDevice;
    __reflect(KeyboardDevice.prototype, "egret3d.KeyboardDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * mouse input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 鼠标输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var MouseDevice = (function (_super) {
        __extends(MouseDevice, _super);
        /**
         *
         */
        function MouseDevice(element) {
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            /**
             * mouse position
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标位置
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.position = new egret3d.Vector2();
            /**
             * mouse wheel value
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前鼠标滚轮值
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.wheel = 0;
            _this._buttons = [false, false, false];
            _this._lastbuttons = [false, false, false];
            _this._element = null;
            _this._upHandler = _this._handleUp.bind(_this);
            _this._moveHandler = _this._handleMove.bind(_this);
            _this._downHandler = _this._handleDown.bind(_this);
            _this._wheelHandler = _this._handleWheel.bind(_this);
            _this._contextMenuHandler = function (event) { event.preventDefault(); };
            _this.attach(element);
            return _this;
        }
        /**
         *
         */
        MouseDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        MouseDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        /**
         * disable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 禁用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.disableContextMenu = function () {
            if (!this._element)
                return;
            this._element.addEventListener("contextmenu", this._contextMenuHandler);
        };
        /**
         * enable right key menu
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 启用右键菜单
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.enableContextMenu = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("contextmenu", this._contextMenuHandler);
        };
        MouseDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener("mouseup", this._upHandler, false);
            this._element.addEventListener("mousemove", this._moveHandler, false);
            this._element.addEventListener("mousedown", this._downHandler, false);
            this._element.addEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.addEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
        };
        MouseDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener("mouseup", this._upHandler, false);
            this._element.removeEventListener("mousemove", this._moveHandler, false);
            this._element.removeEventListener("mousedown", this._downHandler, false);
            this._element.removeEventListener("mousewheel", this._wheelHandler, false); // WebKit
            this._element.removeEventListener("DOMMouseScroll", this._wheelHandler, false); // Gecko
            this._element = null;
        };
        /**
         *
         */
        MouseDevice.prototype.update = function () {
            // Copy current button state
            this._lastbuttons[0] = this._buttons[0];
            this._lastbuttons[1] = this._buttons[1];
            this._lastbuttons[2] = this._buttons[2];
            // set wheel to 0
            this.wheel = 0;
        };
        /**
         * is pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键是否在按下状态
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.isPressed = function (button) {
            return this._buttons[button];
        };
        /**
         * was pressed
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被按下一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasPressed = function (button) {
            return (this._buttons[button] && !this._lastbuttons[button]);
        };
        /**
         * was released
         * @param key key value. 0: left key; 1: middle key; 2: right key.
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 按键被抬起一次
         * @param key 按键。0: 左键；1: 中键；2: 右键。
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        MouseDevice.prototype.wasReleased = function (button) {
            return (!this._buttons[button] && this._lastbuttons[button]);
        };
        MouseDevice.prototype._handleUp = function (event) {
            // disable released button
            this._buttons[event.button] = false;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mouseup", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleMove = function (event) {
            this.convertPosition(event, this.position);
            if (this._buttons[event.button]) {
                this.dispatchEvent({ type: "mousemove", x: this.position.x, y: this.position.y, identifier: event.button });
            }
        };
        MouseDevice.prototype._handleDown = function (event) {
            // Store which button has affected
            this._buttons[event.button] = true;
            this.convertPosition(event, this.position);
            this.dispatchEvent({ type: "mousedown", x: this.position.x, y: this.position.y, identifier: event.button });
        };
        MouseDevice.prototype._handleWheel = function (event) {
            // FF uses 'detail' and returns a value in 'no. of lines' to scroll
            // WebKit and Opera use 'wheelDelta', WebKit goes in multiples of 120 per wheel notch
            if (event.detail) {
                this.wheel = -1 * event.detail;
            }
            else if (event.wheelDelta) {
                this.wheel = event.wheelDelta / 120;
            }
            else {
                this.wheel = 0;
            }
        };
        return MouseDevice;
    }(egret3d.EventDispatcher));
    egret3d.MouseDevice = MouseDevice;
    __reflect(MouseDevice.prototype, "egret3d.MouseDevice");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * touch phase type
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸状态
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPhase;
    (function (TouchPhase) {
        /**
         * touch began
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸开始
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["BEGAN"] = 0] = "BEGAN";
        /**
         * touch moved
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸移动
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["MOVED"] = 1] = "MOVED";
        /**
         * touch stationary
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸静止
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["STATIONARY"] = 2] = "STATIONARY";
        /**
         * touch ended
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸结束
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["ENDED"] = 3] = "ENDED";
        /**
         * touch canceled
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 触摸取消
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchPhase[TouchPhase["CANCELED"] = 4] = "CANCELED";
    })(TouchPhase = egret3d.TouchPhase || (egret3d.TouchPhase = {}));
    /**
     * touch point
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸点信息
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchPoint = (function () {
        function TouchPoint() {
            this.altitudeAngle = Math.PI / 2; // Value of 0 radians indicates that the stylus is parallel to the surface, pi/2 indicates that it is perpendicular.
            this.azimuthAngle = 0; // Value of 0 radians indicates that the stylus is pointed along the x-axis of the device.
            this.deltaPosition = new egret3d.Vector2(); // The position delta since last change.
            // public deltaTime:number = 0; // TODO Amount of time that has passed since the last recorded change in Touch values.
            this.fingerId = 0; // The unique index for the touch.
            this.maximumPossiblePressure = 1.0; // The maximum possible pressure value for a platform. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.position = new egret3d.Vector2(); // The position of the touch in pixel coordinates.
            this.pressure = 1.0; //	The current amount of pressure being applied to a touch. 1.0f is considered to be the pressure of an average touch. If Input.touchPressureSupported returns false, the value of this property will always be 1.0f.
            this.radius = new egret3d.Vector2(); // ADD: different from Unity
            // public radius:number = 0; // DELETE: An estimated value of the radius of a touch. Add radiusletiance to get the maximum touch size, subtract it to get the minimum touch size.
            // public radiusletiance:number = 0; // DELETE: The amount that the radius leties by for a touch.
            // public rawPosition:Vector2 = new Vector2(); // DELETE: The raw position used for the touch.
            // public tapCount:number = 0; // TODO Number of taps.
            this.type = "Direct"; // A value that indicates whether a touch was of Direct, Indirect (or remote), or Stylus type.
        }
        /**
         *
         */
        TouchPoint.prototype.set = function (touch, phase, device) {
            this.altitudeAngle = touch.rotationAngle;
            this.azimuthAngle = touch.rotationAngle;
            if (phase == TouchPhase.BEGAN || phase == TouchPhase.STATIONARY) {
                this.deltaPosition.x = 0;
                this.deltaPosition.y = 0;
            }
            else {
                device.convertPosition(touch, this.deltaPosition);
                egret3d.Vector2.subtract(this.deltaPosition, this.position, this.deltaPosition);
            }
            // this.deltaTime;
            this.fingerId = touch.identifier;
            this.phase = phase;
            device.convertPosition(touch, this.position);
            this.pressure = touch.force;
            this.radius.x = touch.radiusX;
            this.radius.y = touch.radiusY;
            // this.tapCount;
        };
        /**
         *
         */
        TouchPoint.create = function () {
            return this._pointPool.pop() || new TouchPoint();
        };
        /**
         *
         */
        TouchPoint.release = function (touchPoint) {
            this._pointPool.push(touchPoint);
        };
        TouchPoint._pointPool = [];
        return TouchPoint;
    }());
    egret3d.TouchPoint = TouchPoint;
    __reflect(TouchPoint.prototype, "egret3d.TouchPoint");
    /**
     * touch input
     * @version paper 1.0
     * @platform Web
     * @language en_US
     */
    /**
     * 触摸输入
     * @version paper 1.0
     * @platform Web
     * @language zh_CN
     */
    var TouchDevice = (function (_super) {
        __extends(TouchDevice, _super);
        /**
         *
         */
        function TouchDevice(element, options) {
            if (options === void 0) { options = { preventDefault: true, stopPropagation: true }; }
            var _this = _super.call(this) || this;
            _this._offsetX = 0;
            _this._offsetY = 0;
            _this._scalerX = 1;
            _this._scalerY = 1;
            _this._rotated = false;
            _this._touchesMap = {};
            _this._touches = [];
            /**
             * touch count
             * @version paper 1.0
             * @platform Web
             * @language en_US
             */
            /**
             * 当前触摸点的数量
             * @version paper 1.0
             * @platform Web
             * @language zh_CN
             */
            _this.touchCount = 0;
            _this._startHandler = _this._handleTouchStart.bind(_this);
            _this._endHandler = _this._handleTouchEnd.bind(_this);
            _this._moveHandler = _this._handleTouchMove.bind(_this);
            _this._cancelHandler = _this._handleTouchCancel.bind(_this);
            _this._element = null;
            _this.attach(element);
            _this.preventDefault = options.preventDefault;
            _this.stopPropagation = options.stopPropagation;
            return _this;
        }
        /**
         *
         */
        TouchDevice.prototype.updateOffsetAndScale = function (offsetX, offsetY, scalerX, scalerY, rotated) {
            this._offsetX = offsetX;
            this._offsetY = offsetY;
            this._scalerX = scalerX;
            this._scalerY = scalerY;
            this._rotated = rotated;
        };
        /**
         *
         */
        TouchDevice.prototype.convertPosition = function (e, out) {
            if (this._rotated) {
                out.y = (window.innerWidth - e.clientX + this._offsetX) * this._scalerX;
                out.x = (e.clientY - this._offsetY) * this._scalerY;
            }
            else {
                out.x = (e.clientX - this._offsetX) * this._scalerX;
                out.y = (e.clientY - this._offsetY) * this._scalerY;
            }
        };
        TouchDevice.prototype.attach = function (element) {
            if (this._element) {
                this.detach();
            }
            this._element = element;
            this._element.addEventListener('touchstart', this._startHandler, false);
            this._element.addEventListener('touchend', this._endHandler, false);
            this._element.addEventListener('touchmove', this._moveHandler, false);
            this._element.addEventListener('touchcancel', this._cancelHandler, false);
        };
        TouchDevice.prototype.detach = function () {
            if (!this._element)
                return;
            this._element.removeEventListener('touchstart', this._startHandler, false);
            this._element.removeEventListener('touchend', this._endHandler, false);
            this._element.removeEventListener('touchmove', this._moveHandler, false);
            this._element.removeEventListener('touchcancel', this._cancelHandler, false);
            this._element = null;
        };
        /**
         *
         */
        TouchDevice.prototype.update = function () {
            for (var i in this._touchesMap) {
                var touch = this._touchesMap[i];
                if (touch.phase === TouchPhase.BEGAN) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.MOVED) {
                    touch.phase = TouchPhase.STATIONARY;
                }
                if (touch.phase === TouchPhase.ENDED || touch.phase === TouchPhase.CANCELED) {
                    delete this._touchesMap[i];
                    var index = this._touches.indexOf(touch);
                    if (index > -1) {
                        this._touches.splice(index, 1);
                    }
                    this.touchCount--;
                }
            }
        };
        /**
         * get touch point
         * @param index touch index
         * @version paper 1.0
         * @platform Web
         * @language en_US
         */
        /**
         * 获取触摸点
         * @param index 触摸点的索引
         * @version paper 1.0
         * @platform Web
         * @language zh_CN
         */
        TouchDevice.prototype.getTouch = function (index) {
            return this._touches[index];
        };
        TouchDevice.prototype._getTouch = function (identifier) {
            var touchPoint = this._touchesMap[identifier];
            if (!touchPoint) {
                touchPoint = TouchPoint.create();
                this._touchesMap[identifier] = touchPoint;
                this._touches.push(touchPoint);
                this.touchCount++;
            }
            return touchPoint;
        };
        TouchDevice.prototype._handleTouchStart = function (event) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.BEGAN, this);
                this.dispatchEvent({ type: "touchstart", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchEnd = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.ENDED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchMove = function (event) {
            // call preventDefault to avoid issues in Chrome Android:
            // http://wilsonpage.co.uk/touch-events-in-chrome-android/
            if (event["isScroll"] != true && !this._element['userTyping']) {
                event.preventDefault();
            }
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.MOVED, this);
                this.dispatchEvent({ type: "touchmove", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        TouchDevice.prototype._handleTouchCancel = function (event) {
            for (var i = 0; i < event.changedTouches.length; i++) {
                var touch = event.changedTouches[i];
                var identifier = touch.identifier;
                var touchPoint = this._getTouch(identifier);
                touchPoint.set(touch, TouchPhase.CANCELED, this);
                this.dispatchEvent({ type: "touchend", x: touchPoint.position.x, y: touchPoint.position.y, identifier: identifier });
            }
            if (this.preventDefault) {
                event.preventDefault();
            }
            if (this.stopPropagation) {
                event.stopPropagation();
            }
        };
        return TouchDevice;
    }(egret3d.EventDispatcher));
    egret3d.TouchDevice = TouchDevice;
    __reflect(TouchDevice.prototype, "egret3d.TouchDevice");
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var Clock = (function (_super) {
        __extends(Clock, _super);
        function Clock() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.maxFixedSubSteps = 3;
            _this.fixedDeltaTime = 1.0 / 50.0; // TODO same as fps.
            _this.timeScale = 1.0;
            _this._frameCount = 0;
            _this._beginTime = 0.0;
            _this._lastTime = 0.0;
            _this._delayTime = 0.0;
            _this._unscaledTime = 0.0;
            _this._unscaledDeltaTime = 0.0;
            /**
             * @internal
             */
            _this._fixedTime = 0.0;
            return _this;
        }
        Clock.prototype.initialize = function () {
            _super.prototype.initialize.call(this);
            this._lastTime = this._beginTime = Date.now() * 0.001;
        };
        /**
         * @internal
         */
        Clock.prototype.update = function (time) {
            if (this._unscaledTime !== 0.0) {
                this._lastTime = this._unscaledTime;
                if (this._fixedTime < this.fixedDeltaTime) {
                }
                else if (this._fixedTime < this.fixedDeltaTime * this.maxFixedSubSteps) {
                    this._fixedTime %= this.fixedDeltaTime;
                }
                else {
                    this._fixedTime -= this.fixedDeltaTime * this.maxFixedSubSteps;
                }
            }
            var now = time || Date.now() * 0.001;
            this._frameCount += 1;
            this._unscaledTime = now - this._beginTime;
            this._unscaledDeltaTime = this._unscaledTime - this._lastTime;
            this._fixedTime += this._unscaledDeltaTime;
        };
        Object.defineProperty(Clock.prototype, "frameCount", {
            get: function () {
                return this._frameCount;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "time", {
            get: function () {
                return this._unscaledTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "deltaTime", {
            get: function () {
                return this._unscaledDeltaTime * this.timeScale;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledTime", {
            get: function () {
                return this._unscaledTime;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Clock.prototype, "unscaledDeltaTime", {
            get: function () {
                return this._unscaledDeltaTime;
            },
            enumerable: true,
            configurable: true
        });
        return Clock;
    }(paper.SingletonComponent));
    paper.Clock = Clock;
    __reflect(Clock.prototype, "paper.Clock");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    /**
     * WebGL 渲染系统
     */
    var WebGLRenderSystem = (function (_super) {
        __extends(WebGLRenderSystem, _super);
        function WebGLRenderSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                [
                    { componentClass: egret3d.Camera }
                ],
                [
                    { componentClass: egret3d.Egret2DRenderer }
                ],
                [
                    { componentClass: [egret3d.DirectLight, egret3d.SpotLight, egret3d.PointLight] }
                ]
            ];
            _this._webgl = egret3d.WebGLCapabilities.webgl;
            _this._camerasAndLights = _this._globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            _this._drawCalls = _this._globalGameObject.getOrAddComponent(egret3d.DrawCalls);
            _this._lightCamera = _this._globalGameObject.getOrAddComponent(egret3d.Camera);
            _this._stateEnables = [3042 /* BLEND */, 2884 /* CULL_FACE */, 2929 /* DEPTH_TEST */];
            //
            _this._filteredLights = [];
            _this._cacheStateEnable = {};
            return _this;
        }
        //
        WebGLRenderSystem.prototype._updateState = function (state) {
            if (this._cacheState === state) {
                return;
            }
            this._cacheState = state;
            var webgl = this._webgl;
            var stateEnables = this._stateEnables;
            var cacheStateEnable = this._cacheStateEnable;
            var functions = state.functions;
            //TODO WebGLKit.draw(context, drawCall.material, drawCall.mesh, drawCall.subMeshIndex, drawType, transform._worldMatrixDeterminant < 0);
            for (var _i = 0, stateEnables_1 = stateEnables; _i < stateEnables_1.length; _i++) {
                var e = stateEnables_1[_i];
                var b = state.enable.indexOf(e) >= 0;
                if (cacheStateEnable[e] !== b) {
                    cacheStateEnable[e] = b;
                    b ? webgl.enable(e) : webgl.disable(e);
                }
            }
            //functions
            for (var fun in functions) {
                //
                webgl[fun].apply(webgl, functions[fun]);
            }
        };
        WebGLRenderSystem.prototype._updateContextDefines = function (context, material) {
            this._cacheDefines = "";
            if (context.lightCount > 0) {
                this._cacheDefines += "#define USE_LIGHT " + context.lightCount + "\n";
                if (context.directLightCount > 0) {
                    this._cacheDefines += "#define USE_DIRECT_LIGHT " + context.directLightCount + "\n";
                }
                if (context.pointLightCount > 0) {
                    this._cacheDefines += "#define USE_POINT_LIGHT " + context.pointLightCount + "\n";
                }
                if (context.spotLightCount > 0) {
                    this._cacheDefines += "#define USE_SPOT_LIGHT " + context.spotLightCount + "\n";
                }
                if (context.drawCall.renderer.receiveShadows) {
                    this._cacheDefines += "#define USE_SHADOW \n";
                    this._cacheDefines += "#define USE_PCF_SOFT_SHADOW \n";
                }
            }
            //自定义的宏定义TODO
            this._cacheDefines += material.shaderDefine;
        };
        WebGLRenderSystem.prototype._updateContextUniforms = function (context, technique, forceUpdate) {
            var needUpdate = this._cacheContext !== context || this._cacheContextVersion !== context.version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheContext = context;
            this._cacheContextVersion = context.version;
            var webgl = this._webgl;
            for (var key in technique.uniforms) {
                var uniform = technique.uniforms[key];
                var paperExtension = uniform.extensions.paper;
                if (!paperExtension.enable) {
                    continue;
                }
                var location_1 = paperExtension.location;
                switch (uniform.semantic) {
                    case "MODEL" /* MODEL */:
                        webgl.uniformMatrix4fv(location_1, false, context.matrix_m.rawData);
                        break;
                    case "VIEW" /* VIEW */:
                        webgl.uniformMatrix4fv(location_1, false, context.matrix_v.rawData);
                        break;
                    case "PROJECTION" /* PROJECTION */:
                        webgl.uniformMatrix4fv(location_1, false, context.matrix_p.rawData);
                        break;
                    case "_VIEWPROJECTION" /* _VIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_1, false, context.matrix_vp.rawData);
                        break;
                    case "MODELVIEWPROJECTION" /* MODELVIEWPROJECTION */:
                        webgl.uniformMatrix4fv(location_1, false, context.matrix_mvp.rawData);
                        break;
                    case "_CAMERA_POS" /* _CAMERA_POS */:
                        webgl.uniform3fv(location_1, context.cameraPosition);
                        break;
                    case "_CAMERA_FORWARD" /* _CAMERA_FORWARD */:
                        webgl.uniform3fv(location_1, context.cameraForward);
                        break;
                    case "CAMERA_UP" /* _CAMERA_UP */:
                        webgl.uniform3fv(location_1, context.cameraUp);
                        break;
                    case "_LIGHTCOUNT" /* _LIGHTCOUNT */:
                        webgl.uniform1f(location_1, context.lightCount);
                        break;
                    case "_DIRECTLIGHTS" /* _DIRECTLIGHTS */:
                        if (context.directLightCount > 0) {
                            webgl.uniform1fv(location_1, context.directLightArray);
                        }
                        break;
                    case "_POINTLIGHTS" /* _POINTLIGHTS */:
                        if (context.pointLightCount > 0) {
                            webgl.uniform1fv(location_1, context.pointLightArray);
                        }
                        break;
                    case "_SPOTLIGHTS" /* _SPOTLIGHTS */:
                        if (context.spotLightCount > 0) {
                            webgl.uniform1fv(location_1, context.spotLightArray);
                        }
                        break;
                    case "_DIRECTIONSHADOWMAT" /* _DIRECTIONSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_1, false, context.directShadowMatrix);
                        break;
                    case "_SPOTSHADOWMAT" /* _SPOTSHADOWMAT */:
                        webgl.uniformMatrix4fv(location_1, false, context.spotShadowMatrix);
                        break;
                    case "_DIRECTIONSHADOWMAP" /* _DIRECTIONSHADOWMAP */:
                        var directShadowLen = context.directShadowMaps.length;
                        if (directShadowLen > 0 && uniform.extensions.paper.textureUnits) {
                            var units = uniform.extensions.paper.textureUnits;
                            webgl.uniform1iv(location_1, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.directShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.directShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_POINTSHADOWMAP" /* _POINTSHADOWMAP */:
                        var pointShadowLen = context.pointShadowMaps.length;
                        if (pointShadowLen > 0 && uniform.extensions.paper.textureUnits) {
                            var units = uniform.extensions.paper.textureUnits;
                            webgl.uniform1iv(location_1, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.pointShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.pointShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_SPOTSHADOWMAP" /* _SPOTSHADOWMAP */:
                        var spotShadowLen = context.spotShadowMaps.length;
                        if (spotShadowLen > 0 && uniform.extensions.paper.textureUnits) {
                            var units = uniform.extensions.paper.textureUnits;
                            webgl.uniform1iv(location_1, units);
                            for (var i = 0, l = units.length; i < l; i++) {
                                if (context.spotShadowMaps[i]) {
                                    webgl.activeTexture(webgl.TEXTURE0 + units[i]);
                                    webgl.bindTexture(webgl.TEXTURE_2D, context.spotShadowMaps[i]);
                                }
                            }
                        }
                        break;
                    case "_LIGHTMAPTEX" /* _LIGHTMAPTEX */:
                        if (paperExtension.textureUnits && paperExtension.textureUnits.length === 1 && context.lightmap) {
                            var unit = paperExtension.textureUnits[0];
                            webgl.uniform1i(location_1, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, context.lightmap);
                        }
                        else {
                            console.error("Error texture unit");
                        }
                        break;
                    case "_LIGHTMAPINTENSITY" /* _LIGHTMAPINTENSITY */:
                        webgl.uniform1f(location_1, context.lightmapIntensity);
                        break;
                    case "_LIGHTMAPOFFSET" /* _LIGHTMAPOFFSET */:
                        if (context.lightmapOffset) {
                            webgl.uniform4fv(location_1, context.lightmapOffset);
                        }
                        else {
                            console.debug("Error light map scale and offset.");
                        }
                        break;
                    case "_LIGHTMAPUV" /* _LIGHTMAPUV */:
                        webgl.uniform1f(location_1, context.lightmapUV);
                        break;
                    case "_BONESVEC4" /* _BONESVEC4 */:
                        webgl.uniform4fv(location_1, context.boneData);
                        break;
                    case "_REFERENCEPOSITION" /* _REFERENCEPOSITION */:
                        webgl.uniform4fv(location_1, context.lightPosition);
                        break;
                    case "_NEARDICTANCE" /* _NEARDICTANCE */:
                        webgl.uniform1f(location_1, context.lightShadowCameraNear);
                        break;
                    case "_FARDISTANCE" /* _FARDISTANCE */:
                        webgl.uniform1f(location_1, context.lightShadowCameraFar);
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateUniforms = function (context, material, technique, forceUpdate) {
            var needUpdate = this._cacheMaterial !== material || this._cacheMaterialVerision !== material.version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheMaterial = material;
            this._cacheMaterialVerision = material.version;
            var webgl = this._webgl;
            for (var key in technique.uniforms) {
                var uniform = technique.uniforms[key];
                var paperExtension = uniform.extensions.paper;
                if (!paperExtension.enable || uniform.semantic) {
                    continue;
                }
                var location_2 = uniform.extensions.paper.location;
                var value = uniform.value;
                switch (uniform.type) {
                    case 35670 /* BOOL */:
                    case 5124 /* Int */:
                        if (uniform.count && uniform.count > 1) {
                            webgl.uniform1iv(location_2, value);
                        }
                        else {
                            webgl.uniform1i(location_2, value);
                        }
                        break;
                    case 35671 /* BOOL_VEC2 */:
                    case 35667 /* INT_VEC2 */:
                        webgl.uniform2iv(location_2, value);
                        break;
                    case 35672 /* BOOL_VEC3 */:
                    case 35668 /* INT_VEC3 */:
                        webgl.uniform3iv(location_2, value);
                        break;
                    case 35673 /* BOOL_VEC4 */:
                    case 35669 /* INT_VEC4 */:
                        webgl.uniform4iv(location_2, value);
                        break;
                    case 5126 /* FLOAT */:
                        if (uniform.count && uniform.count > 1) {
                            webgl.uniform1fv(location_2, value);
                        }
                        else {
                            webgl.uniform1f(location_2, value);
                        }
                        break;
                    case 35664 /* FLOAT_VEC2 */:
                        webgl.uniform2fv(location_2, value);
                        break;
                    case 35665 /* FLOAT_VEC3 */:
                        webgl.uniform3fv(location_2, value);
                        break;
                    case 35666 /* FLOAT_VEC4 */:
                        webgl.uniform4fv(location_2, value);
                        break;
                    case 35674 /* FLOAT_MAT2 */:
                        webgl.uniformMatrix2fv(location_2, false, value);
                        break;
                    case 35675 /* FLOAT_MAT3 */:
                        webgl.uniformMatrix3fv(location_2, false, value);
                        break;
                    case 35676 /* FLOAT_MAT4 */:
                        webgl.uniformMatrix4fv(location_2, false, value);
                        break;
                    case 35678 /* SAMPLER_2D */:
                        if (paperExtension.textureUnits && paperExtension.textureUnits.length === 1) {
                            var unit = paperExtension.textureUnits[0];
                            webgl.uniform1i(location_2, unit);
                            webgl.activeTexture(webgl.TEXTURE0 + unit);
                            webgl.bindTexture(webgl.TEXTURE_2D, value.glTexture.texture);
                        }
                        else {
                            console.error("Error texture unit");
                        }
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._updateAttributes = function (mesh, subMeshIndex, technique, forceUpdate) {
            var needUpdate = this._cacheMesh !== mesh || this._cacheMeshVersion !== mesh._version || forceUpdate;
            if (!needUpdate) {
                return;
            }
            this._cacheMesh = mesh;
            this._cacheMeshVersion = mesh._version;
            if (0 <= subMeshIndex && subMeshIndex < mesh.glTFMesh.primitives.length) {
                var glTFAsset = mesh.glTFAsset;
                var primitive = mesh.glTFMesh.primitives[subMeshIndex];
                var ibo = mesh.ibos[subMeshIndex];
                var gl = this._webgl;
                gl.bindBuffer(gl.ARRAY_BUFFER, mesh.vbo);
                if (ibo) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo);
                }
                var attributes = technique.attributes;
                for (var k in attributes) {
                    var attribute = attributes[k];
                    if (!attribute.extensions.paper.enable) {
                        continue;
                    }
                    var location_3 = attribute.extensions.paper.location;
                    var accessorIndex = primitive.attributes[attribute.semantic];
                    if (accessorIndex !== undefined) {
                        var accessor = glTFAsset.getAccessor(accessorIndex);
                        var bufferOffset = glTFAsset.getBufferOffset(accessor);
                        var typeCount = egret3d.GLTFAsset.getAccessorTypeCount(accessor.type);
                        gl.vertexAttribPointer(location_3, typeCount, accessor.componentType, accessor.normalized ? true : false, 0, bufferOffset); //TODO normalized应该来源于mesh，应该还没有
                        gl.enableVertexAttribArray(location_3);
                    }
                    else {
                        gl.disableVertexAttribArray(location_3);
                    }
                }
            }
            else {
                console.warn("Error arguments.");
            }
        };
        WebGLRenderSystem.prototype._drawCall = function (mesh, drawCall) {
            var webgl = this._webgl;
            var primitive = mesh.glTFMesh.primitives[drawCall.subMeshIndex];
            var vertexAccessor = mesh.glTFAsset.getAccessor(primitive.attributes.POSITION);
            var bufferOffset = mesh.glTFAsset.getBufferOffset(vertexAccessor);
            if (primitive.indices !== undefined) {
                var indexAccessor = mesh.glTFAsset.getAccessor(primitive.indices);
                switch (primitive.mode) {
                    case 1 /* Lines */:
                        webgl.drawElements(webgl.LINES, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                        break;
                    case 4 /* Triangles */:
                    default:
                        webgl.drawElements(webgl.TRIANGLES, indexAccessor.count, webgl.UNSIGNED_SHORT, bufferOffset);
                        break;
                }
            }
            else {
                switch (primitive.mode) {
                    case 1 /* Lines */:
                        webgl.drawArrays(webgl.LINES, bufferOffset, vertexAccessor.count);
                        break;
                    case 2 /* LineLoop */:
                        webgl.drawArrays(webgl.LINE_LOOP, bufferOffset, vertexAccessor.count);
                        break;
                    case 3 /* LineStrip */:
                        webgl.drawArrays(webgl.LINE_STRIP, bufferOffset, vertexAccessor.count);
                        break;
                    case 4 /* Triangles */:
                    default:
                        webgl.drawArrays(webgl.TRIANGLES, bufferOffset, vertexAccessor.count);
                        break;
                }
            }
        };
        WebGLRenderSystem.prototype._renderCall = function (context, drawCall) {
            var renderer = drawCall.renderer;
            context.drawCall = drawCall;
            context.updateModel(drawCall.matrix || renderer.gameObject.transform.getWorldMatrix());
            if (drawCall.boneData) {
                context.updateBones(drawCall.boneData);
            }
            //
            var material = drawCall.shadow || drawCall.material;
            var technique = material._glTFTechnique;
            //Defines
            this._updateContextDefines(context, material);
            //Program
            var program = egret3d.GlProgram.getProgram(material, technique, this._cacheDefines);
            //State
            this._updateState(technique.states);
            //Use Program
            var force = false;
            if (this._cacheProgram !== program) {
                this._cacheProgram = program;
                this._webgl.useProgram(program);
                force = true;
            }
            //Uniform
            this._updateContextUniforms(context, technique, force);
            this._updateUniforms(context, material, technique, force);
            //Attribute
            this._updateAttributes(drawCall.mesh, drawCall.subMeshIndex, technique, force);
            //Draw
            this._drawCall(drawCall.mesh, drawCall);
        };
        /**
         * @internal
         * @param camera
         */
        WebGLRenderSystem.prototype._renderCamera = function (camera) {
            camera._targetAndViewport(camera.renderTarget, false);
            //在这里先剔除，然后排序，最后绘制
            var drawCalls = this._drawCalls;
            drawCalls.sortAfterFrustumCulling(camera);
            //
            var opaqueCalls = drawCalls.opaqueCalls;
            var transparentCalls = drawCalls.transparentCalls;
            //Step1 draw opaque
            for (var _i = 0, opaqueCalls_1 = opaqueCalls; _i < opaqueCalls_1.length; _i++) {
                var drawCall = opaqueCalls_1[_i];
                this._renderCall(camera.context, drawCall);
            }
            //Step2 draw transparent
            for (var _a = 0, transparentCalls_1 = transparentCalls; _a < transparentCalls_1.length; _a++) {
                var drawCall = transparentCalls_1[_a];
                this._renderCall(camera.context, drawCall);
            }
            // Egret2D渲染不加入DrawCallList的排序
            for (var _b = 0, _c = this._groups[1].gameObjects; _b < _c.length; _b++) {
                var gameObject = _c[_b];
                var egret2DRenderer = gameObject.getComponent(egret3d.Egret2DRenderer);
                if (camera.cullingMask & egret2DRenderer.gameObject.layer) {
                    egret2DRenderer.render(camera.context, camera);
                    //clear State
                    for (var key in this._cacheStateEnable) {
                        delete this._cacheStateEnable[key];
                    }
                    this._cacheProgram = undefined;
                    this._cacheState = undefined;
                }
            }
        };
        /**
         * @internal
         * @param light
         */
        WebGLRenderSystem.prototype._renderLightShadow = function (light) {
            var camera = this._lightCamera;
            var drawCalls = this._drawCalls;
            var faceCount = light.type === 2 /* Point */ ? 6 : 1;
            for (var i = 0; i < faceCount; ++i) {
                light.renderTarget.activeCubeFace = i; // TODO 创建接口。
                light.update(camera, i);
                camera._targetAndViewport(light.renderTarget, false);
                var context = camera.context;
                context.updateCamera(camera, light.matrix);
                context.updateLightDepth(light);
                drawCalls.shadowFrustumCulling(camera);
                //
                var shadowCalls = drawCalls.shadowCalls;
                var shadowMaterial = light.type === 2 /* Point */ ? egret3d.DefaultMaterials.ShadowDistance : egret3d.DefaultMaterials.ShadowDepth;
                for (var _i = 0, shadowCalls_1 = shadowCalls; _i < shadowCalls_1.length; _i++) {
                    var drawCall = shadowCalls_1[_i];
                    //TODO, 现在不支持蒙皮动画阴影                    
                    drawCall.shadow = shadowMaterial;
                    this._renderCall(context, drawCall);
                    drawCall.shadow = undefined;
                }
            }
            egret3d.GlRenderTarget.useNull(egret3d.WebGLCapabilities.webgl);
        };
        WebGLRenderSystem.prototype.onUpdate = function () {
            // Performance.startCounter("render");
            var cameras = this._camerasAndLights.cameras;
            var lights = this._camerasAndLights.lights;
            var filteredLights = this._filteredLights;
            ;
            var camerasScene = paper.Application.sceneManager.camerasScene || paper.Application.sceneManager.activeScene;
            var lightsScene = paper.Application.sceneManager.lightsScene || paper.Application.sceneManager.activeScene;
            // Lights.
            if (filteredLights.length > 0) {
                filteredLights.length = 0;
            }
            if (lights.length > 0) {
                for (var _i = 0, lights_3 = lights; _i < lights_3.length; _i++) {
                    var light = lights_3[_i];
                    if (!light.castShadows || light.gameObject.scene !== lightsScene) {
                        continue;
                    }
                    filteredLights.push(light);
                    this._renderLightShadow(light);
                }
            }
            // Cameras.
            if (cameras.length > 0) {
                for (var _a = 0, cameras_2 = cameras; _a < cameras_2.length; _a++) {
                    var camera = cameras_2[_a];
                    if (camera.gameObject.scene !== camerasScene) {
                        continue;
                    }
                    if (filteredLights.length > 0) {
                        camera.context.updateLights(filteredLights); // TODO 性能优化
                    }
                    if (camera.postQueues.length === 0) {
                        this._renderCamera(camera);
                    }
                    else {
                        for (var _b = 0, _c = camera.postQueues; _b < _c.length; _b++) {
                            var item = _c[_b];
                            item.render(camera, this);
                        }
                    }
                }
            }
            else {
                var webgl = this._webgl;
                webgl.clearColor(0, 0, 0, 1);
                webgl.clearDepth(1.0);
                webgl.clear(webgl.COLOR_BUFFER_BIT | webgl.DEPTH_BUFFER_BIT);
            }
            // Performance.endCounter("render");
        };
        return WebGLRenderSystem;
    }(paper.BaseSystem));
    egret3d.WebGLRenderSystem = WebGLRenderSystem;
    __reflect(WebGLRenderSystem.prototype, "egret3d.WebGLRenderSystem");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    //最大允许合并的顶点数，超过就是下一批次
    egret3d.MAX_VERTEX_COUNT_PER_BUFFER = 50000;
    //
    var helpVec3_1 = new egret3d.Vector3();
    var helpVec3_2 = new egret3d.Vector3();
    var helpInverseMatrix = new egret3d.Matrix();
    //缓存已经校验过的对象，用于过滤
    var cacheInstances = [];
    var beforeCombineCount = 0;
    /**
     * 尝试对场景内所有静态对象合并
     */
    function autoCombine(scene) {
        combine(scene.gameObjects);
    }
    egret3d.autoCombine = autoCombine;
    /**
     * 尝试合并静态对象列表。
     * @param instances
     * @param root
     */
    function combine(instances) {
        cacheInstances.length = 0;
        beforeCombineCount = 0;
        var allCombines = {};
        //1.通过材质填充合并列表
        for (var _i = 0, instances_1 = instances; _i < instances_1.length; _i++) {
            var obj = instances_1[_i];
            _colletCombineInstance(obj, allCombines);
        }
        console.log("合并前:" + beforeCombineCount);
        var afterCombineCount = 0;
        //2.相同材质的合并
        for (var key in allCombines) {
            var combines = allCombines[key];
            for (var _a = 0, combines_1 = combines; _a < combines_1.length; _a++) {
                var combine_1 = combines_1[_a];
                _combineInstance(combine_1);
                afterCombineCount++;
            }
        }
        console.log("合并后:" + afterCombineCount + "节省:" + (beforeCombineCount - afterCombineCount));
        cacheInstances.length = 0;
    }
    egret3d.combine = combine;
    /**
     * TODO(root暂时不支持)尝试合并静态对象列表，如果root有值，合并后可以操作root对象的transform，来实现整体移动，旋转，缩放；反之，相同材质列表的第一个对象为合并节点。
     * @param instances
     * @param root
     */
    function _colletCombineInstance(target, out, root) {
        //过滤重复的对象
        if (cacheInstances.indexOf(target.uuid) >= 0) {
            return;
        }
        cacheInstances.push(target.uuid);
        //
        for (var _i = 0, _a = target.transform.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (child) {
                _colletCombineInstance(child.gameObject, out, root);
            }
        }
        //不是静态的不考虑合并
        if (!target.isStatic) {
            return;
        }
        var meshFilter = target.getComponent(egret3d.MeshFilter);
        var meshRenderer = target.getComponent(egret3d.MeshRenderer);
        //合并条件判断
        if (!meshFilter || !meshFilter.mesh || !meshRenderer || !meshRenderer.materials || meshRenderer.materials.length < 1) {
            return;
        }
        beforeCombineCount++;
        var materials = meshRenderer.materials;
        var meshData = meshFilter.mesh;
        //合并筛选的条件:光照贴图_材质0_材质1... ：0_234_532...
        var key = meshRenderer.lightmapIndex + "_";
        materials.forEach(function (element) { key = key + "_" + element.uuid; });
        if (!out[key]) {
            out[key] = [];
            out[key].push(new CombineInstance());
        }
        var combines = out[key];
        //找相同材质合成列表的最后一个，如果最后一个顶点超过允许最大数了，就新建一个，下个批次处理
        var combine = combines[combines.length - 1];
        if (combine.vertexCount + meshData.vertexCount > egret3d.MAX_VERTEX_COUNT_PER_BUFFER) {
            combine = new CombineInstance();
            out[key].push(combine);
        }
        //合并节点以传入的对象为优先，如果没有传入，那么以每种材质的第一个对象为准
        if (!combine.root) {
            combine.root = root ? root : target;
            combine.lightmapIndex = meshRenderer.lightmapIndex;
            combine.lightmapScaleOffset = meshRenderer.lightmapScaleOffset;
        }
        //适配最大格式
        var glTFAsset = meshData.glTFAsset;
        var primitives = meshData.glTFMesh.primitives;
        for (var i = 0; i < primitives.length; i++) {
            var primitive = primitives[i];
            for (var attStr in primitives[i].attributes) {
                var attrType = attStr;
                if (!combine.meshAttribute[attrType]) {
                    combine.vertexBufferSize += egret3d.GLTFAsset.getAccessorTypeCount(glTFAsset.getAccessor(primitive.attributes[attStr]).type);
                }
                combine.meshAttribute[attrType] = attrType;
            }
            combine.indexBufferTotalSize += glTFAsset.getBufferLength(glTFAsset.getAccessor(primitive.indices)) / Uint16Array.BYTES_PER_ELEMENT;
        }
        //
        combine.vertexCount += meshData.vertexCount;
        combine.instances.push(target);
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     */
    function _combineInstance(combineInstance) {
        var combineMesh = _combineMesh(combineInstance);
        var combineRoot = combineInstance.root;
        //把合成好的放入root中，重新绘制
        if (combineRoot) {
            var meshFilter = combineRoot.getComponent(egret3d.MeshFilter);
            meshFilter.mesh = combineMesh;
        }
        // for(const instance of combineInstance.instances){
        //     const meshFilter = instance.getComponent(MeshFilter);
        //     meshFilter.mesh = combineMesh;
        // }
    }
    /**
     * 合并拥有共享材质的渲染对象
     * @param combineInstance
     * @param root
     */
    function _combineMesh(combineInstance) {
        //
        egret3d.Matrix.inverse(combineInstance.root.transform.getWorldMatrix(), helpInverseMatrix);
        var meshAttribute = combineInstance.meshAttribute;
        var lightmapScaleOffset = combineInstance.lightmapScaleOffset;
        var newAttribute = [];
        var tempIndexBuffers = [];
        var tempVertexBuffers = {};
        for (var key in meshAttribute) {
            tempVertexBuffers[key] = [];
            newAttribute.push(key);
        }
        //
        var startIndex = 0;
        var endIndex = 0;
        for (var _i = 0, _a = combineInstance.instances; _i < _a.length; _i++) {
            var instance = _a[_i];
            var meshFilter = instance.getComponent(egret3d.MeshFilter);
            var meshRenderer = instance.getComponent(egret3d.MeshRenderer);
            var worldMatrix = instance.transform.getWorldMatrix();
            var orginLightmapScaleOffset = meshRenderer.lightmapScaleOffset;
            var mesh = meshFilter.mesh;
            var glTFAsset = mesh.glTFAsset;
            var primitives = mesh.glTFMesh.primitives;
            var isSharedBuffer = mesh.isSharedBuffer;
            //共享一个的buffer，vbo只处理一个submesh就可以了
            var combineOnce = true;
            for (var i = 0; i < primitives.length; i++) {
                var primitive = primitives[i];
                if (combineOnce) {
                    combineOnce = !isSharedBuffer;
                    var orginVertexCount = mesh.getVertexCount(i);
                    var orginAttributes = primitives[i].attributes;
                    var positionBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.POSITION));
                    //vertexBuffers
                    for (var j = 0; j < positionBuffer.length; j += 3) {
                        helpVec3_1.x = positionBuffer[j + 0];
                        helpVec3_1.y = positionBuffer[j + 1];
                        helpVec3_1.z = positionBuffer[j + 2];
                        //转换成世界坐标后在转换为合并节点的本地坐标
                        egret3d.Matrix.transformVector3(helpVec3_1, worldMatrix, helpVec3_2);
                        egret3d.Matrix.transformVector3(helpVec3_2, helpInverseMatrix, helpVec3_1);
                        //
                        tempVertexBuffers["POSITION" /* POSITION */].push(helpVec3_1.x, helpVec3_1.y, helpVec3_1.z);
                    }
                    //
                    if (meshAttribute["NORMAL" /* NORMAL */]) {
                        if (orginAttributes.NORMAL) {
                            var normalBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.NORMAL));
                            var target = tempVertexBuffers["NORMAL" /* NORMAL */];
                            var count = normalBuffer.length;
                            var startIndex_1 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 3) {
                                helpVec3_1.x = normalBuffer[j + 0];
                                helpVec3_1.y = normalBuffer[j + 1];
                                helpVec3_1.z = normalBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_1 + j] = helpVec3_1.x;
                                target[startIndex_1 + j + 1] = helpVec3_1.y;
                                target[startIndex_1 + j + 2] = helpVec3_1.z;
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.NORMAL, tempVertexBuffers[gltf.MeshAttributeType.NORMAL]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["NORMAL" /* NORMAL */], orginVertexCount, [0, 0, 0]);
                        }
                    }
                    if (meshAttribute["TANGENT" /* TANGENT */]) {
                        if (orginAttributes.TANGENT) {
                            var tangentBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TANGENT));
                            var target = tempVertexBuffers["TANGENT" /* TANGENT */];
                            var count = tangentBuffer.length;
                            var startIndex_2 = target.length;
                            target.length += count;
                            for (var j = 0; j < count; j += 4) {
                                helpVec3_1.x = tangentBuffer[j + 0];
                                helpVec3_1.y = tangentBuffer[j + 1];
                                helpVec3_1.z = tangentBuffer[j + 2];
                                worldMatrix.transformNormal(helpVec3_1);
                                helpInverseMatrix.transformNormal(helpVec3_1);
                                helpVec3_1.normalize();
                                target[startIndex_2 + j] = helpVec3_1.x;
                                target[startIndex_2 + j + 1] = helpVec3_1.y;
                                target[startIndex_2 + j + 2] = helpVec3_1.z;
                                target[startIndex_2 + j + 3] = tangentBuffer[j + 3];
                            }
                            // _copyAccessorBufferArray(glTFAsset, orginAttributes.TANGENT, tempVertexBuffers[gltf.MeshAttributeType.TANGENT]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TANGENT" /* TANGENT */], orginVertexCount, [0, 0, 0, 1]);
                        }
                    }
                    if (meshAttribute["COLOR_0" /* COLOR_0 */]) {
                        if (orginAttributes.COLOR_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.COLOR_0, tempVertexBuffers["COLOR_0" /* COLOR_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_0" /* COLOR_0 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_0" /* TEXCOORD_0 */]) {
                        if (orginAttributes.TEXCOORD_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.TEXCOORD_0, tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["TEXCOORD_0" /* TEXCOORD_0 */], orginVertexCount, [0, 0]);
                        }
                    }
                    if (meshAttribute["TEXCOORD_1" /* TEXCOORD_1 */]) {
                        if (combineInstance.lightmapIndex >= 0) {
                            //如果有lightmap,那么将被合并的uv1的坐标转换为root下的坐标,有可能uv1没有，那用uv0来算
                            var uvBuffer = orginAttributes.TEXCOORD_1 ?
                                glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TEXCOORD_1)) :
                                glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(orginAttributes.TEXCOORD_0));
                            //
                            for (var j = 0; j < uvBuffer.length; j += 2) {
                                var u = uvBuffer[j + 0];
                                var v = uvBuffer[j + 1];
                                u = ((u * orginLightmapScaleOffset[0] + orginLightmapScaleOffset[2]) - lightmapScaleOffset[2]) / lightmapScaleOffset[0];
                                v = ((v * orginLightmapScaleOffset[1] - orginLightmapScaleOffset[1] - orginLightmapScaleOffset[3]) + lightmapScaleOffset[3] + lightmapScaleOffset[1]) / lightmapScaleOffset[1];
                                tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */].push(u, v);
                            }
                        }
                        else {
                            if (orginAttributes.TEXCOORD_1) {
                                _copyAccessorBufferArray(glTFAsset, orginAttributes.TEXCOORD_1, tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */]);
                            }
                            else {
                                _fillDefaultArray(tempVertexBuffers["TEXCOORD_1" /* TEXCOORD_1 */], orginVertexCount, [0, 0]);
                            }
                        }
                    }
                    if (meshAttribute["JOINTS_0" /* JOINTS_0 */]) {
                        if (orginAttributes.JOINTS_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.JOINTS_0, tempVertexBuffers["JOINTS_0" /* JOINTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["JOINTS_0" /* JOINTS_0 */], orginVertexCount, [0, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["WEIGHTS_0" /* WEIGHTS_0 */]) {
                        if (orginAttributes.WEIGHTS_0) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.WEIGHTS_0, tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["WEIGHTS_0" /* WEIGHTS_0 */], orginVertexCount, [1, 0, 0, 0]);
                        }
                    }
                    if (meshAttribute["COLOR_1" /* COLOR_1 */]) {
                        if (orginAttributes.COLOR_1) {
                            _copyAccessorBufferArray(glTFAsset, orginAttributes.COLOR_1, tempVertexBuffers["COLOR_1" /* COLOR_1 */]);
                        }
                        else {
                            _fillDefaultArray(tempVertexBuffers["COLOR_1" /* COLOR_1 */], orginVertexCount, [1, 1, 1, 1]);
                        }
                    }
                }
                var subIndexBuffer = glTFAsset.createTypeArrayFromAccessor(glTFAsset.getAccessor(primitive.indices));
                // //indexBuffers
                if (!tempIndexBuffers[i]) {
                    tempIndexBuffers[i] = [];
                }
                for (var j = 0; j < subIndexBuffer.length; j++) {
                    var index = subIndexBuffer[j] + startIndex;
                    tempIndexBuffers[i].push(index);
                    endIndex = index > endIndex ? index : endIndex;
                }
            }
            startIndex = endIndex + 1;
            meshFilter.mesh = null;
        }
        var newVertexBuffers = new Float32Array(combineInstance.vertexBufferSize * combineInstance.vertexCount);
        var newIndexBuffers = new Uint16Array(combineInstance.indexBufferTotalSize);
        var iv = 0;
        for (var key in tempVertexBuffers) {
            var arr = tempVertexBuffers[key];
            for (var _b = 0, arr_1 = arr; _b < arr_1.length; _b++) {
                var v = arr_1[_b];
                newVertexBuffers[iv++] = v;
            }
        }
        var ii = 0;
        for (var key in tempIndexBuffers) {
            var arr = tempIndexBuffers[key];
            for (var _c = 0, arr_2 = arr; _c < arr_2.length; _c++) {
                var v = arr_2[_c];
                newIndexBuffers[ii++] = v;
            }
        }
        var combineMesh = new egret3d.Mesh(newVertexBuffers, newIndexBuffers, tempIndexBuffers[0].length, newAttribute, 1 /* Static */);
        var indicesCount = 0;
        for (var i = 0; i < tempIndexBuffers.length; i++) {
            var subLen = tempIndexBuffers[i].length;
            if (i > 0) {
                //第一个submesh在构造函数中已经添加，需要手动添加后续的
                combineMesh.addSubMesh(indicesCount, subLen, i);
                combineMesh.uploadSubIndexBuffer(i);
            }
            indicesCount += subLen;
        }
        return combineMesh;
    }
    function _copyAccessorBufferArray(gltf, accessor, target) {
        var buffer = gltf.createTypeArrayFromAccessor(gltf.getAccessor(accessor));
        var count = buffer.length;
        var startIndex = target.length;
        target.length += count;
        for (var i = 0; i < count; i++) {
            target[startIndex + i] = buffer[i];
        }
    }
    function _fillDefaultArray(target, count, defaultValue) {
        var startIndex = target.length;
        var defaultValueCount = defaultValue.length;
        target.length += count * defaultValueCount;
        for (var i = 0; i < count; i++) {
            for (var j = 0; j < defaultValueCount; j++) {
                target[startIndex++] = defaultValue[j];
            }
        }
    }
    var CombineInstance = (function () {
        function CombineInstance() {
            this.vertexCount = 0;
            this.vertexBufferSize = 0;
            this.indexBufferTotalSize = 0;
            this.lightmapIndex = -1;
            this.meshAttribute = {};
            this.root = null;
            this.lightmapScaleOffset = null;
            this.instances = [];
        }
        return CombineInstance;
    }());
    __reflect(CombineInstance.prototype, "CombineInstance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * Performance
     * 数据收集
     */
    var Performance = (function () {
        function Performance() {
        }
        Performance.getEntity = function (key) {
            return this._entities[key];
        };
        Performance.getFPS = function () {
            var entity = this.getEntity("fps");
            return (entity && entity.averageDelta) ? Math.floor(1000 / entity.averageDelta) : 0;
        };
        Performance.updateFPS = function () {
            if (!this.enable) {
                return;
            }
            this.endCounter("fps");
            this.startCounter("fps", 60);
        };
        Performance._getNow = function () {
            if (window.performance) {
                return window.performance.now();
            }
            return new Date().getTime();
        };
        Performance.startCounter = function (key, averageRange) {
            if (averageRange === void 0) { averageRange = 1; }
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (!entity) {
                entity = {
                    start: 0,
                    end: 0,
                    delta: 0,
                    _cache: [],
                    averageRange: 1,
                    averageDelta: 0
                };
                this._entities[key] = entity;
            }
            entity.start = this._getNow();
            entity.averageRange = averageRange;
        };
        Performance.endCounter = function (key) {
            if (!this.enable) {
                return;
            }
            var entity = this._entities[key];
            if (entity) {
                entity.end = this._getNow();
                entity.delta = entity.end - entity.start;
                if (entity.averageRange > 1) {
                    entity._cache.push(entity.delta);
                    var length = entity._cache.length;
                    if (length >= entity.averageRange) {
                        if (length > entity.averageRange) {
                            entity._cache.shift();
                            length--;
                        }
                        var sum = 0;
                        for (var i = 0; i < length; i++) {
                            sum += entity._cache[i];
                        }
                        entity.averageDelta = sum / length;
                    }
                }
            }
        };
        Performance._entities = {};
        Performance.enable = false;
        return Performance;
    }());
    egret3d.Performance = Performance;
    __reflect(Performance.prototype, "egret3d.Performance");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var Profile = (function () {
        function Profile() {
        }
        Profile._getNow = function () {
            // if (window.performance) {
            //     return window.performance.now();
            // }
            // return Date.now() * 0.001;
            return new Date().getTime();
        };
        Profile._print = function (list) {
            var totalTime = 0.0;
            for (var _i = 0, list_1 = list; _i < list_1.length; _i++) {
                var item = list_1[_i];
                totalTime += item.time;
            }
            console.log("------------------------");
            for (var _a = 0, list_2 = list; _a < list_2.length; _a++) {
                var item = list_2[_a];
                console.log(item.key + ":用时" + item.time + "平均:" + (item.time / item.count) + "最大值:" + item.maxTime + " 权重:" + (Math.round(item.time / totalTime * 100)) + "%");
            }
        };
        Profile.clear = function () {
            this.profileList.keys.length = 0;
            this.profileList.values.length = 0;
        };
        Profile.startTime = function (key, group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                this.profileList.keys.push(key);
                index = this.profileList.values.length;
                this.profileList.values.push({ key: key, count: 0, startTime: 0, time: 0, group: group, maxTime: 0 });
            }
            var item = this.profileList.values[index];
            item.count++;
            item.startTime = this._getNow();
        };
        Profile.endTime = function (key) {
            if (!this.debug) {
                return;
            }
            var index = this.profileList.keys.indexOf(key);
            if (index < 0) {
                console.log("invalid key error.", this);
            }
            else {
                var item = this.profileList.values[index];
                var d = this._getNow() - item.startTime;
                item.time += d;
                item.maxTime = item.maxTime > d ? item.maxTime : d;
            }
        };
        Profile.printAll = function () {
            if (!this.debug) {
                return;
            }
            var groups = {};
            for (var _i = 0, _a = this.profileList.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (!groups[item.group]) {
                    groups[item.group] = [];
                }
                groups[item.group].push(item);
            }
            for (var key in groups) {
                this._print(groups[key]);
            }
        };
        Profile.print = function (group) {
            if (group === void 0) { group = 0; }
            if (!this.debug) {
                return;
            }
            var list = [];
            for (var _i = 0, _a = this.profileList.values; _i < _a.length; _i++) {
                var item = _a[_i];
                if (item.group === group) {
                    list.push(item);
                }
            }
            this._print(list);
        };
        Profile.test = function () {
            var list0 = [];
            var map = {};
            for (var i = 0; i < 1000; i++) {
                list0.push(i);
                map[i] = i;
            }
            var old = this._getNow();
            for (var _i = 0, list0_1 = list0; _i < list0_1.length; _i++) {
                var i = list0_1[_i];
                console.log("list:");
            }
            console.log("list of用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var i in list0) {
                console.log("list:");
            }
            console.log("list in用时:" + (this._getNow() - old));
            old = this._getNow();
            for (var key in map) {
                console.log("map:");
            }
            console.log("map用时:" + (this._getNow() - old));
        };
        Profile.debug = false;
        Profile.profileList = { keys: [], values: [] };
        return Profile;
    }());
    egret3d.Profile = Profile;
    __reflect(Profile.prototype, "egret3d.Profile");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var programMap = {};
    var vsShaderMap = {};
    var fsShaderMap = {};
    function parseIncludes(string) {
        var pattern = /#include +<([\w\d.]+)>/g;
        //
        function replace(match, include) {
            var replace = egret3d.ShaderChunk[include];
            if (replace === undefined) {
                throw new Error('Can not resolve #include <' + include + '>');
            }
            return parseIncludes(replace);
        }
        //
        return string.replace(pattern, replace);
    }
    function getWebGLShader(type, gl, info, defines) {
        var shader = gl.createShader(type);
        //
        gl.shaderSource(shader, egret3d.WebGLCapabilities.commonDefines + defines + parseIncludes(info.uri));
        gl.compileShader(shader);
        var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        if (!parameter) {
            if (confirm("shader compile:" + info.name + " " + type + " error! ->" + gl.getShaderInfoLog(shader) + "\n" + ". did you want see the code?")) {
                gl.deleteShader(shader);
                alert(info.uri);
            }
            return null;
        }
        return shader;
    }
    /**
     * extract attributes
     */
    function extractAttributes(gl, program) {
        var webglProgram = program.program;
        var totalAttributes = gl.getProgramParameter(webglProgram, gl.ACTIVE_ATTRIBUTES);
        //
        var attributes = {};
        for (var i = 0; i < totalAttributes; i++) {
            var attribData = gl.getActiveAttrib(webglProgram, i);
            var location_4 = gl.getAttribLocation(webglProgram, attribData.name);
            attributes[attribData.name] = { type: attribData.type, size: attribData.size, location: location_4 };
        }
        program.attributes = attributes;
    }
    /**
     * extract uniforms
     */
    function extractUniforms(gl, program) {
        var webglProgram = program.program;
        var totalUniforms = gl.getProgramParameter(webglProgram, gl.ACTIVE_UNIFORMS);
        //
        var uniforms = {};
        for (var i = 0; i < totalUniforms; i++) {
            var uniformData = gl.getActiveUniform(webglProgram, i);
            var location_5 = gl.getUniformLocation(webglProgram, uniformData.name);
            uniforms[uniformData.name] = { type: uniformData.type, size: uniformData.size, location: location_5 };
        }
        program.uniforms = uniforms;
    }
    /**
     * extract texUnits
     */
    function extractTexUnits(program) {
        var activeUniforms = program.uniforms;
        var samplerArrayKeys = [];
        var samplerKeys = [];
        //排序
        for (var key in activeUniforms) {
            var uniform = activeUniforms[key];
            if (uniform.type == 35678 /* SAMPLER_2D */ || uniform.type == 35680 /* SAMPLER_CUBE */) {
                if (key.indexOf("[") > -1) {
                    samplerArrayKeys.push(key);
                }
                else {
                    samplerKeys.push(key);
                }
            }
        }
        program.texUnits = samplerKeys.concat(samplerArrayKeys);
    }
    function allocAttributes(program, technique) {
        var attributes = program.attributes;
        for (var name_2 in technique.attributes) {
            var attribute = technique.attributes[name_2];
            var paperExtension = attribute.extensions.paper;
            if (attributes[name_2]) {
                paperExtension.enable = true;
                paperExtension.location = attributes[name_2].location;
            }
            else {
                paperExtension.enable = false;
            }
        }
    }
    function allocUniforms(program, technique) {
        var uniforms = program.uniforms;
        for (var name_3 in technique.uniforms) {
            var uniform = technique.uniforms[name_3];
            var webglUniform = uniforms[name_3];
            var paperExtension = uniform.extensions.paper;
            if (webglUniform) {
                if (webglUniform.type !== uniform.type) {
                    console.error("Uniform类型不匹配 着色器中类型:" + webglUniform.type + " 文件中类型:" + uniform.type);
                }
                if (webglUniform.size > 1) {
                    uniform.count = webglUniform.size;
                }
                paperExtension.enable = true;
                paperExtension.location = webglUniform.location;
            }
            else {
                paperExtension.enable = false;
                paperExtension.location = null;
            }
        }
    }
    /**
     * allocTexUnits
     */
    function allocTexUnits(program, technique) {
        var uniforms = technique.uniforms;
        var unitNumber = 0;
        for (var _i = 0, _a = program.texUnits; _i < _a.length; _i++) {
            var name_4 = _a[_i];
            var uniform = uniforms[name_4];
            if (uniform && (uniform.type === 35678 /* SAMPLER_2D */ || uniform.type === 35680 /* SAMPLER_CUBE */)) {
                var paperExtension = uniform.extensions.paper;
                if (!paperExtension.textureUnits) {
                    paperExtension.textureUnits = [];
                }
                var textureUnits = paperExtension.textureUnits;
                var count = uniform.count ? uniform.count : 1;
                textureUnits.length = count;
                for (var i = 0; i < count; i++) {
                    textureUnits[i] = unitNumber++;
                }
            }
            else {
                console.error(technique.name + " technique缺少Uniform定义:" + name_4);
            }
        }
    }
    function getWebGLProgram(gl, vs, fs, defines) {
        var program = gl.createProgram();
        var key = vs.name + defines;
        var vertexShader = vsShaderMap[key];
        if (!vertexShader) {
            vertexShader = getWebGLShader(gl.VERTEX_SHADER, gl, vs, defines);
            vsShaderMap[key] = vertexShader;
        }
        key = fs.name + defines;
        var fragmentShader = fsShaderMap[key];
        if (!fragmentShader) {
            fragmentShader = getWebGLShader(gl.FRAGMENT_SHADER, gl, fs, defines);
            fsShaderMap[key] = fragmentShader;
        }
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        var parameter = gl.getProgramParameter(program, gl.LINK_STATUS);
        if (!parameter) {
            alert("program compile: " + vs.name + "_" + fs.name + " error! ->" + gl.getProgramInfoLog(program));
            gl.deleteProgram(program);
            return null;
        }
        return program;
    }
    //TODO 运行时DrawCall排序优化使用
    var _hashCode = 0; //
    /**
     * WebGLProgram的包装类
     */
    var GlProgram = (function () {
        function GlProgram(webglProgram) {
            /**
             * @internal
             */
            this.id = _hashCode++;
            /**
             * @internal
             */
            this.attributes = {};
            /**
             * @internal
             */
            this.uniforms = {};
            /**
             * @internal
             */
            this.texUnits = [];
            this.program = webglProgram;
        }
        GlProgram.getProgram = function (material, technique, defines) {
            var shader = material._glTFShader;
            var extensions = shader.config.extensions.KHR_techniques_webgl;
            var vertexShader = extensions.shaders[0];
            var fragShader = extensions.shaders[1];
            var name = vertexShader.name + "_" + fragShader.name + "_" + defines; //TODO材质标脏可以优化
            var program = programMap[name];
            var webgl = egret3d.WebGLCapabilities.webgl;
            if (!program) {
                var webglProgram = getWebGLProgram(webgl, vertexShader, fragShader, defines);
                program = new GlProgram(webglProgram);
                programMap[name] = program;
                extractAttributes(webgl, program);
                extractUniforms(webgl, program);
                extractTexUnits(program);
            }
            //
            if (technique.program !== program) {
                technique.program = program;
                allocAttributes(program, technique);
                allocUniforms(program, technique);
                allocTexUnits(program, technique);
            }
            return program.program;
        };
        return GlProgram;
    }());
    egret3d.GlProgram = GlProgram;
    __reflect(GlProgram.prototype, "egret3d.GlProgram");
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var TextureReader = (function () {
        function TextureReader(webgl, texRGBA, width, height, gray) {
            if (gray === void 0) { gray = true; }
            this.gray = gray;
            this.width = width;
            this.height = height;
            var fbo = webgl.createFramebuffer();
            var fbold = webgl.getParameter(webgl.FRAMEBUFFER_BINDING);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbo);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, texRGBA, 0);
            var readData = new Uint8Array(this.width * this.height * 4);
            readData[0] = 2;
            webgl.readPixels(0, 0, this.width, this.height, webgl.RGBA, webgl.UNSIGNED_BYTE, readData);
            webgl.deleteFramebuffer(fbo);
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, fbold);
            if (gray) {
                this.data = new Uint8Array(this.width * this.height);
                for (var i = 0; i < width * height; i++) {
                    this.data[i] = readData[i * 4];
                }
            }
            else {
                this.data = readData;
            }
        }
        TextureReader.prototype.getPixel = function (u, v) {
            var x = (u * this.width) | 0;
            var y = (v * this.height) | 0;
            if (x < 0 || x >= this.width || y < 0 || y >= this.height)
                return 0;
            if (this.gray) {
                return this.data[y * this.width + x];
            }
            else {
                var i = (y * this.width + x) * 4;
                return new egret3d.Color(this.data[i], this.data[i + 1], this.data[i + 2], this.data[i + 3]);
            }
        };
        return TextureReader;
    }());
    egret3d.TextureReader = TextureReader;
    __reflect(TextureReader.prototype, "egret3d.TextureReader");
    var GlRenderTarget = (function () {
        function GlRenderTarget(webgl, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            this.width = width;
            this.height = height;
            this.fbo = webgl.createFramebuffer();
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            if (depth || stencil) {
                this.renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
            this.texture = webgl.createTexture();
            this.fbo["width"] = width;
            this.fbo["height"] = height;
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
        }
        GlRenderTarget.prototype.use = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            // webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
            // webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            //webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_2D, this.texture, 0);
        };
        GlRenderTarget.useNull = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTarget.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null)
            //    this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteFramebuffer(this.renderbuffer);
                this.renderbuffer = null;
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlRenderTarget.prototype.caclByteLength = function () {
            //RGBA & no mipmap
            return this.width * this.height * 4;
        };
        GlRenderTarget.prototype.isFrameBuffer = function () {
            return true;
        };
        return GlRenderTarget;
    }());
    egret3d.GlRenderTarget = GlRenderTarget;
    __reflect(GlRenderTarget.prototype, "egret3d.GlRenderTarget", ["egret3d.IRenderTarget", "egret3d.ITexture"]);
    var GlRenderTargetCube = (function () {
        function GlRenderTargetCube(webgl, width, height, depth, stencil) {
            if (depth === void 0) { depth = false; }
            if (stencil === void 0) { stencil = false; }
            this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
            this.width = width;
            this.height = height;
            this.fbo = webgl.createFramebuffer();
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            if (depth || stencil) {
                this.renderbuffer = webgl.createRenderbuffer();
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
                if (depth && stencil) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_STENCIL, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else if (depth) {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.DEPTH_COMPONENT16, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.DEPTH_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                else {
                    webgl.renderbufferStorage(webgl.RENDERBUFFER, webgl.STENCIL_INDEX8, width, height);
                    webgl.framebufferRenderbuffer(webgl.FRAMEBUFFER, webgl.STENCIL_ATTACHMENT, webgl.RENDERBUFFER, this.renderbuffer);
                }
                webgl.bindRenderbuffer(webgl.RENDERBUFFER, null);
            }
            this.texture = webgl.createTexture();
            this.fbo["width"] = width;
            this.fbo["height"] = height;
            webgl.bindTexture(webgl.TEXTURE_CUBE_MAP, this.texture);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
            webgl.texParameteri(webgl.TEXTURE_CUBE_MAP, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            for (var i = 0; i < 6; i++) {
                webgl.texImage2D(webgl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, webgl.RGBA, width, height, 0, webgl.RGBA, webgl.UNSIGNED_BYTE, null);
            }
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        }
        GlRenderTargetCube.prototype.use = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, this.fbo);
            // webgl.bindRenderbuffer(webgl.RENDERBUFFER, this.renderbuffer);
            // webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            webgl.framebufferTexture2D(webgl.FRAMEBUFFER, webgl.COLOR_ATTACHMENT0, webgl.TEXTURE_CUBE_MAP_POSITIVE_X + this.activeCubeFace, this.texture, 0);
        };
        GlRenderTargetCube.useNull = function (webgl) {
            webgl.bindFramebuffer(webgl.FRAMEBUFFER, null);
        };
        GlRenderTargetCube.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null)
            //    this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteFramebuffer(this.renderbuffer);
                this.renderbuffer = null;
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlRenderTargetCube.prototype.caclByteLength = function () {
            //RGBA & no mipmap
            return this.width * this.height * 4;
        };
        GlRenderTargetCube.prototype.isFrameBuffer = function () {
            return true;
        };
        return GlRenderTargetCube;
    }());
    egret3d.GlRenderTargetCube = GlRenderTargetCube;
    __reflect(GlRenderTargetCube.prototype, "egret3d.GlRenderTargetCube", ["egret3d.IRenderTarget", "egret3d.ITexture"]);
    /**
     *
     */
    var GlTexture2D = (function () {
        function GlTexture2D(webgl, format, mipmap, linear) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (mipmap === void 0) { mipmap = false; }
            if (linear === void 0) { linear = true; }
            this.width = 0;
            this.height = 0;
            this.mipmap = false;
            this.webgl = webgl;
            this.format = format;
            this.texture = webgl.createTexture();
        }
        GlTexture2D.prototype.uploadImage = function (img, mipmap, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = img.width;
            this.height = img.height;
            this.mipmap = mipmap;
            var webgl = this.webgl;
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            var formatGL = webgl.RGBA;
            if (this.format == 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (this.format == 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, formatGL, webgl.UNSIGNED_BYTE, img);
            if (mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            var wrap_s_param = webgl.CLAMP_TO_EDGE;
            var wrap_t_param = webgl.CLAMP_TO_EDGE;
            if (repeat) {
                wrap_s_param = mirroredU ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
                wrap_t_param = mirroredV ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
            }
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrap_s_param);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrap_t_param);
        };
        GlTexture2D.prototype.uploadByteArray = function (mipmap, linear, width, height, data, repeat, mirroredU, mirroredV) {
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = width;
            this.height = height;
            this.mipmap = mipmap;
            var webgl = this.webgl;
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 1);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            var formatGL = webgl.RGBA;
            if (this.format == 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (this.format == 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, webgl.UNSIGNED_BYTE, data);
            if (mipmap) {
                webgl.generateMipmap(webgl.TEXTURE_2D);
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR_MIPMAP_LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST_MIPMAP_NEAREST);
                }
            }
            else {
                if (linear) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
                }
            }
            var wrap_s_param = webgl.CLAMP_TO_EDGE;
            var wrap_t_param = webgl.CLAMP_TO_EDGE;
            if (repeat) {
                wrap_s_param = mirroredU ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
                wrap_t_param = mirroredV ? webgl.MIRRORED_REPEAT : webgl.REPEAT;
            }
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, wrap_s_param);
            webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, wrap_t_param);
        };
        GlTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            if (this.mipmap) {
                len = len * (1 - Math.pow(0.25, 10)) / 0.75;
            }
            return len;
        };
        GlTexture2D.prototype.getReader = function (redOnly) {
            if (redOnly === void 0) { redOnly = false; }
            if (this.reader != null) {
                if (this.reader.gray != redOnly)
                    throw new Error("get param diff with this.reader");
                return this.reader;
            }
            if (this.format != 1 /* RGBA */)
                throw new Error("only rgba texture can read");
            if (this.texture == null)
                return null;
            if (this.reader == null)
                this.reader = new TextureReader(this.webgl, this.texture, this.width, this.height, redOnly);
            return this.reader;
        };
        //disposeit: boolean = false;
        GlTexture2D.prototype.dispose = function (webgl) {
            //if (this.texture == null && this.img != null) this.disposeit = true;
            if (this.texture != null) {
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        GlTexture2D.prototype.isFrameBuffer = function () {
            return false;
        };
        GlTexture2D.createColorTexture = function (webgl, r, g, b) {
            var mipmap = false;
            var linear = true;
            var width = 1;
            var height = 1;
            var texture = new GlTexture2D(webgl, 1 /* RGBA */, mipmap, linear);
            var data = new Uint8Array([r, g, b, 255]);
            texture.uploadByteArray(mipmap, linear, width, height, data);
            return texture;
        };
        GlTexture2D.createGridTexture = function (webgl) {
            var mipmap = false;
            var linear = true;
            var t = new GlTexture2D(webgl, 1 /* RGBA */, mipmap, linear);
            var width = 256;
            var height = 256;
            var data = new Uint8Array(width * width * 4);
            for (var y = 0; y < height; y++) {
                for (var x = 0; x < width; x++) {
                    var seek = (y * width + x) * 4;
                    var bool = ((x - width * 0.5) * (y - height * 0.5)) > 0;
                    data[seek] = data[seek + 1] = data[seek + 2] = bool ? 0 : 255;
                    data[seek + 3] = 255;
                }
            }
            t.uploadByteArray(mipmap, linear, width, height, data);
            return t;
        };
        return GlTexture2D;
    }());
    egret3d.GlTexture2D = GlTexture2D;
    __reflect(GlTexture2D.prototype, "egret3d.GlTexture2D", ["egret3d.ITexture"]);
    var WriteableTexture2D = (function () {
        function WriteableTexture2D(webgl, format, width, height, linear, premultiply, repeat, mirroredU, mirroredV) {
            if (format === void 0) { format = 1 /* RGBA */; }
            if (premultiply === void 0) { premultiply = true; }
            if (repeat === void 0) { repeat = false; }
            if (mirroredU === void 0) { mirroredU = false; }
            if (mirroredV === void 0) { mirroredV = false; }
            this.width = 0;
            this.height = 0;
            webgl = webgl;
            this.texture = webgl.createTexture();
            webgl.pixelStorei(webgl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, premultiply ? 1 : 0);
            webgl.pixelStorei(webgl.UNPACK_FLIP_Y_WEBGL, 0);
            webgl.bindTexture(webgl.TEXTURE_2D, this.texture);
            this.format = format;
            var formatGL = webgl.RGBA;
            if (format == 2 /* RGB */) {
                formatGL = webgl.RGB;
            }
            else if (format == 3 /* Gray */) {
                formatGL = webgl.LUMINANCE;
            }
            var data = null;
            webgl.texImage2D(webgl.TEXTURE_2D, 0, formatGL, width, height, 0, formatGL, webgl.UNSIGNED_BYTE, data);
            if (linear) {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.NEAREST);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.NEAREST);
            }
            if (repeat) {
                if (mirroredU && mirroredV) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.MIRRORED_REPEAT);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.MIRRORED_REPEAT);
                }
                else if (mirroredU) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.MIRRORED_REPEAT);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.REPEAT);
                }
                else if (mirroredV) {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.REPEAT);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.MIRRORED_REPEAT);
                }
                else {
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.REPEAT);
                    webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.REPEAT);
                }
            }
            else {
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_S, webgl.CLAMP_TO_EDGE);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_WRAP_T, webgl.CLAMP_TO_EDGE);
            }
        }
        WriteableTexture2D.prototype.isFrameBuffer = function () {
            return false;
        };
        WriteableTexture2D.prototype.dispose = function (webgl) {
            if (this.texture != null) {
                webgl.deleteTexture(this.texture);
                this.texture = null;
            }
        };
        WriteableTexture2D.prototype.caclByteLength = function () {
            var pixellen = 1;
            if (this.format == 1 /* RGBA */) {
                pixellen = 4;
            }
            else if (this.format == 2 /* RGB */) {
                pixellen = 3;
            }
            var len = this.width * this.height * pixellen;
            return len;
        };
        return WriteableTexture2D;
    }());
    egret3d.WriteableTexture2D = WriteableTexture2D;
    __reflect(WriteableTexture2D.prototype, "egret3d.WriteableTexture2D", ["egret3d.ITexture"]);
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    /**
     * @deprecated
     */
    egret3d.Prefab = paper.Prefab;
    /**
     * @deprecated
     */
    egret3d.RawScene = paper.RawScene;
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 场景编辑器
         **/
        var Editor = (function () {
            function Editor() {
            }
            Object.defineProperty(Editor, "editorModel", {
                /**编辑模型 */
                get: function () {
                    return this._editorModel;
                },
                enumerable: true,
                configurable: true
            });
            /**初始化 */
            Editor.init = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                // 覆盖生成 uuid 的方式。
                                paper.createUUID = editor.generateUuid;
                                paper.createAssetID = editor.generateUuid;
                                //启动egret3编辑环境
                                this.runEgret();
                                return [4 /*yield*/, RES.loadConfig("resource/default.res.json", "resource/")];
                            case 1:
                                _a.sent();
                                this.history = new editor.History();
                                //初始化编辑模型
                                this._editorModel = new editor.EditorModel();
                                this._editorModel.init(this.history);
                                return [2 /*return*/];
                        }
                    });
                });
            };
            Editor.runEgret = function () {
                egret3d.runEgret({
                    antialias: false,
                    systems: [
                        egret3d.BeginSystem,
                        paper.EnableSystem,
                        paper.StartSystem,
                        //
                        paper.UpdateSystem,
                        //
                        egret3d.AnimationSystem,
                        //
                        paper.LateUpdateSystem,
                        //
                        egret3d.MeshRendererSystem,
                        egret3d.SkinnedMeshRendererSystem,
                        egret3d.particle.ParticleSystem,
                        egret3d.Egret2DRendererSystem,
                        //
                        egret3d.CameraSystem,
                        egret3d.WebGLRenderSystem,
                        //
                        paper.DisableSystem,
                        egret3d.EndSystem
                    ]
                });
                // 摄像机激活场景设置为编辑场景。
                paper.Application.sceneManager.camerasScene = paper.Application.sceneManager.editorScene;
                // 创建编辑器的相机。
                this._createEditCamera();
                //
                editor.Gizmo.Enabled();
            };
            /**切换场景 */
            Editor.switchScene = function (url) {
                var _this = this;
                paper.Application.sceneManager.unloadAllScene();
                // Application.callLater(() => {
                this.loadEditScene(url).then(function () {
                    _this.editorModel.dispatchEvent(new editor.EditorModelEvent(editor.EditorModelEvent.CHANGE_SCENE, url));
                });
                // });
            };
            Editor.loadEditScene = function (url) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(url)];
                            case 1:
                                _a.sent();
                                this.loadScene(url, true);
                                return [2 /*return*/];
                        }
                    });
                });
            };
            //此方法是对Application.sceneManager.loadScene的一个重写，增加keepUUID参数
            Editor.loadScene = function (resourceName, keepUUID) {
                if (keepUUID === void 0) { keepUUID = false; }
                var rawScene = RES.getRes(resourceName);
                if (rawScene) {
                    var scene = rawScene.createInstance(keepUUID);
                    return scene;
                }
                return null;
            };
            Editor._createEditCamera = function () {
                var cameraObject = paper.GameObject.create("EditorCamera", "EditorOnly" /* EditorOnly */, paper.Application.sceneManager.editorScene);
                {
                    var camera = cameraObject.addComponent(egret3d.Camera);
                    camera.near = 0.1;
                    camera.far = 100.0;
                    camera.backgroundColor.set(0.13, 0.28, 0.51, 1.00);
                    cameraObject.transform.setLocalPosition(0.0, 10.0, -10.0);
                    cameraObject.transform.lookAt(egret3d.Vector3.ZERO);
                }
                {
                    var script = cameraObject.addComponent(editor.EditorCameraScript);
                    script.editorModel = this.editorModel;
                    script.moveSpeed = 10;
                    script.rotateSpeed = 0.5;
                }
                {
                    var script = cameraObject.addComponent(editor.PickGameObjectScript);
                    script.editorModel = this.editorModel;
                }
            };
            Editor.undo = function () {
                this.history.back();
            };
            Editor.redo = function () {
                this.history.forward();
            };
            Editor.deserializeHistory = function (data) {
                this.history.deserialize(data);
            };
            Editor.serializeHistory = function () {
                var historyData = this.history.serialize();
                return JSON.stringify(historyData);
            };
            return Editor;
        }());
        editor.Editor = Editor;
        __reflect(Editor.prototype, "paper.editor.Editor");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var ContactColliders = (function (_super) {
        __extends(ContactColliders, _super);
        function ContactColliders() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            /**
             *
             */
            _this.begin = [];
            /**
             *
             */
            _this.stay = [];
            /**
             *
             */
            _this.end = [];
            return _this;
        }
        return ContactColliders;
    }(paper.SingletonComponent));
    paper.ContactColliders = ContactColliders;
    __reflect(ContactColliders.prototype, "paper.ContactColliders");
})(paper || (paper = {}));
var paper;
(function (paper) {
    var KEY_UUID = "uuid";
    var KEY_ASSET = "asset";
    var KEY_CLASS = "class";
    var KEY_DESERIALIZE = "deserialize";
    var KEY_COMPONENTS = "components";
    var KEY_CHILDREN = "children";
    var _isKeepUUID = false;
    var _deserializedData = null;
    /**
     * 反序列化。
     */
    function deserialize(data, isKeepUUID) {
        if (isKeepUUID === void 0) { isKeepUUID = false; }
        if (_deserializedData) {
            console.debug("The deserialization is not complete.");
        }
        _isKeepUUID = isKeepUUID;
        _deserializedData = { assets: data.assets || [], objects: {}, components: {} };
        var sceneClassName = egret.getQualifiedClassName(paper.Scene);
        var components = {};
        var root = null;
        if (data.components) {
            for (var _i = 0, _a = data.components; _i < _a.length; _i++) {
                var componentSource = _a[_i];
                components[componentSource.uuid] = componentSource;
            }
        }
        if (data.objects) {
            for (var _b = 0, _c = data.objects; _b < _c.length; _b++) {
                var source = _c[_b];
                var className = paper.serializeClassMap[source.class] || source.class;
                var target = void 0;
                if (className === sceneClassName) {
                    target = paper.Application.sceneManager.createScene("");
                }
                else {
                    target = paper.GameObject.create();
                    if (KEY_COMPONENTS in source) {
                        for (var _d = 0, _e = source[KEY_COMPONENTS]; _d < _e.length; _d++) {
                            var componentUUID = _e[_d];
                            var uuid = componentUUID.uuid;
                            var componentSource = components[uuid];
                            var className_1 = paper.serializeClassMap[componentSource.class] || componentSource.class;
                            if (className_1 === egret.getQualifiedClassName(egret3d.Transform)) {
                                _deserializedData.components[uuid] = target.transform;
                            }
                        }
                    }
                }
                _deserializedData.objects[source.uuid] = target;
                root = root || target;
            }
            var i = data.objects.length;
            while (i--) {
                var source = data.objects[i];
                var target = _deserializedData.objects[source.uuid];
                _deserializeObject(source, target);
                if (target.constructor === paper.GameObject && KEY_COMPONENTS in source) {
                    for (var _f = 0, _g = source[KEY_COMPONENTS]; _f < _g.length; _f++) {
                        var componentUUID = _g[_f];
                        var uuid = componentUUID.uuid;
                        var componentSource = components[uuid];
                        var className = paper.serializeClassMap[componentSource.class] || componentSource.class;
                        var clazz = egret.getDefinitionByName(className);
                        if (clazz) {
                            if (clazz === egret3d.Transform) {
                                var transform = _deserializedData.components[uuid];
                                if (KEY_CHILDREN in componentSource) {
                                    for (var _h = 0, _j = componentSource[KEY_CHILDREN]; _h < _j.length; _h++) {
                                        var childUUID = _j[_h];
                                        var child = _deserializedData.components[childUUID.uuid];
                                        child._parent = transform;
                                        transform._children.push(child);
                                    }
                                }
                                root = root || transform;
                            }
                            else {
                                var component = target.addComponent(clazz);
                                _deserializedData.components[uuid] = component;
                                if (clazz === paper.Behaviour) {
                                    component._isReseted = true;
                                }
                                root = root || component;
                            }
                        }
                        else {
                            var component = target.addComponent(paper.MissingComponent);
                            component.missingObject = componentSource;
                            _deserializedData.components[uuid] = component;
                            root = root || component;
                            console.warn("Class " + className + " is not defined.");
                        }
                    }
                }
            }
        }
        if (data.components) {
            for (var _k = 0, _l = data.components; _k < _l.length; _k++) {
                var componentSource = _l[_k];
                var uuid = componentSource.uuid;
                var component = _deserializedData.components[uuid];
                if (component.constructor === paper.MissingComponent) {
                    continue;
                }
                _deserializeObject(componentSource, component);
            }
        }
        _deserializedData = null;
        return root;
    }
    paper.deserialize = deserialize;
    /**
     *
     */
    function getDeserializedAssetOrComponent(source) {
        if (KEY_ASSET in source) {
            return paper.Asset.find(_deserializedData.assets[source[KEY_ASSET]]);
        }
        var uuid = source[KEY_UUID];
        return _deserializedData.components[uuid] || _deserializedData.objects[uuid];
    }
    paper.getDeserializedAssetOrComponent = getDeserializedAssetOrComponent;
    function _deserializeObject(source, target) {
        if (target.constructor.prototype.hasOwnProperty(KEY_DESERIALIZE)) {
            var uuid = source[KEY_UUID];
            if (_isKeepUUID && uuid) {
                delete source[KEY_UUID];
            }
            target.deserialize(source);
            if (_isKeepUUID && uuid) {
                source[KEY_UUID] = uuid;
            }
        }
        else {
            for (var k in source) {
                if (k === KEY_CLASS) {
                    continue;
                }
                if (!_isKeepUUID && k === KEY_UUID) {
                    continue;
                }
                if ("__deserializedIgnore" /* DeserializedIgnore */ in target &&
                    target["__deserializedIgnore" /* DeserializedIgnore */].indexOf(k) >= 0) {
                    continue;
                }
                target[k] = _deserializeChild(source[k], target[k]);
            }
        }
    }
    function _deserializeChild(source, target) {
        if (source === null || source === undefined) {
            return source;
        }
        switch (typeof source) {
            case "function":
                return undefined;
            case "object": {
                if (target) {
                    if (ArrayBuffer.isView(target)) {
                        for (var i = 0, l = Math.min(source.length, target.length); i < l; ++i) {
                            target[i] = source[i];
                        }
                        return target;
                    }
                    else if (Array.isArray(target) && target.length === 0) {
                        for (var i = 0, l = source.length; i < l; ++i) {
                            target[i] = _deserializeChild(source[i]);
                        }
                        return target;
                    }
                    else if (target.constructor.prototype.hasOwnProperty(KEY_DESERIALIZE) &&
                        !(target instanceof paper.BaseComponent)) {
                        _deserializeObject(source, target);
                        return target;
                    }
                    else {
                        // console.info("Deserialize can be optimized.");
                    }
                }
                if (Array.isArray(source)) {
                    target = [];
                    for (var i = 0, l = source.length; i < l; ++i) {
                        target[i] = _deserializeChild(source[i]);
                    }
                    return target;
                }
                var classCodeOrName = source[KEY_CLASS];
                if (KEY_UUID in source) {
                    var uuid = source[KEY_UUID];
                    if (uuid in _deserializedData.objects) {
                        return _deserializedData.objects[uuid];
                    }
                    else if (uuid in _deserializedData.components) {
                        return _deserializedData.components[uuid];
                    }
                    else if (classCodeOrName) {
                        if ((paper.serializeClassMap[classCodeOrName] || classCodeOrName) === egret.getQualifiedClassName(paper.GameObject)) {
                            for (var _i = 0, _a = paper.Application.sceneManager.activeScene.gameObjects; _i < _a.length; _i++) {
                                var gameObject = _a[_i];
                                if (gameObject.uuid === uuid) {
                                    return gameObject;
                                }
                            }
                        }
                        else {
                            for (var _b = 0, _c = paper.Application.sceneManager.activeScene.gameObjects; _b < _c.length; _b++) {
                                var gameObject = _c[_b];
                                for (var _d = 0, _e = gameObject.components; _d < _e.length; _d++) {
                                    var component = _e[_d];
                                    if (component && component.uuid === uuid) {
                                        return component;
                                    }
                                }
                            }
                        }
                    }
                }
                else if (KEY_ASSET in source) {
                    var index = source[KEY_ASSET];
                    if (index >= 0) {
                        return paper.Asset.find(_deserializedData.assets[index]);
                    }
                    return null;
                }
                else if (classCodeOrName) {
                    var clazz = egret.getDefinitionByName(paper.serializeClassMap[classCodeOrName] || classCodeOrName);
                    if (clazz) {
                        target = new clazz();
                        _deserializeObject(source, target);
                        return target;
                    }
                }
                else {
                    target = {};
                    for (var k in source) {
                        target[k] = _deserializeChild(source[k]);
                    }
                    return target;
                }
                console.warn("Deserialize error.", source);
                return null;
            }
            default:
                return source;
        }
    }
})(paper || (paper = {}));
/// <reference path="./EventDispatcher.ts" />
var paper;
(function (paper_1) {
    var editor;
    (function (editor) {
        editor.context = new editor.EventDispatcher();
        var selectItemType;
        (function (selectItemType) {
            selectItemType[selectItemType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            selectItemType[selectItemType["ASSET"] = 1] = "ASSET";
        })(selectItemType = editor.selectItemType || (editor.selectItemType = {}));
        /**
         * 编辑模型事件
         */
        var EditorModelEvent = (function (_super) {
            __extends(EditorModelEvent, _super);
            function EditorModelEvent(type, data) {
                return _super.call(this, type, data) || this;
            }
            EditorModelEvent.ADD_GAMEOBJECTS = "addGameObject";
            EditorModelEvent.DELETE_GAMEOBJECTS = "deleteGameObject";
            EditorModelEvent.SELECT_GAMEOBJECTS = "selectGame";
            EditorModelEvent.CHANGE_PROPERTY = "changeProperty";
            EditorModelEvent.CHANGE_EDIT_MODE = "changeEditMode";
            EditorModelEvent.CHANGE_EDIT_TYPE = "changeEditType";
            EditorModelEvent.CHANGE_SCENE = "changeScene";
            EditorModelEvent.ADD_COMPONENT = "addComponent";
            EditorModelEvent.REMOVE_COMPONENT = "removeComponent";
            EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY = "updateGameObjectsHierarchy";
            return EditorModelEvent;
        }(editor.BaseEvent));
        editor.EditorModelEvent = EditorModelEvent;
        __reflect(EditorModelEvent.prototype, "paper.editor.EditorModelEvent");
        var ModifyObjectType;
        (function (ModifyObjectType) {
            ModifyObjectType[ModifyObjectType["GAMEOBJECT"] = 0] = "GAMEOBJECT";
            ModifyObjectType[ModifyObjectType["BASECOMPONENT"] = 1] = "BASECOMPONENT";
        })(ModifyObjectType = editor.ModifyObjectType || (editor.ModifyObjectType = {}));
        /**
         * 编辑模型
         */
        var EditorModel = (function (_super) {
            __extends(EditorModel, _super);
            function EditorModel() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.getRootGameObjectsByPrefab = function (prefab) {
                    var objects = paper_1.Application.sceneManager.activeScene.gameObjects;
                    var result = [];
                    objects.forEach(function (obj) {
                        if (obj.prefab && obj.prefab.name === prefab.name && editor.Editor.editorModel.isPrefabRoot(obj)) {
                            result.push(obj);
                        }
                    });
                    return result;
                };
                return _this;
            }
            EditorModel.prototype.setBackRuntime = function (back) {
                this.backRunTime = back;
            };
            /**
             * 初始化
             * @param history
             */
            EditorModel.prototype.init = function (history) {
                this.history = history;
            };
            EditorModel.prototype.addState = function (state) {
                state && this.history.add(state);
            };
            EditorModel.prototype.getEditType = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName) {
                        return element.editType;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTransformProperty = function (propName, propValue, target) {
                var valueEditType = this.getEditType(propName, target);
                if (valueEditType != null) {
                    var newPropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(propValue, valueEditType),
                        valueEditType: valueEditType
                    };
                    var prePropertyData = {
                        propName: propName,
                        copyValue: this.serializeProperty(target[propName], valueEditType),
                        valueEditType: valueEditType
                    };
                    this.createModifyComponent(target.gameObject.uuid, target.uuid, [newPropertyData], [prePropertyData]);
                }
            };
            EditorModel.prototype.createModifyGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyGameObjectPropertyState.create(gameObjectUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyComponent = function (gameObjectUUid, componentUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyComponentPropertyState.create(gameObjectUUid, componentUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyPrefabGameObjectPropertyState = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyPrefabGameObjectPropertyState.create(gameObjectUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createModifyPrefabComponentPropertyState = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = editor.ModifyPrefabComponentPropertyState.create(gameObjUUid, componentUUid, newValueList, preValueCopylist);
                this.addState(state);
            };
            EditorModel.prototype.createRemoveComponentFromPrefab = function (stateData) {
                var data = __assign({}, stateData);
                var state = editor.RemovePrefabComponentState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createAddComponentToPrefab = function (sourceData, instanceDatas) {
                var state = editor.AddPrefabComponentState.create(sourceData, instanceDatas);
                this.addState(state);
            };
            EditorModel.prototype.createModifyAssetPropertyState = function (assetUrl, newValueList, preValueCopylist) {
                var data = {
                    assetUrl: assetUrl,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                var state = editor.ModifyAssetPropertyState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.createPrefabState = function (prefab) {
                var state = editor.CreatePrefabState.create({ prefab: prefab });
                this.addState(state);
            };
            EditorModel.prototype.serializeProperty = function (value, editType) {
                switch (editType) {
                    case editor.EditType.NUMBER:
                    case editor.EditType.TEXT:
                    case editor.EditType.CHECKBOX:
                        return value;
                    case editor.EditType.VECTOR2:
                    case editor.EditType.VECTOR3:
                    case editor.EditType.VECTOR4:
                    case editor.EditType.QUATERNION:
                    case editor.EditType.COLOR:
                    case editor.EditType.RECT:
                        var className = egret.getQualifiedClassName(value);
                        var serializeData = paper_1.serialize(value);
                        return { className: className, serializeData: serializeData };
                    case editor.EditType.SHADER:
                        return value.url;
                    case editor.EditType.LIST:
                        return value;
                    case editor.EditType.MATERIAL_ARRAY:
                        var data = value.map(function (item) {
                            var url = item.url.substr(RES.config.config.resourceRoot.length, item.url.length);
                            return { name: url, url: url };
                        });
                        return data;
                    case editor.EditType.MESH:
                        var url = value.glTFAsset.url;
                        url = url.substr(RES.config.config.resourceRoot.length, url.length);
                        return url;
                    case editor.EditType.MATERIAL:
                    case editor.EditType.GAMEOBJECT:
                    case editor.EditType.TRANSFROM:
                    case editor.EditType.SOUND:
                    case editor.EditType.ARRAY:
                        //TODO
                        console.error("not supported!");
                        break;
                    default:
                        break;
                }
            };
            EditorModel.prototype.deserializeProperty = function (serializeData, editType) {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, clazz, target, url, asset, materials, _i, serializeData_1, matrial, asset_1, meshAsset, mesh;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = editType;
                                switch (_a) {
                                    case editor.EditType.NUMBER: return [3 /*break*/, 1];
                                    case editor.EditType.TEXT: return [3 /*break*/, 1];
                                    case editor.EditType.CHECKBOX: return [3 /*break*/, 1];
                                    case editor.EditType.VECTOR2: return [3 /*break*/, 2];
                                    case editor.EditType.VECTOR3: return [3 /*break*/, 2];
                                    case editor.EditType.VECTOR4: return [3 /*break*/, 2];
                                    case editor.EditType.QUATERNION: return [3 /*break*/, 2];
                                    case editor.EditType.COLOR: return [3 /*break*/, 2];
                                    case editor.EditType.RECT: return [3 /*break*/, 2];
                                    case editor.EditType.SHADER: return [3 /*break*/, 3];
                                    case editor.EditType.LIST: return [3 /*break*/, 5];
                                    case editor.EditType.MATERIAL_ARRAY: return [3 /*break*/, 6];
                                    case editor.EditType.MESH: return [3 /*break*/, 11];
                                    case editor.EditType.MATERIAL: return [3 /*break*/, 13];
                                    case editor.EditType.GAMEOBJECT: return [3 /*break*/, 13];
                                    case editor.EditType.TRANSFROM: return [3 /*break*/, 13];
                                    case editor.EditType.SOUND: return [3 /*break*/, 13];
                                    case editor.EditType.ARRAY: return [3 /*break*/, 13];
                                }
                                return [3 /*break*/, 14];
                            case 1: return [2 /*return*/, serializeData];
                            case 2:
                                clazz = egret.getDefinitionByName(serializeData.className);
                                target = null;
                                if (clazz) {
                                    target = new clazz();
                                    target.deserialize(serializeData.serializeData.objects[0]);
                                }
                                return [2 /*return*/, target];
                            case 3:
                                url = serializeData;
                                return [4 /*yield*/, RES.getResAsync(url)];
                            case 4:
                                asset = _b.sent();
                                return [2 /*return*/, asset];
                            case 5: return [2 /*return*/, serializeData];
                            case 6:
                                materials = [];
                                _i = 0, serializeData_1 = serializeData;
                                _b.label = 7;
                            case 7:
                                if (!(_i < serializeData_1.length)) return [3 /*break*/, 10];
                                matrial = serializeData_1[_i];
                                return [4 /*yield*/, RES.getResAsync(matrial.url)];
                            case 8:
                                asset_1 = _b.sent();
                                materials.push(asset_1);
                                _b.label = 9;
                            case 9:
                                _i++;
                                return [3 /*break*/, 7];
                            case 10: return [2 /*return*/, materials];
                            case 11: return [4 /*yield*/, RES.getResAsync(serializeData)];
                            case 12:
                                meshAsset = _b.sent();
                                mesh = new egret3d.Mesh(meshAsset, 0);
                                return [2 /*return*/, mesh];
                            case 13:
                                //TODO
                                console.error("not supported!");
                                return [2 /*return*/, null];
                            case 14: return [3 /*break*/, 15];
                            case 15: return [2 /*return*/];
                        }
                    });
                });
            };
            EditorModel.prototype.createGameObject = function (parentList, createType) {
                var state = editor.CreateGameObjectState.create(parentList, createType);
                this.addState(state);
            };
            EditorModel.prototype.addComponent = function (gameObjectUUid, compClzName) {
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    compClzName: compClzName
                };
                var state = editor.AddComponentState.create(data);
                this.addState(state);
            };
            /**
            *  TODO:因gameobject未提供通过组件实例添加组件的方法，暂时这样处理
            * @param gameObject
            * @param component
            */
            EditorModel.prototype.addComponentToGameObject = function (gameObject, component) {
                var components = gameObject.components;
                components.push(component);
                component.initialize();
                if (component.isActiveAndEnabled) {
                    paper.EventPool.dispatchEvent("__enabled__" /* Enabled */, component);
                }
            };
            EditorModel.prototype.removeComponent = function (gameObjectUUid, componentUUid) {
                var obj = this.getGameObjectByUUid(gameObjectUUid);
                if (!obj) {
                    return;
                }
                var removeComponent = this.getComponentById(obj, componentUUid);
                if (!removeComponent) {
                    return;
                }
                var serializeData = paper_1.serialize(removeComponent);
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    componentUUid: componentUUid,
                    serializeData: serializeData,
                };
                var state = editor.RemoveComponentState.create(data);
                this.addState(state);
            };
            EditorModel.prototype.getComponentById = function (gameObject, componentId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.uuid === componentId) {
                        return comp;
                    }
                }
                return null;
            };
            EditorModel.prototype.getComponentByAssetId = function (gameObject, assetId) {
                for (var i = 0; i < gameObject.components.length; i++) {
                    var comp = gameObject.components[i];
                    if (comp.assetID === assetId) {
                        return comp;
                    }
                }
                return null;
                ;
            };
            EditorModel.prototype.copy = function (objs) {
                var clipboard = __global.runtimeModule.getClipborad();
                var content = [];
                //过滤
                this.filtTopHierarchyGameObjects(objs);
                //排序
                objs = this.sortGameObjectsForHierarchy(objs);
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    content.push({
                        type: "gameObject",
                        serializeData: paper_1.serialize(obj)
                    });
                }
                clipboard.writeText(JSON.stringify(content), "paper");
            };
            EditorModel.prototype.pasteGameObject = function (parent) {
                var clipboard = __global.runtimeModule.getClipborad();
                var msg = clipboard.readText("paper");
                var content = JSON.parse(msg);
                if (content && content.length > 0) {
                    var objData = [];
                    for (var i = 0; i < content.length; i++) {
                        objData.push(content[i].serializeData);
                    }
                    var state = editor.PasteGameObjectsState.create(objData, parent);
                    this.addState(state);
                }
            };
            /**
             * 克隆游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.duplicateGameObjects = function (gameObjects) {
                var state = editor.DuplicateGameObjectsState.create(gameObjects);
                this.addState(state);
            };
            /**
             * 删除游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.deleteGameObject = function (gameObjects) {
                var deleteState = editor.DeleteGameObjectsState.create(gameObjects);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (editor.Editor.editorModel.isPrefabChild(obj) && !editor.Editor.editorModel.isPrefabRoot(obj)) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakState, deleteState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(deleteState);
                }
            };
            EditorModel.prototype._deleteGameObject = function (gameObjects) {
                for (var index = 0; index < gameObjects.length; index++) {
                    var element = gameObjects[index];
                    element.destroy();
                }
            };
            /**
             * 更改层级
             * */
            EditorModel.prototype.updateGameObjectsHierarchy = function (gameObjects, targetGameobjcet, dir) {
                var gameObjectHierarchyState = editor.GameObjectHierarchyState.create(gameObjects, targetGameobjcet, dir);
                var breakList = [];
                gameObjects.forEach(function (obj) {
                    if (editor.Editor.editorModel.isPrefabChild(obj) &&
                        !editor.Editor.editorModel.isPrefabRoot(obj) &&
                        (obj.transform.parent !== targetGameobjcet.transform.parent || dir === 'inner')) {
                        breakList.push(obj);
                    }
                });
                if (breakList.length > 0) {
                    var breakPrefabStructState = editor.BreakPrefabStructState.create(breakList);
                    var stateGroup = editor.StateGroup.create([breakPrefabStructState, gameObjectHierarchyState]);
                    this.addState(stateGroup);
                }
                else {
                    this.addState(gameObjectHierarchyState);
                }
            };
            /**
             * 设置对象的层级
             */
            EditorModel.prototype.setGameObjectsHierarchy = function (objects, targetObject, dir) {
                objects = objects.concat();
                //剔除所有父级
                objects.forEach(function (obj) { obj.transform.parent = null; });
                objects.reverse();
                if (dir === 'inner') {
                    var index = targetObject.transform.children.length;
                    for (var i = 0; i < objects.length; i++) {
                        var obj = objects[i];
                        obj.transform.parent = targetObject.transform;
                        var transform = targetObject.transform.children.pop();
                        targetObject.transform.children.splice(index, 0, transform);
                    }
                }
                else {
                    if (targetObject.transform.parent) {
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform);
                                break;
                            case 'bottom':
                                index = targetObject.transform.parent.children.indexOf(targetObject.transform) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            obj.transform.parent = targetObject.transform.parent;
                            var transform = targetObject.transform.parent.children.pop();
                            targetObject.transform.parent.children.splice(index, 0, transform);
                        }
                    }
                    else {
                        var all = paper.Application.sceneManager.activeScene.gameObjects;
                        for (var i = 0; i < objects.length; i++) {
                            all.splice(all.indexOf(objects[i]), 1);
                        }
                        var index = void 0;
                        switch (dir) {
                            case 'top':
                                index = all.indexOf(targetObject);
                                break;
                            case 'bottom':
                                index = all.indexOf(targetObject) + 1;
                                break;
                        }
                        for (var i = 0; i < objects.length; i++) {
                            var obj = objects[i];
                            all.splice(index, 0, obj);
                        }
                    }
                }
            };
            /**
             * 筛选层级中的顶层游戏对象
             * @param gameObjects
             */
            EditorModel.prototype.filtTopHierarchyGameObjects = function (gameObjects) {
                var findParent = false;
                var parent = null;
                for (var index = gameObjects.length - 1; index >= 0; index--) {
                    var element = gameObjects[index];
                    findParent = false;
                    parent = element.transform.parent;
                    while (parent) {
                        for (var i = 0; i < gameObjects.length; i++) {
                            var element_1 = gameObjects[i];
                            if (element_1.transform === parent) {
                                gameObjects.splice(index, 1);
                                findParent = true;
                                break;
                            }
                        }
                        if (findParent) {
                            break;
                        }
                        parent = parent.parent;
                    }
                }
            };
            EditorModel.prototype.getGameObjectByUUid = function (uuid) {
                var paper = this.backRunTime.paper;
                var objects = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                paper = __global['paper'];
                objects = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < objects.length; i++) {
                    if (objects[i].uuid === uuid) {
                        return objects[i];
                    }
                }
                return null;
            };
            EditorModel.prototype.getAssetByAssetUrl = function (url) {
                return __awaiter(this, void 0, void 0, function () {
                    var RES, asset;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                RES = this.backRunTime.RES;
                                return [4 /*yield*/, RES.getResAsync(url)];
                            case 1:
                                asset = _a.sent();
                                if (asset) {
                                    return [2 /*return*/, asset];
                                }
                                return [2 /*return*/, null];
                        }
                    });
                });
            };
            EditorModel.prototype.getGameObjectsByUUids = function (uuids) {
                var objects = paper_1.Application.sceneManager.activeScene.gameObjects;
                var obj;
                var result = [];
                var idIndex;
                var cloneIds = uuids.concat();
                for (var i = 0; i < objects.length; i++) {
                    if (cloneIds.length == 0) {
                        return result;
                    }
                    obj = objects[i];
                    idIndex = cloneIds.indexOf(obj.uuid);
                    if (idIndex != -1) {
                        result.push(obj);
                        cloneIds.splice(idIndex, 1);
                    }
                }
                return result;
            };
            EditorModel.prototype.findOptionSetName = function (propName, target) {
                var editInfoList = editor.getEditInfo(target);
                for (var index = 0; index < editInfoList.length; index++) {
                    var element = editInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                var extraInfoList = editor.getExtraInfo(target);
                for (var index = 0; index < extraInfoList.length; index++) {
                    var element = extraInfoList[index];
                    if (element.name === propName && element.option && element.option.set) {
                        return element.option.set;
                    }
                }
                return null;
            };
            EditorModel.prototype.setTargetProperty = function (propName, target, value) {
                var setFunName = this.findOptionSetName(propName, target);
                if (setFunName !== null && target[setFunName]) {
                    target[setFunName].call(target, value);
                }
                else {
                    target[propName] = value;
                }
            };
            /**
             * 选择游戏对象
             *  */
            EditorModel.prototype.selectGameObject = function (objs) {
                this.currentSelected = objs;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.SELECT_GAMEOBJECTS, objs));
            };
            /**
             * 切换编辑模式
             */
            EditorModel.prototype.changeEditMode = function (mode) {
                this.currentEditMode = mode;
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_MODE, mode));
            };
            /**
             * 切换编辑类型
             */
            EditorModel.prototype.changeEditType = function (type) {
                this.dispatchEvent(new EditorModelEvent(EditorModelEvent.CHANGE_EDIT_TYPE, type));
            };
            EditorModel.prototype.isPrefabRoot = function (gameObj) {
                if (gameObj.extras.isPrefabRoot === true) {
                    return true;
                }
                return false;
            };
            EditorModel.prototype.isPrefabChild = function (gameObj) {
                if (gameObj.extras.isPrefabRoot === false) {
                    return true;
                }
                return false;
            };
            /**
            * 从一个预置体文件创建实例
            * @param prefabPath 预置体资源路径
            */
            EditorModel.prototype.createGameObjectFromPrefab = function (prefabPath, paper, RES) {
                return __awaiter(this, void 0, void 0, function () {
                    var prefab, instance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, RES.getResAsync(prefabPath)];
                            case 1:
                                prefab = _a.sent();
                                if (prefab) {
                                    instance = prefab.createInstance();
                                    instance.extras.isPrefabRoot = true;
                                    this.setGameObjectPrefab(instance, prefab, instance);
                                    return [2 /*return*/, instance];
                                }
                                return [2 /*return*/, null];
                        }
                    });
                });
            };
            /**
             * 设置children prefab属性
             * @param gameObj
             * @param prefab
             */
            EditorModel.prototype.setGameObjectPrefab = function (gameObj, prefab, rootObj) {
                if (!gameObj) {
                    return;
                }
                gameObj.prefab = prefab;
                if (gameObj != rootObj) {
                    gameObj.extras.isPrefabRoot = false;
                    gameObj.extras.prefabRootId = rootObj.uuid;
                }
                for (var index = 0; index < gameObj.transform.children.length; index++) {
                    var element = gameObj.transform.children[index];
                    var obj = element.gameObject;
                    this.setGameObjectPrefab(obj, prefab, rootObj);
                }
            };
            /**将对象按照层级进行排序
             */
            EditorModel.prototype.sortGameObjectsForHierarchy = function (gameobjects) {
                gameobjects = gameobjects.concat();
                if (gameobjects.length < 2) {
                    return gameobjects;
                }
                //生成每个对象的显示索引路径列表
                var displayPathList = [];
                gameobjects.forEach(function (obj) {
                    var result = [];
                    var currentObj = obj;
                    while (currentObj.transform.parent) {
                        result.unshift(currentObj.transform.parent.children.indexOf(currentObj.transform));
                        currentObj = currentObj.transform.parent.gameObject;
                    }
                    //追加一个根部索引
                    result.unshift(paper.Application.sceneManager.activeScene.gameObjects.indexOf(currentObj));
                    displayPathList.push({ gameObject: obj, path: result });
                });
                function getPath(gameObject) {
                    for (var i_1 = 0; i_1 < displayPathList.length; i_1++) {
                        if (displayPathList[i_1].gameObject === gameObject) {
                            return displayPathList[i_1].path;
                        }
                    }
                }
                var length = gameobjects.length - 1;
                while (length > 0) {
                    for (var i = 0; i < length; i++) {
                        var A = getPath(gameobjects[i]);
                        var B = getPath(gameobjects[i + 1]);
                        var needChangeIndex = false;
                        var minLength = Math.min(A.length, B.length);
                        var k = 0;
                        b: for (k; k < minLength; k++) {
                            if (A[k] === B[k]) {
                                continue;
                            }
                            else if (A[k] > B[k]) {
                                needChangeIndex = true;
                                break b;
                            }
                            else if (A[k] < B[k]) {
                                needChangeIndex = false;
                                break b;
                            }
                        }
                        if (k === minLength && !needChangeIndex && A.length > B.length) {
                            needChangeIndex = true;
                        }
                        if (needChangeIndex) {
                            var tmpv = gameobjects[i];
                            gameobjects[i] = gameobjects[i + 1];
                            gameobjects[i + 1] = tmpv;
                        }
                    }
                    length--;
                }
                return gameobjects;
            };
            EditorModel.prototype.createApplyPrefabState = function (applyGameObjectPropertyList, applyComponentPropertyList) {
                var group = [];
                //apply gameobject proerty
                for (var _i = 0, applyGameObjectPropertyList_1 = applyGameObjectPropertyList; _i < applyGameObjectPropertyList_1.length; _i++) {
                    var p = applyGameObjectPropertyList_1[_i];
                    var gameObjUUid = p.gameObjUUid, newValueList = p.newValueList, preValueCopylist = p.preValueCopylist;
                    var state = editor.ModifyPrefabGameObjectPropertyState.create(gameObjUUid, newValueList, preValueCopylist);
                    group.push(state);
                }
                //apply component property
                for (var _a = 0, applyComponentPropertyList_1 = applyComponentPropertyList; _a < applyComponentPropertyList_1.length; _a++) {
                    var p = applyComponentPropertyList_1[_a];
                    var gameObjUUid = p.gameObjUUid, componentUUid = p.componentUUid, newValueList = p.newValueList, preValueCopylist = p.preValueCopylist;
                    var state = editor.ModifyPrefabComponentPropertyState.create(gameObjUUid, componentUUid, newValueList, preValueCopylist);
                    group.push(state);
                }
                var applyPrefabState = editor.StateGroup.create(group);
                this.addState(applyPrefabState);
            };
            EditorModel.prototype.createRevertPrefabState = function (modifyGameObjectPropertyList, modifyComponentPropertyList) {
                var group = [];
                //revert gameobject proerty
                for (var _i = 0, modifyGameObjectPropertyList_1 = modifyGameObjectPropertyList; _i < modifyGameObjectPropertyList_1.length; _i++) {
                    var p = modifyGameObjectPropertyList_1[_i];
                    var gameObjUUid = p.gameObjUUid, newValueList = p.newValueList, preValueCopylist = p.preValueCopylist;
                    var state = editor.ModifyGameObjectPropertyState.create(gameObjUUid, newValueList, preValueCopylist);
                    group.push(state);
                }
                //revert component property
                for (var _a = 0, modifyComponentPropertyList_1 = modifyComponentPropertyList; _a < modifyComponentPropertyList_1.length; _a++) {
                    var p = modifyComponentPropertyList_1[_a];
                    var gameObjUUid = p.gameObjUUid, componentUUid = p.componentUUid, newValueList = p.newValueList, preValueCopylist = p.preValueCopylist;
                    var state = editor.ModifyComponentPropertyState.create(gameObjUUid, componentUUid, newValueList, preValueCopylist);
                    group.push(state);
                }
                var revertPrefabState = editor.StateGroup.create(group);
                this.addState(revertPrefabState);
            };
            EditorModel.prototype.compareValue = function (a, b) {
                if (typeof a != typeof b) {
                    throw new Error("diffrent type");
                }
                var valueType = typeof a;
                if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
                    if (a === b) {
                        return true;
                    }
                }
                else {
                    if (this.equal(a, b)) {
                        return true;
                    }
                }
                return false;
            };
            EditorModel.prototype.equal = function (a, b) {
                var className = egret.getQualifiedClassName(a);
                if (className === egret.getQualifiedClassName(b)) {
                    switch (className) {
                        case 'egret3d.Vector2': return egret3d.Vector2.equal(a, b);
                        case 'egret3d.Vector3': return egret3d.Vector3.equal(a, b);
                        case 'egret3d.Vector4': return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                        case 'egret3d.Quaternion': return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
                        case 'egret3d.Rect': return a.x === b.x && a.y === b.y && a.w === b.w && a.h === b.h;
                        case 'egret3d.Color': return a.r === b.r && a.g === b.g && a.b === b.b && a.a === b.a;
                        default:
                            return false;
                    }
                }
                else
                    return false;
            };
            return EditorModel;
        }(editor.EventDispatcher));
        editor.EditorModel = EditorModel;
        __reflect(EditorModel.prototype, "paper.editor.EditorModel");
    })(editor = paper_1.editor || (paper_1.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var helpVec3_1 = new egret3d.Vector3();
        var helpVec3_2 = new egret3d.Vector3();
        var helpVec3_3 = new egret3d.Vector3();
        var helpQuat_1 = new egret3d.Quaternion();
        var helpQuat_2 = new egret3d.Quaternion();
        var forward = new egret3d.Vector3(0, 0, 1);
        var up = new egret3d.Vector3(0, 1, 0);
        var right = new egret3d.Vector3(1, 0, 0);
        var DRAG_MODE;
        (function (DRAG_MODE) {
            DRAG_MODE[DRAG_MODE["NONE"] = 0] = "NONE";
            DRAG_MODE[DRAG_MODE["BALL"] = 1] = "BALL";
            DRAG_MODE[DRAG_MODE["X"] = 2] = "X";
            DRAG_MODE[DRAG_MODE["Y"] = 3] = "Y";
            DRAG_MODE[DRAG_MODE["Z"] = 4] = "Z";
            DRAG_MODE[DRAG_MODE["RotX"] = 5] = "RotX";
            DRAG_MODE[DRAG_MODE["RotY"] = 6] = "RotY";
            DRAG_MODE[DRAG_MODE["RotZ"] = 7] = "RotZ";
            DRAG_MODE[DRAG_MODE["ScaX"] = 8] = "ScaX";
            DRAG_MODE[DRAG_MODE["ScaY"] = 9] = "ScaY";
            DRAG_MODE[DRAG_MODE["ScaZ"] = 10] = "ScaZ";
        })(DRAG_MODE || (DRAG_MODE = {}));
        var GeoController = (function () {
            function GeoController(editorModel) {
                this.selectedGameObjs = [];
                this._isEditing = false;
                this._geoCtrlMode = "local";
                this._modeCanChange = true;
                this._geoCtrlType = "position";
                /**
                 * 几何操作逻辑
                 */
                this._dragMode = DRAG_MODE.NONE;
                this._dragOffset = new egret3d.Vector3();
                this._delta = new egret3d.Vector3();
                this._newPosition = new egret3d.Vector3();
                this._ctrlPos = new egret3d.Vector3();
                this._ctrlRot = new egret3d.Quaternion();
                this._dragPlanePoint = new egret3d.Vector3();
                this._dragPlaneNormal = new egret3d.Vector3();
                this._initRotation = new egret3d.Quaternion();
                this._oldLocalScale = new egret3d.Vector3();
                this.selectGameObjects = this._selectGameObjects.bind(this);
                this.changeProperty = this._changeProperty.bind(this);
                this.changeEditMode = this._changeEditMode.bind(this);
                this.changeEditType = this._changeEditType.bind(this);
                this.controllerPool = [];
                this.editorModel = editorModel;
                this._addGizmoController();
                this._addEventListener();
                this.bindMouse = egret3d.InputManager.mouse;
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this._cameraObject = paper.Application.sceneManager.editorScene.find("EditorCamera");
            }
            Object.defineProperty(GeoController.prototype, "geoCtrlMode", {
                get: function () {
                    return this._geoCtrlMode;
                },
                set: function (value) {
                    this._geoCtrlMode = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(GeoController.prototype, "geoCtrlType", {
                get: function () {
                    return this._geoCtrlType;
                },
                set: function (value) {
                    this._geoCtrlType = value;
                },
                enumerable: true,
                configurable: true
            });
            GeoController.prototype.update = function () {
                // console.log(this.pCtrl);
                var len = this.selectedGameObjs.length;
                if (this.selectedGameObjs.length > 0) {
                    editor.Gizmo.DrawArrowXYZ(this.controller.transform);
                    if (this.bindKeyboard.wasPressed('DELETE')) {
                        this.editorModel.deleteGameObject(this.selectedGameObjs);
                        // EditorMessage.instance.DeleteGameObject(this._bindedGameObject);
                    }
                    if (this.selectedGameObjs.length == 1 && this.selectedGameObjs[0].getComponent(egret3d.Camera)) {
                        editor.Gizmo.DrawCameraSquare(this.selectedGameObjs[0], [1.0, 0.0, 1.0, 1.0]);
                    }
                }
                this.inputUpdate();
                if (this._isEditing) {
                    (this.geoCtrlMode == "world" || this.selectedGameObjs.length > 1) ? this.updateInWorldMode() : this.updateInLocalMode();
                }
                if (this.bindMouse.wasReleased(0)) {
                    this._dragMode = DRAG_MODE.NONE;
                    //this.cameraScript.enabled = true;
                    egret3d.Vector3.set(0, 0, 0, this._dragOffset);
                    egret3d.Vector3.set(0, 0, 0, this._dragPlanePoint);
                    egret3d.Vector3.set(0, 0, 0, this._dragPlaneNormal);
                    this.xScl.transform.setLocalPosition(2, 0, 0);
                    this.yScl.transform.setLocalPosition(0, 2, 0);
                    this.zScl.transform.setLocalPosition(0, 0, 2);
                }
            };
            GeoController.prototype.updateInLocalMode = function () {
                var _this = this;
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var camera = this._cameraObject.getComponent(egret3d.Camera);
                var worldRotation = this.selectedGameObjs[0].transform.getRotation();
                var worldPosition = this.selectedGameObjs[0].transform.getPosition();
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    //worldPosition = this.selectedGameObj.transform.getPosition();
                    //worldRotation = this.selectedGameObj.transform.getRotation();
                    var ray_1 = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    var pickInfoArray = egret3d.Ray.raycastAll(ray_1, true);
                    if (pickInfoArray && pickInfoArray.length > 0) {
                        pickInfoArray.forEach(function (pickInfo) {
                            var picked = pickInfo.transform.gameObject;
                            if (_this.geoCtrlType == "position" && (picked == _this.ball || picked == _this.xAxis || picked == _this.yAxis || picked == _this.zAxis)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.ball) {
                                    _this._dragMode = DRAG_MODE.BALL;
                                    _this._cameraObject.transform.getForward(_this._dragPlaneNormal);
                                }
                                else if (picked == _this.xAxis) {
                                    _this._dragMode = DRAG_MODE.X;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yAxis) {
                                    _this._dragMode = DRAG_MODE.Y;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zAxis) {
                                    _this._dragMode = DRAG_MODE.Z;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                            }
                            else if (_this.geoCtrlType == "rotation" && (picked == _this.xRot || picked == _this.yRot || picked == _this.zRot)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.xRot) {
                                    _this._dragMode = DRAG_MODE.RotX;
                                    egret3d.Quaternion.transformVector3(worldRotation, right, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                                egret3d.Quaternion.copy(worldRotation, _this._initRotation);
                            }
                            else if (_this.geoCtrlType == "scale" && (picked == _this.xScl || picked == _this.yScl || picked == _this.zScl)) {
                                egret3d.Vector3.copy(worldPosition, _this._dragPlanePoint);
                                if (picked == _this.xScl) {
                                    _this._dragMode = DRAG_MODE.ScaX;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yScl) {
                                    _this._dragMode = DRAG_MODE.ScaY;
                                    egret3d.Quaternion.transformVector3(worldRotation, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zScl) {
                                    _this._dragMode = DRAG_MODE.ScaZ;
                                    egret3d.Quaternion.transformVector3(worldRotation, up, _this._dragPlaneNormal);
                                }
                                egret3d.Vector3.copy(_this.selectedGameObjs[0].transform.getLocalScale(), _this._oldLocalScale);
                                _this._dragOffset = ray_1.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, worldPosition, _this._dragOffset);
                            }
                        });
                    }
                }
                if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    if (this.geoCtrlType == "position" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, hit);
                        if (this._dragMode == DRAG_MODE.BALL) {
                            this.editorModel.setTransformProperty("position", hit, this.selectedGameObjs[0].transform);
                            egret3d.Vector3.copy(hit, this._ctrlPos);
                            //this.selectedGameObj.transform.setPosition(hit);
                        }
                        else {
                            egret3d.Vector3.subtract(hit, worldPosition, hit);
                            var worldOffset = void 0;
                            if (this._dragMode == DRAG_MODE.X) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, right, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Y) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, up, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Z) {
                                worldOffset = egret3d.Quaternion.transformVector3(worldRotation, forward, helpVec3_1);
                            }
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            egret3d.Vector3.scale(worldOffset, cosHit);
                            var position = egret3d.Vector3.add(worldPosition, worldOffset, helpVec3_2);
                            egret3d.Vector3.copy(position, this._ctrlPos);
                            this.editorModel.setTransformProperty("position", position, this.selectedGameObjs[0].transform);
                        }
                    }
                    else if (this.geoCtrlType == "rotation" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, worldPosition, hit);
                        var cosHitOffset = egret3d.Vector3.dot(egret3d.Vector3.normalize(hit), egret3d.Vector3.normalize(this._dragOffset));
                        egret3d.Vector3.cross(this._dragOffset, hit, helpVec3_1);
                        var theta = egret3d.Vector3.dot(helpVec3_1, this._dragPlaneNormal) >= 0 ? Math.acos(cosHitOffset) : -Math.acos(cosHitOffset);
                        var cos = Math.cos(theta * 0.5), sin = Math.sin(theta * 0.5);
                        egret3d.Quaternion.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos, helpQuat_1);
                        egret3d.Quaternion.multiply(helpQuat_1, this._initRotation, helpQuat_2);
                        egret3d.Quaternion.copy(helpQuat_2, this._ctrlRot);
                        this.editorModel.setTransformProperty("rotation", helpQuat_2, this.selectedGameObjs[0].transform);
                    }
                    else if (this.geoCtrlType == "scale" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, worldPosition, hit);
                        var worldOffset = void 0;
                        var scale = void 0;
                        if (this._dragMode == DRAG_MODE.ScaX) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, right, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_1 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.xScl.transform.setLocalPosition(cosHit / len_1 * 2, 0, 0);
                        }
                        else if (this._dragMode == DRAG_MODE.ScaY) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, up, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_2 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.yScl.transform.setLocalPosition(0, cosHit / len_2 * 2, 0);
                        }
                        else if (this._dragMode == DRAG_MODE.ScaZ) {
                            worldOffset = egret3d.Quaternion.transformVector3(worldRotation, forward, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(hit, worldOffset);
                            var len_3 = egret3d.Vector3.dot(this._dragOffset, worldOffset);
                            this.zScl.transform.setLocalPosition(0, 0, cosHit / len_3 * 2);
                        }
                        var oldScale = this._oldLocalScale;
                        var sx = this.xScl.transform.getLocalPosition().x / 2;
                        var sy = this.yScl.transform.getLocalPosition().y / 2;
                        var sz = this.zScl.transform.getLocalPosition().z / 2;
                        scale = egret3d.Vector3.set(oldScale.x * sx, oldScale.y * sy, oldScale.z * sz, helpVec3_2);
                        this.editorModel.setTransformProperty("localScale", scale, this.selectedGameObjs[0].transform);
                    }
                }
            };
            GeoController.prototype.updateInWorldMode = function () {
                var _this = this;
                var len = this.selectedGameObjs.length;
                if (len <= 0)
                    return;
                var camera = this._cameraObject.getComponent(egret3d.Camera);
                if (this.bindMouse.wasPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    var ctrlPos_1 = egret3d.Vector3.set(0, 0, 0, this._ctrlPos);
                    for (var i = 0; i < len; i++) {
                        var obj = this.selectedGameObjs[i];
                        egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos_1, ctrlPos_1);
                    }
                    ctrlPos_1 = egret3d.Vector3.scale(ctrlPos_1, 1 / len);
                    var ctrlRot_1 = this.controller.transform.getRotation();
                    this._ctrlRot = ctrlRot_1;
                    var ray_2 = camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                    var pickInfoArray = egret3d.Ray.raycastAll(ray_2, true);
                    if (pickInfoArray && pickInfoArray.length > 0) {
                        pickInfoArray.forEach(function (pickInfo) {
                            var picked = pickInfo.transform.gameObject;
                            if (_this.geoCtrlType == "position" && (picked == _this.ball || picked == _this.xAxis || picked == _this.yAxis || picked == _this.zAxis)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                if (picked == _this.ball) {
                                    _this._dragMode = DRAG_MODE.BALL;
                                    _this._cameraObject.transform.getForward(_this._dragPlaneNormal);
                                }
                                else if (picked == _this.xAxis) {
                                    _this._dragMode = DRAG_MODE.X;
                                    egret3d.Vector3.copy(up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yAxis) {
                                    _this._dragMode = DRAG_MODE.Y;
                                    egret3d.Vector3.copy(forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zAxis) {
                                    _this._dragMode = DRAG_MODE.Z;
                                    egret3d.Vector3.copy(up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                            }
                            else if (_this.geoCtrlType == "rotation" && (picked == _this.xRot || picked == _this.yRot || picked == _this.zRot)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                //let ctrlRot = this.controller.transform.getRotation();
                                //this._ctrlRot = ctrlRot;
                                if (picked == _this.xRot) {
                                    _this._dragMode = DRAG_MODE.RotX;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, right, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yRot) {
                                    _this._dragMode = DRAG_MODE.RotY;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zRot) {
                                    _this._dragMode = DRAG_MODE.RotZ;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, forward, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                                egret3d.Vector3.subtract(_this._dragOffset, _this._ctrlPos, _this._dragOffset);
                                egret3d.Vector3.normalize(_this._dragOffset);
                            }
                            else if (_this.geoCtrlType == "scale" && (picked == _this.xScl || picked == _this.yScl || picked == _this.zScl)) {
                                egret3d.Vector3.copy(ctrlPos_1, _this._dragPlanePoint);
                                if (picked == _this.xScl) {
                                    _this._dragMode = DRAG_MODE.ScaX;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.yScl) {
                                    _this._dragMode = DRAG_MODE.ScaY;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, forward, _this._dragPlaneNormal);
                                }
                                else if (picked == _this.zScl) {
                                    _this._dragMode = DRAG_MODE.ScaZ;
                                    egret3d.Quaternion.transformVector3(ctrlRot_1, up, _this._dragPlaneNormal);
                                }
                                _this._dragOffset = ray_2.intersectPlane(_this._dragPlanePoint, _this._dragPlaneNormal);
                            }
                        });
                    }
                }
                if (this.bindMouse.isPressed(0) && !this.bindKeyboard.isPressed('ALT')) {
                    if (this.geoCtrlType == "position" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                        var worldOffset = void 0;
                        if (this._dragMode == DRAG_MODE.BALL) {
                            worldOffset = egret3d.Vector3.copy(this._delta, helpVec3_1);
                        }
                        else {
                            if (this._dragMode == DRAG_MODE.X) {
                                worldOffset = egret3d.Vector3.copy(right, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Y) {
                                worldOffset = egret3d.Vector3.copy(up, helpVec3_1);
                            }
                            else if (this._dragMode == DRAG_MODE.Z) {
                                worldOffset = egret3d.Vector3.copy(forward, helpVec3_1);
                            }
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            egret3d.Vector3.scale(worldOffset, cosHit);
                        }
                        egret3d.Vector3.add(this._ctrlPos, worldOffset, this._ctrlPos);
                        for (var i = 0; i < len; i++) {
                            var obj = this.selectedGameObjs[i];
                            var lastPos = obj.transform.getPosition();
                            egret3d.Vector3.add(lastPos, worldOffset, this._newPosition);
                            this.editorModel.setTransformProperty("position", this._newPosition, obj.transform);
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                    else if (this.geoCtrlType == "rotation" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._ctrlPos, hit);
                        egret3d.Vector3.normalize(hit);
                        var cosHitOffset = egret3d.Vector3.dot(hit, this._dragOffset);
                        cosHitOffset = egret3d.floatClamp(cosHitOffset, -1, 1);
                        egret3d.Vector3.cross(this._dragOffset, hit, helpVec3_1);
                        var theta = egret3d.Vector3.dot(helpVec3_1, this._dragPlaneNormal) >= 0 ? Math.acos(cosHitOffset) : -Math.acos(cosHitOffset);
                        var cos = Math.cos(theta * 0.5), sin = Math.sin(theta * 0.5);
                        egret3d.Quaternion.set(this._dragPlaneNormal.x * sin, this._dragPlaneNormal.y * sin, this._dragPlaneNormal.z * sin, cos, helpQuat_1);
                        egret3d.Quaternion.multiply(helpQuat_1, this._ctrlRot, this._ctrlRot);
                        for (var i = 0; i < len; i++) {
                            var obj = this.selectedGameObjs[i];
                            var lastPos = obj.transform.getPosition();
                            var lastRot = obj.transform.getRotation();
                            egret3d.Quaternion.multiply(helpQuat_1, lastRot, helpQuat_2);
                            egret3d.Vector3.subtract(lastPos, this._ctrlPos, lastPos);
                            egret3d.Quaternion.transformVector3(helpQuat_1, lastPos, lastPos);
                            egret3d.Vector3.add(lastPos, this._ctrlPos, lastPos);
                            this.editorModel.setTransformProperty("rotation", helpQuat_2, obj.transform);
                            this.editorModel.setTransformProperty("position", lastPos, obj.transform);
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                    else if (this.geoCtrlType == "scale" && this._dragMode != DRAG_MODE.NONE) {
                        var screenPosition = this.bindMouse.position;
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        var hit = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                        egret3d.Vector3.subtract(hit, this._dragOffset, this._delta);
                        var worldOffset = void 0;
                        var scale = void 0;
                        if (this._dragMode == DRAG_MODE.ScaX) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, right, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.xScl.transform.getLocalPosition().x;
                            this.xScl.transform.setLocalPosition(cosHit + src, 0, 0);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x * s, lastSca.y, lastSca.z, helpVec3_2);
                                this.editorModel.setTransformProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = helpVec3_2;
                                egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), right, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setTransformProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        else if (this._dragMode == DRAG_MODE.ScaY) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, up, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.yScl.transform.getLocalPosition().y;
                            this.yScl.transform.setLocalPosition(0, cosHit + src, 0);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x, lastSca.y * s, lastSca.z, helpVec3_2);
                                this.editorModel.setTransformProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = helpVec3_2;
                                egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), up, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setTransformProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        else if (this._dragMode == DRAG_MODE.ScaZ) {
                            worldOffset = egret3d.Quaternion.transformVector3(this._ctrlRot, forward, helpVec3_1);
                            var cosHit = egret3d.Vector3.dot(this._delta, worldOffset);
                            var src = this.zScl.transform.getLocalPosition().z;
                            this.zScl.transform.setLocalPosition(0, 0, cosHit + src);
                            var s = cosHit / src + 1;
                            for (var i = 0; i < len; i++) {
                                var lastSca = this.selectedGameObjs[i].transform.getLocalScale();
                                scale = egret3d.Vector3.set(lastSca.x, lastSca.y, lastSca.z * s, helpVec3_2);
                                this.editorModel.setTransformProperty("localScale", scale, this.selectedGameObjs[i].transform);
                                var pos = this.selectedGameObjs[i].transform.getPosition();
                                var sub = helpVec3_2;
                                egret3d.Vector3.subtract(pos, this._ctrlPos, helpVec3_2);
                                egret3d.Quaternion.transformVector3(this.controller.transform.getRotation(), forward, helpVec3_3);
                                var cos = egret3d.Vector3.dot(sub, helpVec3_3);
                                egret3d.Vector3.scale(helpVec3_3, cos * (s - 1));
                                egret3d.Vector3.add(pos, helpVec3_3, pos);
                                this.editorModel.setTransformProperty("position", pos, this.selectedGameObjs[i].transform);
                            }
                        }
                        egret3d.Vector3.copy(hit, this._dragOffset);
                    }
                }
            };
            /**
             * 输入监听
             */
            GeoController.prototype.inputUpdate = function () {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                if (keyboard.wasPressed("Q")) {
                    if (this.geoCtrlMode == "local") {
                        this.editorModel.changeEditMode("world");
                    }
                    else {
                        this.editorModel.changeEditMode("local");
                    }
                }
                if (keyboard.wasPressed("W")) {
                    this.editorModel.changeEditType("position");
                }
                if (keyboard.wasPressed("E")) {
                    this.editorModel.changeEditType("rotation");
                }
                if (keyboard.wasPressed("R")) {
                    this.editorModel.changeEditType("scale");
                }
                // 复制粘贴
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('C')) {
                    this.editorModel.copy(this.selectedGameObjs);
                }
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('V')) {
                    var parent_3 = this.selectedGameObjs.length > 0 ? this.selectedGameObjs[0].transform.parent.gameObject : null;
                    this.editorModel.pasteGameObject(parent_3);
                }
                if (this.bindKeyboard.isPressed('CONTROL') && this.bindKeyboard.wasPressed('M')) {
                    this.editorModel.duplicateGameObjects(this.selectedGameObjs);
                }
            };
            /**
             * 添加监听事件
             */
            GeoController.prototype._addEventListener = function () {
                var _this = this;
                this.editorModel.addEventListener(editor.EditorModelEvent.SELECT_GAMEOBJECTS, function (e) { return _this.selectGameObjects(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_MODE, function (e) { return _this.changeEditMode(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_EDIT_TYPE, function (e) { return _this.changeEditType(e.data); }, this);
                this.editorModel.addEventListener(editor.EditorModelEvent.CHANGE_PROPERTY, function (e) { return _this.changeProperty(e.data); }, this);
            };
            GeoController.prototype._selectGameObjects = function (gameObjects) {
                if (!gameObjects)
                    gameObjects = [];
                this.selectedGameObjs = gameObjects;
                var len = this.selectedGameObjs.length;
                this._modeCanChange = true;
                if (len > 0) {
                    this._isEditing = true;
                    this.geoCtrlType = "position";
                    this.pCtrl.activeSelf = true;
                    this.rCtrl.activeSelf = false;
                    this.sCtrl.activeSelf = false;
                    this.controller.activeSelf = true;
                    if (len == 1) {
                        // console.log("select: " + this.selectedGameObjs[0].name);
                        this.controller.transform.setPosition(this.selectedGameObjs[0].transform.getPosition());
                        if (this.geoCtrlMode == "local") {
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                        }
                        else if (this.geoCtrlMode == "world") {
                            this.controller.transform.setRotation(0, 0, 0, 1);
                        }
                    }
                    else {
                        var ctrlPos = egret3d.Vector3.set(0, 0, 0, helpVec3_3);
                        for (var i = 0; i < len; i++) {
                            // console.log("select: " + i + " " + this.selectedGameObjs[i].name);
                            var obj = this.selectedGameObjs[i];
                            egret3d.Vector3.add(obj.transform.getPosition(), ctrlPos, ctrlPos);
                        }
                        ctrlPos = egret3d.Vector3.scale(ctrlPos, 1 / len);
                        this.controller.transform.setPosition(ctrlPos);
                        this.controller.transform.setRotation(0, 0, 0, 1);
                        this.geoCtrlMode = "world";
                        this._modeCanChange = false;
                    }
                }
                else {
                    this._isEditing = false;
                    // console.log("select: null");
                    this.controller.activeSelf = false;
                }
            };
            GeoController.prototype._changeProperty = function (data) {
                if ((data.target instanceof egret3d.Transform) && data.propName && this.selectedGameObjs.length > 0) {
                    var propName = data.propName;
                    var target = data.target;
                    switch (propName) {
                        case "position":
                            this.controller.transform.setPosition(this._ctrlPos);
                            break;
                        case "rotation":
                            this.controller.transform.setRotation(this._ctrlRot);
                            break;
                        case "localPosition":
                            this._ctrlPos = this.selectedGameObjs[0].transform.getPosition();
                            this.controller.transform.setPosition(this._ctrlPos);
                            break;
                        case "localRotation":
                            this._ctrlRot = this.selectedGameObjs[0].transform.getRotation();
                            this.controller.transform.setRotation(this._ctrlRot);
                            break;
                        default:
                            break;
                    }
                }
                if (data.target instanceof paper.GameObject) {
                    var propName = data.propName;
                    console.log(propName);
                }
            };
            GeoController.prototype._changeEditMode = function (mode) {
                if (!this._modeCanChange) {
                    console.log("current mode: " + this.geoCtrlMode);
                    return;
                }
                this.geoCtrlMode = mode;
                var len = this.selectedGameObjs.length;
                if (len < 1)
                    return;
                if (this.geoCtrlType != "scale") {
                    switch (mode) {
                        case "local":
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                            break;
                        case "world":
                            this.controller.transform.setRotation(0, 0, 0, 1);
                            break;
                        default:
                            break;
                    }
                }
                console.log("current mode: " + this.geoCtrlMode);
            };
            GeoController.prototype._changeEditType = function (type) {
                if (this.geoCtrlType == type)
                    return;
                this.geoCtrlType = type;
                var len = this.selectedGameObjs.length;
                if (len < 1)
                    return;
                switch (type) {
                    case "position":
                        this.geoCtrlMode == "local" ? this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation()) : this.controller.transform.setRotation(this.controller.transform.getRotation());
                        this.pCtrl.activeSelf = true;
                        this.rCtrl.activeSelf = false;
                        this.sCtrl.activeSelf = false;
                        break;
                    case "rotation":
                        this.geoCtrlMode == "local" ? this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation()) : this.controller.transform.setRotation(this.controller.transform.getRotation());
                        this.pCtrl.activeSelf = false;
                        this.rCtrl.activeSelf = true;
                        this.sCtrl.activeSelf = false;
                        break;
                    case "scale":
                        if (len == 1) {
                            this.controller.transform.setRotation(this.selectedGameObjs[0].transform.getRotation());
                        }
                        else {
                            this.controller.transform.setRotation(this.controller.transform.getRotation());
                        }
                        this.pCtrl.activeSelf = false;
                        this.rCtrl.activeSelf = false;
                        this.sCtrl.activeSelf = true;
                        break;
                    default:
                        break;
                }
                console.log("current type: " + this.geoCtrlType);
            };
            GeoController.prototype._addGizmoController = function () {
                var controller = new paper.GameObject();
                controller.activeSelf = false;
                controller.name = "GizmoController";
                controller.tag = "Editor";
                var pcontroller = new paper.GameObject();
                pcontroller.activeSelf = true;
                pcontroller.name = "GizmoController_Position";
                pcontroller.tag = "Editor";
                pcontroller.transform.setParent(controller.transform);
                var rcontroller = new paper.GameObject();
                rcontroller.activeSelf = false;
                rcontroller.name = "GizmoController_Rotation";
                rcontroller.tag = "Editor";
                rcontroller.transform.setParent(controller.transform);
                var scontroller = new paper.GameObject();
                scontroller.activeSelf = false;
                scontroller.name = "GizmoController_Scale";
                scontroller.tag = "Editor";
                scontroller.transform.setParent(controller.transform);
                var ball = new paper.GameObject();
                ball.name = "GizmoController_Ball";
                ball.tag = "Editor";
                ball.transform.setParent(pcontroller.transform);
                ball.transform.setLocalScale(0.3, 0.3, 0.3);
                var mesh = ball.addComponent(egret3d.MeshFilter);
                mesh.mesh = egret3d.DefaultMeshes.SPHERE;
                var renderer = ball.addComponent(egret3d.MeshRenderer);
                var mat = new egret3d.Material(egret3d.DefaultShaders.GIZMOS_COLOR);
                mat.setVector4v("_Color", [0.8, 0.8, 0.4, 0.1]);
                renderer.materials = [mat];
                var xAxis = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 0);
                xAxis.name = "GizmoController_X";
                xAxis.tag = "Editor";
                xAxis.transform.setParent(pcontroller.transform);
                xAxis.transform.setLocalScale(0.1, 2, 0.1);
                xAxis.transform.setLocalEulerAngles(0, 0, 90);
                xAxis.transform.setLocalPosition(1, 0, 0);
                var yAxis = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 0);
                yAxis.name = "GizmoController_Y";
                yAxis.tag = "Editor";
                yAxis.transform.setParent(pcontroller.transform);
                yAxis.transform.setLocalScale(0.1, 2, 0.1);
                yAxis.transform.setLocalEulerAngles(0, 0, 0);
                yAxis.transform.setLocalPosition(0, 1, 0);
                var zAxis = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 0);
                zAxis.name = "GizmoController_Z";
                zAxis.tag = "Editor";
                zAxis.transform.setParent(pcontroller.transform);
                zAxis.transform.setLocalScale(0.1, 2, 0.1);
                zAxis.transform.setLocalEulerAngles(90, 0, 0);
                zAxis.transform.setLocalPosition(0, 0, 1);
                var xRotate = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 1);
                xRotate.name = "GizmoController_Rotate_X";
                xRotate.tag = "Editor";
                xRotate.transform.setParent(rcontroller.transform);
                xRotate.transform.setLocalScale(3, 0.05, 3);
                xRotate.transform.setLocalEulerAngles(0, 0, -90);
                var yRotate = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 1);
                yRotate.name = "GizmoController_Rotate_Y";
                yRotate.tag = "Editor";
                yRotate.transform.setParent(rcontroller.transform);
                yRotate.transform.setLocalScale(3, 0.05, 3);
                yRotate.transform.setLocalEulerAngles(0, 0, 0);
                var zRotate = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 1);
                zRotate.name = "GizmoController_Rotate_Z";
                zRotate.tag = "Editor";
                zRotate.transform.setParent(rcontroller.transform);
                zRotate.transform.setLocalEulerAngles(90, 0, 0);
                zRotate.transform.setLocalScale(3, 0.05, 3);
                var xScale = this._createAxis(new egret3d.Vector4(0.8, 0.0, 0.0, 0.2), 2);
                xScale.name = "GizmoController_Scale_X";
                xScale.tag = "Editor";
                xScale.transform.setParent(scontroller.transform);
                xScale.transform.setLocalScale(0.2, 0.2, 0.2);
                xScale.transform.setLocalPosition(2, 0, 0);
                var yScale = this._createAxis(new egret3d.Vector4(0.0, 0.8, 0.0, 0.2), 2);
                yScale.name = "GizmoController_Scale_Y";
                yScale.tag = "Editor";
                yScale.transform.setParent(scontroller.transform);
                yScale.transform.setLocalScale(0.2, 0.2, 0.2);
                yScale.transform.setLocalPosition(0, 2, 0);
                var zScale = this._createAxis(new egret3d.Vector4(0.0, 0.0, 0.8, 0.2), 2);
                zScale.name = "GizmoController_Scale_Z";
                zScale.tag = "Editor";
                zScale.transform.setParent(scontroller.transform);
                zScale.transform.setLocalScale(0.2, 0.2, 0.2);
                zScale.transform.setLocalPosition(0, 0, 2);
                this.ball = ball;
                this.xAxis = xAxis;
                this.yAxis = yAxis;
                this.zAxis = zAxis;
                this.xRot = xRotate;
                this.yRot = yRotate;
                this.zRot = zRotate;
                this.xScl = xScale;
                this.yScl = yScale;
                this.zScl = zScale;
                this.pCtrl = pcontroller;
                this.rCtrl = rcontroller;
                this.sCtrl = scontroller;
                this.controller = controller;
                this.controllerPool = [controller, scontroller, rcontroller, pcontroller, zScale, yScale, xScale, zRotate, yRotate, xRotate, zAxis, yAxis, xAxis, ball];
            };
            /**
             * type 0:控制位置 1:控制旋转
             */
            GeoController.prototype._createAxis = function (color, type) {
                var gizmoAxis = new paper.GameObject();
                var mesh = gizmoAxis.addComponent(egret3d.MeshFilter);
                switch (type) {
                    case 0:
                        mesh.mesh = egret3d.DefaultMeshes.CYLINDER;
                        break;
                    case 1:
                        mesh.mesh = egret3d.DefaultMeshes.CYLINDER;
                        break;
                    case 2:
                        mesh.mesh = egret3d.DefaultMeshes.SPHERE;
                        break;
                }
                var renderer = gizmoAxis.addComponent(egret3d.MeshRenderer);
                var mat = new egret3d.Material(egret3d.DefaultShaders.GIZMOS_COLOR);
                mat.setVector4v("_Color", [color.x, color.y, color.z, color.w]);
                renderer.materials = [mat];
                return gizmoAxis;
            };
            GeoController.prototype._removeGizmoController = function () {
                var gameObject = paper.GameObject.find("GizmoController");
                this.controller = null;
            };
            return GeoController;
        }());
        editor.GeoController = GeoController;
        __reflect(GeoController.prototype, "paper.editor.GeoController");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.EventType = {
            HistoryState: "HistoryState",
            HistoryAdd: "HistoryAdd",
            HistoryFree: "HistoryFree"
        };
        var History = (function () {
            function History() {
                this.dispatcher = null;
                this._locked = 0;
                this._index = -1;
                this._batchIndex = 0;
                this._states = [];
                this._batchStates = [];
                this._events = [];
            }
            History.prototype._free = function () {
                if (this._states.length > this._index + 1) {
                    this._states.length = this._index + 1; // TODO release.
                    if (this.dispatcher) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryFree, null));
                    }
                }
            };
            History.prototype._doState = function (state, isUndo) {
                if (isUndo) {
                    state.undo();
                }
                else {
                    state.redo();
                }
                var d = isUndo ? "undo" : "redo";
                if (this.dispatcher) {
                    var data = { isUndo: isUndo };
                    this._events.push(data);
                }
                return state.batchIndex > 0 && (isUndo ? this._index >= 0 : this._index < this._states.length - 1);
            };
            History.prototype.back = function () {
                if (this._index < 0 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[this._index--], true)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_1 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_1));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.forward = function () {
                if (this._index >= this._states.length - 1 || this._batchIndex > 0) {
                    return false;
                }
                this._locked |= 1;
                while (this._doState(this._states[++this._index], false)) {
                }
                if (this.dispatcher && this._events.length > 0) {
                    for (var _i = 0, _a = this._events; _i < _a.length; _i++) {
                        var event_2 = _a[_i];
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryState, event_2));
                    }
                    this._events.length = 0;
                }
                this._locked &= 2;
                return true;
            };
            History.prototype.go = function (index) {
                if (this._batchIndex > 0) {
                    return false;
                }
                var result = false;
                if (this._index < index) {
                    while (this._index !== index && this.forward()) {
                        result = true;
                    }
                }
                else {
                    while (this._index !== index && this.back()) {
                        result = true;
                    }
                }
                return result;
            };
            History.prototype.add = function (state) {
                if (this._locked !== 0) {
                    return;
                }
                if (this._batchIndex > 0) {
                    state.batchIndex = this._batchIndex;
                    this._batchStates.push(state);
                }
                else {
                    this._states[this._index + 1] = state;
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this.forward();
                    this._free();
                }
            };
            History.prototype.beginBatch = function () {
                this._batchIndex++;
            };
            History.prototype.endBatch = function () {
                if (this._batchIndex === 0) {
                    return;
                }
                this._batchIndex--;
                if (this._batchIndex === 0) {
                    var index = this._index + 1;
                    for (var _i = 0, _a = this._batchStates; _i < _a.length; _i++) {
                        var state = _a[_i];
                        this._states[index++] = state;
                    }
                    if (this.dispatcher !== null) {
                        this.dispatcher.dispatchEvent(new editor.BaseEvent(editor.EventType.HistoryAdd, event));
                    }
                    this._batchStates.length = 0;
                    this.go(this._states.length - 1);
                }
            };
            History.prototype.getState = function (index) {
                return this._states[index];
            };
            Object.defineProperty(History.prototype, "enabled", {
                get: function () {
                    return this._locked === 0;
                },
                set: function (value) {
                    if (value) {
                        this._locked &= 1;
                    }
                    else {
                        this._locked |= 2;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "count", {
                get: function () {
                    return this._states.length;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "batchIndex", {
                get: function () {
                    return this._batchIndex;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "locked", {
                get: function () {
                    return this._locked;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(History.prototype, "states", {
                get: function () {
                    return this._states;
                },
                enumerable: true,
                configurable: true
            });
            History.prototype.serialize = function () {
                var states = this.states;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element.hasOwnProperty('deserialize') ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                var serializeHistory = {
                    index: this.index,
                    batchIndex: this.batchIndex,
                    locked: this.locked,
                    statesData: statesData,
                };
                return serializeHistory;
            };
            History.prototype.deserialize = function (serializeHistory) {
                var states = [];
                var statesData = serializeHistory.statesData;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element.hasOwnProperty('deserialize') ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        states.push(state);
                    }
                }
                var initData = {
                    states: states,
                    index: serializeHistory.index,
                    batchIndex: serializeHistory.batchIndex,
                    locked: serializeHistory.locked,
                };
                this._index = initData ? initData.index : -1;
                this._locked = initData ? initData.locked : 0;
                this._batchIndex = initData ? initData.batchIndex : 0;
                this._states = initData ? initData.states : [];
            };
            return History;
        }());
        editor.History = History;
        __reflect(History.prototype, "paper.editor.History");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 状态组
         * @author 杨宁
         */
        var StateGroup = (function (_super) {
            __extends(StateGroup, _super);
            function StateGroup() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            StateGroup.create = function (stateList) {
                var instance = new StateGroup();
                instance.stateList = stateList;
                return instance;
            };
            StateGroup.prototype.redo = function () {
                for (var i = 0; i < this.stateList.length; i++) {
                    this.stateList[i].redo();
                }
                return true;
            };
            StateGroup.prototype.undo = function () {
                for (var i = this.stateList.length - 1; i >= 0; i--) {
                    this.stateList[i].undo();
                }
                return true;
            };
            StateGroup.prototype.serialize = function () {
                var states = this.stateList;
                var statesData = [];
                for (var index = 0; index < states.length; index++) {
                    var element = states[index];
                    var className = egret.getQualifiedClassName(element);
                    var data = {
                        className: className,
                        batchIndex: element.batchIndex,
                        data: element['serialize'] ? element['serialize']() : element.data,
                        autoClear: element.autoClear,
                        isDone: element.isDone,
                    };
                    statesData.push(data);
                }
                return states;
            };
            StateGroup.prototype.deserialize = function (data) {
                this.stateList = [];
                var statesData = data;
                for (var index = 0; index < statesData.length; index++) {
                    var element = statesData[index];
                    var clazz = egret.getDefinitionByName(element.className);
                    var state = null;
                    if (clazz) {
                        state = new clazz();
                        state.batchIndex = element.batchIndex;
                        state.data = element['deserialize'] ? element['deserialize'](element.data) : element.data;
                        state.autoClear = element.autoClear;
                        state.isDone = element.isDone;
                        this.stateList.push(state);
                    }
                }
            };
            return StateGroup;
        }(editor.BaseState));
        editor.StateGroup = StateGroup;
        __reflect(StateGroup.prototype, "paper.editor.StateGroup");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ModifyGameObjectPropertyState = (function (_super) {
            __extends(ModifyGameObjectPropertyState, _super);
            function ModifyGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyGameObjectPropertyState.create = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = new ModifyGameObjectPropertyState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyGameObjectPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyGameObjectPropertyState.prototype.modifyProperty = function (valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var uuid, modifyObj;
                    return __generator(this, function (_a) {
                        uuid = this.stateData.gameObjectUUid;
                        modifyObj = editor.Editor.editorModel.getGameObjectByUUid(uuid);
                        if (modifyObj !== null) {
                            valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                var propName, copyValue, valueEditType, newValue;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                            return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                        case 1:
                                            newValue = _a.sent();
                                            editor.Editor.editorModel.setTargetProperty(propName, modifyObj, newValue);
                                            this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
                                            return [2 /*return*/];
                                    }
                                });
                            }); });
                        }
                        return [2 /*return*/];
                    });
                });
            };
            ModifyGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyGameObjectPropertyState;
        }(editor.BaseState));
        editor.ModifyGameObjectPropertyState = ModifyGameObjectPropertyState;
        __reflect(ModifyGameObjectPropertyState.prototype, "paper.editor.ModifyGameObjectPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改组件属性属性
        var ModifyComponentPropertyState = (function (_super) {
            __extends(ModifyComponentPropertyState, _super);
            function ModifyComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyComponentPropertyState.toString = function () {
                return "[class common.ModifyComponentPropertyState]";
            };
            ModifyComponentPropertyState.create = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = new ModifyComponentPropertyState();
                var data = {
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            Object.defineProperty(ModifyComponentPropertyState.prototype, "stateData", {
                get: function () {
                    return this.data;
                },
                enumerable: true,
                configurable: true
            });
            ModifyComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    this.modifyProperty(this.stateData.preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyComponentPropertyState.prototype.modifyProperty = function (valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var gameObjectUUid, componentUUid, gameObj, modifyObj;
                    return __generator(this, function (_a) {
                        gameObjectUUid = this.stateData.gameObjUUid;
                        componentUUid = this.stateData.componentUUid;
                        gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (gameObj) {
                            modifyObj = editor.Editor.editorModel.getComponentById(gameObj, componentUUid);
                            if (modifyObj) {
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                            case 1:
                                                newValue = _a.sent();
                                                editor.Editor.editorModel.setTargetProperty(propName, modifyObj, newValue);
                                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: gameObj, propName: propName, propValue: newValue });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                        }
                        return [2 /*return*/];
                    });
                });
            };
            ModifyComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.modifyProperty(this.stateData.newValueList);
                    return true;
                }
                return false;
            };
            return ModifyComponentPropertyState;
        }(editor.BaseState));
        editor.ModifyComponentPropertyState = ModifyComponentPropertyState;
        __reflect(ModifyComponentPropertyState.prototype, "paper.editor.ModifyComponentPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //创建游戏对象
        var CreateGameObjectState = (function (_super) {
            __extends(CreateGameObjectState, _super);
            function CreateGameObjectState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.isFirst = true;
                return _this;
            }
            CreateGameObjectState.toString = function () {
                return "[class common.AddGameObjectState]";
            };
            CreateGameObjectState.create = function (parentList, createType) {
                var infos = parentList.map(function (obj) { return { parentUUID: obj.uuid, serializeData: null }; });
                var state = new CreateGameObjectState();
                state.infos = infos;
                state.createType = createType;
                return state;
            };
            CreateGameObjectState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = editor.Editor.editorModel.getGameObjectsByUUids(this.addList);
                    editor.Editor.editorModel._deleteGameObject(objs);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    //一条信息都没有则添加到场景根
                    if (this.infos.length === 0) {
                        this.infos.push({ parentUUID: null, serializeData: null });
                    }
                    for (var i = 0; i < this.infos.length; i++) {
                        var obj = void 0;
                        if (this.isFirst) {
                            obj = this.createGameObjectByType(this.createType);
                            this.infos[i].serializeData = paper.serialize(obj);
                        }
                        else {
                            obj = paper.deserialize(this.infos[i].serializeData, true);
                        }
                        var parent_4 = editor.Editor.editorModel.getGameObjectByUUid(this.infos[i].parentUUID);
                        if (parent_4)
                            obj.transform.parent = parent_4.transform;
                        this.addList.push(obj.uuid);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.isFirst = false;
                    return true;
                }
                return false;
            };
            CreateGameObjectState.prototype.createGameObjectByType = function (createType) {
                var obj;
                switch (createType) {
                    case 'empty':
                        obj = new paper.GameObject();
                        obj.name = "NewGameObject";
                        break;
                    case 'cube':
                        obj = new paper.GameObject();
                        obj.name = "cube";
                        var mat = new egret3d.Material(egret3d.DefaultShaders.GIZMOS_COLOR);
                        mat.setVector4v("_Color", [1, 0, 0, 1]);
                        var mesh = obj.addComponent(egret3d.MeshFilter);
                        mesh.mesh = egret3d.DefaultMeshes.CUBE;
                        var renderer = obj.addComponent(egret3d.MeshRenderer);
                        renderer.materials = [mat];
                        break;
                }
                return obj;
            };
            return CreateGameObjectState;
        }(editor.BaseState));
        editor.CreateGameObjectState = CreateGameObjectState;
        __reflect(CreateGameObjectState.prototype, "paper.editor.CreateGameObjectState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //删除游戏对象
        var DeleteGameObjectsState = (function (_super) {
            __extends(DeleteGameObjectsState, _super);
            function DeleteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            DeleteGameObjectsState.toString = function () {
                return "[class common.deleteGameObjectsState]";
            };
            DeleteGameObjectsState.create = function (gameObjects) {
                gameObjects = gameObjects.concat();
                //筛选
                editor.Editor.editorModel.filtTopHierarchyGameObjects(gameObjects);
                //排序
                gameObjects = editor.Editor.editorModel.sortGameObjectsForHierarchy(gameObjects);
                var infos = [];
                for (var i = 0; i < gameObjects.length; i++) {
                    var obj = gameObjects[i];
                    var oldParentUUID = void 0;
                    var oldIndex = void 0;
                    var serializeData = paper.serialize(obj);
                    if (obj.transform.parent) {
                        oldParentUUID = obj.transform.parent.gameObject.uuid;
                        oldIndex = obj.transform.parent.children.indexOf(obj.transform);
                    }
                    else {
                        oldParentUUID = undefined;
                        oldIndex = paper.Application.sceneManager.activeScene.gameObjects.indexOf(obj);
                    }
                    infos.push({ UUID: obj.uuid, oldParentUUID: oldParentUUID, oldIndex: oldIndex, serializeData: serializeData });
                }
                var state = new DeleteGameObjectsState();
                state.deleteInfo = infos;
                return state;
            };
            DeleteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    for (var i = 0; i < this.deleteInfo.length; i++) {
                        var info = this.deleteInfo[i];
                        var obj = paper.deserialize(info.serializeData, true);
                        var oldParentObj = editor.Editor.editorModel.getGameObjectByUUid(info.oldParentUUID);
                        if (oldParentObj) {
                            var oldTargetTransform = oldParentObj.transform.children[info.oldIndex];
                            if (oldTargetTransform) {
                                editor.Editor.editorModel.setGameObjectsHierarchy([obj], oldTargetTransform.gameObject, 'top');
                            }
                            else {
                                editor.Editor.editorModel.setGameObjectsHierarchy([obj], oldParentObj, 'inner');
                            }
                        }
                        else {
                            obj.transform.parent = null;
                            var all = paper.Application.sceneManager.activeScene.gameObjects;
                            var currentIndex = all.indexOf(obj);
                            all.splice(currentIndex, 1);
                            all.splice(info.oldIndex, 0, obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.deleteInfo.map(function (info) { return info.UUID; }));
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var ids = this.deleteInfo.map(function (info) { return info.UUID; });
                    var objs = editor.Editor.editorModel.getGameObjectsByUUids(ids);
                    editor.Editor.editorModel._deleteGameObject(objs);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, ids);
                    return true;
                }
                return false;
            };
            DeleteGameObjectsState.prototype.serialize = function () {
                return this.deleteInfo;
            };
            DeleteGameObjectsState.prototype.deserialize = function (data) {
                this.deleteInfo = data;
            };
            return DeleteGameObjectsState;
        }(editor.BaseState));
        editor.DeleteGameObjectsState = DeleteGameObjectsState;
        __reflect(DeleteGameObjectsState.prototype, "paper.editor.DeleteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //克隆游戏对象
        var DuplicateGameObjectsState = (function (_super) {
            __extends(DuplicateGameObjectsState, _super);
            function DuplicateGameObjectsState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.firstDo = true;
                return _this;
            }
            DuplicateGameObjectsState.toString = function () {
                return "[class common.DuplicateGameObjectsState]";
            };
            DuplicateGameObjectsState.create = function (objs) {
                //过滤
                editor.Editor.editorModel.filtTopHierarchyGameObjects(objs);
                //排序
                objs = editor.Editor.editorModel.sortGameObjectsForHierarchy(objs);
                var duplicateInfo = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var UUID = obj.uuid;
                    var parentUUID = obj.transform.parent ? obj.transform.parent.gameObject.uuid : null;
                    var serializeData = paper.serialize(obj);
                    duplicateInfo.push({ UUID: UUID, parentUUID: parentUUID, serializeData: serializeData });
                }
                var state = new DuplicateGameObjectsState();
                state.duplicateInfo = duplicateInfo;
                return state;
            };
            DuplicateGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = editor.Editor.editorModel.getGameObjectsByUUids(this.addList);
                    editor.Editor.editorModel._deleteGameObject(objs);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, objs);
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    for (var i = 0; i < this.duplicateInfo.length; i++) {
                        var info = this.duplicateInfo[i];
                        var obj = paper.deserialize(info.serializeData, !this.firstDo);
                        var parent_5 = editor.Editor.editorModel.getGameObjectByUUid(info.parentUUID);
                        if (parent_5) {
                            obj.transform.parent = parent_5.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (this.firstDo) {
                            info.serializeData = paper.serialize(obj);
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    this.firstDo = false;
                    return true;
                }
                return false;
            };
            DuplicateGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (editor.Editor.editorModel.isPrefabChild(obj)) {
                    obj.prefab = null;
                    obj.extras = {};
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            DuplicateGameObjectsState.prototype.serialize = function () {
                return { duplicateInfo: this.duplicateInfo, addList: this.addList };
            };
            DuplicateGameObjectsState.prototype.deserialize = function (data) {
                this.duplicateInfo = data.duplicateInfo;
                this.addList = data.addList;
            };
            return DuplicateGameObjectsState;
        }(editor.BaseState));
        editor.DuplicateGameObjectsState = DuplicateGameObjectsState;
        __reflect(DuplicateGameObjectsState.prototype, "paper.editor.DuplicateGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //粘贴游戏对象
        var PasteGameObjectsState = (function (_super) {
            __extends(PasteGameObjectsState, _super);
            function PasteGameObjectsState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            PasteGameObjectsState.toString = function () {
                return "[class common.PasteGameObjectsState]";
            };
            PasteGameObjectsState.create = function (serializeData, parent) {
                var state = new PasteGameObjectsState();
                var parentUUID = parent ? parent.uuid : null;
                state.pasteInfo = { parentUUID: parentUUID, serializeData: serializeData };
                return state;
            };
            PasteGameObjectsState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var objs = editor.Editor.editorModel.getGameObjectsByUUids(this.addList);
                    editor.Editor.editorModel._deleteGameObject(objs);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    this.addList = [];
                    var parent_6 = editor.Editor.editorModel.getGameObjectByUUid(this.pasteInfo.parentUUID);
                    var serializeDataList = this.cacheSerializeData ? this.cacheSerializeData : this.pasteInfo.serializeData;
                    var keepUID = this.cacheSerializeData ? true : false;
                    for (var i = 0; i < serializeDataList.length; i++) {
                        var info = serializeDataList[i];
                        var obj = paper.deserialize(info, keepUID);
                        if (parent_6) {
                            obj.transform.parent = parent_6.transform;
                        }
                        //清理预置体信息
                        this.clearPrefabInfo(obj);
                        this.addList.push(obj.uuid);
                        if (serializeDataList === this.pasteInfo.serializeData) {
                            if (!this.cacheSerializeData)
                                this.cacheSerializeData = [];
                            this.cacheSerializeData.push(paper.serialize(obj));
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, this.addList);
                    return true;
                }
                return false;
            };
            PasteGameObjectsState.prototype.clearPrefabInfo = function (obj) {
                if (editor.Editor.editorModel.isPrefabChild(obj)) {
                    obj.prefab = null;
                    obj.extras = {};
                    for (var i = 0; i < obj.transform.children.length; i++) {
                        this.clearPrefabInfo(obj.transform.children[i].gameObject);
                    }
                }
            };
            PasteGameObjectsState.prototype.serialize = function () {
                return { pasteInfo: this.pasteInfo, addList: this.addList };
            };
            PasteGameObjectsState.prototype.deserialize = function (data) {
                this.addList = data.addList;
                this.pasteInfo = data.pasteInfo;
            };
            return PasteGameObjectsState;
        }(editor.BaseState));
        editor.PasteGameObjectsState = PasteGameObjectsState;
        __reflect(PasteGameObjectsState.prototype, "paper.editor.PasteGameObjectsState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var AddComponentState = (function (_super) {
            __extends(AddComponentState, _super);
            function AddComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddComponentState.toString = function () {
                return "[class common.AddComponentState]";
            };
            AddComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new AddComponentState();
                state.data = data;
                return state;
            };
            AddComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var componentId = this.data.cacheUUid;
                    var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        for (var i = 0; i < gameObject.components.length; i++) {
                            var comp = gameObject.components[i];
                            if (comp.uuid === componentId) {
                                gameObject.removeComponent(comp.constructor);
                                break;
                            }
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                    return true;
                }
                return false;
            };
            AddComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var compClzName = this.data.compClzName;
                    var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObject) {
                        var addComponent = void 0;
                        if (this.data.serializeData) {
                            addComponent = paper.deserialize(this.data.serializeData, true);
                            editor.Editor.editorModel.addComponentToGameObject(gameObject, addComponent);
                        }
                        else {
                            var compClz = egret.getDefinitionByName(compClzName);
                            addComponent = gameObject.addComponent(compClz);
                            this.data.serializeData = paper.serialize(addComponent);
                        }
                        this.data.cacheUUid = addComponent.uuid;
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    return true;
                }
                return false;
            };
            return AddComponentState;
        }(editor.BaseState));
        editor.AddComponentState = AddComponentState;
        __reflect(AddComponentState.prototype, "paper.editor.AddComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //移除组件
        var RemoveComponentState = (function (_super) {
            __extends(RemoveComponentState, _super);
            function RemoveComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemoveComponentState.toString = function () {
                return "[class common.RemoveComponentState]";
            };
            RemoveComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new RemoveComponentState();
                state.data = data;
                return state;
            };
            RemoveComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var serializeData = this.data.serializeData;
                    var component = paper.deserialize(serializeData, true);
                    var gameObjectUUid = this.data.gameObjectUUid;
                    if (component) {
                        var gameObject = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (gameObject) {
                            component.gameObject = gameObject;
                            editor.Editor.editorModel.addComponentToGameObject(gameObject, component);
                            this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                        }
                    }
                    return true;
                }
                return false;
            };
            RemoveComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUid = this.data.gameObjectUUid;
                    var componentUUid = this.data.componentUUid;
                    var obj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (obj) {
                        for (var i = 0; i < obj.components.length; i++) {
                            var comp = obj.components[i];
                            if (comp.uuid === componentUUid) {
                                obj.removeComponent(comp.constructor);
                                break;
                            }
                        }
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                    return true;
                }
                return false;
            };
            return RemoveComponentState;
        }(editor.BaseState));
        editor.RemoveComponentState = RemoveComponentState;
        __reflect(RemoveComponentState.prototype, "paper.editor.RemoveComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 游戏对象层级
         * @author 杨宁
         */
        var GameObjectHierarchyState = (function (_super) {
            __extends(GameObjectHierarchyState, _super);
            function GameObjectHierarchyState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.gameObjectsInfo = [];
                return _this;
            }
            GameObjectHierarchyState.create = function (gameObjects, targetGameObj, dir) {
                //筛选
                gameObjects = gameObjects.concat();
                editor.Editor.editorModel.filtTopHierarchyGameObjects(gameObjects);
                //必须进行层级排序
                var objs = editor.Editor.editorModel.sortGameObjectsForHierarchy(gameObjects);
                //整理对象信息
                var objInfos = [];
                for (var i = 0; i < objs.length; i++) {
                    var obj = objs[i];
                    var oldTargetUUID = void 0;
                    var oldDir = void 0;
                    if (obj.transform.parent) {
                        var index = obj.transform.parent.children.indexOf(obj.transform);
                        if (++index < obj.transform.parent.children.length) {
                            oldTargetUUID = obj.transform.parent.children[index].gameObject.uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = obj.transform.parent.gameObject.uuid;
                            oldDir = 'inner';
                        }
                    }
                    else {
                        var all = paper.Application.sceneManager.activeScene.gameObjects;
                        var index = all.indexOf(obj);
                        if (++index < all.length) {
                            oldTargetUUID = all[index].uuid;
                            oldDir = 'top';
                        }
                        else {
                            oldTargetUUID = 'scene'; //特殊标记，用来标记最外层最后一个
                            oldDir = 'inner';
                        }
                    }
                    objInfos.push({ UUID: obj.uuid, oldTargetUUID: oldTargetUUID, oldDir: oldDir });
                }
                var instance = new GameObjectHierarchyState();
                instance.gameObjectsInfo = objInfos;
                instance.targetDir = dir;
                instance.targetObject = targetGameObj.uuid;
                return instance;
            };
            GameObjectHierarchyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var tmpList = this.gameObjectsInfo.concat();
                    tmpList.reverse();
                    for (var index = 0; index < tmpList.length; index++) {
                        var info = tmpList[index];
                        var obj = editor.Editor.editorModel.getGameObjectByUUid(info.UUID);
                        var oldTarget = editor.Editor.editorModel.getGameObjectByUUid(info.oldTargetUUID);
                        ;
                        var oldDir = info.oldDir;
                        if (info.oldTargetUUID === 'scene') {
                            var all = paper.Application.sceneManager.activeScene.gameObjects;
                            oldTarget = all[all.length - 1];
                            oldDir = 'bottom';
                        }
                        editor.Editor.editorModel.setGameObjectsHierarchy([obj], oldTarget, oldDir);
                    }
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            GameObjectHierarchyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var gameObjectUUids = this.gameObjectsInfo.map(function (v) { return v.UUID; });
                    var gameObjs = editor.Editor.editorModel.getGameObjectsByUUids(gameObjectUUids);
                    var targetGameObj = editor.Editor.editorModel.getGameObjectByUUid(this.targetObject);
                    gameObjs = editor.Editor.editorModel.sortGameObjectsForHierarchy(gameObjs);
                    editor.Editor.editorModel.setGameObjectsHierarchy(gameObjs, targetGameObj, this.targetDir);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.UPDATE_GAMEOBJECTS_HIREARCHY);
                    return true;
                }
                return false;
            };
            return GameObjectHierarchyState;
        }(editor.BaseState));
        editor.GameObjectHierarchyState = GameObjectHierarchyState;
        __reflect(GameObjectHierarchyState.prototype, "paper.editor.GameObjectHierarchyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ModifyPrefabGameObjectPropertyState = (function (_super) {
            __extends(ModifyPrefabGameObjectPropertyState, _super);
            function ModifyPrefabGameObjectPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyPrefabGameObjectPropertyState.toString = function () {
                return "[class common.ModifyPrefabGameObjectPropertyState]";
            };
            ModifyPrefabGameObjectPropertyState.create = function (gameObjectUUid, newValueList, preValueCopylist) {
                var state = new ModifyPrefabGameObjectPropertyState();
                var data = {
                    gameObjectUUid: gameObjectUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            ModifyPrefabGameObjectPropertyState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            /**
             * 修改预制体游戏对象属性,目前只支持修改根对象
             * @param gameObjectId
             * @param valueList
             */
            ModifyPrefabGameObjectPropertyState.prototype.modifyPrefabGameObjectPropertyValues = function (gameObjectUUid, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var prefabObj, objects;
                    return __generator(this, function (_a) {
                        prefabObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                        if (!prefabObj) {
                            return [2 /*return*/];
                        }
                        objects = editor.Editor.editorModel.getRootGameObjectsByPrefab(prefabObj.prefab);
                        valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                            var _this = this;
                            var propName, copyValue, valueEditType, newValue;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                        return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                    case 1:
                                        newValue = _a.sent();
                                        objects.forEach(function (object) {
                                            if (editor.Editor.editorModel.compareValue(object[propName], prefabObj[propName])) {
                                                editor.Editor.editorModel.setTargetProperty(propName, object, newValue);
                                                _this.dispathPropertyEvent(object, propName, newValue);
                                            }
                                        });
                                        editor.Editor.editorModel.setTargetProperty(propName, prefabObj, newValue);
                                        this.dispathPropertyEvent(prefabObj, propName, newValue);
                                        return [2 /*return*/];
                                }
                            });
                        }); });
                        return [2 /*return*/];
                    });
                });
            };
            ModifyPrefabGameObjectPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, gameObjectUUid = _a.gameObjectUUid, preValueCopylist = _a.preValueCopylist;
                    this.modifyPrefabGameObjectPropertyValues(gameObjectUUid, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyPrefabGameObjectPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, gameObjectUUid = _a.gameObjectUUid, newValueList = _a.newValueList;
                    this.modifyPrefabGameObjectPropertyValues(gameObjectUUid, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyPrefabGameObjectPropertyState;
        }(editor.BaseState));
        editor.ModifyPrefabGameObjectPropertyState = ModifyPrefabGameObjectPropertyState;
        __reflect(ModifyPrefabGameObjectPropertyState.prototype, "paper.editor.ModifyPrefabGameObjectPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改预制体组件属性
        var ModifyPrefabComponentPropertyState = (function (_super) {
            __extends(ModifyPrefabComponentPropertyState, _super);
            function ModifyPrefabComponentPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyPrefabComponentPropertyState.toString = function () {
                return "[class common.ModifyPrefabComponentPropertyState]";
            };
            ModifyPrefabComponentPropertyState.create = function (gameObjUUid, componentUUid, newValueList, preValueCopylist) {
                var state = new ModifyPrefabComponentPropertyState();
                var data = {
                    gameObjUUid: gameObjUUid,
                    componentUUid: componentUUid,
                    newValueList: newValueList,
                    preValueCopylist: preValueCopylist,
                };
                state.data = data;
                return state;
            };
            ModifyPrefabComponentPropertyState.prototype.dispathPropertyEvent = function (modifyObj, propName, newValue) {
                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: modifyObj, propName: propName, propValue: newValue });
            };
            ModifyPrefabComponentPropertyState.prototype.modifyPrefabComponentPropertyValues = function (gameObjUUid, componentUUid, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var prefabObj, objects, _loop_1, k;
                    return __generator(this, function (_a) {
                        prefabObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                        if (!prefabObj) {
                            return [2 /*return*/];
                        }
                        objects = editor.Editor.editorModel.getRootGameObjectsByPrefab(prefabObj.prefab);
                        _loop_1 = function (k) {
                            var prefabComp = prefabObj.components[k];
                            var editInfoList = editor.getEditInfo(prefabComp);
                            if (prefabComp.uuid === componentUUid) {
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var _this = this;
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                            case 1:
                                                newValue = _a.sent();
                                                objects.forEach(function (object) {
                                                    var objectComp = editor.Editor.editorModel.getComponentByAssetId(object, prefabComp.assetID);
                                                    if (objectComp !== null) {
                                                        if (editor.Editor.editorModel.compareValue(objectComp[propName], prefabComp[propName])) {
                                                            editor.Editor.editorModel.setTargetProperty(propName, objectComp, newValue);
                                                            _this.dispathPropertyEvent(objectComp, propName, newValue);
                                                        }
                                                    }
                                                    else {
                                                        console.warn("{prefabComp.assetId} not match!");
                                                    }
                                                });
                                                editor.Editor.editorModel.setTargetProperty(propName, prefabComp, newValue);
                                                this.dispathPropertyEvent(prefabComp, propName, newValue);
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                            }
                        };
                        for (k = 0; k < prefabObj.components.length; k++) {
                            _loop_1(k);
                        }
                        return [2 /*return*/];
                    });
                });
            };
            ModifyPrefabComponentPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, gameObjUUid = _a.gameObjUUid, componentUUid = _a.componentUUid, preValueCopylist = _a.preValueCopylist;
                    this.modifyPrefabComponentPropertyValues(gameObjUUid, componentUUid, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyPrefabComponentPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, gameObjUUid = _a.gameObjUUid, componentUUid = _a.componentUUid, newValueList = _a.newValueList;
                    this.modifyPrefabComponentPropertyValues(gameObjUUid, componentUUid, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyPrefabComponentPropertyState;
        }(editor.BaseState));
        editor.ModifyPrefabComponentPropertyState = ModifyPrefabComponentPropertyState;
        __reflect(ModifyPrefabComponentPropertyState.prototype, "paper.editor.ModifyPrefabComponentPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //移除组件
        var RemovePrefabComponentState = (function (_super) {
            __extends(RemovePrefabComponentState, _super);
            function RemovePrefabComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            RemovePrefabComponentState.toString = function () {
                return "[class common.RemovePrefabComponentState]";
            };
            RemovePrefabComponentState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new RemovePrefabComponentState();
                state.data = data;
                return state;
            };
            RemovePrefabComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjUUid = element.gameObjUUid, componentUUid = element.componentUUid, serializeData = element.serializeData;
                        var addComponent = paper.deserialize(serializeData, true);
                        if (addComponent) {
                            var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                            if (gameObj) {
                                // addComponent.uuid = componentUUid;
                                addComponent.gameObject = gameObj;
                                editor.Editor.editorModel.addComponentToGameObject(gameObj, addComponent);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            RemovePrefabComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var datas = this.data.datas;
                    for (var index = 0; index < datas.length; index++) {
                        var element = datas[index];
                        var gameObjUUid = element.gameObjUUid, componentUUid = element.componentUUid;
                        var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjUUid);
                        if (gameObj) {
                            var componentObj = editor.Editor.editorModel.getComponentById(gameObj, componentUUid);
                            if (componentObj) {
                                gameObj.removeComponent(componentObj.constructor);
                                this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                            }
                        }
                    }
                    return true;
                }
                return false;
            };
            return RemovePrefabComponentState;
        }(editor.BaseState));
        editor.RemovePrefabComponentState = RemovePrefabComponentState;
        __reflect(RemovePrefabComponentState.prototype, "paper.editor.RemovePrefabComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //添加组件
        var AddPrefabComponentState = (function (_super) {
            __extends(AddPrefabComponentState, _super);
            function AddPrefabComponentState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddPrefabComponentState.toString = function () {
                return "[class common.AddPrefabComponentState]";
            };
            AddPrefabComponentState.create = function (sourceData, instanceDatas) {
                var state = new AddPrefabComponentState();
                var data = {
                    sourceData: sourceData,
                    instanceDatas: instanceDatas
                };
                state.data = data;
                return state;
            };
            AddPrefabComponentState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, instanceDatas = _a.instanceDatas, sourceData = _a.sourceData;
                    //remove from prefab
                    this.removeComponent(sourceData);
                    //remove from instance
                    for (var index = 0; index < instanceDatas.length; index++) {
                        var instanceData = instanceDatas[index];
                        this.removeComponent(instanceData);
                    }
                    return true;
                }
                return false;
            };
            AddPrefabComponentState.prototype.removeComponent = function (data) {
                var gameObjectUUid = data.gameObjectUUid, cacheUUid = data.cacheUUid;
                var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                if (gameObj && cacheUUid) {
                    var removeComponent = editor.Editor.editorModel.getComponentById(gameObj, cacheUUid);
                    if (removeComponent) {
                        gameObj.removeComponent(removeComponent);
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.REMOVE_COMPONENT);
                    }
                }
            };
            AddPrefabComponentState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, instanceDatas = _a.instanceDatas, sourceData = _a.sourceData;
                    //add component to prefab
                    var gameObjectUUid = sourceData.gameObjectUUid, compClz = sourceData.compClz;
                    var gameObj = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid);
                    if (gameObj) {
                        var addComponent = void 0;
                        if (sourceData.serializeData) {
                            addComponent = paper.deserialize(sourceData.serializeData, true);
                            editor.Editor.editorModel.addComponentToGameObject(gameObj, addComponent);
                        }
                        else {
                            addComponent = gameObj.addComponent(compClz);
                            sourceData.serializeData = paper.serialize(addComponent);
                            sourceData.cacheUUid = addComponent.uuid;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    //add component to instances
                    for (var index = 0; index < instanceDatas.length; index++) {
                        var instanceData = instanceDatas[index];
                        var gameObjectUUid_1 = instanceData.gameObjectUUid, compClz_1 = instanceData.compClz;
                        var gameObj_1 = editor.Editor.editorModel.getGameObjectByUUid(gameObjectUUid_1);
                        var addComponent = void 0;
                        if (instanceData.serializeData) {
                            addComponent = paper.deserialize(instanceData.serializeData, true);
                            editor.Editor.editorModel.addComponentToGameObject(gameObj_1, addComponent);
                        }
                        else {
                            addComponent = paper.deserialize(sourceData.serializeData, false);
                            instanceData.serializeData = paper.serialize(addComponent);
                            editor.Editor.editorModel.addComponentToGameObject(gameObj_1, addComponent);
                            instanceData.cacheUUid = addComponent.uuid;
                        }
                        this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_COMPONENT);
                    }
                    return true;
                }
                return false;
            };
            return AddPrefabComponentState;
        }(editor.BaseState));
        editor.AddPrefabComponentState = AddPrefabComponentState;
        __reflect(AddPrefabComponentState.prototype, "paper.editor.AddPrefabComponentState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        //修改asset
        var ModifyAssetPropertyState = (function (_super) {
            __extends(ModifyAssetPropertyState, _super);
            function ModifyAssetPropertyState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ModifyAssetPropertyState.toString = function () {
                return "[class common.ModifyAssetPropertyState]";
            };
            ModifyAssetPropertyState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new ModifyAssetPropertyState();
                state.data = data;
                return state;
            };
            ModifyAssetPropertyState.prototype.modifyAssetPropertyValues = function (assetUrl, valueList) {
                return __awaiter(this, void 0, void 0, function () {
                    var _this = this;
                    var target, editInfoList;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, editor.Editor.editorModel.getAssetByAssetUrl(assetUrl)];
                            case 1:
                                target = _a.sent();
                                editInfoList = editor.getEditInfo(target);
                                valueList.forEach(function (propertyValue) { return __awaiter(_this, void 0, void 0, function () {
                                    var propName, copyValue, valueEditType, newValue;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0:
                                                propName = propertyValue.propName, copyValue = propertyValue.copyValue, valueEditType = propertyValue.valueEditType;
                                                return [4 /*yield*/, editor.Editor.editorModel.deserializeProperty(copyValue, valueEditType)];
                                            case 1:
                                                newValue = _a.sent();
                                                editor.Editor.editorModel.setTargetProperty(propName, target, newValue);
                                                this.dispatchEditorModelEvent(editor.EditorModelEvent.CHANGE_PROPERTY, { target: target, propName: propName, propValue: newValue });
                                                return [2 /*return*/];
                                        }
                                    });
                                }); });
                                return [2 /*return*/];
                        }
                    });
                });
            };
            ModifyAssetPropertyState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var _a = this.data, assetUrl = _a.assetUrl, preValueCopylist = _a.preValueCopylist;
                    this.modifyAssetPropertyValues(assetUrl, preValueCopylist);
                    return true;
                }
                return false;
            };
            ModifyAssetPropertyState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var _a = this.data, newValueList = _a.newValueList, assetUrl = _a.assetUrl;
                    this.modifyAssetPropertyValues(assetUrl, newValueList);
                    return true;
                }
                return false;
            };
            return ModifyAssetPropertyState;
        }(editor.BaseState));
        editor.ModifyAssetPropertyState = ModifyAssetPropertyState;
        __reflect(ModifyAssetPropertyState.prototype, "paper.editor.ModifyAssetPropertyState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var CreatePrefabState = (function (_super) {
            __extends(CreatePrefabState, _super);
            function CreatePrefabState() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            CreatePrefabState.toString = function () {
                return "[class common.CreatePrefabState]";
            };
            CreatePrefabState.create = function (data) {
                if (data === void 0) { data = null; }
                var state = new CreatePrefabState();
                state.data = data;
                return state;
            };
            CreatePrefabState.prototype.undo = function () {
                if (_super.prototype.undo.call(this)) {
                    var deleteUUid = this.data.cachePrefabUUid;
                    var gameObj = editor.Editor.editorModel.getGameObjectByUUid(deleteUUid);
                    editor.Editor.editorModel._deleteGameObject([gameObj]);
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.DELETE_GAMEOBJECTS, []);
                    return true;
                }
                return false;
            };
            CreatePrefabState.prototype.redo = function () {
                if (_super.prototype.redo.call(this)) {
                    var prefab = this.data.prefab;
                    if (prefab) {
                        var instance = void 0;
                        if (this.data.serializeData) {
                            instance = paper.deserialize(this.data.serializeData, true);
                            editor.Editor.editorModel.setGameObjectPrefab(instance, prefab, instance);
                        }
                        else {
                            instance = prefab.createInstance();
                            instance.extras.isPrefabRoot = true;
                            editor.Editor.editorModel.setGameObjectPrefab(instance, prefab, instance);
                            this.data.serializeData = paper.serialize(instance);
                        }
                        this.data.cachePrefabUUid = instance.uuid;
                    }
                    //select prefab root
                    this.dispatchEditorModelEvent(editor.EditorModelEvent.ADD_GAMEOBJECTS, [this.data.cachePrefabUUid]);
                    return true;
                }
                return false;
            };
            return CreatePrefabState;
        }(editor.BaseState));
        editor.CreatePrefabState = CreatePrefabState;
        __reflect(CreatePrefabState.prototype, "paper.editor.CreatePrefabState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        /**
         * 预置体结构状态
         * @author 杨宁
         */
        var BreakPrefabStructState = (function (_super) {
            __extends(BreakPrefabStructState, _super);
            function BreakPrefabStructState() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.prefabInfos = [];
                return _this;
            }
            BreakPrefabStructState.create = function (prefabInstanceList) {
                var _this = this;
                var instance = new BreakPrefabStructState();
                instance.prefabInfos = [];
                prefabInstanceList.forEach(function (obj) {
                    instance.prefabInfos = instance.prefabInfos.concat(_this.makePrefabInfo(obj));
                });
                return instance;
            };
            BreakPrefabStructState.makePrefabInfo = function (gameOjbect) {
                var makeInfo = function (target, result) {
                    if (result === void 0) { result = []; }
                    result.push({ uuid: target.uuid, editInfo: __assign({}, target.extras), prefab: target.prefab.name });
                    target.transform.children.forEach(function (transform) {
                        var obj = transform.gameObject;
                        if (editor.Editor.editorModel.isPrefabChild(obj) && !editor.Editor.editorModel.isPrefabRoot(obj)) {
                            makeInfo(obj, result);
                        }
                    });
                };
                var target = gameOjbect;
                var infos = [];
                while (target) {
                    if (editor.Editor.editorModel.isPrefabRoot(target)) {
                        makeInfo(target, infos);
                        break;
                    }
                    if (target.transform.parent)
                        target = target.transform.parent.gameObject;
                    else
                        break;
                }
                return infos;
            };
            BreakPrefabStructState.prototype.redo = function () {
                var ids = this.prefabInfos.map(function (prefabInfos) { return prefabInfos.uuid; });
                var objs = editor.Editor.editorModel.getGameObjectsByUUids(ids);
                objs.forEach(function (obj) {
                    obj.prefab = null;
                    obj.extras = {};
                });
                return true;
            };
            BreakPrefabStructState.prototype.undo = function () {
                var all = paper.Application.sceneManager.activeScene.gameObjects;
                for (var i = 0; i < all.length; i++) {
                    var obj = all[i];
                    b: for (var k = 0; k < this.prefabInfos.length; k++) {
                        var info = this.prefabInfos[k];
                        if (obj.uuid === info.uuid) {
                            obj.extras = info.editInfo;
                            obj.prefab = paper.Asset.find(info.prefab);
                            break b;
                        }
                    }
                }
                return true;
            };
            BreakPrefabStructState.prototype.serialize = function () {
                return this.prefabInfos;
            };
            BreakPrefabStructState.prototype.deserialize = function (data) {
                this.prefabInfos = data;
            };
            return BreakPrefabStructState;
        }(editor.BaseState));
        editor.BreakPrefabStructState = BreakPrefabStructState;
        __reflect(BreakPrefabStructState.prototype, "paper.editor.BreakPrefabStructState");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var ValueUUID = (function () {
            function ValueUUID(_value) {
                this._value = _value;
                // empty
            }
            ValueUUID.prototype.asHex = function () {
                return this._value;
            };
            return ValueUUID;
        }());
        __reflect(ValueUUID.prototype, "ValueUUID", ["paper.editor.UUID"]);
        var V4UUID = (function (_super) {
            __extends(V4UUID, _super);
            function V4UUID() {
                return _super.call(this, [
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    '4',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._oneOf(V4UUID._timeHighBits),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    '-',
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                    V4UUID._randomHex(),
                ].join('')) || this;
            }
            V4UUID._oneOf = function (array) {
                return array[Math.floor(array.length * Math.random())];
            };
            V4UUID._randomHex = function () {
                return V4UUID._oneOf(V4UUID._chars);
            };
            V4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
            V4UUID._timeHighBits = ['8', '9', 'a', 'b'];
            return V4UUID;
        }(ValueUUID));
        __reflect(V4UUID.prototype, "V4UUID");
        function v4() {
            return new V4UUID();
        }
        editor.v4 = v4;
        var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
        function isUUID(value) {
            return _UUIDPattern.test(value);
        }
        editor.isUUID = isUUID;
        /**
         * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.
         * @param value A uuid string.
         */
        function parse(value) {
            if (!isUUID(value)) {
                throw new Error('invalid uuid');
            }
            return new ValueUUID(value);
        }
        editor.parse = parse;
        function generateUuid() {
            return v4().asHex();
        }
        editor.generateUuid = generateUuid;
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var forward = new egret3d.Vector3();
        var up = new egret3d.Vector3();
        var right = new egret3d.Vector3();
        var EditorCameraScript = (function (_super) {
            __extends(EditorCameraScript, _super);
            function EditorCameraScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.moveSpeed = 20;
                _this.wheelSpeed = 2;
                _this.rotateSpeed = 1;
                _this._lastMouseX = 0;
                _this._lastMouseY = 0;
                _this._mouseDown_r = false;
                _this._mouseDown_l = false;
                _this._lookAtPiont = new egret3d.Vector3();
                _this._dragPlanePoint = new egret3d.Vector3(0, 0, 0);
                _this._dragPlaneNormal = new egret3d.Vector3(0, 1, 0);
                _this._helpQuat = new egret3d.Quaternion();
                _this._helpVec3 = new egret3d.Vector3();
                return _this;
            }
            EditorCameraScript.prototype.onStart = function () {
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.bindMouse = egret3d.InputManager.mouse;
            };
            ;
            EditorCameraScript.prototype.onUpdate = function (delta) {
                this.inputUpdate(delta);
                //this.mouseUpdate(delta);
                //Gizmo.DrawLine(new egret3d.Vector3(-5, 5, 0.5), new egret3d.Vector3(5, 5, 0.5), 100.0, [1.0, 0.0, 0.0, 1.0]);
                editor.Gizmo.DrawCoord();
                editor.Gizmo.DrawLights();
                editor.Gizmo.DrawCameras();
                //Gizmo.DrawArrowXYZ();
                // this.editorModel.geoController.update();
            };
            ;
            EditorCameraScript.prototype.OnEnable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.OnDisable = function () {
                this._lastMouseX = 0;
                this._lastMouseY = 0;
                this._mouseDown_r = false;
                this._mouseDown_l = false;
            };
            EditorCameraScript.prototype.inputUpdate = function (delta) {
                var mouse = this.bindMouse;
                var keyboard = this.bindKeyboard;
                forward.x = 0;
                forward.y = 0;
                forward.z = 0;
                up.x = 0;
                up.y = this.moveSpeed * delta;
                up.z = 0;
                right.x = this.moveSpeed * delta;
                right.y = 0;
                right.z = 0;
                var rotation = this.gameObject.transform.getLocalRotation();
                egret3d.Quaternion.transformVector3(rotation, up, up);
                egret3d.Quaternion.transformVector3(rotation, right, right);
                var p = this.gameObject.transform.getLocalPosition();
                var result = new egret3d.Vector3();
                egret3d.Vector3.copy(p, result);
                //上下左右
                if (keyboard.isPressed("LEFT")) {
                    egret3d.Vector3.subtract(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("RIGHT")) {
                    egret3d.Vector3.add(result, right, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("UP")) {
                    egret3d.Vector3.add(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (keyboard.isPressed("DOWN")) {
                    egret3d.Vector3.subtract(result, up, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                //放大缩小
                if (mouse.wheel !== 0) {
                    forward.z = mouse.wheel * this.wheelSpeed;
                    egret3d.Quaternion.transformVector3(rotation, forward, forward);
                    egret3d.Vector3.add(result, forward, result);
                    this.gameObject.transform.setLocalPosition(result);
                }
                if (mouse.isPressed(2) && keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        forward.z = moveX * 0.1;
                        egret3d.Quaternion.transformVector3(rotation, forward, forward);
                        egret3d.Vector3.add(result, forward, result);
                        this.gameObject.transform.setLocalPosition(result);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_r = false;
                }
                //方向
                if (mouse.isPressed(2) && !keyboard.isPressed('ALT')) {
                    if (!this._mouseDown_r) {
                        this._mouseDown_r = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        var euler = this.gameObject.transform.getLocalEulerAngles();
                        this.gameObject.transform.setLocalEulerAngles(Math.max(Math.min((euler.x + moveY * this.rotateSpeed), 89.9), -89.9), euler.y + moveX * this.rotateSpeed, euler.z);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (mouse.wasReleased(2) || keyboard.wasPressed('ALT')) {
                    this._mouseDown_r = false;
                }
                if (keyboard.isPressed('ALT') && mouse.isPressed(0)) {
                    if (!this._mouseDown_l) {
                        this._mouseDown_l = true;
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                        var screenPosition = new egret3d.Vector2(egret3d.stage.screenViewport.w / 2, egret3d.stage.screenViewport.h / 2);
                        var camera = this.gameObject.getComponent(egret3d.Camera);
                        var ray = camera.createRayByScreen(screenPosition.x, screenPosition.y);
                        this._lookAtPiont = ray.intersectPlane(this._dragPlanePoint, this._dragPlaneNormal);
                    }
                    else {
                        var moveX = mouse.position.x - this._lastMouseX;
                        var moveY = mouse.position.y - this._lastMouseY;
                        //let euler = this.gameObject.transform.getLocalEulerAngles();
                        var theta_x = moveY * this.rotateSpeed, theta_y = moveX * this.rotateSpeed;
                        var sinX = Math.sin(theta_x / 180 * Math.PI / 2), cosX = Math.cos(theta_x / 180 * Math.PI / 2);
                        var sinY = Math.sin(theta_y / 180 * Math.PI / 2), cosY = Math.cos(theta_y / 180 * Math.PI / 2);
                        //this.gameObject.transform.setLocalEulerAngles(Math.max(Math.min((euler.x + theta_x), 89.9), -89.9), euler.y + theta_y, euler.z);
                        var rot = this.gameObject.transform.getRotation();
                        var pos = this.gameObject.transform.getPosition();
                        egret3d.Vector3.subtract(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.getRight(this._helpVec3);
                        egret3d.Vector3.normalize(this._helpVec3);
                        egret3d.Quaternion.set(sinX * this._helpVec3.x, sinX * this._helpVec3.y, sinX * this._helpVec3.z, cosX, this._helpQuat);
                        egret3d.Quaternion.transformVector3(this._helpQuat, pos, pos);
                        egret3d.Quaternion.multiply(this._helpQuat, rot, rot);
                        egret3d.Vector3.set(0, 1, 0, this._helpVec3);
                        egret3d.Quaternion.set(sinY * this._helpVec3.x, sinY * this._helpVec3.y, sinY * this._helpVec3.z, cosY, this._helpQuat);
                        egret3d.Quaternion.transformVector3(this._helpQuat, pos, pos);
                        egret3d.Quaternion.multiply(this._helpQuat, rot, rot);
                        egret3d.Vector3.add(pos, this._lookAtPiont, pos);
                        this.gameObject.transform.setRotation(rot);
                        this.gameObject.transform.setPosition(pos);
                        this._lastMouseX = mouse.position.x;
                        this._lastMouseY = mouse.position.y;
                    }
                }
                else if (keyboard.wasReleased('ALT') || mouse.wasReleased(0)) {
                    this._mouseDown_l = false;
                }
                // 复制粘贴
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('C')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     clipboard.writeText("zhrit", "paper");
                // }
                // if (keyboard.isPressed('CONTROL') && keyboard.wasPressed('V')) {
                //     let clipboard = __global.runtimeModule.getClipborad()
                //     let msg = clipboard.readText("paper");
                //     console.log(msg);
                // }
                //(keyboard.isPressed('ALT') && mouse.isPressed(0)) || 
            };
            ;
            EditorCameraScript.prototype.onDestroy = function () {
                var inputManager = egret3d.InputManager;
                if (inputManager.mouse.wasPressed(0)) {
                    // do something
                }
                if (inputManager.keyboard.isPressed("K")) {
                    // do something
                }
                if (inputManager.touch.touchCount > 0) {
                    var touch = inputManager.touch.getTouch(0);
                    // do something
                }
            };
            EditorCameraScript = __decorate([
                paper.executeInEditMode
            ], EditorCameraScript);
            return EditorCameraScript;
        }(paper.Behaviour));
        editor.EditorCameraScript = EditorCameraScript;
        __reflect(EditorCameraScript.prototype, "paper.editor.EditorCameraScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var PickGameObjectScript = (function (_super) {
            __extends(PickGameObjectScript, _super);
            function PickGameObjectScript() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._tapStart = 0;
                _this.selectedGameObjects = [];
                return _this;
            }
            PickGameObjectScript.prototype.onStart = function () {
                this.bindMouse = egret3d.InputManager.mouse;
                this.bindKeyboard = egret3d.InputManager.keyboard;
                this.camera = this.gameObject.getComponent(egret3d.Camera);
                this.cameraScript = this.gameObject.getComponent(editor.EditorCameraScript);
                this.selectedGameObjects = [];
            };
            PickGameObjectScript.prototype.onUpdate = function (delta) {
                try {
                    // 点击 game object 激活
                    if (this.bindMouse.wasReleased(0)) {
                        var ray = this.camera.createRayByScreen(this.bindMouse.position.x, this.bindMouse.position.y);
                        var pickInfo = egret3d.Ray.raycast(ray, true);
                        var tapDelta = Date.now() - this._tapStart;
                        if (this.bindKeyboard.isPressed('CONTROL')) {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                if (picked.name !== "GizmoController_Ball" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        var index = -1;
                                        var l = this.selectedGameObjects.length;
                                        for (var i = 0; i < l; i++) {
                                            if (this.selectedGameObjects[i] == picked) {
                                                index = i;
                                                break;
                                            }
                                        }
                                        if (index < 0) {
                                            this.selectedGameObjects.push(picked);
                                        }
                                        else if (l > 1) {
                                            this.selectedGameObjects.splice(index, 1);
                                        }
                                        this.editorModel.selectGameObject(this.selectedGameObjects);
                                    }
                                }
                            }
                        }
                        else {
                            if (pickInfo) {
                                var picked = pickInfo.transform.gameObject;
                                if (picked.name !== "GizmoController_Ball" && picked.name !== "GizmoController_X" && picked.name !== "GizmoController_Y" && picked.name !== "GizmoController_Z"
                                    && picked.name !== "GizmoController_Rotate_X" && picked.name !== "GizmoController_Rotate_Y" && picked.name !== "GizmoController_Rotate_Z"
                                    && picked.name !== "GizmoController_Scale_X" && picked.name !== "GizmoController_Scale_Y" && picked.name !== "GizmoController_Scale_Z") {
                                    // 对GameObject的点选
                                    if (tapDelta < 200) {
                                        this.selectedGameObjects = [picked];
                                        this.editorModel.selectGameObject(this.selectedGameObjects);
                                    }
                                }
                            }
                            else if (tapDelta < 200) {
                                this.selectedGameObjects = [];
                                this.editorModel.selectGameObject(this.selectedGameObjects);
                            }
                        }
                    }
                    // 点击控制杆，更新控制点
                    if (this.bindMouse.wasPressed(0)) {
                        this._tapStart = Date.now();
                    }
                }
                catch (e) {
                    console.log(e);
                }
            };
            //TODO,描边
            PickGameObjectScript.prototype.setStroke = function (picked) {
            };
            PickGameObjectScript = __decorate([
                paper.executeInEditMode
            ], PickGameObjectScript);
            return PickGameObjectScript;
        }(paper.Behaviour));
        editor.PickGameObjectScript = PickGameObjectScript;
        __reflect(PickGameObjectScript.prototype, "paper.editor.PickGameObjectScript");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var icons = {
            camera: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIcSURBVFhH7ZbPjtMwEMYj7vAACCFg28Rx4oQmtGnLQo/7Du1pK3Hk2BtSHwYkXoA34C34I7Fozxxoy+6yaocZx9M6u4WkFaA95JN+qu0Z21/riVOnVq1a/0oiaoMXPdlCBxpxG0xaNXlB+vHqIl7Utfo5Jl3LxU2uxpkmmjNp1RTEGfg4kZhOp/eRe8xwOHzqmnjSPXxnpjhBlIEIM5BRb40f96Ch2jCZTO6atGryVQeESjVmqCA/zGNy15/2xuv4xcuBK1N4KBNw445FZugauG/ndKr9GlJRYWBBxcn7LHveHAyOHtC4iJKLbQW0C0IlBRNemH6jTzpSQqouOFQ89iSdibLHcrKKbObYBqhGaC9qc/yaAdnKdMKjoLUe08QpvH7zFsp08fOyMI8N0DHRPqUGRJhXsWr112ME5SwWM73Jp5NTzecvFtg/+XqK0UsQ1vNvG+Ax6nN7bYBN8GPW0HVRZL44h+VqdW2cafcOYYUW9jZAAZb3uHiWxPcfZQae7Wdgmw7wYuEk5r8a8MPNBGa+OIMVGpBRfyu9rI/bL/+OAU/Sy2azOS06m81xgzItoRkmm3l7G2gGr7gwGR8LU+JbLAcvEQ29bIi8L4Li0bEBunR4TK9v2r81QCIDwiQSblwNzifYAMkNW+Dil6A2x/9ogGQvtg8HQn0wS2mxIY5LlV98pRqNRnfG4/HtXcD/CrfM9Fq1at1kOc4vVSG2+aaGzOwAAAAASUVORK5CYII=",
            light: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAPcSURBVFhH3ZdLSNRRFMbn4fuZmtmYZpn0gCx6YbQokBZRq6hVL6xWUdCmICIoIYjaWBDRu3WShhUJLSKIIKISgqBWao9NlIsUwlKn33fnzDij/1HHsU0fHM693z333HPOffxnfNNBMBjcgRpCVjjiX6GwsHAJKhDpjYIAdqLCyEpHxKG8vLwgJyen2rrTR25uboPf7/+Ns31GxTBRAJmZmc2BQKC/rKys0qhpAz+Bt8inUCiUZ5xDsgAIeh5BDzCnzaj0kJ2d3YjDcFZW1imjHJIFkJGRcQf7waKiojqj0gdOH5DRz7y8vLlGeQZA6Vex+DBjLUalhtLS0iJrJoDsl+os4PiGUVqsHu48zVCEcYE+JdAfZF9qVAKS+XfgoM1nch+LnK2oqMg3OgYWvIhcsu44VFVV5RLAXYI9alQMBQUFsxm7prPk5dtBhwejdu03hr04Uonj4TftKy4ursVmP/bH0LvZmlgVQMwOBDlDh/D53bbmWklJSbGNeYMJW3D6kWaYBZ4Q/bLIiM+nM8BYG85G6Gr/ndD/owy5doWyE6joBmzf0Ayz8EsSXBsZmRqycHgCx/1MPieCyKtpdyNhgnTCluh2hHGuIFS519EgsGul/w27g3THPWRTAoemyg6OH2fPtLgWoz9OqI4CUNVu0Ve1QmxVidppgywaUUkXjwplVyWGsF9If+ZA5i3Knuw8F46KApCmEkfQKaEH+ewhWxG9xw+13zQnFJ0DBYl2DxHzDqO8/D5HRsGEVuTeWGFovcZx1D6VAKJVQl+gr8pt9/KLXNb4lIGjMzpgkwWhmyGN3V70zMHeguGJDqECtEP4k9M/Cy59cMe3ktUCtcnqKs7D+fn5bq+hEhYXrzZzjqN1DdcQcIPaKcOe2g6aKqfbr5qamhy4TnHKVA+QSh4V8ez/dbR7iml3Eugw+ibBzRE3KfRBYb+bmfhLwuLNY36IBFn4KGO6NfEVeI/tLhlEoS8ivq5gO8R4H4HoagYjox7AwXIMu5mgTDrIqtaGHOwTG31S/aoSduv0RBvnqhT/PRDYitX4fUFTt6NL35PIyBhoIkE8J8NtRiWAxR4x/tS642DV+4BcNCoefhJqYv5j2ql/F5i8GaV9PxlhXECbUM+QRY4AcLep4CC/pBcbNSMIUsIupFdZGuf5k4xTX0kAAwRy36j0QdkO6Fyg9xjl4BWAwOKnUSPcFFUoPegPBpl/RV7RTdi7ZAHoJxf2Xxh/TXd6vwOiIOt6HPWQzUajYkgWgMC8JsbfJT3xqaCuri7bmgmYKACgzDMizX+EuFswc39A/kfE/0RPAp/vL7M1A0/aWSCCAAAAAElFTkSuQmCC"
        };
        //只有编辑模式可以执行，编辑相机
        var Gizmo = (function () {
            function Gizmo() {
            }
            Gizmo.Enabled = function () {
                this.webgl = egret3d.WebGLCapabilities.webgl;
                this.camera = paper.Application.sceneManager.editorScene.find("EditorCamera").getComponent(egret3d.Camera);
                this.initPrg();
                this.lineVertexBuffer = this.webgl.createBuffer();
                this.setVertices();
                this.initIconTexture();
            };
            Gizmo.DrawIcon = function (path, pos, size, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_icon;
                this.verticesLine = [pos.x, pos.y, pos.z];
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesLine), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, this.textures[path]);
                if (color) {
                    prg.setBool("hasColor", true);
                    prg.setColor("iconColor", [color.r, color.g, color.b, color.a]);
                }
                else {
                    prg.setBool("hasColor", false);
                    prg.setColor("iconColor", [0, 0, 0, 1]);
                }
                prg.setTexture("PointTexture", 0);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setFloat("pointSize", size);
                gl.drawArrays(gl.POINTS, 0, 1);
            };
            Gizmo.DrawLine = function (posStart, posEnd, size, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                this.verticesLine = [
                    posStart.x, posStart.y, posStart.z,
                    posEnd.x, posEnd.y, posEnd.z
                ];
                gl.lineWidth(size || 1);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.lineVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesLine), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                gl.drawArrays(gl.LINES, 0, 2);
            };
            Gizmo.DrawCoord = function () {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [0.7, 0.7, 0.7, 0.8]);
                gl.drawArrays(gl.LINES, 0, (2 * this.nrLine + 1) * 4 + 2);
            };
            Gizmo.setVertices = function () {
                var gl = this.webgl;
                var nrLine = this.nrLine = 100;
                this.verticesCoord = [];
                this.cameraVertexBuffer = gl.createBuffer();
                this.cameraIndexBuffer = gl.createBuffer();
                this.coordVertexBuffer = gl.createBuffer();
                this.cylinderVertexBuffer = gl.createBuffer();
                this.arrowVertexBuffer = gl.createBuffer();
                var bia = -0.05;
                for (var i = 0, len = 2 * nrLine + 1; i < len; i++) {
                    this.verticesCoord[6 * i] = -nrLine + i;
                    this.verticesCoord[6 * i + 1] = bia;
                    this.verticesCoord[6 * i + 2] = -nrLine;
                    this.verticesCoord[6 * i + 3] = -nrLine + i;
                    this.verticesCoord[6 * i + 4] = bia;
                    this.verticesCoord[6 * i + 5] = nrLine;
                    this.verticesCoord[6 * len + 6 * i] = -nrLine;
                    this.verticesCoord[6 * len + 6 * i + 1] = bia;
                    this.verticesCoord[6 * len + 6 * i + 2] = -nrLine + i;
                    this.verticesCoord[6 * len + 6 * i + 3] = nrLine;
                    this.verticesCoord[6 * len + 6 * i + 4] = bia;
                    this.verticesCoord[6 * len + 6 * i + 5] = -nrLine + i;
                }
                this.verticesCylinder = [
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, 0.25, 0, 0.433, 0.25, 2,
                    0.25, 0.433, 0, 0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, 0.25, 0, -0.433, 0.25, 2,
                    -0.25, 0.433, 0, -0.25, 0.433, 2,
                    -0.5, 0, 0, -0.5, 0, 2,
                    -0.433, -0.25, 0, -0.433, -0.25, 2,
                    -0.25, -0.433, 0, -0.25, -0.433, 2,
                    0.5, 0, 0, 0.5, 0, 2,
                    0.433, -0.25, 0, 0.433, -0.25, 2,
                    0.25, -0.433, 0, 0.25, -0.433, 2,
                ];
                for (var i = 0; i < this.verticesCylinder.length; i++) {
                    this.verticesCylinder[i] *= 0.5;
                }
                this.verticesArrow = [
                    0.7, 0.0, 0.0, 0.0, 0.0, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    0.7, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    0.7, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, 0.1, 0.7, 0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, 0.1, 0.0, 0.7, 0.0, -0.1,
                    1.0, 0.0, 0.0, 0.7, 0.0, -0.1, 0.7, -0.1, 0.0,
                    1.0, 0.0, 0.0, 0.7, -0.1, 0.0, 0.7, 0.0, 0.1
                ];
                this.verticesCoord = this.verticesCoord.concat([0, -this.nrLine, 0, 0, this.nrLine, 0]);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.coordVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCoord), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCylinder), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesArrow), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);
            };
            Gizmo.setMVPMatrix = function (m) {
                var asp = this.camera.context.viewPortPixel.w / this.camera.context.viewPortPixel.h;
                this.camera.calcViewMatrix(this.vMatrix);
                this.camera.calcProjectMatrix(asp, this.pMatrix);
                egret3d.Matrix.multiply(this.pMatrix, this.vMatrix, this.mvpMatrix);
                m = m || new egret3d.Matrix();
                egret3d.Matrix.copy(m, this.mMatrix);
                egret3d.Matrix.multiply(this.mvpMatrix, this.mMatrix, this.mvpMatrix);
            };
            Gizmo.initPrg = function () {
                this.glProgram_line = new editor.GizmoShader(this.webgl, editor.line_vert, editor.line_frag);
                this.glProgram_icon = new editor.GizmoShader(this.webgl, editor.icon_vert, editor.icon_frag);
            };
            // const cameras = Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
            Gizmo.DrawLights = function () {
                if (!this.enabled)
                    return;
                var camerasAndLights = paper.Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
                for (var _i = 0, _a = camerasAndLights.lights; _i < _a.length; _i++) {
                    var light = _a[_i];
                    Gizmo.DrawIcon("light", light.gameObject.transform.getPosition(), 30, light.color);
                    Gizmo.DrawCylinder(light.gameObject.transform, light.color);
                }
            };
            Gizmo.DrawCylinder = function (transform, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cylinderVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                var m = this.helpMat;
                this.getWorldMatrixWithoutScale(transform, 15, m);
                this.setMVPMatrix(m);
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", [color.r, color.g, color.b, color.a]);
                gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.DrawCameras = function () {
                if (!this.enabled)
                    return;
                var camerasAndLights = paper.Application.sceneManager.globalGameObject.getOrAddComponent(egret3d.CamerasAndLights);
                for (var _i = 0, _a = camerasAndLights.cameras; _i < _a.length; _i++) {
                    var camera = _a[_i];
                    Gizmo.DrawIcon("camera", camera.gameObject.transform.getPosition(), 30);
                    //Gizmo.DrawCameraSquare(this.cameraPool[i], [1.0, 0.0, 1.0, 1.0]);
                }
            };
            Gizmo.DrawCameraSquare = function (obj, color) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.enable(gl.DEPTH_TEST);
                this.getCameraSquare(obj);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.cameraVertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.verticesCameraSquare), gl.STATIC_DRAW);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix();
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                var indices = [1, 0, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7];
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.cameraIndexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                gl.drawElements(gl.LINES, indices.length, gl.UNSIGNED_SHORT, 0);
                //sconsole.log(this.verticesCameraSquare);
                //gl.drawArrays(gl.LINES, 0, 24);
            };
            Gizmo.getCameraSquare = function (obj) {
                this.verticesCameraSquare = [];
                var t = obj.transform;
                var camera = obj.getComponent(egret3d.Camera);
                var forward = this.helpVec31;
                var up = this.helpVec32;
                var right = this.helpVec33;
                var nearCenter = this.helpVec34;
                var farCenter = this.helpVec35;
                t.getForward(forward);
                t.getUp(up);
                t.getRight(right);
                var cameraPos = t.getPosition();
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.near), cameraPos, nearCenter);
                t.getForward(forward);
                egret3d.Vector3.add(egret3d.Vector3.scale(forward, camera.far), cameraPos, farCenter);
                var asp = this.camera.context.viewPortPixel.w / this.camera.context.viewPortPixel.h;
                var nearH = camera.opvalue > 0 ? camera.near * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var nearW = nearH * asp;
                var farH = camera.opvalue > 0 ? camera.far * Math.tan(camera.fov * 0.5) : camera.size * 0.5;
                var farW = farH * asp;
                var point = this.helpVec36;
                //0
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //1
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //2
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //3
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(nearCenter, egret3d.Vector3.scale(up, -nearH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, nearW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //4
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //5
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //6
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, -farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
                //7
                t.getUp(up);
                t.getRight(right);
                egret3d.Vector3.add(farCenter, egret3d.Vector3.scale(up, -farH), point);
                egret3d.Vector3.add(point, egret3d.Vector3.scale(right, farW), point);
                this.verticesCameraSquare = this.verticesCameraSquare.concat([point.x, point.y, point.z]);
            };
            Gizmo.DrawArrow = function (m, color, fixSize) {
                if (!this.enabled)
                    return;
                var gl = this.webgl;
                var prg = this.glProgram_line;
                gl.disable(gl.DEPTH_TEST);
                prg.use();
                var prgVertexPosition = gl.getAttribLocation(prg.prg, "aVertexPosition");
                gl.bindBuffer(gl.ARRAY_BUFFER, this.arrowVertexBuffer);
                gl.vertexAttribPointer(prgVertexPosition, 3, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(prgVertexPosition);
                this.setMVPMatrix(m);
                prg.setMatrix("mvpMat", this.mvpMatrix);
                prg.setColor("lineColor", color);
                gl.drawArrays(gl.LINES, 0, 2);
                gl.drawArrays(gl.TRIANGLES, 2, 24);
            };
            Gizmo.DrawArrowXYZ = function (transform) {
                var worldMat = Gizmo.helpMat;
                Gizmo.getWorldMatrixWithoutScale(transform, 10, worldMat);
                egret3d.Matrix.multiply(worldMat, this.xArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [1.0, 0.0, 0.0, 1.0], true);
                egret3d.Matrix.multiply(worldMat, this.yArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [0.0, 1.0, 0.0, 1.0], true);
                egret3d.Matrix.multiply(worldMat, this.zArrowMMatrix, worldMat);
                Gizmo.DrawArrow(worldMat, [0.0, 0.0, 1.0, 1.0], true);
            };
            Gizmo.getWorldMatrixWithoutScale = function (transform, fixScale, out) {
                egret3d.Matrix.identify(out);
                var p = transform.getPosition();
                var r = transform.getRotation();
                var p_c = this.camera.gameObject.transform.getPosition();
                egret3d.Vector3.subtract(p, p_c, p_c);
                var sca = egret3d.Vector3.getLength(p_c) / fixScale;
                var matS = this.helpMat1;
                egret3d.Matrix.formScale(sca, sca, sca, matS);
                egret3d.Quaternion.toMatrix(r, out);
                egret3d.Matrix.multiply(out, matS, out);
                out.rawData[12] = p.x;
                out.rawData[13] = p.y;
                out.rawData[14] = p.z;
            };
            Gizmo.initIconTexture = function () {
                for (var key in icons) {
                    var image = new Image();
                    this._imageLoadCount++;
                    image.setAttribute('src', icons[key]);
                    image.onload = this.loadIconTexture.bind(this, image, key);
                }
            };
            Gizmo.loadIconTexture = function (image, key) {
                var webgl = egret3d.WebGLCapabilities.webgl;
                var texture = webgl.createTexture();
                webgl.bindTexture(webgl.TEXTURE_2D, texture);
                webgl.texImage2D(webgl.TEXTURE_2D, 0, webgl.RGBA, webgl.RGBA, webgl.UNSIGNED_BYTE, image);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MAG_FILTER, webgl.LINEAR);
                webgl.texParameteri(webgl.TEXTURE_2D, webgl.TEXTURE_MIN_FILTER, webgl.LINEAR);
                this._imageLoadCount--;
                this.textures[key] = texture;
                if (this._imageLoadCount === 0) {
                    this.enabled = true;
                }
            };
            Gizmo.enabled = false;
            Gizmo.mvpMatrix = new egret3d.Matrix();
            Gizmo.mMatrix = new egret3d.Matrix();
            Gizmo.vMatrix = new egret3d.Matrix();
            Gizmo.pMatrix = new egret3d.Matrix();
            Gizmo.helpVec31 = new egret3d.Vector3();
            Gizmo.helpVec32 = new egret3d.Vector3();
            Gizmo.helpVec33 = new egret3d.Vector3();
            Gizmo.helpVec34 = new egret3d.Vector3();
            Gizmo.helpVec35 = new egret3d.Vector3();
            Gizmo.helpVec36 = new egret3d.Vector3();
            Gizmo.xArrowMMatrix = new egret3d.Matrix();
            Gizmo.yArrowMMatrix = new egret3d.Matrix(new Float32Array([
                0, 1, 0, 0,
                -1, 0, 0, 0,
                0, 0, 1, 0,
                0, 0, 0, 1
            ]));
            Gizmo.zArrowMMatrix = new egret3d.Matrix(new Float32Array([
                0, 0, 1, 0,
                0, 1, 0, 0,
                -1, 0, 0, 0,
                0, 0, 0, 1
            ]));
            Gizmo.helpMat = new egret3d.Matrix();
            Gizmo.helpMat1 = new egret3d.Matrix();
            Gizmo._imageLoadCount = 0;
            Gizmo.textures = {};
            return Gizmo;
        }());
        editor.Gizmo = Gizmo;
        __reflect(Gizmo.prototype, "paper.editor.Gizmo");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        var GizmoShader = (function () {
            function GizmoShader(gl, vshader, fshader) {
                this.gl = gl;
                this.prg = this.createProgram(vshader, fshader);
            }
            GizmoShader.prototype.createProgram = function (vshader, fshader) {
                var gl = this.gl;
                var prg = gl.createProgram();
                var vertexShader = this.createShader(gl.VERTEX_SHADER, vshader);
                var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fshader);
                gl.attachShader(prg, vertexShader);
                gl.attachShader(prg, fragmentShader);
                gl.linkProgram(prg);
                if (!gl.getProgramParameter(prg, gl.LINK_STATUS)) {
                    alert("Could not initialise shaders");
                }
                return prg;
            };
            GizmoShader.prototype.createShader = function (type, str) {
                var gl = this.gl;
                var shader = gl.createShader(type);
                gl.shaderSource(shader, str);
                gl.compileShader(shader);
                var parameter = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
                if (!parameter) {
                    if (confirm("shader compile:" + gl.getShaderInfoLog(shader) + "\n")) {
                        gl.deleteShader(shader);
                    }
                    return null;
                }
                return shader;
            };
            GizmoShader.prototype.use = function () {
                this.gl.useProgram(this.prg);
            };
            GizmoShader.prototype.setFloat = function (name, value) {
                var gl = this.gl;
                gl.uniform1f(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setInt = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            GizmoShader.prototype.setBool = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value ? 1 : 0);
            };
            GizmoShader.prototype.setVec3 = function (name, value) {
                var gl = this.gl;
                gl.uniform3f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z);
            };
            GizmoShader.prototype.setVec4 = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value.x, value.y, value.z, value.w);
            };
            GizmoShader.prototype.setColor = function (name, value) {
                var gl = this.gl;
                gl.uniform4f(gl.getUniformLocation(this.prg, name), value[0], value[1], value[2], value[3]);
            };
            //public setColor (name: string, value: egret3d.Color) {
            //let gl = this.gl;
            //gl.uniform4f(gl.getUniformLocation(this.prg, name), value.r, value.g, value.b, value.a);
            //}
            GizmoShader.prototype.setMatrix = function (name, value) {
                var gl = this.gl;
                gl.uniformMatrix4fv(gl.getUniformLocation(this.prg, name), false, value.rawData);
            };
            GizmoShader.prototype.setTexture = function (name, value) {
                var gl = this.gl;
                gl.uniform1i(gl.getUniformLocation(this.prg, name), value);
            };
            return GizmoShader;
        }());
        editor.GizmoShader = GizmoShader;
        __reflect(GizmoShader.prototype, "paper.editor.GizmoShader");
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    var editor;
    (function (editor) {
        editor.icon_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform sampler2D PointTexture;\n        uniform bool hasColor;\n        uniform vec4 iconColor;\n        void main(void) {\n            vec4 tex = texture2D(PointTexture, gl_PointCoord);\n            gl_FragColor = tex;\n            if (hasColor) {\n                if (gl_FragColor.a >= 0.1) {\n                    gl_FragColor = iconColor;\n                } else {\n                    gl_FragColor.a = 0.0;\n                }\n            }\n        }";
        editor.icon_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        uniform float pointSize;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n            gl_PointSize = pointSize; \n        }";
        editor.line_frag = "\n        #ifdef GL_ES\n        precision highp float;\n        #endif\n        uniform vec4 lineColor;\n        void main(void) {\n            gl_FragColor = lineColor;\n        }";
        editor.line_vert = "\n        attribute vec3 aVertexPosition; \n        uniform mat4 mvpMat;\n        void main(void) {\n            gl_Position = mvpMat * vec4(aVertexPosition,1.0);\n        }";
    })(editor = paper.editor || (paper.editor = {}));
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     *
     */
    var Group = (function () {
        function Group(interestConfig) {
            /**
             *
             */
            this.locked = false;
            this.name = "";
            this._isRemoved = false;
            this._isBehaviour = false;
            this._bufferedGameObjects = [];
            /**
             * @internal
             */
            this._addedGameObjects = [];
            this._gameObjects = [];
            this._bufferedComponents = [];
            /**
             * @internal
             */
            this._addedComponents = [];
            this._components = [];
            this._interestConfig = null;
            this._globalGameObject = paper.Application.sceneManager.globalGameObject;
            this._isBehaviour = interestConfig.length === 1 && interestConfig[0].type !== undefined && interestConfig[0].type !== 0;
            this._interestConfig = interestConfig;
            this._onAddComponent = this._onAddComponent.bind(this);
            this._onRemoveComponent = this._onRemoveComponent.bind(this);
            this._onAddUnessentialComponent = this._onAddUnessentialComponent.bind(this);
            this._onRemoveUnessentialComponent = this._onRemoveUnessentialComponent.bind(this);
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    if (Array.isArray(config.componentClass)) {
                        for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                            var componentClass = _c[_b];
                            paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddUnessentialComponent);
                            paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveUnessentialComponent);
                        }
                    }
                    else {
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddUnessentialComponent);
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveUnessentialComponent);
                    }
                }
                else {
                    if (Array.isArray(config.componentClass)) {
                        for (var _d = 0, _e = config.componentClass; _d < _e.length; _d++) {
                            var componentClass = _e[_d];
                            paper.EventPool.addEventListener("__enabled__" /* Enabled */, componentClass, this._onAddComponent);
                            paper.EventPool.addEventListener("__disabled__" /* Disabled */, componentClass, this._onRemoveComponent);
                        }
                    }
                    else {
                        paper.EventPool.addEventListener("__enabled__" /* Enabled */, config.componentClass, this._onAddComponent);
                        paper.EventPool.addEventListener("__disabled__" /* Disabled */, config.componentClass, this._onRemoveComponent);
                    }
                }
            }
            for (var _f = 0, _g = paper.Application.sceneManager.scenes; _f < _g.length; _f++) {
                var scene = _g[_f];
                for (var _h = 0, _j = scene.gameObjects; _h < _j.length; _h++) {
                    var gameObject = _j[_h];
                    this._addGameObject(gameObject);
                }
            }
        }
        /**
         * @internal
         */
        Group.create = function (interestConfig) {
            interestConfig = Array.isArray(interestConfig) ? interestConfig : [interestConfig];
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group_1 = _a[_i];
                if (group_1._interestConfig.length !== interestConfig.length) {
                    continue;
                }
                var isSame = true;
                for (var i = 0, l = interestConfig.length; i < l; ++i) {
                    var configA = interestConfig[i];
                    var configB = group_1._interestConfig[i];
                    if (configA.type !== configB.type) {
                        isSame = false;
                        break;
                    }
                    if (Array.isArray(configA.componentClass) && Array.isArray(configB.componentClass)) {
                        if (configA.componentClass.length !== configB.componentClass.length) {
                            isSame = false;
                            break;
                        }
                    }
                    else if (configA.componentClass !== configB.componentClass) {
                        isSame = false;
                        break;
                    }
                }
                if (isSame) {
                    return group_1;
                }
            }
            var group = new Group(interestConfig);
            this._groups.push(group);
            return group;
        };
        /**
         * @internal
         */
        Group.update = function () {
            for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
                var group = _a[_i];
                group._update();
            }
        };
        Group.prototype._onAddComponent = function (component) {
            this._addGameObject(component.gameObject);
        };
        Group.prototype._onAddUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (gameObject === this._globalGameObject) {
                return;
            }
            if (!this._isBehaviour &&
                this._bufferedGameObjects.indexOf(gameObject) < 0 && this._gameObjects.indexOf(gameObject) < 0 // Uninclude.
            ) {
                return;
            }
            if (this._bufferedComponents.indexOf(component) >= 0 || this._components.indexOf(component) >= 0) {
                return;
            }
            this._bufferedComponents.push(component);
        };
        Group.prototype._onRemoveUnessentialComponent = function (component) {
            var gameObject = component.gameObject;
            if (gameObject === this._globalGameObject) {
                return;
            }
            var index = this._bufferedComponents.indexOf(component);
            if (index >= 0) {
                this._bufferedComponents.splice(index, 1);
                return;
            }
            if (this._isBehaviour) {
                index = this._components.indexOf(component);
                if (index < 0) {
                    return;
                }
                this._isRemoved = true;
                this._components[index] = null;
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            else {
                if (this._gameObjects.indexOf(gameObject) < 0) {
                    return;
                }
                index = this._addedComponents.indexOf(component);
                if (index >= 0) {
                    this._addedComponents[index] = null;
                }
            }
            for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                var system = _a[_i];
                if (!system.onRemoveComponent || system.groups.indexOf(this) < 0) {
                    continue;
                }
                system.onRemoveComponent(component, this);
            }
        };
        Group.prototype._onRemoveComponent = function (component) {
            this._removeGameObject(component.gameObject);
        };
        Group.prototype._addGameObject = function (gameObject) {
            if (gameObject === this._globalGameObject) {
                return;
            }
            if (this._bufferedGameObjects.indexOf(gameObject) >= 0 ||
                this._gameObjects.indexOf(gameObject) >= 0) {
                return;
            }
            for (var _i = 0, _a = this._interestConfig; _i < _a.length; _i++) {
                var config = _a[_i];
                if (config.type && (config.type & 4 /* Unessential */)) {
                    continue;
                }
                var isExtends = config.type && (config.type & 1 /* Extends */) !== 0;
                var isExculde = config.type && (config.type & 2 /* Exculde */) !== 0;
                var insterestComponent = null;
                if (Array.isArray(config.componentClass)) {
                    for (var _b = 0, _c = config.componentClass; _b < _c.length; _b++) {
                        var componentClass = _c[_b];
                        insterestComponent = gameObject.getComponent(componentClass, isExtends);
                        if (insterestComponent) {
                            break;
                        }
                    }
                }
                else {
                    insterestComponent = gameObject.getComponent(config.componentClass, isExtends);
                }
                if (isExculde ? insterestComponent : !insterestComponent) {
                    return;
                }
            }
            this._bufferedGameObjects.push(gameObject);
        };
        Group.prototype._removeGameObject = function (gameObject) {
            var index = this._bufferedGameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._bufferedGameObjects.splice(index, 1);
            }
            else {
                index = this._gameObjects.indexOf(gameObject);
                if (index >= 0) {
                    if (this.locked) {
                        this.locked = false;
                        this._gameObjects = this._gameObjects.concat();
                    }
                    this._gameObjects.splice(index, 1);
                    index = this._addedGameObjects.indexOf(gameObject);
                    if (index >= 0) {
                        this._addedGameObjects[index] = null;
                    }
                    for (var _i = 0, _a = paper.Application.systemManager.systems; _i < _a.length; _i++) {
                        var system = _a[_i];
                        if (!system.onRemoveGameObject || system.groups.indexOf(this) < 0) {
                            continue;
                        }
                        system.onRemoveGameObject(gameObject, this);
                    }
                }
            }
        };
        Group.prototype._update = function () {
            this.locked = false;
            if (this._addedGameObjects.length > 0) {
                this._addedGameObjects.length = 0;
            }
            if (this._addedComponents.length > 0) {
                this._addedComponents.length = 0;
            }
            if (this._isRemoved) {
                var index = 0;
                var removeCount = 0;
                this._isRemoved = false;
                for (var _i = 0, _a = this._components; _i < _a.length; _i++) {
                    var component = _a[_i];
                    if (component) {
                        if (removeCount > 0) {
                            this._components[index - removeCount] = component;
                            this._components[index] = null;
                        }
                    }
                    else {
                        removeCount++;
                    }
                    index++;
                }
                if (removeCount > 0) {
                    this._components.length -= removeCount;
                }
            }
            if (this._bufferedGameObjects.length > 0) {
                for (var _b = 0, _c = this._bufferedGameObjects; _b < _c.length; _b++) {
                    var gameObject = _c[_b];
                    if (!gameObject) {
                        continue;
                    }
                    this._addedGameObjects.push(gameObject);
                    this._gameObjects.push(gameObject);
                }
                this._bufferedGameObjects.length = 0;
            }
            if (this._bufferedComponents.length > 0) {
                for (var _d = 0, _e = this._bufferedComponents; _d < _e.length; _d++) {
                    var component = _e[_d];
                    if (!component) {
                        continue;
                    }
                    this._addedComponents.push(component);
                    this._components.push(component);
                }
                this._bufferedComponents.length = 0;
            }
        };
        /**
         * 判断实体是否被收集。
         */
        Group.prototype.hasGameObject = function (gameObject) {
            return this._gameObjects.indexOf(gameObject) >= 0;
        };
        Object.defineProperty(Group.prototype, "gameObjects", {
            /**
             *
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Group.prototype, "components", {
            /**
             *
             */
            get: function () {
                return this._components;
            },
            enumerable: true,
            configurable: true
        });
        Group._groups = [];
        return Group;
    }());
    paper.Group = Group;
    __reflect(Group.prototype, "paper.Group");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * 场景类
     */
    var Scene = (function (_super) {
        __extends(Scene, _super);
        /**
         * @internal
         */
        function Scene(isActive) {
            if (isActive === void 0) { isActive = true; }
            var _this = _super.call(this) || this;
            /**
             * 场景名称。
             */
            _this.name = "";
            /**
             * 场景的light map列表。
             */
            _this.lightmaps = [];
            /**
             * lightmap强度
             */
            _this.lightmapIntensity = 1.0;
            /**
             * 存储着关联的数据
             * 场景保存时，将场景快照数据保存至对应的资源中
             */
            _this.rawScene = null;
            /**
             * @internal
             */
            _this._gameObjects = [];
            paper.Application.sceneManager._addScene(_this, isActive);
            return _this;
        }
        /**
         * @internal
         */
        Scene.prototype._destroy = function () {
            var i = this._gameObjects.length;
            while (i--) {
                var gameObject = this._gameObjects[i];
                if (!gameObject || gameObject.transform.parent) {
                    continue;
                }
                gameObject.destroy();
            }
            this.lightmaps.length = 0;
            this._gameObjects.length = 0;
            this.rawScene = null;
        };
        /**
         * @internal
         */
        Scene.prototype._addGameObject = function (gameObject) {
            if (this._gameObjects.indexOf(gameObject) < 0) {
                this._gameObjects.push(gameObject);
            }
            else {
                console.debug("Add game object error.", gameObject.path);
            }
        };
        /**
         * @internal
         */
        Scene.prototype._removeGameObject = function (gameObject) {
            var index = this._gameObjects.indexOf(gameObject);
            if (index >= 0) {
                this._gameObjects.splice(index, 1);
            }
            else {
                console.debug("Remove game object error.", gameObject.path);
            }
        };
        /**
         * 返回当前激活场景中查找对应名称的GameObject
         * @param name
         */
        Scene.prototype.find = function (name) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.name === name) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回一个在当前激活场景中查找对应tag的GameObject
         * @param tag
         */
        Scene.prototype.findWithTag = function (tag) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回一个在当前激活场景中查找对应 uuid 的GameObject
         * @param uuid
         */
        Scene.prototype.findWithUUID = function (uuid) {
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.uuid === uuid) {
                    return gameObject;
                }
            }
            return null;
        };
        /**
         * 返回所有在当前激活场景中查找对应tag的GameObject
         * @param name
         */
        Scene.prototype.findGameObjectsWithTag = function (tag) {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (gameObject.tag === tag) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        /**
         * 获取所有根级GameObject对象
         */
        Scene.prototype.getRootGameObjects = function () {
            var gameObjects = [];
            for (var _i = 0, _a = this._gameObjects; _i < _a.length; _i++) {
                var gameObject = _a[_i];
                if (!gameObject.transform.parent) {
                    gameObjects.push(gameObject);
                }
            }
            return gameObjects;
        };
        Object.defineProperty(Scene.prototype, "gameObjectCount", {
            get: function () {
                return this._gameObjects.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Scene.prototype, "gameObjects", {
            /**
             * 当前场景的所有GameObject对象池
             */
            get: function () {
                return this._gameObjects;
            },
            enumerable: true,
            configurable: true
        });
        __decorate([
            paper.serializedField
        ], Scene.prototype, "name", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmaps", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "lightmapIntensity", void 0);
        __decorate([
            paper.serializedField
        ], Scene.prototype, "extras", void 0);
        __decorate([
            paper.serializedField,
            paper.deserializedIgnore
        ], Scene.prototype, "gameObjects", null);
        return Scene;
    }(paper.SerializableObject));
    paper.Scene = Scene;
    __reflect(Scene.prototype, "paper.Scene");
})(paper || (paper = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var EnableSystem = (function (_super) {
        __extends(EnableSystem, _super);
        function EnableSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        EnableSystem.prototype.onAddComponent = function (component) {
            if (!component) {
                return;
            }
            if (this._isEditorUpdate()) {
                if (!component.constructor.executeInEditMode) {
                    return;
                }
                if (!component._isReseted) {
                    component._isReseted = true;
                    component.onReset && component.onReset();
                }
            }
            component.onEnable && component.onEnable();
        };
        return EnableSystem;
    }(paper.BaseSystem));
    paper.EnableSystem = EnableSystem;
    __reflect(EnableSystem.prototype, "paper.EnableSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var BoxCollider = (function (_super) {
            __extends(BoxCollider, _super);
            function BoxCollider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.geometryType = oimo.GeometryType.Box;
                _this._size = egret3d.Vector3.ONE.clone();
                return _this;
            }
            BoxCollider.prototype._createShape = function () {
                var config = this._updateConfig();
                config.geometry = new OIMO.BoxGeometry(egret3d.helpVector3A.copy(this._size).scale(0.5));
                var shape = new OIMO.Shape(config);
                shape.userData = this;
                return shape;
            };
            Object.defineProperty(BoxCollider.prototype, "size", {
                /**
                 *
                 */
                get: function () {
                    return this._size;
                },
                set: function (value) {
                    if (this._oimoShape) {
                        console.warn("Cannot change the size after the collider has been created.");
                    }
                    else {
                        this._size.copy(value);
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], BoxCollider.prototype, "_size", void 0);
            BoxCollider = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], BoxCollider);
            return BoxCollider;
        }(oimo.Collider));
        oimo.BoxCollider = BoxCollider;
        __reflect(BoxCollider.prototype, "egret3d.oimo.BoxCollider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var SphereCollider = (function (_super) {
            __extends(SphereCollider, _super);
            function SphereCollider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.geometryType = oimo.GeometryType.Sphere;
                _this._radius = 1.0;
                return _this;
            }
            SphereCollider.prototype._createShape = function () {
                var config = this._updateConfig();
                config.geometry = new OIMO.SphereGeometry(this._radius);
                var shape = new OIMO.Shape(config);
                shape.userData = this;
                return shape;
            };
            Object.defineProperty(SphereCollider.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the radius after the collider has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], SphereCollider.prototype, "_radius", void 0);
            SphereCollider = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], SphereCollider);
            return SphereCollider;
        }(oimo.Collider));
        oimo.SphereCollider = SphereCollider;
        __reflect(SphereCollider.prototype, "egret3d.oimo.SphereCollider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var CylinderCollider = (function (_super) {
            __extends(CylinderCollider, _super);
            function CylinderCollider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.geometryType = oimo.GeometryType.Cylinder;
                _this._radius = 1.0;
                _this._height = 1.0;
                return _this;
            }
            CylinderCollider.prototype._createShape = function () {
                var config = this._updateConfig();
                config.geometry = new OIMO.CylinderGeometry(this._radius, this._height * 0.5);
                var shape = new OIMO.Shape(config);
                shape.userData = this;
                return shape;
            };
            Object.defineProperty(CylinderCollider.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the radius after the collider has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CylinderCollider.prototype, "height", {
                /**
                 *
                 */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the height after the collider has been created.");
                    }
                    else {
                        this._height = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CylinderCollider.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], CylinderCollider.prototype, "_height", void 0);
            CylinderCollider = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], CylinderCollider);
            return CylinderCollider;
        }(oimo.Collider));
        oimo.CylinderCollider = CylinderCollider;
        __reflect(CylinderCollider.prototype, "egret3d.oimo.CylinderCollider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var ConeCollider = (function (_super) {
            __extends(ConeCollider, _super);
            function ConeCollider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.geometryType = oimo.GeometryType.Cone;
                _this._radius = 1.0;
                _this._height = 1.0;
                return _this;
            }
            ConeCollider.prototype._createShape = function () {
                var config = this._updateConfig();
                config.geometry = new OIMO.ConeGeometry(this._radius, this._height * 0.5);
                var shape = new OIMO.Shape(config);
                shape.userData = this;
                return shape;
            };
            Object.defineProperty(ConeCollider.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the radius after the collider has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeCollider.prototype, "height", {
                /**
                 *
                 */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the height after the collider has been created.");
                    }
                    else {
                        this._height = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ConeCollider.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], ConeCollider.prototype, "_height", void 0);
            ConeCollider = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], ConeCollider);
            return ConeCollider;
        }(oimo.Collider));
        oimo.ConeCollider = ConeCollider;
        __reflect(ConeCollider.prototype, "egret3d.oimo.ConeCollider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var CapsuleCollider = (function (_super) {
            __extends(CapsuleCollider, _super);
            function CapsuleCollider() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.geometryType = oimo.GeometryType.Capsule;
                _this._radius = 1.0;
                _this._height = 1.0;
                return _this;
            }
            CapsuleCollider.prototype._createShape = function () {
                var config = this._updateConfig();
                config.geometry = new OIMO.CapsuleGeometry(this._radius, this._height * 0.5);
                var shape = new OIMO.Shape(config);
                shape.userData = this;
                return shape;
            };
            Object.defineProperty(CapsuleCollider.prototype, "radius", {
                /**
                 *
                 */
                get: function () {
                    return this._radius;
                },
                set: function (value) {
                    if (this._radius === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the radius after the collider has been created.");
                    }
                    else {
                        this._radius = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CapsuleCollider.prototype, "height", {
                /**
                 *
                 */
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (this._height === value) {
                        return;
                    }
                    if (this._oimoShape) {
                        console.warn("Cannot change the height after the collider has been created.");
                    }
                    else {
                        this._height = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], CapsuleCollider.prototype, "_radius", void 0);
            __decorate([
                paper.serializedField
            ], CapsuleCollider.prototype, "_height", void 0);
            CapsuleCollider = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], CapsuleCollider);
            return CapsuleCollider;
        }(oimo.Collider));
        oimo.CapsuleCollider = CapsuleCollider;
        __reflect(CapsuleCollider.prototype, "egret3d.oimo.CapsuleCollider");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var paper;
(function (paper) {
    /**
     * @internal
     */
    var StartSystem = (function (_super) {
        __extends(StartSystem, _super);
        function StartSystem() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this._interests = [
                { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true }
            ];
            return _this;
        }
        StartSystem.prototype.onAddComponent = function (component) {
            if (!component || component._isStarted) {
                return;
            }
            if (this._isEditorUpdate() &&
                !component.constructor.executeInEditMode) {
                return;
            }
            component._isStarted = true;
            component.onStart && component.onStart();
        };
        return StartSystem;
    }(paper.BaseSystem));
    paper.StartSystem = StartSystem;
    __reflect(StartSystem.prototype, "paper.StartSystem");
})(paper || (paper = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var SphericalJoint = (function (_super) {
            __extends(SphericalJoint, _super);
            function SphericalJoint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.jointType = oimo.JointType.Spherical;
                _this._valuesB = new Float32Array([
                    0.0, 0.0, 0,
                ]);
                return _this;
            }
            SphericalJoint_1 = SphericalJoint;
            SphericalJoint.prototype._createJoint = function () {
                if (!this._connectedBody) {
                    // TODO
                    return null;
                }
                this._rigidbody = this.gameObject.getComponent(oimo.Rigidbody);
                var config = SphericalJoint_1._config;
                config.allowCollision = this.collisionEnabled;
                if (this.useGlobalAnchor) {
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, this._anchor);
                }
                else {
                    var matrix = this.gameObject.transform.getWorldMatrix();
                    var anchor = matrix.transformVector3(egret3d.helpVector3A.copy(this._anchor));
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, anchor);
                }
                config.springDamper = SphericalJoint_1._springDamper;
                config.springDamper.frequency = this.frequency;
                config.springDamper.dampingRatio = this.dampingRatio;
                config.springDamper.useSymplecticEuler = this.useSymplecticEuler;
                var joint = new OIMO.SphericalJoint(config);
                joint.userData = this;
                return joint;
            };
            Object.defineProperty(SphericalJoint.prototype, "frequency", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[0 /* Frequency */];
                },
                set: function (value) {
                    this._valuesB[0 /* Frequency */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SphericalJoint.prototype, "dampingRatio", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[1 /* DampingRatio */];
                },
                set: function (value) {
                    this._valuesB[1 /* DampingRatio */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SphericalJoint.prototype, "useSymplecticEuler", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[2 /* UseSymplecticEuler */] > 0;
                },
                set: function (value) {
                    this._valuesB[2 /* UseSymplecticEuler */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            SphericalJoint._config = new OIMO.SphericalJointConfig();
            SphericalJoint._springDamper = new OIMO.SpringDamper();
            __decorate([
                paper.serializedField
            ], SphericalJoint.prototype, "_valuesB", void 0);
            SphericalJoint = SphericalJoint_1 = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], SphericalJoint);
            return SphericalJoint;
            var SphericalJoint_1;
        }(oimo.Joint));
        oimo.SphericalJoint = SphericalJoint;
        __reflect(SphericalJoint.prototype, "egret3d.oimo.SphericalJoint");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var HingeJoint = (function (_super) {
            __extends(HingeJoint, _super);
            function HingeJoint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.jointType = oimo.JointType.Hinge;
                _this._axis = egret3d.Vector3.UP.clone();
                _this._valuesB = new Float32Array([
                    0.0, 0.0, 0,
                    -180.0, 180.0, 0.0, 0.0,
                ]);
                return _this;
            }
            HingeJoint_1 = HingeJoint;
            HingeJoint.prototype._createJoint = function () {
                if (!this._connectedBody) {
                    // TODO
                    return null;
                }
                this._rigidbody = this.gameObject.getComponent(oimo.Rigidbody);
                var config = HingeJoint_1._config;
                config.allowCollision = this.collisionEnabled;
                if (this.useGlobalAnchor) {
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, this._anchor, this._axis);
                }
                else {
                    var matrix = this.gameObject.transform.getWorldMatrix();
                    var anchor = matrix.transformVector3(egret3d.helpVector3A.copy(this._anchor));
                    var axis = matrix.transformNormal(egret3d.helpVector3B.copy(this._axis));
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, anchor, axis);
                }
                config.springDamper = HingeJoint_1._springDamper;
                config.limitMotor = HingeJoint_1._limitMotor;
                config.springDamper.frequency = this.frequency;
                config.springDamper.dampingRatio = this.dampingRatio;
                config.springDamper.useSymplecticEuler = this.useSymplecticEuler;
                config.limitMotor.lowerLimit = this.lowerLimit * egret3d.DEG_RAD;
                config.limitMotor.upperLimit = this.upperLimit * egret3d.DEG_RAD;
                config.limitMotor.motorSpeed = this.motorSpeed * egret3d.DEG_RAD;
                config.limitMotor.motorTorque = this.motorTorque;
                var joint = new OIMO.RevoluteJoint(config);
                joint.userData = this;
                return joint;
            };
            Object.defineProperty(HingeJoint.prototype, "frequency", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[0 /* Frequency */];
                },
                set: function (value) {
                    this._valuesB[0 /* Frequency */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "dampingRatio", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[1 /* DampingRatio */];
                },
                set: function (value) {
                    this._valuesB[1 /* DampingRatio */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "useSymplecticEuler", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[2 /* UseSymplecticEuler */] > 0;
                },
                set: function (value) {
                    this._valuesB[2 /* UseSymplecticEuler */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "lowerLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[3 /* LowerLimit */];
                },
                set: function (value) {
                    this._valuesB[3 /* LowerLimit */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor();
                        limitMotor.lowerLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "upperLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[4 /* UpperLimit */];
                },
                set: function (value) {
                    this._valuesB[4 /* UpperLimit */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor();
                        limitMotor.upperLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "motorSpeed", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[5 /* MotorSpeed */];
                },
                set: function (value) {
                    this._valuesB[5 /* MotorSpeed */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor();
                        limitMotor.motorSpeed = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "motorTorque", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[6 /* MotorTorque */];
                },
                set: function (value) {
                    this._valuesB[6 /* MotorTorque */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor();
                        limitMotor.motorTorque = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(HingeJoint.prototype, "axis", {
                /**
                 *
                 */
                get: function () {
                    return this._axis;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the axis after the joint has been created.");
                    }
                    else {
                        this._axis.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            HingeJoint._config = new OIMO.RevoluteJointConfig();
            HingeJoint._springDamper = new OIMO.SpringDamper();
            HingeJoint._limitMotor = new OIMO.RotationalLimitMotor();
            __decorate([
                paper.serializedField
            ], HingeJoint.prototype, "_axis", void 0);
            __decorate([
                paper.serializedField
            ], HingeJoint.prototype, "_valuesB", void 0);
            HingeJoint = HingeJoint_1 = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], HingeJoint);
            return HingeJoint;
            var HingeJoint_1;
        }(oimo.Joint));
        oimo.HingeJoint = HingeJoint;
        __reflect(HingeJoint.prototype, "egret3d.oimo.HingeJoint");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var ConeTwistJoint = (function (_super) {
            __extends(ConeTwistJoint, _super);
            function ConeTwistJoint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.jointType = oimo.JointType.ConeTwist;
                _this._twistAxis = egret3d.Vector3.UP.clone();
                _this._swingAxis = egret3d.Vector3.RIGHT.clone();
                _this._valuesB = new Float32Array([
                    0.0, 0.0, 0,
                    0.0, 0.0, 0,
                    -180.0, 180.0, 0.0, 0.0,
                    180.0, 180.0,
                ]);
                return _this;
            }
            ConeTwistJoint_1 = ConeTwistJoint;
            ConeTwistJoint.prototype._createJoint = function () {
                if (!this._connectedBody) {
                    // TODO
                    return null;
                }
                this._rigidbody = this.gameObject.getComponent(oimo.Rigidbody);
                var config = ConeTwistJoint_1._config;
                config.allowCollision = this.collisionEnabled;
                if (this.useGlobalAnchor) {
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, this._anchor, this._twistAxis, this._swingAxis);
                }
                else {
                    var matrix = this.gameObject.transform.getWorldMatrix();
                    var anchor = matrix.transformVector3(egret3d.helpVector3A.copy(this._anchor));
                    var twistAxis = matrix.transformNormal(egret3d.helpVector3B.copy(this._twistAxis));
                    var swingAxis = matrix.transformNormal(egret3d.helpVector3C.copy(this._swingAxis));
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, anchor, twistAxis, swingAxis);
                }
                config.twistSpringDamper = ConeTwistJoint_1._twistSpringDamper;
                config.swingSpringDamper = ConeTwistJoint_1._swingSpringDamper;
                config.twistLimitMotor = ConeTwistJoint_1._twistLimitMotor;
                config.twistSpringDamper.frequency = this.twistFrequency;
                config.twistSpringDamper.dampingRatio = this.twistDampingRatio;
                config.twistSpringDamper.useSymplecticEuler = this.twistUseSymplecticEuler;
                config.swingSpringDamper.frequency = this.swingFrequency;
                config.swingSpringDamper.dampingRatio = this.swingDampingRatio;
                config.swingSpringDamper.useSymplecticEuler = this.swingUseSymplecticEuler;
                config.twistLimitMotor.lowerLimit = this.lowerLimit * egret3d.DEG_RAD;
                config.twistLimitMotor.upperLimit = this.upperLimit * egret3d.DEG_RAD;
                config.twistLimitMotor.motorSpeed = this.motorSpeed * egret3d.DEG_RAD;
                config.twistLimitMotor.motorTorque = this.motorTorque;
                config.maxSwingAngle1 = this.maxSwingAngleZ * egret3d.DEG_RAD;
                config.maxSwingAngle2 = this.maxSwingAngleX * egret3d.DEG_RAD;
                var joint = new OIMO.RagdollJoint(config);
                joint.userData = this;
                return joint;
            };
            Object.defineProperty(ConeTwistJoint.prototype, "twistFrequency", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[3 /* TWFrequency */];
                },
                set: function (value) {
                    this._valuesB[3 /* TWFrequency */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getTwistSpringDamper();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "twistDampingRatio", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[4 /* TWDampingRatio */];
                },
                set: function (value) {
                    this._valuesB[4 /* TWDampingRatio */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getTwistSpringDamper();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "twistUseSymplecticEuler", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[5 /* TWUseSymplecticEuler */] > 0;
                },
                set: function (value) {
                    this._valuesB[5 /* TWUseSymplecticEuler */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getTwistSpringDamper();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "swingFrequency", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[0 /* SWFrequency */];
                },
                set: function (value) {
                    this._valuesB[0 /* SWFrequency */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSwingSpringDamper();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "swingDampingRatio", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[1 /* SWDampingRatio */];
                },
                set: function (value) {
                    this._valuesB[1 /* SWDampingRatio */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSwingSpringDamper();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "swingUseSymplecticEuler", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[2 /* SWUseSymplecticEuler */] > 0;
                },
                set: function (value) {
                    this._valuesB[2 /* SWUseSymplecticEuler */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSwingSpringDamper();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "lowerLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[6 /* LowerLimit */];
                },
                set: function (value) {
                    this._valuesB[6 /* LowerLimit */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getTwistLimitMotor();
                        limitMotor.lowerLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "upperLimit", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[7 /* UpperLimit */];
                },
                set: function (value) {
                    this._valuesB[7 /* UpperLimit */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getTwistLimitMotor();
                        limitMotor.upperLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "motorSpeed", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[8 /* MotorSpeed */];
                },
                set: function (value) {
                    this._valuesB[8 /* MotorSpeed */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getTwistLimitMotor();
                        limitMotor.motorSpeed = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "motorTorque", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[9 /* MotorTorque */];
                },
                set: function (value) {
                    this._valuesB[9 /* MotorTorque */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getTwistLimitMotor();
                        limitMotor.motorTorque = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "maxSwingAngleX", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[10 /* MaxSwingAngleX */];
                },
                set: function (value) {
                    if (value < 1.0) {
                        value = 1.0;
                    }
                    if (this._oimoJoint) {
                        console.warn("Cannot change the maxSwingAngleX after the joint has been created.");
                    }
                    else {
                        this._valuesB[10 /* MaxSwingAngleX */] = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "maxSwingAngleZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[11 /* MaxSwingAngleZ */];
                },
                set: function (value) {
                    if (value < 1.0) {
                        value = 1.0;
                    }
                    if (this._oimoJoint) {
                        console.warn("Cannot change the maxSwingAngleZ after the joint has been created.");
                    }
                    else {
                        this._valuesB[11 /* MaxSwingAngleZ */] = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "twistAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._twistAxis;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the axis x after the joint has been created.");
                    }
                    else {
                        this._twistAxis.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ConeTwistJoint.prototype, "swingAxis", {
                /**
                 *
                 */
                get: function () {
                    return this._swingAxis;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the axis x after the joint has been created.");
                    }
                    else {
                        this._swingAxis.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            ConeTwistJoint._config = new OIMO.RagdollJointConfig();
            ConeTwistJoint._swingSpringDamper = new OIMO.SpringDamper();
            ConeTwistJoint._twistSpringDamper = new OIMO.SpringDamper();
            ConeTwistJoint._twistLimitMotor = new OIMO.RotationalLimitMotor();
            __decorate([
                paper.serializedField
            ], ConeTwistJoint.prototype, "_twistAxis", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistJoint.prototype, "_swingAxis", void 0);
            __decorate([
                paper.serializedField
            ], ConeTwistJoint.prototype, "_valuesB", void 0);
            ConeTwistJoint = ConeTwistJoint_1 = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], ConeTwistJoint);
            return ConeTwistJoint;
            var ConeTwistJoint_1;
        }(oimo.Joint));
        oimo.ConeTwistJoint = ConeTwistJoint;
        __reflect(ConeTwistJoint.prototype, "egret3d.oimo.ConeTwistJoint");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        /**
         *
         */
        var UniversalJoint = (function (_super) {
            __extends(UniversalJoint, _super);
            function UniversalJoint() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.jointType = oimo.JointType.Universal;
                _this._axisY = egret3d.Vector3.FORWARD.clone();
                _this._axisZ = egret3d.Vector3.FORWARD.clone();
                _this._valuesB = new Float32Array([
                    0.0, 0.0, 0,
                    0.0, 0.0, 0,
                    -180.0, 180.0, 0.0, 0.0,
                    -180.0, 180.0, 0.0, 0.0,
                ]);
                return _this;
            }
            UniversalJoint_1 = UniversalJoint;
            UniversalJoint.prototype._createJoint = function () {
                if (!this._connectedBody) {
                    // TODO
                    return null;
                }
                this._rigidbody = this.gameObject.getComponent(oimo.Rigidbody);
                var config = UniversalJoint_1._config;
                config.allowCollision = this.collisionEnabled;
                if (this.useGlobalAnchor) {
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, this._anchor, this._axisY, this._axisZ);
                }
                else {
                    var matrix = this.gameObject.transform.getWorldMatrix();
                    var anchor = matrix.transformVector3(egret3d.helpVector3A.copy(this._anchor));
                    var axisY = matrix.transformNormal(egret3d.helpVector3B.copy(this._axisY));
                    var axisZ = matrix.transformNormal(egret3d.helpVector3C.copy(this._axisZ));
                    config.init(this._rigidbody.oimoRigidbody, this._connectedBody.oimoRigidbody, anchor, axisY, axisZ);
                }
                config.springDamper1 = UniversalJoint_1._springDamperY;
                config.springDamper2 = UniversalJoint_1._springDamperZ;
                config.limitMotor1 = UniversalJoint_1._limitMotorY;
                config.limitMotor2 = UniversalJoint_1._limitMotorZ;
                config.springDamper1.frequency = this.frequencyY;
                config.springDamper1.dampingRatio = this.dampingRatioY;
                config.springDamper1.useSymplecticEuler = this.useSymplecticEulerY;
                config.springDamper2.frequency = this.frequencyZ;
                config.springDamper2.dampingRatio = this.dampingRatioZ;
                config.springDamper2.useSymplecticEuler = this.useSymplecticEulerZ;
                config.limitMotor1.lowerLimit = this.lowerLimitY * egret3d.DEG_RAD;
                config.limitMotor1.upperLimit = this.upperLimitY * egret3d.DEG_RAD;
                config.limitMotor1.motorSpeed = this.motorSpeedY * egret3d.DEG_RAD;
                config.limitMotor1.motorTorque = this.motorTorqueY;
                config.limitMotor2.lowerLimit = this.lowerLimitZ * egret3d.DEG_RAD;
                config.limitMotor2.upperLimit = this.upperLimitZ * egret3d.DEG_RAD;
                config.limitMotor2.motorSpeed = this.motorSpeedZ * egret3d.DEG_RAD;
                config.limitMotor2.motorTorque = this.motorTorqueZ;
                var joint = new OIMO.UniversalJoint(config);
                joint.userData = this;
                return joint;
            };
            Object.defineProperty(UniversalJoint.prototype, "frequencyY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[0 /* FrequencyY */];
                },
                set: function (value) {
                    this._valuesB[0 /* FrequencyY */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper1();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "dampingRatioY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[1 /* DampingRatioY */];
                },
                set: function (value) {
                    this._valuesB[1 /* DampingRatioY */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper1();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "useSymplecticEulerY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[2 /* UseSymplecticEulerY */] > 0;
                },
                set: function (value) {
                    this._valuesB[2 /* UseSymplecticEulerY */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper1();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "frequencyZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[3 /* FrequencyZ */];
                },
                set: function (value) {
                    this._valuesB[3 /* FrequencyZ */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper2();
                        springDamper.frequency = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "dampingRatioZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[4 /* DampingRatioZ */];
                },
                set: function (value) {
                    this._valuesB[4 /* DampingRatioZ */] = value;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper2();
                        springDamper.dampingRatio = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "useSymplecticEulerZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[5 /* UseSymplecticEulerZ */] > 0;
                },
                set: function (value) {
                    this._valuesB[5 /* UseSymplecticEulerZ */] = value ? 1 : 0;
                    if (this._oimoJoint) {
                        var springDamper = this._oimoJoint.getSpringDamper2();
                        springDamper.useSymplecticEuler = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "lowerLimitY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[6 /* LowerLimitY */];
                },
                set: function (value) {
                    this._valuesB[6 /* LowerLimitY */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor1();
                        limitMotor.lowerLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "upperLimitY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[7 /* UpperLimitY */];
                },
                set: function (value) {
                    this._valuesB[7 /* UpperLimitY */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor1();
                        limitMotor.upperLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "motorSpeedY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[8 /* MotorSpeedY */];
                },
                set: function (value) {
                    this._valuesB[8 /* MotorSpeedY */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor1();
                        limitMotor.motorSpeed = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "motorTorqueY", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[9 /* MotorTorqueY */];
                },
                set: function (value) {
                    this._valuesB[9 /* MotorTorqueY */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor1();
                        limitMotor.motorTorque = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "lowerLimitZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[10 /* LowerLimitZ */];
                },
                set: function (value) {
                    this._valuesB[10 /* LowerLimitZ */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor2();
                        limitMotor.lowerLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "upperLimitZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[11 /* UpperLimitZ */];
                },
                set: function (value) {
                    this._valuesB[11 /* UpperLimitZ */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor2();
                        limitMotor.upperLimit = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "motorSpeedZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[12 /* MotorSpeedZ */];
                },
                set: function (value) {
                    this._valuesB[12 /* MotorSpeedZ */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor2();
                        limitMotor.motorSpeed = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "motorTorqueZ", {
                /**
                 *
                 */
                get: function () {
                    return this._valuesB[13 /* MotorTorqueZ */];
                },
                set: function (value) {
                    this._valuesB[13 /* MotorTorqueZ */] = value;
                    if (this._oimoJoint) {
                        var limitMotor = this._oimoJoint.getLimitMotor2();
                        limitMotor.motorTorque = value;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "axisY", {
                /**
                 *
                 */
                get: function () {
                    return this._axisY;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the axisY after the joint has been created.");
                    }
                    else {
                        this._axisY.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(UniversalJoint.prototype, "axisZ", {
                /**
                 *
                 */
                get: function () {
                    return this._axisZ;
                },
                set: function (value) {
                    if (this._oimoJoint) {
                        console.warn("Cannot change the axisZ after the joint has been created.");
                    }
                    else {
                        this._axisZ.copy(value).normalize();
                    }
                },
                enumerable: true,
                configurable: true
            });
            UniversalJoint._config = new OIMO.UniversalJointConfig();
            UniversalJoint._springDamperY = new OIMO.SpringDamper();
            UniversalJoint._springDamperZ = new OIMO.SpringDamper();
            UniversalJoint._limitMotorY = new OIMO.RotationalLimitMotor();
            UniversalJoint._limitMotorZ = new OIMO.RotationalLimitMotor();
            __decorate([
                paper.serializedField
            ], UniversalJoint.prototype, "_axisY", void 0);
            __decorate([
                paper.serializedField
            ], UniversalJoint.prototype, "_axisZ", void 0);
            __decorate([
                paper.serializedField
            ], UniversalJoint.prototype, "_valuesB", void 0);
            UniversalJoint = UniversalJoint_1 = __decorate([
                paper.requireComponent(oimo.Rigidbody)
            ], UniversalJoint);
            return UniversalJoint;
            var UniversalJoint_1;
        }(oimo.Joint));
        oimo.UniversalJoint = UniversalJoint;
        __reflect(UniversalJoint.prototype, "egret3d.oimo.UniversalJoint");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var oimo;
    (function (oimo) {
        var _helpVector3 = new egret3d.Vector3();
        /**
         *
         */
        var PhysicsSystem = (function (_super) {
            __extends(PhysicsSystem, _super);
            function PhysicsSystem() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._interests = [
                    [
                        { componentClass: oimo.Rigidbody },
                        { componentClass: [oimo.BoxCollider, oimo.SphereCollider], type: 4 /* Unessential */ },
                        { componentClass: [oimo.SphericalJoint, oimo.HingeJoint, oimo.ConeTwistJoint], type: 4 /* Unessential */ }
                    ],
                    [
                        { componentClass: paper.Behaviour, type: 1 /* Extends */ | 4 /* Unessential */, isBehaviour: true, }
                    ]
                ];
                _this._gravity = new egret3d.Vector3(0, -9.80665, 0);
                _this._rayCastClosest = new OIMO.RayCastClosest();
                _this._contactCallback = new OIMO.ContactCallback();
                _this._contactColliders = _this._globalGameObject.getComponent(paper.ContactColliders) || _this._globalGameObject.addComponent(paper.ContactColliders);
                _this._oimoWorld = null;
                return _this;
            }
            PhysicsSystem.prototype.rayCast = function (rayOrFrom, distanceOrTo, mask, raycastInfo) {
                var rayCastClosest = this._rayCastClosest;
                rayCastClosest.clear(); // TODO mask.
                if (rayOrFrom instanceof egret3d.Ray) {
                    distanceOrTo = _helpVector3.copy(rayOrFrom.direction).scale(distanceOrTo || 100.0).add(rayOrFrom.origin);
                    rayOrFrom = rayOrFrom.origin;
                }
                this._oimoWorld.rayCast(rayOrFrom, distanceOrTo, rayCastClosest);
                if (rayCastClosest.hit) {
                    raycastInfo = raycastInfo || new oimo.RaycastInfo();
                    raycastInfo.clean();
                    raycastInfo.distance = egret3d.Vector3.getDistance(rayOrFrom, distanceOrTo) * rayCastClosest.fraction;
                    raycastInfo.position.copy(rayCastClosest.position);
                    raycastInfo.normal.copy(rayCastClosest.normal);
                    raycastInfo.rigidbody = rayCastClosest.shape.getRigidBody().userData;
                    raycastInfo.collider = rayCastClosest.shape.userData;
                    return raycastInfo;
                }
                return null;
            };
            PhysicsSystem.prototype.onAwake = function () {
                var _this = this;
                PhysicsSystem.instance = this;
                this._oimoWorld = new OIMO.World();
                this._oimoWorld.setGravity(this._gravity);
                this._contactCallback.beginContact = function (contact) {
                    // do {
                    // }
                    // while (contact.getNext());
                    _this._contactColliders.begin.push(contact);
                };
                this._contactCallback.preSolve = function (contact) {
                };
                this._contactCallback.postSolve = function (contact) {
                };
                this._contactCallback.endContact = function (contact) {
                    _this._contactColliders.end.push(contact);
                };
            };
            PhysicsSystem.prototype.onAddGameObject = function (gameObject, group) {
                var rigidbody = gameObject.getComponent(oimo.Rigidbody);
                for (var _i = 0, _a = gameObject.getComponents(oimo.Collider, true); _i < _a.length; _i++) {
                    var shape = _a[_i];
                    if (!shape.oimoShape._rigidBody) {
                        rigidbody.oimoRigidbody.addShape(shape.oimoShape);
                        // rigidbody._updateMass(rigidbody.oimoRigidbody);
                    }
                }
                for (var _b = 0, _c = gameObject.getComponents(oimo.Joint, true); _b < _c.length; _b++) {
                    var joint = _c[_b];
                    if (!joint.oimoJoint._world) {
                        this._oimoWorld.addJoint(joint.oimoJoint);
                    }
                }
                this._oimoWorld.addRigidBody(rigidbody.oimoRigidbody);
            };
            PhysicsSystem.prototype.onAddComponent = function (component, group) {
                if (group !== this._groups[0]) {
                    return;
                }
                if (component instanceof oimo.Collider) {
                    if (!component.oimoShape._rigidBody) {
                        var rigidbody = component.gameObject.getComponent(oimo.Rigidbody);
                        rigidbody.oimoRigidbody.addShape(component.oimoShape);
                        // rigidbody._updateMass(rigidbody.oimoRigidbody);
                    }
                }
                else if (!component.oimoJoint._world) {
                    this._oimoWorld.addJoint(component.oimoJoint);
                }
            };
            PhysicsSystem.prototype.onUpdate = function (deltaTime) {
                var currentTimes = 0;
                var fixedTime = this._clock._fixedTime;
                var totalTimes = Math.min(Math.floor(fixedTime / this._clock.fixedDeltaTime), this._clock.maxFixedSubSteps);
                var oimoTransform = PhysicsSystem._helpTransform;
                var components = this._groups[0].components;
                var behaviourComponents = this._groups[1].components;
                while (fixedTime >= this._clock.fixedDeltaTime && currentTimes++ < this._clock.maxFixedSubSteps) {
                    for (var _i = 0, behaviourComponents_1 = behaviourComponents; _i < behaviourComponents_1.length; _i++) {
                        var component = behaviourComponents_1[_i];
                        if (component) {
                            component.onFixedUpdate && component.onFixedUpdate(currentTimes, totalTimes);
                        }
                    }
                    for (var _a = 0, components_5 = components; _a < components_5.length; _a++) {
                        var component = components_5[_a];
                        var transform = component.gameObject.transform;
                        var oimoRigidbody = component.oimoRigidbody;
                        switch (component.type) {
                            case 2 /* KINEMATIC */:
                            case 1 /* STATIC */:
                                if (oimoRigidbody.isSleeping()) {
                                }
                                else {
                                    var position = transform.getPosition();
                                    var quaternion = transform.getRotation();
                                    oimoTransform.setPosition(position);
                                    oimoTransform.setOrientation(quaternion);
                                    oimoRigidbody.setTransform(oimoTransform);
                                }
                                break;
                        }
                    }
                    this._oimoWorld.step(this._clock.fixedDeltaTime);
                    for (var _b = 0, components_6 = components; _b < components_6.length; _b++) {
                        var component = components_6[_b];
                        var transform = component.gameObject.transform;
                        var oimoRigidbody = component.oimoRigidbody;
                        switch (component.type) {
                            case 0 /* DYNAMIC */:
                                if (oimoRigidbody.isSleeping()) {
                                }
                                else {
                                    oimoRigidbody.getTransformTo(oimoTransform);
                                    oimoTransform.getPositionTo(egret3d.helpVector3A);
                                    oimoTransform.getOrientationTo(egret3d.helpVector4A);
                                    transform.setPosition(egret3d.helpVector3A);
                                    transform.setRotation(egret3d.helpVector4A);
                                }
                                break;
                        }
                    }
                    //
                    var begin = this._contactColliders.begin;
                    var stay = this._contactColliders.stay;
                    var end = this._contactColliders.end;
                    if (begin.length > 0) {
                        for (var _c = 0, begin_2 = begin; _c < begin_2.length; _c++) {
                            var contact = begin_2[_c];
                            var colliderA = contact.getShape1().userData;
                            var colliderB = contact.getShape2().userData;
                            for (var _d = 0, _e = colliderA.gameObject.getComponents(paper.Behaviour, true); _d < _e.length; _d++) {
                                var behaviour = _e[_d];
                                behaviour.onCollisionEnter && behaviour.onCollisionEnter(colliderB);
                            }
                            for (var _f = 0, _g = colliderB.gameObject.getComponents(paper.Behaviour, true); _f < _g.length; _f++) {
                                var behaviour = _g[_f];
                                behaviour.onCollisionEnter && behaviour.onCollisionEnter(colliderA);
                            }
                        }
                    }
                    if (end.length > 0) {
                        for (var _h = 0, end_2 = end; _h < end_2.length; _h++) {
                            var contact = end_2[_h];
                            var colliderA = contact.getShape1().userData;
                            var colliderB = contact.getShape2().userData;
                            for (var _j = 0, _k = colliderA.gameObject.getComponents(paper.Behaviour, true); _j < _k.length; _j++) {
                                var behaviour = _k[_j];
                                behaviour.onCollisionExit && behaviour.onCollisionExit(colliderB);
                            }
                            for (var _l = 0, _m = colliderB.gameObject.getComponents(paper.Behaviour, true); _l < _m.length; _l++) {
                                var behaviour = _m[_l];
                                behaviour.onCollisionExit && behaviour.onCollisionExit(colliderA);
                            }
                        }
                    }
                    if (stay.length > 0) {
                        for (var _o = 0, stay_1 = stay; _o < stay_1.length; _o++) {
                            var contact = stay_1[_o];
                            var colliderA = contact.getShape1().userData;
                            var colliderB = contact.getShape2().userData;
                            for (var _p = 0, _q = colliderA.gameObject.getComponents(paper.Behaviour, true); _p < _q.length; _p++) {
                                var behaviour = _q[_p];
                                behaviour.onCollisionStay && behaviour.onCollisionStay(colliderB);
                            }
                            for (var _r = 0, _s = colliderB.gameObject.getComponents(paper.Behaviour, true); _r < _s.length; _r++) {
                                var behaviour = _s[_r];
                                behaviour.onCollisionStay && behaviour.onCollisionStay(colliderA);
                            }
                        }
                    }
                    fixedTime -= this._clock.fixedDeltaTime;
                }
            };
            PhysicsSystem.prototype.onRemoveComponent = function (component, group) {
                if (group !== this._groups[0]) {
                    return;
                }
                if (component instanceof oimo.Collider) {
                    var rigidbody = component.gameObject.getComponent(oimo.Rigidbody);
                    rigidbody.oimoRigidbody.removeShape(component.oimoShape);
                    // rigidbody._updateMass(rigidbody.oimoRigidbody);
                }
                else {
                    this._oimoWorld.removeJoint(component.oimoJoint);
                }
            };
            PhysicsSystem.prototype.onRemoveGameObject = function (gameObject, group) {
                var rigidbody = gameObject.getComponent(oimo.Rigidbody);
                for (var _i = 0, _a = gameObject.getComponents(oimo.Joint, true); _i < _a.length; _i++) {
                    var joint = _a[_i];
                    this._oimoWorld.removeJoint(joint.oimoJoint);
                }
                for (var _b = 0, _c = gameObject.getComponents(oimo.Collider, true); _b < _c.length; _b++) {
                    var shape = _c[_b];
                    rigidbody.oimoRigidbody.removeShape(shape.oimoShape);
                    // rigidbody._updateMass(rigidbody.oimoRigidbody);
                }
                this._oimoWorld.removeRigidBody(rigidbody.oimoRigidbody);
            };
            PhysicsSystem.prototype.onDestroy = function () {
                // TODO
            };
            Object.defineProperty(PhysicsSystem.prototype, "gravity", {
                /**
                 *
                 */
                get: function () {
                    return this._gravity;
                },
                set: function (value) {
                    this._gravity.copy(value);
                    this._oimoWorld.setGravity(this._gravity);
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @internal
             */
            PhysicsSystem._helpTransform = new OIMO.Transform();
            return PhysicsSystem;
        }(paper.BaseSystem));
        oimo.PhysicsSystem = PhysicsSystem;
        __reflect(PhysicsSystem.prototype, "egret3d.oimo.PhysicsSystem");
    })(oimo = egret3d.oimo || (egret3d.oimo = {}));
})(egret3d || (egret3d = {}));
var egret3d;
(function (egret3d) {
    var particle;
    (function (particle) {
        particle.BillboardPerVertexCount = 37;
        particle.MeshPerVertexCount = 42;
        /**
         * 渲染类型为Mesh的属性格式
         */
        particle.MeshShaderAttributeFormat = [
            { key: "POSITION" /* POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "COLOR_0" /* COLOR_0 */, type: "VEC4" /* VEC4 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "START_POSITION" /* START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "START_VELOCITY" /* START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "START_COLOR" /* START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "START_SIZE" /* START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "START_ROTATION" /* START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "TIME" /* TIME */, type: "VEC2" /* VEC2 */ },
            { key: "RANDOM0" /* RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "RANDOM1" /* RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "WORLD_POSITION" /* WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "WORLD_ROTATION" /* WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        /**
         * 渲染类型为Billboard的属性格式
         */
        particle.BillboardShaderAttributeFormat = [
            { key: "CORNER" /* CORNER */, type: "VEC2" /* VEC2 */ },
            { key: "TEXCOORD_0" /* TEXCOORD_0 */, type: "VEC2" /* VEC2 */ },
            { key: "START_POSITION" /* START_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "START_VELOCITY" /* START_VELOCITY */, type: "VEC3" /* VEC3 */ },
            { key: "START_COLOR" /* START_COLOR */, type: "VEC4" /* VEC4 */ },
            { key: "START_SIZE" /* START_SIZE */, type: "VEC3" /* VEC3 */ },
            { key: "START_ROTATION" /* START_ROTATION */, type: "VEC3" /* VEC3 */ },
            { key: "TIME" /* TIME */, type: "VEC2" /* VEC2 */ },
            { key: "RANDOM0" /* RANDOM0 */, type: "VEC4" /* VEC4 */ },
            { key: "RANDOM1" /* RANDOM1 */, type: "VEC4" /* VEC4 */ },
            { key: "WORLD_POSITION" /* WORLD_POSITION */, type: "VEC3" /* VEC3 */ },
            { key: "WORLD_ROTATION" /* WORLD_ROTATION */, type: "VEC4" /* VEC4 */ },
        ];
        var ParticleRenderer = (function (_super) {
            __extends(ParticleRenderer, _super);
            function ParticleRenderer() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this._materials = [];
                _this._renderMode = 0 /* Billboard */;
                return _this;
            }
            ParticleRenderer.prototype.uninitialize = function () {
                _super.prototype.uninitialize.call(this);
                this._mesh = null;
                this._materials.length = 0;
                this._renderMode = 0 /* Billboard */;
                this.velocityScale = 1.0;
                this.lengthScale = 1.0;
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._addShaderDefine = function (key) {
                if (!this.batchMaterial && this._materials.length > 0) {
                    this.batchMaterial = this._materials[0];
                }
                if (this.batchMaterial) {
                    this.batchMaterial.addDefine(key);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._removeShaderDefine = function (key) {
                if (!this.batchMaterial && this._materials.length > 0) {
                    this.batchMaterial = this._materials[0];
                }
                if (this.batchMaterial) {
                    this.batchMaterial.removeDefine(key);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setBoolean = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setBoolean(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setInt = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setInt(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setFloat = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setFloat(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector2 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector2(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector2v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector2v(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector3 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector3(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector4 = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector4(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector3v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector3v(_id, _value);
                }
            };
            /**
             * @internal
             * @param key
             */
            ParticleRenderer.prototype._setVector4v = function (_id, _value) {
                if (this.batchMaterial) {
                    this.batchMaterial.setVector4v(_id, _value);
                }
            };
            Object.defineProperty(ParticleRenderer.prototype, "mesh", {
                /**
                 * mesh model
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 组件挂载的 mesh 模型
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._mesh;
                },
                set: function (mesh) {
                    if (this._mesh === mesh) {
                        return;
                    }
                    this._mesh = mesh;
                    paper.EventPool.dispatchEvent("mesh" /* Mesh */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "materials", {
                /**
                 * material list
                 * @version paper 1.0
                 * @platform Web
                 * @language en_US
                 */
                /**
                 * 材质数组
                 * @version paper 1.0
                 * @platform Web
                 * @language
                 */
                get: function () {
                    return this._materials;
                },
                set: function (value) {
                    if (value === this._materials) {
                        return;
                    }
                    this._materials.length = 0;
                    for (var _i = 0, value_4 = value; _i < value_4.length; _i++) {
                        var material = value_4[_i];
                        this._materials.push(material);
                    }
                    paper.EventPool.dispatchEvent("materials" /* Materials */, this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ParticleRenderer.prototype, "renderMode", {
                get: function () {
                    return this._renderMode;
                },
                set: function (value) {
                    if (this._renderMode === value) {
                        return;
                    }
                    var old = this._renderMode;
                    this._renderMode = value;
                    paper.EventPool.dispatchEvent("renderMode" /* RenderMode */, this);
                },
                enumerable: true,
                configurable: true
            });
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_mesh", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_materials", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "velocityScale", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "_renderMode", void 0);
            __decorate([
                paper.serializedField
            ], ParticleRenderer.prototype, "lengthScale", void 0);
            __decorate([
                paper.editor.property(paper.editor.EditType.MESH)
            ], ParticleRenderer.prototype, "mesh", null);
            __decorate([
                paper.editor.property(paper.editor.EditType.ARRAY)
            ], ParticleRenderer.prototype, "materials", null);
            ParticleRenderer = __decorate([
                paper.disallowMultiple
            ], ParticleRenderer);
            return ParticleRenderer;
        }(paper.BaseRenderer));
        particle.ParticleRenderer = ParticleRenderer;
        __reflect(ParticleRenderer.prototype, "egret3d.particle.ParticleRenderer");
    })(particle = egret3d.particle || (egret3d.particle = {}));
})(egret3d || (egret3d = {}));
