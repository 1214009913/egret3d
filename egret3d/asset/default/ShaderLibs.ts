namespace egret3d.ShaderLibs {
    export const cube = {"name":"buildin/cube.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"cube_vert","type":35633,"uri":"varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_Position.z = gl_Position.w; // set z to camera.far\r\n\r\n}\r\n"},{"name":"cube_frag","type":35632,"uri":"uniform samplerCube tCube;\r\nuniform float tFlip;\r\nuniform float opacity;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\r\n\tgl_FragColor.a *= opacity;\r\n\r\n}\r\n"}],"techniques":[{"name":"cube","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"tCube":{"type":35680,"value":[]},"tFlip":{"type":5126,"value":[]},"opacity":{"type":5126,"value":1}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const depthpackage = {"name":"buildin/depthpackage.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"depthpackage_vert","type":35633,"uri":"#include <common>\r\nattribute vec3 position;\r\n\r\nuniform mat4 modelViewProjectionMatrix;\r\n\r\nvoid main() { \r\n    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\r\n}"},{"name":"depthpackage_frag","type":35632,"uri":"#include <common>\r\n#include <packing>\r\n\r\nvoid main() {\r\n\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n}"}],"techniques":[{"name":"depthpackage","attributes":{"position":{"semantic":"POSITION"}},"uniforms":{"modelViewProjectionMatrix":{"type":35676,"value":[],"semantic":"MODELVIEWPROJECTION"}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const depth = {"name":"buildin/depth.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"depth_vert","type":35633,"uri":"#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n}\r\n"},{"name":"depth_frag","type":35632,"uri":"#if DEPTH_PACKING == 3200\r\n\r\n\tuniform float opacity;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tdiffuseColor.a = opacity;\r\n\r\n\t#endif\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\r\n\t#if DEPTH_PACKING == 3200\r\n\r\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\r\n\r\n\t#elif DEPTH_PACKING == 3201\r\n\r\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\r\n\r\n\t#endif\r\n\r\n}\r\n"}],"techniques":[{"name":"depth","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"displacementMap":{"type":35678,"value":[]},"displacementScale":{"type":5126,"value":[]},"displacementBias":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"logDepthBufFC":{"type":5126,"value":[]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const diffuse = {"name":"buildin/diffuse.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"diffuse_vert","type":35633,"uri":"#include <common>\r\n#include <skinning_pars_vert>\r\n#include <lightmap_pars_vert> \r\nattribute vec4 position;\r\nattribute vec4 uv;\r\nuniform highp mat4 modelViewProjectionMatrix;\r\nuniform highp vec4 _MainTex_ST;  \r\nvarying highp vec2 xlv_TEXCOORD0;\r\n\r\nvoid main() {\r\n    #include <skinning_base_vert>\r\n    xlv_TEXCOORD0 = uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;\r\n    #include <lightmap_vert>\r\n    gl_Position = (modelViewProjectionMatrix * tmpVertex);\r\n}"},{"name":"diffuse_frag","type":35632,"uri":"#include <common>\r\n#include <lightmap_pars_frag>\r\nuniform vec4 _MainColor;\r\nuniform sampler2D _MainTex;\r\nuniform lowp float _AlphaCut;\r\nvarying highp vec2 xlv_TEXCOORD0;\r\nvoid main() {\r\n    lowp vec4 outColor = texture2D(_MainTex, xlv_TEXCOORD0) * _MainColor;\r\n    if(outColor.a < _AlphaCut)\r\n        discard;\r\n    #include <lightmap_frag>    \r\n}"}],"techniques":[{"name":"diffuse","attributes":{"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"},"uv2":{"semantic":"TEXCOORD_1"},"position":{"semantic":"POSITION"},"uv":{"semantic":"TEXCOORD_0"}},"uniforms":{"glstate_vec4_bones[0]":{"type":35666,"value":[],"semantic":"_BONESVEC4"},"lightMapOffset":{"type":35666,"value":[],"semantic":"_LIGHTMAPOFFSET"},"lightMapUV":{"type":5126,"value":[],"semantic":"_LIGHTMAPUV"},"modelViewProjectionMatrix":{"type":35676,"value":[],"semantic":"MODELVIEWPROJECTION"},"_MainTex_ST":{"type":35666,"value":[1,1,0,0]},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"_MainColor":{"type":35666,"value":[1,1,1,1]},"_MainTex":{"type":35678,"value":[]},"_AlphaCut":{"type":5126,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const distancepackage = {"name":"buildin/distancepackage.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"distancepackage_vert","type":35633,"uri":"#include <common>\r\nattribute vec3 position;\r\n\r\nuniform mat4 modelViewProjectionMatrix;\r\nuniform mat4 modelMatrix;\r\n\r\nvarying vec3 xlv_POS;\r\n\r\nvoid main() {   \r\n    xlv_POS = (modelMatrix * vec4(position, 1.0)).xyz;\r\n    gl_Position = modelViewProjectionMatrix * vec4(position, 1.0);\r\n}"},{"name":"distancepackage_frag","type":35632,"uri":"#include <common>\r\n#include <packing>\r\n\r\nvarying vec3 xlv_POS;\r\nuniform vec4 glstate_referencePosition;\r\nuniform float glstate_nearDistance;\r\nuniform float glstate_farDistance;\r\n\r\nvoid main() {\r\n    float dist = length( xlv_POS - glstate_referencePosition.xyz );\r\n\tdist = ( dist - glstate_nearDistance ) / ( glstate_farDistance - glstate_nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n}"}],"techniques":[{"name":"distancepackage","attributes":{"position":{"semantic":"POSITION"}},"uniforms":{"modelViewProjectionMatrix":{"type":35676,"value":[],"semantic":"MODELVIEWPROJECTION"},"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"glstate_referencePosition":{"type":35666,"value":[]},"glstate_nearDistance":{"type":5126,"value":[]},"glstate_farDistance":{"type":5126,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const distanceRGBA = {"name":"buildin/distanceRGBA.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"distanceRGBA_vert","type":35633,"uri":"#define DISTANCE\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_DISPLACEMENTMAP\r\n\r\n\t\t#include <beginnormal_vertex>\r\n\t\t#include <morphnormal_vertex>\r\n\t\t#include <skinnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvWorldPosition = worldPosition.xyz;\r\n\r\n}\r\n"},{"name":"distanceRGBA_frag","type":35632,"uri":"#define DISTANCE\r\n\r\nuniform vec3 referencePosition;\r\nuniform float nearDistance;\r\nuniform float farDistance;\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main () {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( 1.0 );\r\n\r\n\t#include <map_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\tfloat dist = length( vWorldPosition - referencePosition );\r\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\r\n\tdist = saturate( dist ); // clamp to [ 0, 1 ]\r\n\r\n\tgl_FragColor = packDepthToRGBA( dist );\r\n\r\n}\r\n"}],"techniques":[{"name":"distanceRGBA","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"displacementMap":{"type":35678,"value":[]},"displacementScale":{"type":5126,"value":[]},"displacementBias":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"referencePosition":{"type":35665,"value":[]},"nearDistance":{"type":5126,"value":[]},"farDistance":{"type":5126,"value":[]},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const equirect = {"name":"buildin/equirect.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"equirect_vert","type":35633,"uri":"varying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n#include <common2>\r\n\r\nvoid main() {\r\n\r\n\tvWorldPosition = transformDirection( position, modelMatrix );\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\r\n}\r\n"},{"name":"equirect_frag","type":35632,"uri":"uniform sampler2D tEquirect;\r\n\r\nvarying vec3 vWorldPosition;\r\n\r\n#include <common>\r\n\r\nvoid main() {\r\n\r\n\tvec3 direction = normalize( vWorldPosition );\r\n\r\n\tvec2 sampleUV;\r\n\r\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\r\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\r\n\r\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\r\n\r\n}\r\n"}],"techniques":[{"name":"equirect","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"tEquirect":{"type":35678,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const linedashed = {"name":"buildin/linedashed.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"linedashed_vert","type":35633,"uri":"uniform float scale;\r\nattribute float lineDistance;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\r\n\tvLineDistance = scale * lineDistance;\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"linedashed_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\nuniform float dashSize;\r\nuniform float totalSize;\r\n\r\nvarying float vLineDistance;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\r\n\r\n\t\tdiscard;\r\n\r\n\t}\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <color_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb; // simple shader\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"linedashed","attributes":{"lineDistance":{"semantic":"Unknown"},"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"scale":{"type":5126,"value":[]},"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"opacity":{"type":5126,"value":1},"dashSize":{"type":5126,"value":[]},"totalSize":{"type":5126,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const line = {"name":"buildin/line.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"line_vert","type":35633,"uri":"#include <common>\r\nattribute vec4 position;\r\nattribute vec4 color;\r\nuniform highp mat4 modelViewProjectionMatrix;\r\nvarying lowp vec4 xlv_COLOR;\r\nvoid main() {\r\n    highp vec4 tmpvar_1;\r\n    tmpvar_1.w = 1.0;\r\n    tmpvar_1.xyz = position.xyz;\r\n    xlv_COLOR = color;\r\n    gl_Position = (modelViewProjectionMatrix * tmpvar_1);\r\n}"},{"name":"line_frag","type":35632,"uri":"#include <common>\r\nvarying lowp vec4 xlv_COLOR;\r\nvoid main() {\r\n    gl_FragData[0] = xlv_COLOR;\r\n}"}],"techniques":[{"name":"line","attributes":{"position":{"semantic":"POSITION"},"color":{"semantic":"COLOR_0"}},"uniforms":{"modelViewProjectionMatrix":{"type":35676,"value":[],"semantic":"MODELVIEWPROJECTION"}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const meshbasic = {"name":"buildin/meshbasic.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"meshbasic_vert","type":35633,"uri":"#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\t#include <skinbase_vertex>\r\n\r\n\t#ifdef USE_ENVMAP\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"meshbasic_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\r\n\t// accumulation (baked indirect lighting only)\r\n\t#ifdef USE_LIGHTMAP\r\n\r\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\r\n\r\n\t#endif\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\r\n\r\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"meshbasic","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"},"uv2":{"semantic":"TEXCOORD_1"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"refractionRatio":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"aoMap":{"type":35678,"value":[]},"aoMapIntensity":{"type":5126,"value":1},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"reflectivity":{"type":5126,"value":[]},"envMapIntensity":{"type":5126,"value":1},"envMap":{"type":35678,"value":[]},"flipEnvMap":{"type":5126,"value":1},"maxMipLevel":{"type":5124,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"specularMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const meshlambert = {"name":"buildin/meshlambert.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"meshlambert_vert","type":35633,"uri":"#define LAMBERT\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <lights_lambert_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"meshlambert_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\n\r\nvarying vec3 vLightFront;\r\n\r\n#ifdef DOUBLE_SIDED\r\n\r\n\tvarying vec3 vLightBack;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_pars_maps>\r\n#include <fog_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n\r\n\t#include <lightmap_fragment>\r\n\r\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n\r\n\t#ifdef DOUBLE_SIDED\r\n\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\r\n\t#else\r\n\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\r\n\t#endif\r\n\r\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t// #include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"meshlambert","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"},"uv2":{"semantic":"TEXCOORD_1"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"refractionRatio":{"type":5126,"value":[]},"ambientLightColor":{"type":35665,"value":[0,0,0],"semantic":"_AMBIENTLIGHTCOLOR"},"directionalLights[0]":{"type":5126,"value":[],"semantic":"_DIRECTLIGHTS"},"pointLights[0]":{"type":5126,"value":[],"semantic":"_POINTLIGHTS"},"spotLights[0]":{"type":5126,"value":[],"semantic":"_SPOTLIGHTS"},"ltc_1":{"type":35678,"value":[],"semantic":"Unknown"},"ltc_2":{"type":35678,"value":[],"semantic":"Unknown"},"rectAreaLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"hemisphereLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"directionalShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_DIRECTIONSHADOWMAT"},"spotShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_SPOTSHADOWMAT"},"pointShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_POINTSHADOWMAT"},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"emissive":{"type":35665,"value":[0,0,0]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"aoMap":{"type":35678,"value":[]},"aoMapIntensity":{"type":5126,"value":1},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"emissiveMap":{"type":35678,"value":[]},"reflectivity":{"type":5126,"value":[]},"envMapIntensity":{"type":5126,"value":1},"envMap":{"type":35678,"value":[]},"flipEnvMap":{"type":5126,"value":1},"maxMipLevel":{"type":5124,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"directionalShadowMap[0]":{"type":35678,"value":[],"semantic":"_DIRECTIONSHADOWMAP"},"spotShadowMap[0]":{"type":35678,"value":[],"semantic":"_SPOTSHADOWMAP"},"pointShadowMap[0]":{"type":35678,"value":[],"semantic":"_POINTSHADOWMAT"},"specularMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const meshphong = {"name":"buildin/meshphong.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"meshphong_vert","type":35633,"uri":"#define PHONG\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <envmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <envmap_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"meshphong_frag","type":35632,"uri":"#define PHONG\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform vec3 specular;\r\nuniform float shininess;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <gradientmap_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <lights_phong_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <specularmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <specularmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_phong_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\t#include <envmap_fragment>\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"meshphong","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"},"uv2":{"semantic":"TEXCOORD_1"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"displacementMap":{"type":35678,"value":[]},"displacementScale":{"type":5126,"value":[]},"displacementBias":{"type":5126,"value":[]},"refractionRatio":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"directionalShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_DIRECTIONSHADOWMAT"},"spotShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_SPOTSHADOWMAT"},"pointShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_POINTSHADOWMAT"},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"emissive":{"type":35665,"value":[0,0,0]},"specular":{"type":35665,"value":[]},"shininess":{"type":5126,"value":[]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"aoMap":{"type":35678,"value":[]},"aoMapIntensity":{"type":5126,"value":1},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"emissiveMap":{"type":35678,"value":[]},"reflectivity":{"type":5126,"value":[]},"envMapIntensity":{"type":5126,"value":1},"envMap":{"type":35678,"value":[]},"flipEnvMap":{"type":5126,"value":1},"maxMipLevel":{"type":5124,"value":[]},"gradientMap":{"type":35678,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"ambientLightColor":{"type":35665,"value":[0,0,0],"semantic":"_AMBIENTLIGHTCOLOR"},"directionalLights[0]":{"type":5126,"value":[],"semantic":"_DIRECTLIGHTS"},"pointLights[0]":{"type":5126,"value":[],"semantic":"_POINTLIGHTS"},"spotLights[0]":{"type":5126,"value":[],"semantic":"_SPOTLIGHTS"},"ltc_1":{"type":35678,"value":[],"semantic":"Unknown"},"ltc_2":{"type":35678,"value":[],"semantic":"Unknown"},"rectAreaLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"hemisphereLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"directionalShadowMap[0]":{"type":35678,"value":[],"semantic":"_DIRECTIONSHADOWMAP"},"spotShadowMap[0]":{"type":35678,"value":[],"semantic":"_SPOTSHADOWMAP"},"pointShadowMap[0]":{"type":35678,"value":[],"semantic":"_POINTSHADOWMAT"},"bumpMap":{"type":35678,"value":[]},"bumpScale":{"type":5126,"value":[]},"normalMap":{"type":35678,"value":[]},"normalScale":{"type":35664,"value":[]},"specularMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const meshphysical = {"name":"buildin/meshphysical.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"meshphysical_vert","type":35633,"uri":"#define PHYSICAL\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <uv2_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\t#include <uv2_vertex>\r\n\t#include <color_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"meshphysical_frag","type":35632,"uri":"#define PHYSICAL\r\n\r\nuniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float roughness;\r\nuniform float metalness;\r\nuniform float opacity;\r\n\r\n#ifndef STANDARD\r\n\tuniform float clearCoat;\r\n\tuniform float clearCoatRoughness;\r\n#endif\r\n\r\nvarying vec3 vViewPosition;\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <dithering_pars_fragment>\r\n#include <color_pars_fragment>\r\n#include <uv_pars_fragment>\r\n#include <uv2_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <alphamap_pars_fragment>\r\n#include <aomap_pars_fragment>\r\n#include <lightmap_pars_fragment>\r\n#include <emissivemap_pars_fragment>\r\n#include <bsdfs>\r\n#include <cube_uv_reflection_fragment>\r\n#include <envmap_pars_fragment>\r\n#include <envmap_physical_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <lights_pars_begin>\r\n#include <lights_physical_pars_fragment>\r\n#include <shadowmap_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <roughnessmap_pars_fragment>\r\n#include <metalnessmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\n\tvec3 totalEmissiveRadiance = emissive;\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphamap_fragment>\r\n\t#include <alphatest_fragment>\r\n\t#include <roughnessmap_fragment>\r\n\t#include <metalnessmap_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\t#include <emissivemap_fragment>\r\n\r\n\t// accumulation\r\n\t#include <lights_physical_fragment>\r\n\t#include <lights_fragment_begin>\r\n\t#include <lights_fragment_maps>\r\n\t#include <lights_fragment_end>\r\n\r\n\t// modulation\r\n\t#include <aomap_fragment>\r\n\r\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <dithering_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"meshphysical","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"},"uv2":{"semantic":"TEXCOORD_1"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"displacementMap":{"type":35678,"value":[]},"displacementScale":{"type":5126,"value":[]},"displacementBias":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"directionalShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_DIRECTIONSHADOWMAT"},"spotShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_SPOTSHADOWMAT"},"pointShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_POINTSHADOWMAT"},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"emissive":{"type":35665,"value":[0,0,0]},"roughness":{"type":5126,"value":[]},"metalness":{"type":5126,"value":[]},"opacity":{"type":5126,"value":1},"clearCoat":{"type":5126,"value":[]},"clearCoatRoughness":{"type":5126,"value":[]},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"aoMap":{"type":35678,"value":[]},"aoMapIntensity":{"type":5126,"value":1},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"emissiveMap":{"type":35678,"value":[]},"reflectivity":{"type":5126,"value":[]},"envMapIntensity":{"type":5126,"value":1},"envMap":{"type":35678,"value":[]},"flipEnvMap":{"type":5126,"value":1},"maxMipLevel":{"type":5124,"value":[]},"refractionRatio":{"type":5126,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"ambientLightColor":{"type":35665,"value":[0,0,0],"semantic":"_AMBIENTLIGHTCOLOR"},"directionalLights[0]":{"type":5126,"value":[],"semantic":"_DIRECTLIGHTS"},"pointLights[0]":{"type":5126,"value":[],"semantic":"_POINTLIGHTS"},"spotLights[0]":{"type":5126,"value":[],"semantic":"_SPOTLIGHTS"},"ltc_1":{"type":35678,"value":[],"semantic":"Unknown"},"ltc_2":{"type":35678,"value":[],"semantic":"Unknown"},"rectAreaLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"hemisphereLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"directionalShadowMap[0]":{"type":35678,"value":[],"semantic":"_DIRECTIONSHADOWMAP"},"spotShadowMap[0]":{"type":35678,"value":[],"semantic":"_SPOTSHADOWMAP"},"pointShadowMap[0]":{"type":35678,"value":[],"semantic":"_POINTSHADOWMAT"},"bumpMap":{"type":35678,"value":[]},"bumpScale":{"type":5126,"value":[]},"normalMap":{"type":35678,"value":[]},"normalScale":{"type":35664,"value":[]},"roughnessMap":{"type":35678,"value":[]},"metalnessMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const normal = {"name":"buildin/normal.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"normal_vert","type":35633,"uri":"#define NORMAL\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <displacementmap_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <skinning_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\t#include <beginnormal_vertex>\r\n\t#include <morphnormal_vertex>\r\n\t#include <skinbase_vertex>\r\n\t#include <skinnormal_vertex>\r\n\t#include <defaultnormal_vertex>\r\n\r\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\r\n\r\n\tvNormal = normalize( transformedNormal );\r\n\r\n#endif\r\n\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <skinning_vertex>\r\n\t#include <displacementmap_vertex>\r\n\t#include <project_vertex>\r\n\t#include <logdepthbuf_vertex>\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvViewPosition = - mvPosition.xyz;\r\n\r\n#endif\r\n\r\n}\r\n"},{"name":"normal_frag","type":35632,"uri":"#define NORMAL\r\n\r\nuniform float opacity;\r\n\r\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\r\n\r\n\tvarying vec3 vViewPosition;\r\n\r\n#endif\r\n\r\n#ifndef FLAT_SHADED\r\n\r\n\tvarying vec3 vNormal;\r\n\r\n#endif\r\n\r\n#include <packing>\r\n#include <uv_pars_fragment>\r\n#include <bumpmap_pars_fragment>\r\n#include <normalmap_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <normal_fragment_begin>\r\n\t#include <normal_fragment_maps>\r\n\r\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\r\n\r\n}\r\n"}],"techniques":[{"name":"normal","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"displacementMap":{"type":35678,"value":[]},"displacementScale":{"type":5126,"value":[]},"displacementBias":{"type":5126,"value":[]},"morphTargetInfluences[0]":{"type":5126,"value":[]},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"logDepthBufFC":{"type":5126,"value":[]},"opacity":{"type":5126,"value":1},"bumpMap":{"type":35678,"value":[]},"bumpScale":{"type":5126,"value":[]},"normalMap":{"type":35678,"value":[]},"normalScale":{"type":35664,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const particlesystem = {"name":"buildin/particlesystem.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"particlesystem_vert","type":35633,"uri":"//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.vs\r\n#include <common>\r\n#if defined(SPHERHBILLBOARD)||defined(STRETCHEDBILLBOARD)||defined(HORIZONTALBILLBOARD)||defined(VERTICALBILLBOARD)\r\n\tattribute vec2 corner;\r\n#endif\r\n#ifdef RENDERMESH\r\n\tattribute vec3 position;\r\n\tattribute vec4 color;\r\n#endif\r\nattribute vec2 uv;\r\nattribute vec3 startPosition;\r\nattribute vec3 startVelocity;\r\nattribute vec4 startColor;\r\nattribute vec3 startSize;\r\nattribute vec3 startRotation;\r\nattribute vec2 time;\r\n#if defined(COLOROGRADIENT)||defined(COLORTWOGRADIENTS)||defined(SIZETWOCURVES)||defined(SIZETWOCURVESSEPERATE)||defined(ROTATIONTWOCONSTANTS)||defined(ROTATIONTWOCURVES)\r\n  attribute vec4 random0;\r\n#endif\r\n#if defined(TEXTURESHEETANIMATIONTWOCURVE)||defined(VELOCITYTWOCONSTANT)||defined(VELOCITYTWOCURVE)\r\n  attribute vec4 random1;\r\n#endif\r\nattribute vec3 startWorldPosition;\r\nattribute vec4 startWorldRotation;\r\n\r\n#include <particle_common>\r\n\r\nvoid main()\r\n{\r\n\tfloat age = u_currentTime - time.y;\r\n\tfloat t = age/time.x;\r\n\tif(t>1.0){ \t\t\t\r\n\t\t\tv_discard=1.0;\r\n\t\t\treturn;\r\n  }\r\n\t  \r\n\t#include <particle_affector>\r\n\tgl_Position=viewProjectionMatrix*vec4(center,1.0);\r\n\tv_color = computeColor(startColor, t);\r\n\tv_texcoord =computeUV(uv * _MainTex_ST.xy + _MainTex_ST.zw, t);\r\n\tv_discard=0.0;\r\n}\r\n\r\n"},{"name":"particlesystem_frag","type":35632,"uri":"//inspired by layaair:https://github.com/layabox/layaair/blob/master/src/d3/src/laya/d3/shader/files/ParticleShuriKen.ps\r\n#include <common>\r\nuniform sampler2D _MainTex;\r\nuniform vec4 _TintColor;\r\nvarying float v_discard;\r\nvarying vec4 v_color;\r\nvarying vec2 v_texcoord;\r\n\r\n#ifdef RENDERMODE_MESH\r\n\tvarying vec4 v_mesh_color;\r\n#endif\r\n\r\nvoid main()\r\n{\t\r\n\t#ifdef RENDERMODE_MESH\r\n\t\tgl_FragColor=v_mesh_color;\r\n\t#else\r\n\t\tgl_FragColor=vec4(1.0);\t\r\n\t#endif\r\n\r\n\tif(v_discard!=0.0)\r\n\t\tdiscard;\r\n\tgl_FragColor*=texture2D(_MainTex,v_texcoord)*_TintColor*v_color*2.0;\r\n}"}],"techniques":[{"name":"particlesystem","attributes":{"corner":{"semantic":"Unknown"},"position":{"semantic":"POSITION"},"color":{"semantic":"COLOR_0"},"uv":{"semantic":"TEXCOORD_0"},"startPosition":{"semantic":"Unknown"},"startVelocity":{"semantic":"Unknown"},"startColor":{"semantic":"Unknown"},"startSize":{"semantic":"Unknown"},"startRotation":{"semantic":"Unknown"},"time":{"semantic":"Unknown"},"random0":{"semantic":"Unknown"},"random1":{"semantic":"Unknown"},"startWorldPosition":{"semantic":"Unknown"},"startWorldRotation":{"semantic":"Unknown"}},"uniforms":{"u_currentTime":{"type":5126,"value":[]},"u_gravity":{"type":35665,"value":[]},"u_worldPosition":{"type":35665,"value":[]},"u_worldRotation":{"type":35666,"value":[]},"u_startRotation3D":{"type":35670,"value":[]},"u_scalingMode":{"type":5124,"value":[]},"u_positionScale":{"type":35665,"value":[]},"u_sizeScale":{"type":35665,"value":[]},"viewProjectionMatrix":{"type":35676,"value":[]},"_MainTex_ST":{"type":35666,"value":[1,1,0,0]},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"cameraForward":{"type":35665,"value":[]},"cameraUp":{"type":35665,"value":[]},"u_lengthScale":{"type":5126,"value":[]},"u_speeaScale":{"type":5126,"value":[]},"u_simulationSpace":{"type":5124,"value":[]},"u_spaceType":{"type":5124,"value":[]},"u_velocityConst":{"type":35665,"value":[]},"u_velocityCurveX[0]":{"type":35664,"value":[]},"u_velocityCurveY[0]":{"type":35664,"value":[]},"u_velocityCurveZ[0]":{"type":35664,"value":[]},"u_velocityConstMax":{"type":35665,"value":[]},"u_velocityCurveMaxX[0]":{"type":35664,"value":[]},"u_velocityCurveMaxY[0]":{"type":35664,"value":[]},"u_velocityCurveMaxZ[0]":{"type":35664,"value":[]},"u_colorGradient[0]":{"type":35666,"value":[]},"u_alphaGradient[0]":{"type":35664,"value":[]},"u_colorGradientMax[0]":{"type":35666,"value":[]},"u_alphaGradientMax[0]":{"type":35664,"value":[]},"u_sizeCurve[0]":{"type":35664,"value":[]},"u_sizeCurveMax[0]":{"type":35664,"value":[]},"u_sizeCurveX[0]":{"type":35664,"value":[]},"u_sizeCurveY[0]":{"type":35664,"value":[]},"u_sizeCurveZ[0]":{"type":35664,"value":[]},"u_sizeCurveMaxX[0]":{"type":35664,"value":[]},"u_sizeCurveMaxY[0]":{"type":35664,"value":[]},"u_sizeCurveMaxZ[0]":{"type":35664,"value":[]},"u_rotationConst":{"type":5126,"value":[]},"u_rotationConstMax":{"type":5126,"value":[]},"u_rotationCurve[0]":{"type":35664,"value":[]},"u_rotationCurveMax[0]":{"type":35664,"value":[]},"u_rotationConstSeprarate":{"type":35665,"value":[]},"u_rotationConstMaxSeprarate":{"type":35665,"value":[]},"u_rotationCurveX[0]":{"type":35664,"value":[]},"u_rotationCurveY[0]":{"type":35664,"value":[]},"u_rotationCurveZ[0]":{"type":35664,"value":[]},"u_rotationCurveW[0]":{"type":35664,"value":[]},"u_rotationCurveMaxX[0]":{"type":35664,"value":[]},"u_rotationCurveMaxY[0]":{"type":35664,"value":[]},"u_rotationCurveMaxZ[0]":{"type":35664,"value":[]},"u_rotationCurveMaxW[0]":{"type":35664,"value":[]},"u_cycles":{"type":5126,"value":[]},"u_subUV":{"type":35666,"value":[]},"u_uvCurve[0]":{"type":35664,"value":[]},"u_uvCurveMax[0]":{"type":35664,"value":[]},"_MainTex":{"type":35678,"value":[]},"_TintColor":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const points = {"name":"buildin/points.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"points_vert","type":35633,"uri":"uniform float size;\r\nuniform float scale;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <color_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <morphtarget_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <color_vertex>\r\n\t#include <begin_vertex>\r\n\t#include <morphtarget_vertex>\r\n\t#include <project_vertex>\r\n\r\n\tgl_PointSize = size;\r\n\r\n\t#ifdef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\r\n\r\n\t#endif\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"points_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <color_pars_fragment>\r\n#include <map_particle_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_particle_fragment>\r\n\t#include <color_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <premultiplied_alpha_fragment>\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"points","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"size":{"type":5126,"value":[]},"scale":{"type":5126,"value":[]},"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"morphTargetInfluences[0]":{"type":5126,"value":[]},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"opacity":{"type":5126,"value":1},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"map":{"type":35678,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const shadow = {"name":"buildin/shadow.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"shadow_vert","type":35633,"uri":"\r\n#include <common2>\r\n#include <fog_pars_vertex>\r\n#include <shadowmap_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <begin_vertex>\r\n\t#include <project_vertex>\r\n\t#include <worldpos_vertex>\r\n\t#include <shadowmap_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"shadow_frag","type":35632,"uri":"uniform vec3 color;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <packing>\r\n#include <fog_pars_fragment>\r\n#include <bsdfs>\r\n#include <lights_pars_begin>\r\n#include <shadowmap_pars_fragment>\r\n#include <shadowmask_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\r\n\r\n\t#include <fog_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"shadow","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"directionalShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_DIRECTIONSHADOWMAT"},"spotShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_SPOTSHADOWMAT"},"pointShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_POINTSHADOWMAT"},"color":{"type":35665,"value":[]},"opacity":{"type":5126,"value":1},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"ambientLightColor":{"type":35665,"value":[0,0,0],"semantic":"_AMBIENTLIGHTCOLOR"},"directionalLights[0]":{"type":5126,"value":[],"semantic":"_DIRECTLIGHTS"},"pointLights[0]":{"type":5126,"value":[],"semantic":"_POINTLIGHTS"},"spotLights[0]":{"type":5126,"value":[],"semantic":"_SPOTLIGHTS"},"ltc_1":{"type":35678,"value":[],"semantic":"Unknown"},"ltc_2":{"type":35678,"value":[],"semantic":"Unknown"},"rectAreaLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"hemisphereLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"directionalShadowMap[0]":{"type":35678,"value":[],"semantic":"_DIRECTIONSHADOWMAP"},"spotShadowMap[0]":{"type":35678,"value":[],"semantic":"_SPOTSHADOWMAP"},"pointShadowMap[0]":{"type":35678,"value":[],"semantic":"_POINTSHADOWMAT"}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const sprite = {"name":"buildin/sprite.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"sprite_vert","type":35633,"uri":"uniform float rotation;\r\nuniform vec2 center;\r\n\r\n#include <common>\r\n#include <common2>\r\n#include <uv_pars_vertex>\r\n#include <fog_pars_vertex>\r\n#include <logdepthbuf_pars_vertex>\r\n#include <clipping_planes_pars_vertex>\r\n\r\nvoid main() {\r\n\r\n\t#include <uv_vertex>\r\n\r\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\r\n\r\n\tvec2 scale;\r\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\r\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\r\n\r\n\t#ifndef USE_SIZEATTENUATION\r\n\r\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\r\n\r\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\r\n\r\n\t#endif\r\n\r\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\r\n\r\n\tvec2 rotatedPosition;\r\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\r\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\r\n\r\n\tmvPosition.xy += rotatedPosition;\r\n\r\n\tgl_Position = projectionMatrix * mvPosition;\r\n\r\n\t#include <logdepthbuf_vertex>\r\n\t#include <clipping_planes_vertex>\r\n\t#include <fog_vertex>\r\n\r\n}\r\n"},{"name":"sprite_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform float opacity;\r\n\r\n#include <common>\r\n#include <uv_pars_fragment>\r\n#include <map_pars_fragment>\r\n#include <fog_pars_fragment>\r\n#include <logdepthbuf_pars_fragment>\r\n#include <clipping_planes_pars_fragment>\r\n\r\nvoid main() {\r\n\r\n\t#include <clipping_planes_fragment>\r\n\r\n\tvec3 outgoingLight = vec3( 0.0 );\r\n\tvec4 diffuseColor = vec4( diffuse, opacity );\r\n\r\n\t#include <logdepthbuf_fragment>\r\n\t#include <map_fragment>\r\n\t#include <alphatest_fragment>\r\n\r\n\toutgoingLight = diffuseColor.rgb;\r\n\r\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n\r\n\t#include <tonemapping_fragment>\r\n\t#include <encodings_fragment>\r\n\t#include <fog_fragment>\r\n\r\n}\r\n"}],"techniques":[{"name":"sprite","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"uv":{"semantic":"TEXCOORD_0"},"color":{"semantic":"COLOR_0"},"morphTarget0":{"semantic":"MORPHTARGET_0"},"morphTarget1":{"semantic":"MORPHTARGET_1"},"morphTarget2":{"semantic":"MORPHTARGET_2"},"morphTarget3":{"semantic":"MORPHTARGET_3"},"morphNormal0":{"semantic":"MORPHNORMAL_0"},"morphNormal1":{"semantic":"MORPHNORMAL_1"},"morphNormal2":{"semantic":"MORPHNORMAL_2"},"morphNormal3":{"semantic":"MORPHNORMAL_3"},"morphTarget4":{"semantic":"MORPHTARGET_4"},"morphTarget5":{"semantic":"MORPHTARGET_5"},"morphTarget6":{"semantic":"MORPHTARGET_6"},"morphTarget7":{"semantic":"MORPHTARGET_7"},"skinIndex":{"semantic":"JOINTS_0"},"skinWeight":{"semantic":"WEIGHTS_0"}},"uniforms":{"rotation":{"type":5126,"value":[]},"center":{"type":35664,"value":[]},"modelMatrix":{"type":35676,"value":[],"semantic":"MODEL"},"modelViewMatrix":{"type":35676,"value":[],"semantic":"MODELVIEW"},"projectionMatrix":{"type":35676,"value":[],"semantic":"PROJECTION"},"viewMatrix":{"type":35676,"value":[],"semantic":"VIEW"},"normalMatrix":{"type":35675,"value":[],"semantic":"MODELVIEWINVERSE"},"cameraPosition":{"type":35665,"value":[],"semantic":"_CAMERA_POS"},"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"logDepthBufFC":{"type":5126,"value":[]},"diffuse":{"type":35665,"value":[1,1,1]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"fogColor":{"type":35665,"value":[]},"fogDensity":{"type":5126,"value":[]},"fogNear":{"type":5126,"value":[]},"fogFar":{"type":5126,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const test1 = {"name":"buildin/test1.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"test1_vert","type":35633,"uri":"#define LAMBERT\r\nvarying vec3 vLightFront;\r\n#ifdef DOUBLE_SIDED\r\n\tvarying vec3 vLightBack;\r\n#endif\r\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\tvarying vec2 vUv;\r\n\tuniform mat3 uvTransform;\r\n#endif\r\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\tattribute vec2 uv2;\r\n\tvarying vec2 vUv2;\r\n#endif\r\n#ifdef USE_ENVMAP\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\t\tvarying vec3 vWorldPosition;\r\n\t#else\r\n\t\tvarying vec3 vReflect;\r\n\t\tuniform float refractionRatio;\r\n\t#endif\r\n\r\n#endif\r\nuniform vec3 ambientLightColor;\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\tvec3 irradiance = ambientLightColor;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\treturn irradiance;\r\n}\r\n#if NUM_DIR_LIGHTS > 0\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\t}\r\n#endif\r\n\r\n#if NUM_POINT_LIGHTS > 0\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t\tfloat shadowCameraNear;\r\n\t\tfloat shadowCameraFar;\r\n\t};\r\n\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\t}\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\t\t} else {\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\t\t}\r\n\t}\r\n#endif\r\n\r\n\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\r\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\r\n\t// BRDF approximation Texture is 64x64\r\n\tuniform sampler2D ltc_1; // RGBA Float\r\n\tuniform sampler2D ltc_2; // RGBA Float\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n#endif\r\n\r\n\r\n#if NUM_HEMI_LIGHTS > 0\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\t\tirradiance *= PI;\r\n\t\t#endif\r\n\t\treturn irradiance;\r\n\t}\r\n\r\n#endif\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\r\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#else\r\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\r\n\t\t#else\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\t\t#endif\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\r\n\t}\r\n\r\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\r\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\t// clamp to allowable LOD ranges.\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\t}\r\n\r\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\t\t#else\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\t\t#endif\r\n\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#endif\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\t}\r\n\r\n#endif\r\n#ifdef USE_COLOR\r\n\tvarying vec3 vColor;\r\n#endif\r\n#ifdef USE_FOG\r\n  varying float fogDepth;\r\n#endif\r\n#ifdef USE_SKINNING\r\n\tuniform mat4 bindMatrix;\r\n\tuniform mat4 bindMatrixInverse;\r\n\t#ifdef BONE_TEXTURE\r\n\t\tuniform sampler2D boneTexture;\r\n\t\tuniform int boneTextureSize;\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\t\t\tfloat j = i * 4.0;\r\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\r\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\r\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\r\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\r\n\t\t\ty = dy * ( y + 0.5 );\r\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\r\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\r\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\r\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\r\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\r\n\t\t\treturn bone;\r\n\t\t}\r\n\t#else\r\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\r\n\t\tmat4 getBoneMatrix( const in float i ) {\r\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\r\n\t\t\treturn bone;\r\n\t\t}\r\n\t#endif\r\n#endif\r\n#ifdef USE_SHADOWMAP\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\t#endif\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\t#endif\r\n\r\n\t/*\r\n\t#if NUM_RECT_AREA_LIGHTS > 0\r\n\r\n\t\t// TODO (abelnation): uniforms for area light shadows\r\n\r\n\t#endif\r\n\t*/\r\n\r\n#endif\r\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\tvarying vec3 vViewPosition;\r\n#endif\r\n\r\nvoid main(){\r\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\r\n#endif\r\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\tvUv2 = uv2;\r\n#endif\r\n#ifdef USE_COLOR\r\n\tvColor.xyz = color.xyz;\r\n#endif\r\nvec3 objectNormal = vec3( normal );\r\nvec3 transformed = vec3( position );\r\n#ifdef USE_SKINNING\r\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\r\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\r\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\r\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\r\n\r\n\tmat4 skinMatrix = mat4( 0.0 );\r\n\tskinMatrix += skinWeight.x * boneMatX;\r\n\tskinMatrix += skinWeight.y * boneMatY;\r\n\tskinMatrix += skinWeight.z * boneMatZ;\r\n\tskinMatrix += skinWeight.w * boneMatW;\r\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\r\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\r\n\r\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\r\n\tvec4 skinned = vec4( 0.0 );\r\n\tskinned += boneMatX * skinVertex * skinWeight.x;\r\n\tskinned += boneMatY * skinVertex * skinWeight.y;\r\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\r\n\tskinned += boneMatW * skinVertex * skinWeight.w;\r\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\r\n#endif\r\nvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\r\ngl_Position = projectionMatrix * mvPosition;\r\n#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\tvViewPosition = - mvPosition.xyz;\r\n#endif\r\n#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\r\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\r\n#endif\r\n#ifdef USE_ENVMAP\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\t\tvWorldPosition = worldPosition.xyz;\r\n\t#else\r\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\r\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\r\n\t\t#else\r\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\t\t#endif\r\n\t#endif\r\n#endif\r\nvec3 diffuse = vec3( 1.0 );\r\nGeometricContext geometry;\r\ngeometry.position = mvPosition.xyz;\r\ngeometry.normal = normalize( transformedNormal );\r\ngeometry.viewDir = normalize( -mvPosition.xyz );\r\nGeometricContext backGeometry;\r\nbackGeometry.position = geometry.position;\r\nbackGeometry.normal = -geometry.normal;\r\nbackGeometry.viewDir = geometry.viewDir;\r\nvLightFront = vec3( 0.0 );\r\n#ifdef DOUBLE_SIDED\r\n\tvLightBack = vec3( 0.0 );\r\n#endif\r\nIncidentLight directLight;\r\nfloat dotNL;\r\nvec3 directLightColor_Diffuse;\r\n#if NUM_POINT_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\t\t#ifdef DOUBLE_SIDED\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n#if NUM_SPOT_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\t\t#ifdef DOUBLE_SIDED\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n#if NUM_DIR_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\r\n\t\tdotNL = dot( geometry.normal, directLight.direction );\r\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\r\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\r\n\t\t#ifdef DOUBLE_SIDED\r\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\r\n\t\t#endif\r\n\t}\r\n#endif\r\n#if NUM_HEMI_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\r\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\r\n\t\t#ifdef DOUBLE_SIDED\r\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\r\n\t\t#endif\r\n\t}\r\n#endif\r\n#ifdef USE_SHADOWMAP\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\r\n\t}\r\n\t#endif\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\r\n\t}\r\n\t#endif\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\r\n\t}\r\n\t#endif\r\n#endif\r\n}\r\n\r\n"},{"name":"test1_frag","type":35632,"uri":"uniform vec3 diffuse;\r\nuniform vec3 emissive;\r\nuniform float opacity;\r\nvarying vec3 vLightFront;\r\n#ifdef DOUBLE_SIDED\r\n\tvarying vec3 vLightBack;\r\n#endif\r\n#if defined( DITHERING )\r\n\t// based on https://www.shadertoy.com/view/MslGR8\r\n\tvec3 dithering( vec3 color ) {\r\n\t\t//Calculate grid position\r\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\r\n\t\t//Shift the individual colors differently, thus making it even harder to see the dithering pattern\r\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\r\n\t\t//modify shift acording to grid position.\r\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\r\n\t\t//shift the color by dither_shift\r\n\t\treturn color + dither_shift_RGB;\r\n\t}\r\n#endif\r\n#ifdef USE_COLOR\r\n\tvarying vec3 vColor;\r\n#endif\r\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\r\n\tvarying vec2 vUv;\r\n#endif\r\n#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\r\n\tvarying vec2 vUv2;\r\n#endif\r\n#ifdef USE_MAP\r\n\tuniform mat3 uvTransform;\r\n\tuniform sampler2D map;\r\n#endif\r\n#ifdef USE_ALPHAMAP\r\n\tuniform sampler2D alphaMap;\r\n#endif\r\n#ifdef USE_AOMAP\r\n\tuniform sampler2D aoMap;\r\n\tuniform float aoMapIntensity;\r\n#endif\r\n#ifdef USE_LIGHTMAP\r\n\tuniform sampler2D lightMap;\r\n\tuniform float lightMapIntensity;\r\n#endif\r\n#ifdef USE_EMISSIVEMAP\r\n\tuniform sampler2D emissiveMap;\r\n#endif\r\n#if defined( USE_ENVMAP ) || defined( PHYSICAL )\r\n\tuniform float reflectivity;\r\n\tuniform float envMapIntensity;\r\n#endif\r\n#ifdef USE_ENVMAP\r\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\r\n\t\tvarying vec3 vWorldPosition;\r\n\t#endif\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\tuniform samplerCube envMap;\r\n\t#else\r\n\t\tuniform sampler2D envMap;\r\n\t#endif\r\n\tuniform float flipEnvMap;\r\n\tuniform int maxMipLevel;\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\r\n\t\tuniform float refractionRatio;\r\n\t#else\r\n\t\tvarying vec3 vReflect;\r\n\t#endif\r\n#endif\r\nuniform vec3 ambientLightColor;\r\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\r\n\tvec3 irradiance = ambientLightColor;\r\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\tirradiance *= PI;\r\n\t#endif\r\n\treturn irradiance;\r\n}\r\n#if NUM_DIR_LIGHTS > 0\r\n\tstruct DirectionalLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\r\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tdirectLight.color = directionalLight.color;\r\n\t\tdirectLight.direction = directionalLight.direction;\r\n\t\tdirectLight.visible = true;\r\n\t}\r\n#endif\r\n#if NUM_POINT_LIGHTS > 0\r\n\tstruct PointLight {\r\n\t\tvec3 position;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t\tfloat shadowCameraNear;\r\n\t\tfloat shadowCameraFar;\r\n\t};\r\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\r\n\t\tvec3 lVector = pointLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tdirectLight.color = pointLight.color;\r\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\r\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\r\n\t}\r\n#endif\r\n\r\n#if NUM_SPOT_LIGHTS > 0\r\n\tstruct SpotLight {\r\n\t\tvec3 position;\r\n\t\tvec3 direction;\r\n\t\tvec3 color;\r\n\t\tfloat distance;\r\n\t\tfloat decay;\r\n\t\tfloat coneCos;\r\n\t\tfloat penumbraCos;\r\n\r\n\t\tint shadow;\r\n\t\tfloat shadowBias;\r\n\t\tfloat shadowRadius;\r\n\t\tvec2 shadowMapSize;\r\n\t};\r\n\r\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\r\n\t// directLight is an out parameter as having it as a return value caused compiler errors on some devices\r\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\r\n\t\tvec3 lVector = spotLight.position - geometry.position;\r\n\t\tdirectLight.direction = normalize( lVector );\r\n\t\tfloat lightDistance = length( lVector );\r\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\r\n\t\tif ( angleCos > spotLight.coneCos ) {\r\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\r\n\t\t\tdirectLight.color = spotLight.color;\r\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\r\n\t\t\tdirectLight.visible = true;\r\n\t\t} else {\r\n\t\t\tdirectLight.color = vec3( 0.0 );\r\n\t\t\tdirectLight.visible = false;\r\n\t\t}\r\n\t}\r\n#endif\r\n#if NUM_RECT_AREA_LIGHTS > 0\r\n\tstruct RectAreaLight {\r\n\t\tvec3 color;\r\n\t\tvec3 position;\r\n\t\tvec3 halfWidth;\r\n\t\tvec3 halfHeight;\r\n\t};\r\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\r\n\t// BRDF approximation Texture is 64x64\r\n\tuniform sampler2D ltc_1; // RGBA Float\r\n\tuniform sampler2D ltc_2; // RGBA Float\r\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\r\n#endif\r\n#if NUM_HEMI_LIGHTS > 0\r\n\tstruct HemisphereLight {\r\n\t\tvec3 direction;\r\n\t\tvec3 skyColor;\r\n\t\tvec3 groundColor;\r\n\t};\r\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\r\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\r\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\r\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\r\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\r\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\r\n\t\t\tirradiance *= PI;\r\n\t\t#endif\r\n\t\treturn irradiance;\r\n\t}\r\n#endif\r\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\tvec3 getLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in int maxMIPLevel ) {\r\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\t// TODO: replace with properly filtered cubemaps and access the irradiance LOD level, be it the last LOD level\r\n\t\t\t// of a specular cubemap, or just the default level of a specially created irradiance cubemap.\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#else\r\n\t\t\t\t// force the bias high to get the last LOD level as it is the most blurred.\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\r\n\t\t#else\r\n\t\t\tvec4 envMapColor = vec4( 0.0 );\r\n\t\t#endif\r\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\r\n\t}\r\n\t// taken from here: http://casual-effects.blogspot.ca/2011/08/plausible-environment-lighting-in-two.html\r\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\t//float envMapWidth = pow( 2.0, maxMIPLevelScalar );\r\n\t\t//float desiredMIPLevel = log2( envMapWidth * sqrt( 3.0 ) ) - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\r\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\r\n\t\t// clamp to allowable LOD ranges.\r\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\r\n\t}\r\n\tvec3 getLightProbeIndirectRadiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\r\n\t\t#else\r\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\r\n\t\t#endif\r\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\r\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\r\n\t\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\r\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\r\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\r\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\t\t\tvec2 sampleUV;\r\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\r\n\t\t\t#ifdef TEXTURE_LOD_EXT\r\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#else\r\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\r\n\t\t\t#endif\r\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\r\n\t\t#endif\r\n\t\treturn envMapColor.rgb * envMapIntensity;\r\n\t}\r\n#endif\r\n#ifdef USE_SHADOWMAP\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\r\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\r\n\t#endif\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\r\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\r\n\t#endif\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\r\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\r\n\t#endif\r\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\r\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\r\n\t}\r\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\r\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\r\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\r\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\r\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\r\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\r\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\r\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\r\n\t\tvec2 f = fract( uv * size + 0.5 );\r\n\t\tfloat a = mix( lb, lt, f.y );\r\n\t\tfloat b = mix( rb, rt, f.y );\r\n\t\tfloat c = mix( a, b, f.x );\r\n\t\treturn c;\r\n\t}\r\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\r\n\t\tfloat shadow = 1.0;\r\n\t\tshadowCoord.xyz /= shadowCoord.w;\r\n\t\tshadowCoord.z += shadowBias;\r\n\t\t// if ( something && something ) breaks ATI OpenGL shader compiler\r\n\t\t// if ( all( something, something ) ) using this instead\r\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\r\n\t\tbool inFrustum = all( inFrustumVec );\r\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\r\n\t\tbool frustumTest = all( frustumTestVec );\r\n\t\tif ( frustumTest ) {\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\t\t\tshadow = (\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\r\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\r\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\r\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\r\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\r\n\t\t\tshadow = (\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\r\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\t\t#else // no percentage-closer filtering:\r\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\r\n\t\t#endif\r\n\t\t}\r\n\t\treturn shadow;\r\n\t}\r\n\t// cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D\r\n\t// vector suitable for 2D texture mapping. This code uses the following layout for the\r\n\t// 2D texture:\r\n\t//\r\n\t// xzXZ\r\n\t//  y Y\r\n\t//\r\n\t// Y - Positive y direction\r\n\t// y - Negative y direction\r\n\t// X - Positive x direction\r\n\t// x - Negative x direction\r\n\t// Z - Positive z direction\r\n\t// z - Negative z direction\r\n\t//\r\n\t// Source and test bed:\r\n\t// https://gist.github.com/tschw/da10c43c467ce8afd0c4\r\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\r\n\t\t// Number of texels to avoid at the edge of each square\r\n\t\tvec3 absV = abs( v );\r\n\t\t// Intersect unit cube\r\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\r\n\t\tabsV *= scaleToCube;\r\n\t\t// Apply scale to avoid seams\r\n\t\t// two texels less per square (one texel will do for NEAREST)\r\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\r\n\t\t// Unwrap\r\n\t\t// space: -1 ... 1 range for each square\r\n\t\t//\r\n\t\t// #X##\t\tdim    := ( 4 , 2 )\r\n\t\t//  # #\t\tcenter := ( 1 , 1 )\r\n\t\tvec2 planar = v.xy;\r\n\t\tfloat almostATexel = 1.5 * texelSizeY;\r\n\t\tfloat almostOne = 1.0 - almostATexel;\r\n\t\tif ( absV.z >= almostOne ) {\r\n\t\t\tif ( v.z > 0.0 )\r\n\t\t\t\tplanar.x = 4.0 - v.x;\r\n\t\t} else if ( absV.x >= almostOne ) {\r\n\t\t\tfloat signX = sign( v.x );\r\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\r\n\t\t} else if ( absV.y >= almostOne ) {\r\n\t\t\tfloat signY = sign( v.y );\r\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\r\n\t\t\tplanar.y = v.z * signY - 2.0;\r\n\t\t}\r\n\t\t// Transform to UV space\r\n\t\t// scale := 0.5 / dim\r\n\t\t// translate := ( center + 0.5 ) / dim\r\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\r\n\t}\r\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\r\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\r\n\t\t// for point lights, the uniform @vShadowCoord is re-purposed to hold\r\n\t\t// the vector from the light to the world-space position of the fragment.\r\n\t\tvec3 lightToPosition = shadowCoord.xyz;\r\n\t\t// dp = normalized distance from light to fragment position\r\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear ); // need to clamp?\r\n\t\tdp += shadowBias;\r\n\t\t// bd3D = base direction 3D\r\n\t\tvec3 bd3D = normalize( lightToPosition );\r\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\r\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\r\n\t\t\treturn (\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\r\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\r\n\t\t\t) * ( 1.0 / 9.0 );\r\n\t\t#else // no percentage-closer filtering\r\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\r\n\t\t#endif\r\n\t}\r\n#endif\r\nfloat getShadowMask() {\r\n\tfloat shadow = 1.0;\r\n\t#ifdef USE_SHADOWMAP\r\n\t#if NUM_DIR_LIGHTS > 0\r\n\tDirectionalLight directionalLight;\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\r\n\t\tdirectionalLight = directionalLights[ i ];\r\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\r\n\t}\r\n\t#endif\r\n\t#if NUM_SPOT_LIGHTS > 0\r\n\tSpotLight spotLight;\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\r\n\t\tspotLight = spotLights[ i ];\r\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\r\n\t}\r\n\t#endif\r\n\t#if NUM_POINT_LIGHTS > 0\r\n\tPointLight pointLight;\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\r\n\t\tpointLight = pointLights[ i ];\r\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\r\n\t}\r\n\t#endif\r\n\t#endif\r\n\treturn shadow;\r\n}\r\n#ifdef USE_SPECULARMAP\r\n\tuniform sampler2D specularMap;\r\n#endif\r\n#if NUM_CLIPPING_PLANES > 0\r\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\r\n\t\tvarying vec3 vViewPosition;\r\n\t#endif\r\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\r\n#endif\r\nvoid main(){\r\n#if NUM_CLIPPING_PLANES > 0\r\n\tvec4 plane;\r\n\t#pragma unroll_loop\r\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\r\n\t\tplane = clippingPlanes[ i ];\r\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\r\n\t}\r\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\r\n\t\tbool clipped = true;\r\n\t\t#pragma unroll_loop\r\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\r\n\t\t\tplane = clippingPlanes[ i ];\r\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\r\n\t\t}\r\n\t\tif ( clipped ) discard;\r\n\t#endif\r\n#endif\r\nvec4 diffuseColor = vec4( diffuse, opacity );\r\nReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\r\nvec3 totalEmissiveRadiance = emissive;\t\r\n#ifdef USE_MAP\r\nvec4 texelColor = texture2D( map, vUv );\r\ntexelColor = mapTexelToLinear( texelColor );\r\ndiffuseColor *= texelColor;\r\n#endif\r\n#ifdef USE_COLOR\r\n\tdiffuseColor.rgb *= vColor;\r\n#endif\r\n#ifdef USE_ALPHAMAP\r\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\r\n#endif\r\n#ifdef ALPHATEST\r\n\tif ( diffuseColor.a < ALPHATEST ) discard;\r\n#endif\r\nfloat specularStrength;\r\n#ifdef USE_SPECULARMAP\r\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\r\n\tspecularStrength = texelSpecular.r;\r\n#else\r\n\tspecularStrength = 1.0;\r\n#endif\r\n#ifdef USE_EMISSIVEMAP\r\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\r\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\r\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\r\n#endif\r\n// accumulation\r\nreflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\r\n#ifdef USE_LIGHTMAP\r\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity; // factor of PI should not be present; included here to prevent breakage\r\n#endif\r\nreflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\r\n#ifdef DOUBLE_SIDED\r\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\r\n\t#else\r\n\t\treflectedLight.directDiffuse = vLightFront;\r\n\t#endif\r\nreflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\r\n#ifdef USE_AOMAP\r\n\t// reads channel R, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\r\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\r\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\r\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\r\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\r\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\r\n\t#endif\r\n#endif\r\nvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\r\n#ifdef USE_ENVMAP\r\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\r\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\r\n\t\t// Transforming Normal Vectors with the Inverse Transformation\r\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\r\n\t\t#ifdef ENVMAP_MODE_REFLECTION\r\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\r\n\t\t#else\r\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\r\n\t\t#endif\r\n\t#else\r\n\t\tvec3 reflectVec = vReflect;\r\n\t#endif\r\n\t#ifdef ENVMAP_TYPE_CUBE\r\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\r\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\r\n\t\tvec2 sampleUV;\r\n\t\treflectVec = normalize( reflectVec );\r\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\r\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\r\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\r\n\t#elif defined( ENVMAP_TYPE_SPHERE )\r\n\t\treflectVec = normalize( reflectVec );\r\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\r\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\r\n\t#else\r\n\t\tvec4 envColor = vec4( 0.0 );\r\n\t#endif\r\n\tenvColor = envMapTexelToLinear( envColor );\r\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\r\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\r\n\t#elif defined( ENVMAP_BLENDING_MIX )\r\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\r\n\t#elif defined( ENVMAP_BLENDING_ADD )\r\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\r\n\t#endif\r\n#endif\r\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\r\n#if defined( TONE_MAPPING )\r\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\r\n#endif\r\n gl_FragColor = linearToOutputTexel( gl_FragColor );\r\n #ifdef PREMULTIPLIED_ALPHA\r\n\t// Get get normal blending with premultipled, use with CustomBlending, OneFactor, OneMinusSrcAlphaFactor, AddEquation.\r\n\tgl_FragColor.rgb *= gl_FragColor.a;\r\n#endif\r\n#if defined( DITHERING )\r\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\r\n#endif\r\n}\r\n\r\n\r\n"}],"techniques":[{"name":"test1","attributes":{"uv2":{"semantic":"TEXCOORD_1"}},"uniforms":{"uvTransform":{"type":35675,"value":[1,0,0,0,1,0,0,0,1]},"refractionRatio":{"type":5126,"value":[]},"ambientLightColor":{"type":35665,"value":[0,0,0],"semantic":"_AMBIENTLIGHTCOLOR"},"directionalLights[0]":{"type":-1,"value":[],"semantic":"_DIRECTLIGHTS"},"pointLights[0]":{"type":-1,"value":[],"semantic":"_POINTLIGHTS"},"spotLights[0]":{"type":-1,"value":[],"semantic":"_SPOTLIGHTS"},"ltc_1":{"type":35678,"value":[],"semantic":"Unknown"},"ltc_2":{"type":35678,"value":[],"semantic":"Unknown"},"rectAreaLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"hemisphereLights[0]":{"type":-1,"value":[],"semantic":"Unknown"},"bindMatrix":{"type":35676,"value":[],"semantic":"_BINDMATRIX"},"bindMatrixInverse":{"type":35676,"value":[],"semantic":"_BINDMATRIXINVERSE"},"boneTexture":{"type":35678,"value":[]},"boneTextureSize":{"type":5124,"value":[]},"boneMatrices[0]":{"type":35676,"value":[]},"directionalShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_DIRECTIONSHADOWMAT"},"spotShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_SPOTSHADOWMAT"},"pointShadowMatrix[0]":{"type":35676,"value":[],"semantic":"_POINTSHADOWMAT"},"diffuse":{"type":35665,"value":[1,1,1]},"emissive":{"type":35665,"value":[0,0,0]},"opacity":{"type":5126,"value":1},"map":{"type":35678,"value":[]},"alphaMap":{"type":35678,"value":[]},"aoMap":{"type":35678,"value":[]},"aoMapIntensity":{"type":5126,"value":1},"lightMap":{"type":35678,"value":[],"semantic":"_LIGHTMAPTEX"},"lightMapIntensity":{"type":5126,"value":[],"semantic":"_LIGHTMAPINTENSITY"},"emissiveMap":{"type":35678,"value":[]},"reflectivity":{"type":5126,"value":[]},"envMapIntensity":{"type":5126,"value":1},"envMap":{"type":35678,"value":[]},"flipEnvMap":{"type":5126,"value":1},"maxMipLevel":{"type":5124,"value":[]},"directionalShadowMap[0]":{"type":35678,"value":[],"semantic":"_DIRECTIONSHADOWMAP"},"spotShadowMap[0]":{"type":35678,"value":[],"semantic":"_SPOTSHADOWMAP"},"pointShadowMap[0]":{"type":35678,"value":[],"semantic":"_POINTSHADOWMAT"},"specularMap":{"type":35678,"value":[]},"clippingPlanes[0]":{"type":35666,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
    export const vertcolor = {"name":"buildin/vertcolor.shader.gltf","config":{"version":"3","asset":{"version":"2.0"},"extensions":{"KHR_techniques_webgl":{"shaders":[{"name":"vertcolor_vert","type":35633,"uri":"#include <common>\r\nattribute vec4 position;   \r\nattribute vec4 normal;   \r\nattribute vec4 color;                  \r\nattribute vec4 uv;        \r\nuniform highp mat4 modelViewProjectionMatrix;   \r\nuniform highp vec4 _MainTex_ST;       \r\n\r\nvarying lowp vec4 xlv_COLOR;                \r\nvarying highp vec2 xlv_TEXCOORD0;   \r\n\r\nvoid main()                                     \r\n{                                               \r\n    highp vec4 tmpvar_1;                        \r\n    tmpvar_1.w = 1.0;                           \r\n    tmpvar_1.xyz = position.xyz;             \r\n    xlv_COLOR = color;                     \r\n    xlv_TEXCOORD0 = uv.xy * _MainTex_ST.xy + _MainTex_ST.zw;   \r\n\r\n    //xlv_COLOR.xyz =pos.xyz;\r\n    gl_Position = (modelViewProjectionMatrix * tmpvar_1);  \r\n}\r\n"},{"name":"vertcolor_frag","type":35632,"uri":"#include <common>\r\nuniform sampler2D _MainTex;                                                 \r\nvarying lowp vec4 xlv_COLOR;                                                 \r\nvarying highp vec2 xlv_TEXCOORD0;   \r\nvoid main() \r\n{\r\n    lowp vec4 col_1;    \r\n    mediump vec4 prev_2;\r\n    lowp vec4 tmpvar_3;\r\n\r\n    tmpvar_3 = (texture2D(_MainTex, xlv_TEXCOORD0));\r\n    //prev_2 = tmpvar_3;\r\n    //mediump vec4 tmpvar_4;\r\n    //tmpvar_4 = mix(vec4(1.0, 1.0, 1.0, 1.0), prev_2, prev_2.wwww);\r\n    //col_1 = tmpvar_4;\r\n    //col_1.x = xlv_TEXCOORD0.x;\r\n    //col_1.y = xlv_TEXCOORD0.y;\r\n    gl_FragData[0] = tmpvar_3;\r\n}"}],"techniques":[{"name":"vertcolor","attributes":{"position":{"semantic":"POSITION"},"normal":{"semantic":"NORMAL"},"color":{"semantic":"COLOR_0"},"uv":{"semantic":"TEXCOORD_0"}},"uniforms":{"modelViewProjectionMatrix":{"type":35676,"value":[],"semantic":"MODELVIEWPROJECTION"},"_MainTex_ST":{"type":35666,"value":[1,1,0,0]},"_MainTex":{"type":35678,"value":[]}},"states":{"enable":[],"functions":{}}}]},"paper":{}},"extensionsRequired":["paper"],"extensionsUsed":["paper"],"materials":[]},"_isBuiltin":true};
}
